<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="X_ray">


    <meta name="subtitle" content="yesterday you said tomorrow">




<title>设计模式 | X_ray&#39;s blog</title>



    <link rel="icon" href="/image/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.1.1"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Xray&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Xray&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">设计模式</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">X_ray</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">八月 24, 2020&nbsp;&nbsp;15:38:58</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="0-设计模式"><a href="#0-设计模式" class="headerlink" title="0 设计模式"></a>0 设计模式</h2><pre><code>一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案

本质是面向对象设计原则的实际应用</code></pre>
<a id="more"></a>

<h3 id="0-1-分类"><a href="#0-1-分类" class="headerlink" title="0.1 分类"></a>0.1 分类</h3><p><strong>创建型模式：</strong></p>
<ul>
<li>单例模式<ul>
<li>工厂模式</li>
<li>抽象工厂模式 </li>
<li>建造者模式 </li>
<li>原型模式</li>
</ul>
</li>
</ul>
<p><strong>结构型模式：</strong></p>
<ul>
<li>适配器模式</li>
<li>桥接模式</li>
<li>装饰模式</li>
<li>组合模式</li>
<li>外观模式</li>
<li>享元模式</li>
<li>代理模式</li>
</ul>
<p><strong>行为型模式：</strong></p>
<ul>
<li>模板方法模式</li>
<li>命令模式</li>
<li>迭代器模式</li>
<li>观察者模式</li>
<li>中介者模式</li>
<li>备忘录模式</li>
<li>解释器模式</li>
<li>状态模式</li>
<li>策略模式</li>
<li>职责链模式</li>
<li>访问者模式</li>
</ul>
<h3 id="0-2-OOP七大原则"><a href="#0-2-OOP七大原则" class="headerlink" title="0.2 OOP七大原则"></a>0.2 OOP七大原则</h3><p><strong>开闭原则：</strong> 对扩展开放，对修改关闭；<br><strong>里氏替换原则：</strong> 继承必须确保超类拥有的性质在子类中仍然成立；<br><strong>依赖倒置原则：</strong> 面向接口编程，而不是面向实现编程；<br><strong>单一职责原则：</strong> 控制类的粒度大小，将对象解耦，提高内聚性；<br><strong>接口隔离原则：</strong> 为类建立需要的专用接口；<br><strong>迪米特法则：</strong> 只与直接朋友交谈；<br><strong>合成复用原则：</strong> 优先使用组合、聚合等关联关系，其次才考虑使用继承实现。</p>
<h3 id="0-3-UML类图"><a href="#0-3-UML类图" class="headerlink" title="0.3 UML类图"></a>0.3 UML类图</h3><pre><code>UML（unified modeling language） 统一建模语言</code></pre>
<ul>
<li>note 注释</li>
<li>class 类</li>
<li>interface 接口</li>
<li>dependency 依赖：一种使用的关系，即一个类的实现需要另一个类的协助</li>
<li>association 关联：一个类知道另一个类的属性和方法</li>
<li>generalization 泛化（继承）：指定子类如何特化父类所以的特征和行为</li>
<li>realization 实现：表示类是接口所有特征和行为的表现</li>
<li>aggregation 聚合：整体与部分的关系，并且部分可以离开整体而单独存在</li>
<li>composite 组合：整体与部分的关系，并且部分不可以离开整体而单独存在</li>
</ul>
<figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">泛化 </span>=<span class="string"> 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖</span></span><br></pre></td></tr></table></figure>

<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><h2 id="为什么用工厂模式"><a href="#为什么用工厂模式" class="headerlink" title="为什么用工厂模式"></a>为什么用工厂模式</h2><ul>
<li><p><strong>工厂模式都需要依赖接口**</strong>，主体对象通过接口规定的方法获取对象**，具体的实现逻辑由实现类完成，当实现逻辑变化时只需要修改实现类即可，达到了解耦的目的</p>
</li>
<li><p>降低重复代码，把创建过程统一管理方便维护</p>
</li>
<li><p>使用者不需要知道具体创建过程</p>
</li>
<li><p><strong>Spring源码中所有Bean的创建在源码中是简单工厂模式</strong>(不属于23种GOF设计模式之一)</p>
</li>
<li><ul>
<li>主体对象根据接口定义的方法调用，具体的实现逻辑由Spring源码完成，实现逻辑如下：</li>
<li>getBean-&gt;doGetBean-&gt;creatBean-&gt;doCreatBean-&gt;instantiateBean</li>
<li>具体的实例化操作由InstantiationStrategy接口规定，实现类调用instantiate()完成实例化，根据是否有方法需要被重写(是否使用方法注入)决定使用JDK的实例化方式(BeanUtils.<em>instantiateClass</em>(ctor))还是CGLIB的生成子类的实例化方法</li>
<li>本质还是调用某个方法返回一个对象</li>
</ul>
</li>
</ul>
<h2 id="还可以防止this引用逃逸"><a href="#还可以防止this引用逃逸" class="headerlink" title="还可以防止this引用逃逸"></a>还可以防止this引用逃逸</h2><ul>
<li><p>什么是this引用逃逸：</p>
</li>
<li><ul>
<li>在构造器构造还未彻底完成前（即实例初始化阶段还未完成），将自身this引用向外抛出并被其他线程复制（访问）了该引用，可能会问到该还未被初始化的变量，甚至可能会造成更大严重的问题</li>
<li>常见this引用逃逸错误：在构造函数中启动一个线程，当对象在其构造函数中创建一个线程时，this引用会被新创建的线程共享，在对象尚未完全构造之前，新的线程就可以看件它了。这一点和单例模式中使用不使用volatile会出现的问题类似，都是没有完全初始化好就被发现了</li>
<li>只有当构造函数返回时，this引用才应该从线程中逸出</li>
</ul>
</li>
<li><p>this引用逃逸发生的两个必要条件</p>
</li>
<li><ul>
<li>在构造函数中创建内部类</li>
<li>在构造函数中发布这个内部类</li>
</ul>
</li>
<li><p>错误示例伪码：构造过程中this逸出</p>
</li>
<li><ul>
<li>下面代码中初始化了事件监听器，事件监听器一旦注册成功，就能够监听用户的操作，调用对应的回调函数，比如监听到了e这个事件，那么就会执行doSomething()回调函数，函数中返回的是addListener的变量var，由于接受到监听事件是在构造函数中，所以很可能接受到事件时，var的值还没有在构造器中初始化完成，就会导致doSomething方法返回的值可能是0，也可能是10</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">getListener</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="keyword">var</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">getListener</span><span class="params">(EventSource source)</span></span>&#123;</span><br><span class="line">        <span class="comment">//注册事件，会一直监听，当发生事件e时，会执行回调函数doSomething</span></span><br><span class="line">        source.registerListener(</span><br><span class="line">            <span class="comment">//匿名内部类实现</span></span><br><span class="line">            <span class="keyword">new</span> EventListener()&#123;</span><br><span class="line">                <span class="comment">//此时getListener可能还未初始化完成，onEvent()中就持有this指针，有可能发生严重错误</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event e)</span></span>&#123;</span><br><span class="line">                    doSomething(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="keyword">var</span>=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doSomething</span><span class="params">(Event e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">var</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用工厂方法解决</p>
</li>
<li><ul>
<li>构造函数私有，有一个public的方法返回监听器，而不是上面的使用构造函数构造一个监听器对象</li>
</ul>
</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> SafeListener &#123;</span><br><span class="line">  <span class="keyword">private</span> final EventListener listener;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="constructor">SafeListener()</span> &#123;</span><br><span class="line">    listener = <span class="keyword">new</span> <span class="constructor">EventListener()</span> &#123;</span><br><span class="line">      public void on<span class="constructor">Event(Event <span class="params">e</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">do</span><span class="constructor">Something(<span class="params">e</span>)</span>;</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public static SafeListener <span class="keyword">new</span><span class="constructor">Instance(EventSource <span class="params">source</span>)</span> &#123;</span><br><span class="line">    SafeListener safe = <span class="keyword">new</span> <span class="constructor">SafeListener()</span>;</span><br><span class="line">    source.register<span class="constructor">Listener(<span class="params">safe</span>.<span class="params">listener</span>)</span>;</span><br><span class="line">    return safe;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h1><p><strong><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/double-checked-locking-with-delay-initialization/">双重检查锁定详细描述</a></strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Single</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Single instance=<span class="literal">null</span>;<span class="comment">//volatile必须有</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single</span>(<span class="params"></span>)</span>&#123;&#125;<span class="comment">//不给外界暴漏构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">null</span>)&#123;<span class="comment">//已经完成对象创建后不用再执行synchronized了，节省性能</span></span><br><span class="line">            synchronized (Single.class)&#123;</span><br><span class="line">                <span class="comment">//防止执行完if(s==null)后进入同步代码块前还有另一个线程也在同一位置，所有需要再判断一次防止写两次</span></span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="literal">null</span>)&#123;</span><br><span class="line">                    instance=<span class="keyword">new</span> Single();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">demo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String args[]</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(Single.getInstance());<span class="comment">//Single@677327b6</span></span><br><span class="line">        System.<span class="keyword">out</span>.println(Single.getInstance());<span class="comment">//Single@677327b6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="为什么使用volatile"><a href="#为什么使用volatile" class="headerlink" title="为什么使用volatile"></a>为什么使用volatile</h2><ul>
<li><p><strong>synchronized可以保证代码块的原子性和可见性，但是不能保证包裹的代码块内部的有序性</strong></p>
</li>
<li><ul>
<li>new一个对象，new Single可以分为三步</li>
</ul>
</li>
</ul>
<ol>
<li><ol>
<li><ol>
<li>分配对象的内存空间</li>
<li>初始化对象</li>
<li>设置 instance 指向刚分配的内存地址</li>
</ol>
</li>
</ol>
</li>
</ol>
<ul>
<li><ul>
<li>如果没有volatile修饰该对象，则<strong>这三步可能会发生重排序</strong>，变成</li>
</ul>
</li>
</ul>
<ol>
<li><ol>
<li><ol>
<li>分配对象的内存空间</li>
<li>设置 instance 指向刚分配的内存地址</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><strong>如果这里跳转到另外的线程了，**</strong>会发现instance!=null，那么就会return instance，但是此时instance还没有初始化**</p>
<ol>
<li><ol>
<li><ol>
<li>初始化对象</li>
</ol>
</li>
</ol>
</li>
</ol>
<ul>
<li><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1587288097853-b6000c80-20fb-4d42-b4b3-dd4c215c2ed1.png" alt="image.png"></li>
</ul>
</li>
</ul>
<h2 id="Spring中的单例设计模式"><a href="#Spring中的单例设计模式" class="headerlink" title="Spring中的单例设计模式"></a>Spring中的单例设计模式</h2><p>此处为语雀文档，点击链接查看：<a target="_blank" rel="noopener" href="https://www.yuque.com/luka/note/beanfactory#EvQuu">https://www.yuque.com/luka/note/beanfactory#EvQuu</a></p>
<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><ul>
<li><p>适配器模式(adapter pattern)：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，在适配器模式中，通过增加一个新的适配器类来解决接口不兼容的问题，使得原本没有任何关系的类可以协同工作</p>
</li>
<li><p>根据适配器类与适配者类的关系不同，适配器模式可分为对象适配器和类适配器两种</p>
</li>
<li><ul>
<li>在<strong>类适配器模式</strong>中，适配器与适配者之间是<strong>继承</strong>(或实现)关系</li>
<li>在<strong>对象适配器模式</strong>中，适配器与适配者之间是<strong>关联</strong>关系</li>
</ul>
</li>
</ul>
<h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ul>
<li>Target（目标抽象类）：目标抽象类定义客户所需接口，被客户直接访问，可以是一个抽象类或接口，也可以是具体类</li>
<li>Adapter（适配器类）：适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过实现Target接口并继承/关联一个Adaptee对象使二者产生联系</li>
<li>Adaptee（适配者类）：适配者类作为被适配的角色，它定义了一个已经存在的功能接口(旧方法)，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码</li>
</ul>
<h2 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1587457070222-66c806e1-7d30-4d90-a205-b9c12643c754.png" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//已经存在的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adapteeRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;适配者的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//目标类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//适配器类模式，实现Target接口，继承Adaptee</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="comment">//Target接口中规定的方法，会被用户直接访问的</span></span><br><span class="line">    <span class="comment">//方法内部回调用Adaptee类的方法，所以起到了中转适配的作用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...一些操作...</span></span><br><span class="line">        <span class="keyword">super</span>.adapteeRequest();</span><br><span class="line">        <span class="comment">//...一些操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h2><ul>
<li>对象适配器与类适配器不同之处在于，类适配器通过继承来完成适配，对象适配器则是通过关联来完成</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1587457308209-31e42c9e-b26a-4a6a-bcf1-be0d0141f8c2.png" alt="image.png"></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="comment">// 适配者是对象适配器的一个属性</span></span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee = <span class="keyword">new</span> Adaptee();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        adaptee.adapteeRequest();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="适配器模式总结"><a href="#适配器模式总结" class="headerlink" title="适配器模式总结"></a>适配器模式总结</h2><p>优点：</p>
<ul>
<li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构</li>
<li>增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用</li>
<li>类适配器模式：由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强</li>
<li>对象适配器模式：一个对象适配器可以把多个不同的适配者适配到同一个目标，</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>类适配器模式：</p>
</li>
<li><ul>
<li>目标抽象类只能为接口，不能为类，有一定的局限性</li>
<li>Java只能单继承，类适配器模式中一次只能适配一个适配类(adaptee)</li>
</ul>
</li>
<li><p>对象适配器模式：</p>
</li>
<li><ul>
<li>与类适配器模式相比，要在适配器中置换适配者类的某些方法比较麻烦，没有子类那么方便</li>
</ul>
</li>
</ul>
<p>适用场景：</p>
<ul>
<li>系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要，甚至没有这些类的源代码</li>
</ul>
<h2 id="Spring中的适配器模式"><a href="#Spring中的适配器模式" class="headerlink" title="Spring中的适配器模式"></a>Spring中的适配器模式</h2><p>详见AOP模块</p>
<p>此处为语雀文档，点击链接查看：<a target="_blank" rel="noopener" href="https://www.yuque.com/luka/note/aop#GMj1r">https://www.yuque.com/luka/note/aop#GMj1r</a></p>
<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>代理模式分为静态代理和动态代理</p>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>假设现在项目经理有一个需求：在项目现有所有类的方法前后打印日志。</p>
<p>如何在不修改已有代码的前提下，完成这个需求？</p>
<p>首先想到的是静态代理。具体做法是：</p>
<p>1.为现有的每一个类都编写一个对应的代理类，并且让它实现和目标类相同的接口（假设都有）</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1266758/1586510323777-262ad8b5-2cc2-4376-8109-057025883c6d.jpg" alt="image"></p>
<p>2.在创建代理对象时，通过<strong>构造器塞入一个目标对象</strong>，然后在<strong>代理对象的方法内部调用目标对象同名方法</strong>，并在<strong>调用前后打印日志</strong>。</p>
<p>   也就是说，代理对象 = 增强代码 + 目标对象（原对象）。有了代理对象后，就不用原对象了</p>
<p>   <img src="https://cdn.nlark.com/yuque/0/2020/jpg/1266758/1586510323900-47b5fb3f-65f3-48d3-b339-9532b54da2bb.jpg" alt="image"></p>
<h3 id="静态代理的缺陷"><a href="#静态代理的缺陷" class="headerlink" title="静态代理的缺陷"></a>静态代理的缺陷</h3><p><strong>程序员要手动为每一个目标类编写对应的代理类</strong>。如果当前系统已经有成百上千个类，工作量太大了。所以，现在我们的努力方向是：如何少写或者不写代理类，却能完成代理功能？</p>
<ul>
<li><strong>能否不写代理类，而直接得到代理Class对象，然后根据它创建代理实例（反射）。</strong></li>
</ul>
<p>Class对象包含了一个类的所有信息，比如构造器、方法、字段等。如果我们不写代理类，这些信息从哪获取呢？苦思冥想，突然灵光一现：代理类和目标类理应实现同一组接口。<strong>之所以实现相同接口，是为了尽可能保证代理对象的内部结构和目标对象一致，这样我们对代理对象的操作最终都可以转移到目标对象身上，代理对象只需专注于增强代码的编写</strong>。<strong>同时，代理类必须继承Proxy类，所以只能且必须和目标类实现同一组接口。</strong>所以，可以这样说：<strong>接口拥有代理对象和目标对象共同的类信息</strong>。所以，我们可以从接口那得到理应由代理类提供的信息。<strong>但是别忘了，接口是无法创建对象的，怎么办？</strong></p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>介绍动态代理前可以看看这个关于<a target="_blank" rel="noopener" href="https://blog.csdn.net/zxysshgood/article/details/78684229">源码</a>的分析，还包括代理类的反汇编。</p>
<p>JDK提供了java.lang.reflect.InvocationHandler接口和 java.lang.reflect.Proxy类，这两个类相互配合，入口是Proxy，所以我们先聊它。</p>
<p><strong>Proxy有个静态方法：getProxyClass(ClassLoader, interfaces)，只要你给它传入类加载器和一组接口，它就给你返回代理Class对象</strong>。</p>
<p>用通俗的话说，<strong>getProxyClass()这个方法，会从你传入的接口Class中，“拷贝”类结构信息到一个新的Class对象中，但新的Class对象带有构造器，是可以创建对象的。</strong>打个比方，一个大内太监（接口Class），空有一身武艺（类信息），但是无法传给后人。现在江湖上有个妙手神医（Proxy类），发明了克隆大法（getProxyClass），不仅能克隆太监的一身武艺，还保留了小DD（构造器）…</p>
<p>所以，一旦我们明确接口，完全可以通过接口的Class对象，创建一个代理Class，通过代理Class即可创建代理对象。</p>
<p>所以，按我理解，Proxy.getProxyClass()这个方法的本质就是：以Class造Class。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1266758/1586510323966-94f8f8dd-d037-47f9-8269-d6a988902966.jpg" alt="image"></p>
<h3 id="静态代理和动态代理的区别"><a href="#静态代理和动态代理的区别" class="headerlink" title="静态代理和动态代理的区别"></a>静态代理和动态代理的区别</h3><p>静态代理</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1266758/1586510324027-f6541a6c-3bf7-4ce9-9611-e830a4c78300.jpg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<p>动态代理</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1266758/1586510324122-a22bb377-9228-49ad-bb69-8e2617ff31b3.jpg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<h3 id="使用getProxyClass完成动态代理"><a href="#使用getProxyClass完成动态代理" class="headerlink" title="使用getProxyClass完成动态代理"></a>使用getProxyClass完成动态代理</h3><p>1.基于Calculator类和Calculator接口创建的calculatorProxyClazz代理class</p>
<p>2.获取代理Class的构造器</p>
<p>3.使用构造器创建一个代理对象(构造器的参数是InvocationHandler接口的对象)</p>
<p>4.InvocationHandler接口的对象必须重写invoke方法，实现对目标对象的增强</p>
<p>5.代理对象可调用的方法与目标对象的方法一致</p>
<p>6.每次调用代理对象的方式时，最终都会调用InvocationHandler的invoke()方法</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1266758/1586510324177-6989ebdc-44f7-4d49-beee-bd9f06407339.jpg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_14,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1266758/1586510324241-fdc9029c-5865-4f3d-b6db-cbe9857f2153.jpg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_14,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<ul>
<li>怎么实现的呢？</li>
</ul>
<p>上面说的根据代理Class的构造器创建对象时，需要传入InvocationHandler。<strong>通过构造器传入一个引用，那么必然有个成员变量去接收。</strong>代理对象内部有InvocationHandler的成员变量，变量名为h(继承自父类Proxy的)，而且代理对象的每个方法内部都会调用h.invoke()。InvocationHandler对象成了代理对象和目标对象的桥梁，不像静态代理这么直接。</p>
<ul>
<li>上面超链接的代理类反汇编：</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">printSomeThing</span><span class="params">(<span class="keyword">String</span> paramString)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">new</span> Object[] &#123; paramString &#125;);</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Error|RuntimeException localError) &#123;</span><br><span class="line">        <span class="keyword">throw</span> localError;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable localThrowable) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="静态代理和动态代理调用方法的区别"><a href="#静态代理和动态代理调用方法的区别" class="headerlink" title="静态代理和动态代理调用方法的区别"></a>静态代理和动态代理调用方法的区别</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1266758/1586510324286-8efc8def-4901-446a-8c1c-d50487b09c3f.jpg" alt="image"></p>
<p>仔细看上图右侧的动态代理，我在invocationHandler的invoke()方法中并没有写目标对象。因为一开始invocationHandler的invoke()里确实没有目标对象，需要我们手动new。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1266758/1586510324328-487f763e-6177-4955-a827-b62355826b16.jpg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_14,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<p>但这种写法不够优雅，属于硬编码。我这次代理A对象，下次想代理B对象还要进来改invoke()方法，太差劲了。改进一下，让调用者把目标对象作为参数传进来：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> ProxyTest &#123;</span><br><span class="line">        public static void main(String<span class="literal">[]</span> args) throws Throwable &#123;</span><br><span class="line">            CalculatorImpl target = <span class="keyword">new</span> <span class="constructor">CalculatorImpl()</span>;</span><br><span class="line">            <span class="comment">//传入目标对象</span></span><br><span class="line">            <span class="comment">//目的：1.根据它实现的接口生成代理对象 2.代理对象调用目标对象方法</span></span><br><span class="line">            Calculator calculatorProxy = (Calculator) get<span class="constructor">Proxy(<span class="params">target</span>)</span>;</span><br><span class="line">            calculatorProxy.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">            calculatorProxy.subtract(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span> static Object get<span class="constructor">Proxy(<span class="params">final</span> Object <span class="params">target</span>)</span> throws Exception &#123;</span><br><span class="line">        <span class="comment">//参数1：随便找个类加载器给它， 参数2：目标对象实现的接口，让代理对象实现相同接口</span></span><br><span class="line">        Class proxyClazz = <span class="module-access"><span class="module"><span class="identifier">Proxy</span>.</span></span>get<span class="constructor">ProxyClass(<span class="params">target</span>.<span class="params">getClass</span>()</span>.get<span class="constructor">ClassLoader()</span>, target.get<span class="constructor">Class()</span>.get<span class="constructor">Interfaces()</span>);</span><br><span class="line">        Constructor constructor = proxyClazz.get<span class="constructor">Constructor(InvocationHandler.<span class="params">class</span>)</span>;</span><br><span class="line">        Object proxy = constructor.<span class="keyword">new</span><span class="constructor">Instance(<span class="params">new</span> InvocationHandler()</span> &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Object invoke(Object proxy, Method <span class="keyword">method</span>, Object<span class="literal">[]</span> args) throws Throwable &#123;</span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="keyword">method</span>.get<span class="constructor">Name()</span> + <span class="string">&quot;方法开始执行...&quot;</span>);</span><br><span class="line">                Object result = <span class="keyword">method</span>.invoke(target, args);</span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(result);</span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="keyword">method</span>.get<span class="constructor">Name()</span> + <span class="string">&quot;方法执行结束...&quot;</span>);</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return proxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>这样就非常灵活，非常优雅了。无论现在系统有多少类，只要你<strong>把实例传进来，getProxy()都能给你返回对应的代理对象</strong>。就这样，我们完美地跳过了代理类，直接创建了代理对象！</p>
<p>不过实际编程中，一般不用getProxyClass()，而是使用Proxy类的另一个静态方法：Proxy.newProxyInstance()，直接返回代理实例，连中间得到代理Class对象的过程都帮你隐藏：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> ProxyTest &#123;</span><br><span class="line">        <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) throws Throwable &#123;</span><br><span class="line">            CalculatorImpl target = <span class="built_in">new</span> CalculatorImpl();</span><br><span class="line">            Calculator calculatorProxy = (Calculator) getProxy(target);</span><br><span class="line">            calculatorProxy.<span class="keyword">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">            calculatorProxy.subtract(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        private static <span class="keyword">Object</span> getProxy(final <span class="keyword">Object</span> target) throws <span class="keyword">Exception</span> &#123;</span><br><span class="line">            <span class="keyword">Object</span> proxy = Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(),<span class="comment">/*类加载器*/</span></span><br><span class="line">                target.getClass().getInterfaces(),<span class="comment">/*让代理对象和目标对象实现相同接口*/</span></span><br><span class="line">                <span class="built_in">new</span> InvocationHandler()&#123;<span class="comment">/*代理对象的方法最终都会被JVM导向它的invoke方法*/</span></span><br><span class="line">                    <span class="built_in">public</span> <span class="keyword">Object</span> invoke(<span class="keyword">Object</span> proxy, <span class="keyword">Method</span> <span class="keyword">method</span>, <span class="keyword">Object</span>[] args) throws Throwable &#123;</span><br><span class="line">                        <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="keyword">method</span>.getName() + &quot;方法开始执行...&quot;);</span><br><span class="line">                        <span class="keyword">Object</span> result = <span class="keyword">method</span>.invoke(target, args);</span><br><span class="line">                        <span class="keyword">System</span>.<span class="keyword">out</span>.println(result);</span><br><span class="line">                        <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="keyword">method</span>.getName() + &quot;方法执行结束...&quot;);</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">return</span> proxy;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h3 id="动态代理总结"><a href="#动态代理总结" class="headerlink" title="动态代理总结"></a>动态代理总结</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1266758/1586510324382-164e0b9b-9a82-43fc-bdce-6bdcefa1a627.jpg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<p><strong>补充：InvocationHandler</strong></p>
<p>   0.Java动态代理机制中有两个重要的类和接口InvocationHandler（接口）和Proxy（类），这一个类Proxy和接口InvocationHandler是实现动态代理的核心</p>
<p>   1.InvocationHandler接口是proxy代理实例的调用处理程序实现的一个接口，每一个proxy代理实例都有一个关联的调用处理程序；在代理实例调用方法时，方法调用被编码分派到调用处理程序的invoke方法</p>
<p>   <img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1586510324427-b0de2672-f514-45e1-bb7d-0fc95a53396a.png" alt="image"></p>
<p>   2.<strong>每一个动态代理类的调用处理程序都必须实现InvocationHandler接口</strong>，<strong>并且每个代理类的实例都关联到了实现该接口的动态代理类调用处理程序中</strong>，当我们通过动态代理对象调用一个方法时候，这个方法的调用就会被转发到实现InvocationHandler接口类的invoke方法来调用</p>
<p>   <strong>代理对象中拥有原对象的所有方法，这些方法只少有一行，使用InvocationHandler对象h调用invoke的语句，具体的增强和调用原对象的对应方法由InvocationHandler实现类完成：</strong></p>
<p>​     <img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1586510324464-81e23b07-3745-4808-8035-f163a6540dcf.png" alt="image"></p>
<p>​     调用invoke是会携带Method信息，invoke会在增强中调用原方法</p>
<p>   3.<strong>Proxy类</strong>就是用来<strong>创建一个代理对象的类</strong>，它提供了很多方法，但是我们最常用的是newProxyInstance方法</p>
<h3 id="动态代理的应用"><a href="#动态代理的应用" class="headerlink" title="动态代理的应用"></a>动态代理的应用</h3><ul>
<li>Spring AOP</li>
<li>RPC框架 Dubbo</li>
<li>断路器 Spring Cloud Hystrix</li>
<li>Mock单元测试</li>
</ul>
<h1 id="适配器模式和代理模式的区别"><a href="#适配器模式和代理模式的区别" class="headerlink" title="适配器模式和代理模式的区别"></a>适配器模式和代理模式的区别</h1><ul>
<li>适配器模式：本质上是将一个旧接口换成一个新接口，对原有方法进行增强，用户调用时调用新接口的方法。原接口功能由新接口实现类进行调用</li>
<li>代理模式：代理模式没有产生新接口，而是实现了原接口，并且返回一个代理对象给调用者。而CGLIB创建子类代理对象的方法也是一样，用的还是原来的接口</li>
<li>目的不完全一样：除了都能原有功能进行增强外，适配器模式初心是旧接口不满足需求，使用适配器完成新旧接口的转换，而代理模式是为了不让用户直接接触原对象，返回一个代理对象给用户调用</li>
</ul>
<h2 id="适配器模式示意图"><a href="#适配器模式示意图" class="headerlink" title="适配器模式示意图"></a>适配器模式示意图</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1266758/1587472095548-2b6da71c-9bec-4cbd-bf11-a67d74f8122e.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="1.jpg"></p>
<h2 id="代理模式示意图"><a href="#代理模式示意图" class="headerlink" title="代理模式示意图"></a>代理模式示意图</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1266758/1587472117679-1440a002-1ad3-4173-ad0c-3918c0e4ee38.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="2.jpg"></p>
<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><ul>
<li>策略模式：策略模式是对算法的包装，把使用算法的责任和算法本身分隔开，委派给不同的对象管理。策略模式通常把一系列的算法包装到一系列的策略类里面，作为一个抽象策略类的子类</li>
<li>主要解决：在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护</li>
<li>使用时机：一个系统有多个类，而区分它们的只是他们直接的行为</li>
<li>解决方式：将这些算法封装成一个一个的类，任意地替换</li>
<li>关键特点：实现同一个接口</li>
<li>优点：1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好</li>
</ul>
<h2 id="Spring中的策略模式"><a href="#Spring中的策略模式" class="headerlink" title="Spring中的策略模式"></a>Spring中的策略模式</h2><h3 id="实例化的策略模式"><a href="#实例化的策略模式" class="headerlink" title="实例化的策略模式"></a>实例化的策略模式</h3><ul>
<li><p>Spring实例化Bean时会判断设置的哪种实例化策略：getInstantiationStrategy()方法，而setInstantiationStrategy()方法是public的可以由用户选择实例化策略。默认的是Cglib方式实例化，但是如果没使用方法注入则仍然使用JDK方式初始化</p>
</li>
<li><p>实例化策略有两种</p>
</li>
<li><ul>
<li>一种使用JDK的反射原理实例化对象——BeanUtils.<em>instantiateClass</em>(constructorToUse)</li>
<li>另一种是使用CGLIB生成Bean的子类对象——instantiateWithMethodInjection(bd, beanName, owner)</li>
</ul>
</li>
<li><p>策略选择点：</p>
</li>
<li><ul>
<li>createBean()–&gt;doCreateBean()–&gt;createBeanInstance–&gt;instantiateBean–&gt;SimpleInstantiationStrategy类instantiate()的↓：</li>
<li>方法中的策略选择语句：if (!bd.hasMethodOverrides()) {…}</li>
<li>根据SimpleInstantiationStrategy类中的instantiateWithMethodInjection()是否被CGLIB重写，而选择调用JDK方式还是CGLIB方式</li>
<li>在使用<strong>方法注入</strong>的时候会才会使用CglibxxxStrategy中的实例化方法，平时只会使用JDK方式实例化</li>
</ul>
</li>
<li><p>类关系图：级联结构和下面的不同</p>
</li>
<li><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1587539451277-a95ec07e-d64b-4cff-b814-54a6cbdebc19.png" alt="image.png"></li>
</ul>
</li>
</ul>
<h3 id="代理方式的策略模式"><a href="#代理方式的策略模式" class="headerlink" title="代理方式的策略模式"></a>代理方式的策略模式</h3><ul>
<li><p>Spring AOP会根据被代理对象是否有接口而选择使用JdkDynamicAopProxy类/CglibAopProxy类的算法创建代理对象</p>
</li>
<li><p>策略选择点：</p>
</li>
<li><ul>
<li>DefaultAopProxyFactory类中createAopProxy()方法的语句↓(详见<a target="_blank" rel="noopener" href="https://www.yuque.com/luka/note/aop#MhJYj">堆栈调用图</a>)：</li>
<li>如果targetClass有接口则使用JDK的方式创建代理对象，否则使用CGLIB的方式创建代理对象</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1587538194215-abb3832d-a485-4926-9a70-18392f6c60a1.png" alt="image.png"></li>
</ul>
</li>
<li><p>类结构图：</p>
</li>
<li><ul>
<li>两种策略都实现AopProxy接口，是策略模式的特点之一</li>
<li>策略模式中的并列实现接口，而实例化中的策略模式是级联的方式，其中一种策略间接实现接口</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1587537883215-343a7ac1-4a41-45e7-a6cd-c982341c6f9c.png" alt="image.png"></li>
</ul>
</li>
</ul>
<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li><p>当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象</p>
</li>
<li><p><strong>意图：</strong>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新</p>
</li>
<li><p><strong>主要解决：</strong>一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作</p>
</li>
<li><p><strong>何时使用：</strong>一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知</p>
</li>
<li><p><strong>如何解决：</strong>使用面向对象技术，可以将这种依赖关系弱化</p>
</li>
<li><p><strong>关键代码：</strong>在抽象类里有一个 ArrayList 存放观察者们</p>
</li>
<li><p><strong>优点：</strong></p>
</li>
<li><ul>
<li>观察者和被观察者是抽象耦合的</li>
<li>建立一套触发机制</li>
</ul>
</li>
<li><p><strong>缺点：</strong></p>
</li>
<li><ul>
<li>如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间</li>
<li>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃</li>
<li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化</li>
</ul>
</li>
<li><p><strong>使用场景：</strong></p>
</li>
<li><ul>
<li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用</li>
<li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度</li>
<li>一个对象必须通知其他对象，而并不知道这些对象是谁</li>
<li>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制</li>
</ul>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul>
<li>观察者模式使用三个类 Subject、Observer 和 Client</li>
<li>Subject 对象带有绑定观察者到 Client 对象和从 Client 对象解绑观察者的方法</li>
<li>创建 <em>Subject</em> 类、<em>Observer</em> 抽象类和扩展了抽象类 <em>Observer</em> 的实体类</li>
<li>被观察的Subject有所有观察者的对象，而每一个观察者都有被观察的Subject对象</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1266758/1598419382702-5c19c784-9c9c-4c45-be04-e825b23b564e.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></li>
<li>Subject类</li>
</ul>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"> </span><br><span class="line">public class Subject &#123;</span><br><span class="line">   </span><br><span class="line">   private List<span class="variable">&lt;Observer&gt;</span> observers </span><br><span class="line">      = new ArrayList<span class="variable">&lt;Observer&gt;</span>();</span><br><span class="line">   private int <span class="keyword">state</span>;</span><br><span class="line"> </span><br><span class="line">   public int getState() &#123;</span><br><span class="line">      return <span class="keyword">state</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   //状态变化，通知所有观察者</span><br><span class="line">   public void <span class="built_in">set</span>State(int <span class="keyword">state</span>) &#123;</span><br><span class="line">      this.<span class="keyword">state</span> = <span class="keyword">state</span>;</span><br><span class="line">      notifyAllObservers();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void attach(Observer observer)&#123;</span><br><span class="line">      observers.add(observer);      </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void notifyAllObservers()&#123;</span><br><span class="line">      <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">         observer.update();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Observer抽象类和实现类</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">   <span class="keyword">protected</span> <span class="type">Subject</span> subject;</span><br><span class="line">   public <span class="keyword">abstract</span> void update();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">BinaryObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">   public <span class="type">BinaryObserver</span>(<span class="type">Subject</span> subject)&#123;</span><br><span class="line">      <span class="keyword">this</span>.subject = subject;</span><br><span class="line">      <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   public void update() &#123;</span><br><span class="line">      <span class="type">System</span>.out.println( <span class="string">&quot;Binary String: &quot;</span> </span><br><span class="line">      + <span class="type">Integer</span>.toBinaryString( subject.getState() ) ); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">HexaObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">   public <span class="type">HexaObserver</span>(<span class="type">Subject</span> subject)&#123;</span><br><span class="line">      <span class="keyword">this</span>.subject = subject;</span><br><span class="line">      <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   public void update() &#123;</span><br><span class="line">      <span class="type">System</span>.out.println( <span class="string">&quot;Hex String: &quot;</span> </span><br><span class="line">      + <span class="type">Integer</span>.toHexString( subject.getState() ).toUpperCase() ); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用观察者观察Subject</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> ObserverPatternDemo &#123;</span><br><span class="line">   public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">      Subject subject = <span class="keyword">new</span> <span class="constructor">Subject()</span>;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">new</span> <span class="constructor">HexaObserver(<span class="params">subject</span>)</span>;</span><br><span class="line">      <span class="keyword">new</span> <span class="constructor">BinaryObserver(<span class="params">subject</span>)</span>;</span><br><span class="line"> </span><br><span class="line">      <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;First state change: 15&quot;</span>);   </span><br><span class="line">      subject.set<span class="constructor">State(15)</span>;</span><br><span class="line">      <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;Second state change: 10&quot;</span>);  </span><br><span class="line">      subject.set<span class="constructor">State(10)</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h1><h2 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构</li>
<li><strong>意图：</strong>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活</li>
<li><strong>何时使用：</strong>在不想增加很多子类的情况下扩展类</li>
<li><strong>优点：</strong>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能</li>
<li><strong>缺点：</strong>多层装饰比较复杂</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ul>
<li><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1599488169556-29522580-220f-47c5-a4d4-78eb6c4b31fb.png" alt="image.png"></p>
</li>
<li><p>第一步：定义奶茶接口（Component）</p>
</li>
<li><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1599488027636-f9c6fea6-9991-4457-9894-553af7e53f52.png" alt="image.png"></li>
</ul>
</li>
<li><p>第二步：定义两种不同种类的奶茶：珍珠奶茶和蜂蜜奶茶（ConcreteComponent）</p>
</li>
<li><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1599488033817-6389b760-5800-4171-a7fe-3f64fcae004f.png" alt="image.png"></li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1599488041801-491feb30-1c2d-460f-88f6-8af578256d2c.png" alt="image.png"></li>
</ul>
</li>
<li><p>第三步：定义口味</p>
</li>
<li><ul>
<li>装饰类的抽象方法，实现同样的接口</li>
<li>也可以不用抽象类，用抽象类方便实现多个装饰类</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Taste</span> <span class="keyword">implements</span> <span class="title">MilkTea</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">milkTeaName</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">milkTeaPrice</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第四步：具体的装饰类：具体口味（ConcreteDecorator）：加冰和加咖啡</p>
</li>
<li><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1599488640555-e9a632f6-7aee-419b-94c4-5a5af25fe5f8.png" alt="image.png"></li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1599488665640-b07a4f7f-f182-4ec3-a5ca-fa565223df75.png" alt="image.png"></li>
</ul>
</li>
<li><p>第五步：使用：用户买奶茶</p>
</li>
<li><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1599488710347-5ebaa282-dcb5-42c8-a385-ad8066bb26e1.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image.png"></li>
</ul>
</li>
</ul>
<h1 id="装饰器模式和代理模式的区别"><a href="#装饰器模式和代理模式的区别" class="headerlink" title="装饰器模式和代理模式的区别"></a>装饰器模式和代理模式的区别</h1><ol>
<li>对装饰器模式来说，装饰者（Decorator）和被装饰者（Decoratee）都实现一个接口。对代理模式来说，代理类（Proxy Class）和真实处理的类（Real Class）都实现同一个接口</li>
<li>不论我们使用哪一个模式，都可以很容易地在真实对象的方法前面或者后面加上自定义的方法</li>
<li>上面的例子中，装饰器模式是使用的调用者从外部传入的被装饰对象（coffee），调用者只想要你把他给你的对象装饰（加强）一下。而代理模式使用的是代理对象在自己的构造方法里面new的一个被代理的对象，不是调用者传入的。代理模式中，调用者不需要也不知道是否有其他实现类</li>
<li>装饰器模式关注于在一个对象上动态地添加方法，而代理模式关注于控制对对象的访问。换句话说，用代理模式，代理类可以对它的客户隐藏一个对象的具体信息。因此当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例；当使用装饰器模式的时候，我们通常的做法是将原始对象作为一个参数传给装饰器的构造器</li>
<li>装饰器模式和代理模式的使用场景不一样，比如IO流使用的是装饰者模式，可以层层增加功能。而代理模式则一般是用于增加特殊的功能，有些动态代理不支持多层嵌套</li>
<li>代理更多的是强调对对象的访问控制，而装饰器更多的强调给对象加强功能</li>
</ol>

        </div>

        
            <section class="post-copyright">
                
                
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>年与时驰，意与日去，遂成枯落，多不接世，悲守穷庐，将复何及</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"># 设计模式</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2020/09/02/redis/">Redis</a>
            
            
            <a class="next" rel="next" href="/2020/08/24/JavaSE/">JavaSE</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© X_ray | Powered by <a href="https://xray1025.top" target="_blank">Xray</a></span>
    </div>
</footer>

    </div>
</body>
</html>
