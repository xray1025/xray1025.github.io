<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>数据库 | X_ray's blog</title><meta name="keywords" content="数据库"><meta name="author" content="X_ray"><meta name="copyright" content="X_ray"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="MySQL 一、MySQL架构和其它数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎的架构上，插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。   连接层：最上层是一些客户端和连接服务。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概">
<meta property="og:type" content="article">
<meta property="og:title" content="数据库">
<meta property="og:url" content="https://xray1025.github.io/2020/10/13/0000.%E6%95%B0%E6%8D%AE%E5%BA%93/index.html">
<meta property="og:site_name" content="X_ray&#39;s blog">
<meta property="og:description" content="MySQL 一、MySQL架构和其它数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎的架构上，插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。   连接层：最上层是一些客户端和连接服务。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2020-10-13T00:52:22.744Z">
<meta property="article:modified_time" content="2020-11-05T10:56:01.606Z">
<meta property="article:author" content="X_ray">
<meta property="article:tag" content="数据库">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://xray1025.github.io/2020/10/13/0000.%E6%95%B0%E6%8D%AE%E5%BA%93/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-11-05 18:56:01'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/null" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">104</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div></div><hr/></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">X_ray's blog</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据库</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-10-13T00:52:22.744Z" title="发表于 2020-10-13 08:52:22">2020-10-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-11-05T10:56:01.606Z" title="更新于 2020-11-05 18:56:01">2020-11-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/1590590509208-c55e311d-4d15-4bd8-8b43-5bec5a1c2193.png" alt="image"></p>
<h2 id="一、MySQL架构"><a href="#一、MySQL架构" class="headerlink" title="一、MySQL架构"></a>一、MySQL架构</h2><p>和其它数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎的架构上，<strong>插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离</strong>。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/1590590539775-66b802ba-2c1c-4c50-9cd0-a41eb54578e5.png" alt="image"></p>
<ul>
<li><strong>连接层</strong>：最上层是一些客户端和连接服务。<strong>主要完成一些类似于连接处理、授权认证、及相关的安全方案</strong>。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</li>
<li><strong>服务层</strong>：第二层服务层，主要完成大部分的核心服务功能， 包括<strong>查询解析、分析、优化、缓存**</strong>、以及所有的内置函数<strong>，所有跨存储引擎的功能也都在这一层实现，包括</strong>触发器、存储过程、视图**等</li>
<li><strong>引擎层</strong>：第三层存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取</li>
<li><strong>存储层</strong>：第四层为数据存储层，主要是将数据存储在运行于该设备的文件系统之上，并完成与存储引擎的交互</li>
</ul>
<p><strong>MySQL 的查询流程</strong></p>
<p>（所有SQL语句都可以称为查询，包括INSERT,DELETE,UPDATE）</p>
<p>—&gt; 客户端请求</p>
<p>—&gt; 连接器（验证用户身份，给予权限）  </p>
<p>—&gt; 查询缓存（存在缓存则直接返回，不存在则执行后续操作）</p>
<p>—&gt; 分析器（对SQL进行词法分析和语法分析操作）  </p>
<p>—&gt; 优化器（主要对执行的sql优化选择最优的执行方案方法）  </p>
<p>—&gt; 执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口）</p>
<p>—&gt; 去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）</p>
<h2 id="二、MySQL-事务"><a href="#二、MySQL-事务" class="headerlink" title="二、MySQL 事务"></a>二、MySQL 事务</h2><blockquote>
<p>❝</p>
<p>事务的隔离级别有哪些？MySQL的默认隔离级别是什么？</p>
<p>什么是幻读，脏读，不可重复读呢？</p>
<p>MySQL事务的四大特性以及实现原理</p>
<p>MVCC熟悉吗，它的底层原理？</p>
</blockquote>
<p>MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！</p>
<h3 id="ACID-—-事务基本要素"><a href="#ACID-—-事务基本要素" class="headerlink" title="ACID — 事务基本要素"></a>ACID — 事务基本要素</h3><p>事务是由一组SQL语句组成的逻辑处理单元，具有4个属性，通常简称为事务的ACID属性。</p>
<ul>
<li><strong>A (Atomicity) 原子性</strong>：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样</li>
<li><strong>C (Consistency) 一致性</strong>：在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。AID是手段，C是目的，即通过种种手段保证数据库在事务执行前后都处于正确的状态（即数据库列上没有限制数据的范围，但是转账业务中不可能出现账户余额为负的情况，所以要保证事务前后要保证数据库在业务上处于正确的状态）</li>
<li><strong>I (Isolation)隔离性</strong>：一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰</li>
<li><strong>D (Durability) 持久性</strong>：在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚</li>
</ul>
<p><strong>（隔离性不够时）**</strong>并发事务处理带来的问题**</p>
<ul>
<li>**更新丢失（Lost Update)**：事务A和事务B选择同一行，并基于最初选定的值更新该行时，由于两个事务都不知道彼此的存在，就会发生丢失更新问题</li>
<li>**脏读(Dirty Reads)**：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</li>
<li>**不可重复读（Non-Repeatable Reads)**：事务 A 多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。</li>
<li>**幻读（Phantom Reads)**：幻读与不可重复读类似。它发生在一个事务A读取了几行数据，接着另一个并发事务B插入了一些数据时。在随后的查询中，事务A就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>
</ul>
<p><strong>幻读和不可重复读的区别：</strong></p>
<ul>
<li><strong>不可重复读的重点是修改</strong>：在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样。（因为中间有其他事务提交了修改）</li>
<li><strong>幻读的重点在于新增或者删除</strong>：在同一事务中，同样的条件,第一次和第二次读出来的记录数不一样。（因为中间有其他事务提交了插入/删除）</li>
</ul>
<p><strong>并发事务处理带来的问题的解决办法：</strong></p>
<ul>
<li><p>“更新丢失”通常是应该完全避免的。但防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决，因此，防止更新丢失应该是应用的责任。</p>
</li>
<li><p><strong>“脏读” 、 “不可重复读”和“幻读” ，其实都是数据库读一致性问题</strong>，必须由数据库提供一定的事务隔离机制来解决：</p>
</li>
<li><ul>
<li>一种是加锁：在读取数据前，对其加锁，阻止其他事务对数据进行修改。</li>
<li>另一种是数据多版本并发控制（MultiVersion Concurrency Control，<strong>MVCC</strong> ）：可以认为是行级锁的变种， 通过一定机制生成一个数据请求时间点的一致性数据快照 （Snapshot)， 并用这个快照来提供一定级别 （语句级或事务级） 的一致性读取。下面会详细介绍MVCC。</li>
</ul>
</li>
</ul>
<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>数据库事务的隔离级别有4种，由低到高分别为</p>
<ul>
<li><strong>READ-UNCOMMITTED(读未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li>
<li><strong>READ-COMMITTED(读已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li>
<li><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li>
<li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li>
</ul>
<p>查看当前数据库的事务隔离级别：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">&#x27;tx_isolation&#x27;</span></span><br></pre></td></tr></table></figure>

<p>下面通过事例一一阐述在事务的并发操作中可能会出现脏读，不可重复读，幻读和事务隔离级别的联系。</p>
<p><strong>数据库的事务隔离越严格，并发副作用越小，但付出的代价就越大</strong>，因为事务隔离实质上就是使事务在一定程度上“串行化”进行，这显然与“并发”是矛盾的。同时，不同的应用对读一致性和事务隔离程度的要求也是不同的，比如许多应用对“不可重复读”和“幻读”并不敏感，可能更关心数据并发访问的能力。</p>
<ul>
<li><strong>Read uncommitted</strong></li>
</ul>
<p><strong>读未提交，就是一个事务可以读取另一个未提交事务的数据</strong>。</p>
<p>事例：老板要给程序员发工资，程序员的工资是3.6万/月。但是发工资时老板不小心按错了数字，按成3.9万/月，该钱已经打到程序员的户口，但是事务还没有提交，就在这时，程序员去查看自己这个月的工资，发现比往常多了3千元，以为涨工资了非常高兴。但是老板及时发现了不对，马上回滚差点就提交了的事务，将数字改成3.6万再提交。</p>
<p>分析：实际程序员这个月的工资还是3.6万，但是程序员看到的是3.9万。他看到的是老板还没提交事务时的数据。这就是脏读。</p>
<p>那怎么解决脏读呢？Read committed！读提交，能解决脏读问题。</p>
<ul>
<li><strong>Read committed</strong></li>
</ul>
<p><strong>读**</strong>提交，顾名思义，就是一个事务要等另一个事务提交后才能读取数据**。</p>
<p>事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（程序员事务开启），收费系统事先检测到他的卡里有3.6万，就在这个时候！！程序员的妻子要把钱全部转出充当家用，并提交。当收费系统准备扣款时，再检测卡里的金额，发现已经没钱了（第二次检测金额当然要等待妻子转出金额事务提交完）。程序员就会很郁闷，明明卡里是有钱的…</p>
<p>分析：这就是读提交，若有事务对数据进行更新（UPDATE）操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。但在这个事例中，<strong>出现了一个事务范围内两个相同的查询却返回了不同数据</strong>，这就是<strong>不可重复读</strong>。</p>
<p>那怎么解决可能的不可重复读问题？Repeatable read ！</p>
<ul>
<li><strong>Repeatable read</strong></li>
</ul>
<p>重复读，就是在开始读取数据（事务开启）时，不再允许修改操作。<strong>MySQL的默认事务隔离级别</strong></p>
<p>事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（事务开启，不允许其他事务的UPDATE修改操作），收费系统事先检测到他的卡里有3.6万。这个时候他的妻子不能转出金额了。接下来收费系统就可以扣款了。</p>
<p>分析：重复读可以解决不可重复读问题。写到这里，应该明白的一点就是，<strong>不可重复读对应的是修改，即UPDATE操作。但是可能还会有幻读问题。因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作</strong>。</p>
<p><strong>什么时候会出现幻读？</strong></p>
<p>事例：程序员某一天去消费，花了2千元，然后他的妻子去查看他今天的消费记录（全表扫描FTS，妻子事务开启），看到确实是花了2千元，就在这个时候，程序员花了1万买了一部电脑，即新增INSERT了一条消费记录，并提交。当妻子打印程序员的消费记录清单时（妻子事务提交），发现花了1.2万元，似乎出现了幻觉，这就是幻读。</p>
<p>那怎么解决幻读问题？Serializable！</p>
<ul>
<li><strong>Serializable</strong></li>
</ul>
<p>Serializable 是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。简单来说，Serializable会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用问题。这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。</p>
<h4 id="隔离级别比较"><a href="#隔离级别比较" class="headerlink" title="隔离级别比较"></a>隔离级别比较</h4><table>
<thead>
<tr>
<th>事务隔离级别</th>
<th>读数据一致性</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交（read-uncommitted）</td>
<td>最低级被，只能保证不读取物理上损坏的数据</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>读已提交（read-committed）</td>
<td>语句级</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>可重复读（repeatable-read）</td>
<td>事务级</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>串行化（serializable）</td>
<td>最高级别，事务级</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
<p>需要说明的是，<strong>事务隔离级别和数据访问的并发性是对立的</strong>，事务隔离级别越高并发性就越差。所以要根据具体的应用来确定合适的事务隔离级别，这个地方没有万能的原则。</p>
<p><strong>这里需要注意的是：</strong>与 SQL 标准不同的地方在于InnoDB 存储引擎在 <strong>REPEATABLE-READ</strong>（可重读）事务隔离级别下使用的是<strong>Next-Key Lock</strong> 算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 <strong>SERIALIZABLE</strong>(可串行化)隔离级别，而且保留了比较好的并发性能。</p>
<p>因为<strong>隔离级别越低，事务请求的锁越少</strong>，所以大部分数据库系统的隔离级别都是<strong>READ-COMMITTED</strong>(读已提交):，但是你要知道的是<strong>InnoDB 存储引擎默认使用 REPEATABLE-READ（可重读）并不会有任何性能损失</strong>。</p>
<h3 id="MVCC-多版本并发控制"><a href="#MVCC-多版本并发控制" class="headerlink" title="MVCC 多版本并发控制"></a>MVCC 多版本并发控制</h3><p>MySQL的大多数<strong>事务型存储引擎实现都不是简单的行级锁**</strong>。基于提升并发性考虑，一般都同时实现了多版本并发控制（MVCC）**，包括Oracle、PostgreSQL。只是实现机制各不相同</p>
<p><strong>可以认为 MVCC 是行级锁的一个变种，但它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只是锁定必要的行</strong></p>
<p>MVCC 的实现是通过保存数据在某个时间点的快照来实现的。也就是说不管事务需要执行多长时间，每个事物看到的数据都是一致的。根据事务开始时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的</p>
<p><strong>MVCC与幻读：</strong></p>
<ul>
<li><p>当前读：读取数据的最新版本，例如update/insert/dalete/select … for update/select … lock in share mode</p>
</li>
<li><ul>
<li>这种MVCC不能防止幻读</li>
</ul>
</li>
<li><p>快照读：读取事务快照，普通的select语句都是快照读</p>
</li>
<li><ul>
<li>这种方式因为读取的是快照（如果发生了insert也不会修改到快照），所以天然解决了幻读</li>
</ul>
</li>
</ul>
<p>典型的MVCC实现方式，分为<strong>乐观并发控制</strong>和<strong>悲观并发控制</strong>。下边通过 InnoDB的简化版行为来说明 MVCC 是如何工作的。</p>
<p><strong>InnoDB 的 MVCC，是通过在每行记录后面保存两个隐藏的列来实现</strong>。<strong>一个保存了行的创建时间，一个保存行的过期时间（删除时间）</strong>。当然存储的并不是真实的时间，而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</p>
<p><strong>REPEATABLE READ（可重读）隔离级别下MVCC如何工作：</strong></p>
<ul>
<li><p><strong>SELECT：</strong></p>
</li>
<li><ul>
<li>InnoDB会根据以下两个条件检查每行记录，只有符合上述两个条件的才会被查询出来</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>只查找版本早于当前事务版本的数据行，这样可以确保事务读取的行，要么是在开始事务之前已经存在要么是事务自身插入或者修改过的</li>
<li>行的删除版本号要么未定义，要么大于当前事务版本号，这样可以确保事务读取到的行在事务开始之前未被删除</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>INSERT：</strong>InnoDB为新插入的每一行保存当前系统版本号作为行版本号</p>
</li>
<li><p><strong>DELETE：</strong>InnoDB为删除的每一行保存当前系统版本号作为行删除标识</p>
</li>
<li><p><strong>UPDATE：**</strong>InnoDB为插入的一行新纪录保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识**</p>
</li>
</ul>
<p>保存这两个额外系统版本号，使大多数操作都不用加锁。使数据操作简单，性能很好，并且也能保证只会读取到符合要求的行。不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作和一些额外的维护工作。</p>
<p>MVCC 只在 COMMITTED READ（读提交）和REPEATABLE READ（可重复读）两种隔离级别下工作。</p>
<blockquote>
<p>❝你知道MySQL 有多少种日志吗？</p>
</blockquote>
<ul>
<li><strong>错误日志</strong>：记录出错信息，也记录一些警告信息或者正确的信息。</li>
<li><strong>查询日志</strong>：记录所有对数据库请求的信息，不论这些请求是否得到了正确的执行。</li>
<li><strong>慢查询日志</strong>：设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询的日志文件中。</li>
<li><strong>二进制日志</strong>：binlog 记录对数据库执行更改的所有操作。</li>
<li><strong>中继日志</strong>：中继日志也是二进制日志，用来给slave 库恢复</li>
<li><strong>事务日志</strong>：重做日志redo和回滚日志undo</li>
</ul>
<h3 id="InnoDB事务日志"><a href="#InnoDB事务日志" class="headerlink" title="InnoDB事务日志"></a>InnoDB事务日志</h3><p><strong>InnoDB 使用日志来减少提交事务时的开销：因为日志中已经记录了事务，就无须在每个事务提交时把缓冲池的脏块刷新(flush)到磁盘中</strong>。</p>
<p><strong>事务修改的数据和索引通常会映射到表空间的随机位置，所以刷新这些变更到磁盘需要很多随机 I/O</strong>。</p>
<p>随机I/O比顺序IO昂贵得多，因为一个I/O请求需要时间把磁头移到正确的位置，然后等待磁盘上读出需要的部分，再转到开始位置。</p>
<p><strong>InnoDB 用日志把随机IO变成顺序IO。一旦日志安全写到磁盘，事务就持久化了，即使断电了，InnoDB可以重放日志并且恢复已经提交的事务</strong>。</p>
<p>InnoDB 使用一个后台线程智能地刷新这些变更到数据文件。这个线程可以批量组合写入，使得数据写入更顺序，以提高效率。</p>
<p>事务日志可以帮助提高事务效率：</p>
<ul>
<li>使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。</li>
<li>事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，所以采用事务日志的方式相对来说要快得多。</li>
<li>事务日志持久以后，内存中被修改的数据在后台可以慢慢刷回到磁盘。</li>
<li>如果数据的修改已经记录到事务日志并持久化，但数据本身没有写回到磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这一部分修改的数据。</li>
</ul>
<p>目前来说，大多数存储引擎都是这样实现的，我们通常称之为<strong>预写式日志</strong>（Write-Ahead Logging），修改数据需要写两次磁盘。</p>
<h3 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h3><p>事务的实现是基于数据库的存储引擎。不同的存储引擎对事务的支持程度不一样。MySQL 中支持事务的存储引擎有 InnoDB 和 NDB。</p>
<p>事务的实现就是如何实现ACID特性。</p>
<p><strong>事务的隔离性是通过锁实现，而**</strong>事务的**<strong>一致性和持久性则是通过事务日志实现</strong> 。</p>
<blockquote>
<p>❝事务是如何通过日志来实现的，说得越深入越好。</p>
</blockquote>
<p>事务日志包括：<strong>重做日志redo</strong>和<strong>回滚日志undo</strong></p>
<ul>
<li><p><strong>redo log（重做日志</strong>）：实现持久化</p>
</li>
<li><ul>
<li>redo log 是<strong>事务中</strong>操作任何数据，都会将最新的数据备份到一个地方</li>
<li>在InnoDB的存储引擎中，事务日志通过重做(redo)日志和InnoDB存储引擎的日志缓冲(InnoDB Log Buffer)实现。事务开启时，<strong>事务中的操作，在**</strong>执行过程中都会先写入存储引擎的日志缓冲中，**<strong>在**</strong>事务提交之前**<strong>，这些缓冲的日志都需要提前刷新到磁盘上持久化</strong>，这就是DBA们口中常说的“日志先行”(Write-Ahead Logging)。</li>
<li>当事务提交之后，在Buffer Pool中映射的数据文件才会慢慢刷新到磁盘。此时如果数据库崩溃或者宕机，那么当系统重启进行恢复时，就可以根据redo log中记录的日志，把数据库恢复到崩溃前的一个状态。未完成的事务，可以继续提交，也可以选择回滚，这基于恢复的策略而定。</li>
<li><strong>在系统启动的时候，就已经为redo log分配了一块连续的存储空间，以顺序追加的方式记录redo log，通过顺序IO来改善性能</strong>。所有的事务共享redo log的存储空间，它们的redo log按语句的执行顺序，依次交替的记录在一起</li>
<li><strong>redo log和存储结构的关系：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>MySQL基本存储结构是页，所以会先将页加载到内存中，对内存中的页进行修改，然后再刷回磁盘（这个过程是随机IO）</li>
<li>但是一个页16KB，不值得每一次都刷入磁盘，所以会异步的刷到磁盘中</li>
<li>同时防止数据库宕机，而内存没有来得及刷入磁盘，引入了redo log（es也有类似的，translog）</li>
<li>redo log也有自己的内存buffer，先写buffer，然后由于redo log在磁盘中是顺序存储，所以可以很快的就写入磁盘</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1596528160059-8e4787a5-7932-43b1-9c53-c01696d8b624.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image.png"></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>undo log（回滚日志）：</strong>原子性</p>
</li>
<li><ul>
<li>undo log 是<strong>事务开始之前</strong>，操作任何数据之前，首先将需要操作的数据备份到一个地方</li>
<li>undo log 提供两个功能：回滚和MVCC（原子性需要要么成功要么回滚，所以undo log帮助实现原子性）</li>
<li><strong>undo log记录了数据在每个操作前的状态，如果事务执行过程中需要回滚，就可以根据undo log进行回滚操作</strong>。单个事务的回滚，只会回滚当前事务做的操作，并不会影响到其他的事务做的操作</li>
<li>undo log记录的是已部分完成并且写入硬盘的未完成的事务，默认情况下回滚日志是记录下表空间中的（共享表空间或者独享表空间）</li>
<li><strong>undo log和MVCC：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>undo log中的数据可以作为数据旧版本快照供其他并发事务进行快照读</li>
<li>当读取被其他事务锁定的行时，可以从undo log中分析出改行记录以前的数据是什么，从而提供该行版本信息，实现非锁定一致性读取</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1596527329634-8360cba5-8e2c-4d0f-8761-168fe59d4286.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>上面二种日志均可以视为一种恢复操作，redo_log是恢复提交事务修改的页操作，而undo_log是回滚行记录到特定版本。二者记录的内容也不同</p>
</li>
<li><p><strong>redo_log是物理日志，记录页的物理修改操作，而undo_log是逻辑日志，根据每行记录进行记录，binlog也是逻辑日志</strong></p>
</li>
<li><p><strong>binlog：实现复制功能</strong></p>
</li>
<li><ul>
<li><strong>因为MySQL可能使用不同的引擎，所以需要在server层记录执行操作的日志，这样可以实现MySQL的主从复制功能以及发送消息队列功能</strong></li>
<li>然而这种情况会导致redo log与binlog的一致性问题，MySQL通过内部XA两阶段提交机制解决这种一致性的问题</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>本来直接提交redo log啥事也没有，但是因为有binlog的存在，就要想办法保证redo log和binlog一致</li>
<li>步骤细节在下面一节</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>redo log 和 binlog都有共同的字段XID(事务ID)，崩溃时的恢复操作：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>恢复时，顺序扫描redo log</li>
<li>如果既prepare，又commit，则直接提交redo log，将redo log中的数据写入真正的页中</li>
<li>如果只有prepare，没有commit，则根据XID检查binlog，如果binlog中有XID，则也将redo log中的数据写入真的的页中</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>为什么这么做？</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>引入binlog保证数据库的主从一致性</li>
<li>防止出现主从不一致，使用了两阶段提交</li>
<li>崩溃恢复时如果binlog中包含了事务，则会提交，因为binlog会复制到其他数据库中，所以binlog中有的事务需要提交</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>只用binlog行不行？</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>binlog记录逻辑日志，没有数据页的更新细节，所以不能恢复</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>只用redo log行不行？</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>不可行，需要binlog屏蔽MySQL底层的引擎</li>
<li>同时，主从复制的时候传播的是逻辑操作，redo log这种物理操作不能应用在主从复制中</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="事务的写入过程"><a href="#事务的写入过程" class="headerlink" title="事务的写入过程"></a>事务的写入过程</h3><ul>
<li><p>一个事务的例子：</p>
</li>
<li><ul>
<li>步骤1:begin;</li>
<li>步骤2:insert into t1 …r</li>
<li>步骤3:insert into t2 …</li>
<li>步骤4:commit;</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/1590590539973-d4b0a609-44be-4018-b989-cc1e2967d8c9.png" alt="image.png"></p>
<ul>
<li><p>MySQL的事务使用两阶段提交(2PC)，事务提交前，将redo log的写入拆成了两个步骤，prepare和commit</p>
</li>
<li><ul>
<li>redo log 和binlog 有一个共同的数据字段，叫 XID,崩溃恢复的时候，会按顺序扫描 redo log</li>
<li>假设在写入binlog前系统崩溃，那么数据库恢复后顺序扫描 redo log，碰到只有 parepare、而没有 commit 的 redo log，就拿着 XID（事务ID） 去 binlog 找对应的事务，而且binlog也没写入，所以事务就直接回滚了</li>
<li>假设在写入binlog之后，事务提交前数据库崩溃，那么数据库恢复后顺序扫描 redo log，碰到既有 prepare、又有 commit 的 redo log，就直接提交，保证主从一致性</li>
</ul>
</li>
</ul>
<h3 id="MySQL对分布式事务的支持"><a href="#MySQL对分布式事务的支持" class="headerlink" title="MySQL对分布式事务的支持"></a>MySQL对分布式事务的支持</h3><p>分布式事务的实现方式有很多，既可以采用 InnoDB 提供的原生的事务支持，也可以采用消息队列来实现分布式事务的最终一致性。这里我们主要聊一下 InnoDB 对分布式事务的支持。</p>
<p>MySQL 从 5.0.3  InnoDB 存储引擎开始支持XA协议的分布式事务。一个分布式事务会涉及多个行动，这些行动本身是事务性的。所有行动都必须一起成功完成，或者一起被回滚。</p>
<p>在MySQL中，使用分布式事务涉及一个或多个资源管理器和一个事务管理器。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/1590590539973-d4b0a609-44be-4018-b989-cc1e2967d8c9.png" alt="image"></p>
<p>如图，MySQL 的分布式事务模型。模型中分三块：应用程序（AP）、资源管理器（RM）、事务管理器（TM）:</p>
<ul>
<li>应用程序：定义了事务的边界，指定需要做哪些事务；</li>
<li>资源管理器：提供了访问事务的方法，通常一个数据库就是一个资源管理器；</li>
<li>事务管理器：协调参与了全局事务中的各个事务。</li>
</ul>
<p>分布式事务采用两段式提交（two-phase commit）的方式：</p>
<ul>
<li>第一阶段所有的事务节点开始准备，告诉事务管理器ready。</li>
<li>第二阶段事务管理器告诉每个节点是commit还是rollback。如果有一个节点失败，就需要全局的节点全部rollback，以此保障事务的原子性。</li>
</ul>
<h2 id="三、MySQL锁机制"><a href="#三、MySQL锁机制" class="headerlink" title="三、MySQL锁机制"></a>三、MySQL锁机制</h2><blockquote>
<p>❝</p>
<p>数据库的乐观锁和悲观锁？</p>
<p>MySQL 中有哪几种锁，列举一下？</p>
<p>MySQL中InnoDB引擎的行锁是怎么实现的？</p>
<p>MySQL 间隙锁有没有了解，死锁有没有了解，写一段会造成死锁的 sql 语句，死锁发生了如何解决，MySQL 有没有提供什么机制去解决死锁</p>
</blockquote>
<h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><p><strong>从对数据操作的类型分类</strong>：</p>
<ul>
<li><strong>读锁</strong>（共享锁）：针对同一份数据，多个读操作可以同时进行，不会互相影响</li>
<li><strong>写锁</strong>（排他锁）：当前写操作没有完成前，它会阻断其他写锁和读锁</li>
</ul>
<p><strong>从对数据操作的粒度分类</strong>：</p>
<p>为了尽可能提高数据库的并发度，每次锁定的数据范围越小越好，理论上每次只锁定当前操作的数据的方案会得到最大的并发度，但是管理锁是很耗资源的事情（涉及获取，检查，释放锁等动作），因此数据库系统需要在高并发响应和系统性能两方面进行平衡，这样就产生了“锁粒度（Lock granularity）”的概念。</p>
<ul>
<li><strong>表级锁</strong>：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低（MyISAM 和 MEMORY 存储引擎采用的是表级锁）；</li>
<li><strong>行级锁</strong>：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高（InnoDB 存储引擎既支持行级锁也支持表级锁，但默认情况下是采用行级锁）；</li>
<li><strong>页面锁</strong>：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</li>
</ul>
<p>适用：从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。</p>
<table>
<thead>
<tr>
<th></th>
<th>行锁</th>
<th>表锁</th>
<th>页锁</th>
</tr>
</thead>
<tbody><tr>
<td>MyISAM</td>
<td></td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>BDB</td>
<td></td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>InnoDB</td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>Memory</td>
<td></td>
<td>√</td>
<td></td>
</tr>
</tbody></table>
<h3 id="MyISAM-表锁"><a href="#MyISAM-表锁" class="headerlink" title="MyISAM 表锁"></a>MyISAM 表锁</h3><p>MyISAM 的表锁有两种模式：</p>
<ul>
<li>表共享读锁 （Table Read Lock）：不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；</li>
<li>表独占写锁 （Table Write Lock）：会阻塞其他用户对同一表的读和写操作；</li>
</ul>
<p>MyISAM 表的读操作与写操作之间，以及写操作之间是串行的。当一个线程获得对一个表的写锁后， 只有持有锁的线程可以对表进行更新操作。其他线程的读、 写操作都会等待，直到锁被释放为止。</p>
<p>默认情况下，写锁比读锁具有更高的优先级：当一个锁释放时，这个锁会优先给写锁队列中等候的获取锁请求，然后再给读锁队列中等候的获取锁请求。</p>
<h3 id="InnoDB-行锁"><a href="#InnoDB-行锁" class="headerlink" title="InnoDB 行锁"></a>InnoDB 行锁</h3><ul>
<li><p>InnoDB 实现了以下两种类型的<strong>行锁</strong>：</p>
</li>
<li><ul>
<li>共享锁（shared lock S锁，又称读锁）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</li>
<li>排他锁（exclusive lock X锁，又称写锁）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。insert ，delete ， <strong>update在事务中都会自动默认加上排它锁</strong>。</li>
</ul>
</li>
<li><p>同时InnoDB还实现了<strong>多粒度锁</strong>：</p>
</li>
</ul>
<p><strong>为了允许行锁和表锁共存，实现多粒度锁机制——意向锁</strong>（Intention Locks）：未来的某个时刻，事务可能要加共享/排它锁了，先提前声明一个意向</p>
<ul>
<li><ul>
<li>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。</li>
<li>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。</li>
</ul>
</li>
<li><p>“冲突—兼容”规则：</p>
</li>
<li><ul>
<li><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/1590745463390-4377c2d2-8ea7-4d04-8a13-a78ec84125eb.png" alt="image"></li>
<li><strong>意向锁是怎么提高检测效率的？</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li><strong>在加表锁的时可立即检测到是否存在意向锁，若存在，则说明有行锁，因此无须遍历整个表即可知道发生冲突</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="加锁机制"><a href="#加锁机制" class="headerlink" title="加锁机制"></a>加锁机制</h4><ul>
<li><p><strong>乐观锁与悲观锁是两种并发控制的思想，可用于解决丢失更新问题</strong></p>
</li>
<li><ul>
<li>乐观锁会“乐观地”假定大概率不会发生并发更新冲突，访问、<strong>处理数据过程中不加锁**</strong>，**<strong>只在更新数据时再根据版本号或时间戳判断是否有冲突</strong>，有则处理，无则提交事务。用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式</li>
<li>悲观锁会“悲观地”假定大概率会发生并发更新冲突，访问、<strong>处理数据前就加排他锁</strong>，<strong>在整个数据处理过程中锁定数据，事务提交或回滚后才释放锁</strong>。另外与乐观锁相对应的，<strong>悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。</strong></li>
</ul>
</li>
<li><p><strong>悲观锁的例子：</strong></p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//step1: 查出商品状态，使用悲观锁锁定需要修改的数据</span><br><span class="line"><span class="keyword">select</span> quantity <span class="keyword">from</span> items <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">100</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line">//step2: 根据商品信息生成订单</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> orders(<span class="keyword">id</span>,item_id) <span class="keyword">values</span>(<span class="literal">null</span>,<span class="number">100</span>);</span><br><span class="line">//step3: 修改商品的库存</span><br><span class="line"><span class="keyword">update</span> Items <span class="keyword">set</span> quantity=quantity<span class="number">-2</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>乐观锁的例子</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//step1: 查询出商品信息，普通快照读</span><br><span class="line"><span class="keyword">select</span> (quantity,<span class="keyword">version</span>) <span class="keyword">from</span> items <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">100</span>;</span><br><span class="line">//step2: 根据商品信息生成订单</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> orders(<span class="keyword">id</span>,item_id) <span class="keyword">values</span>(<span class="literal">null</span>,<span class="number">100</span>);</span><br><span class="line">//step3: 修改商品的库存，使用版本号进行判断修改</span><br><span class="line"><span class="keyword">update</span> items <span class="keyword">set</span> quantity=quantity<span class="number">-1</span>,<span class="keyword">version</span>=<span class="keyword">version</span>+<span class="number">1</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">100</span> <span class="keyword">and</span> <span class="keyword">version</span>=<span class="comment">#&#123;version&#125;;</span></span><br></pre></td></tr></table></figure>

<p>**<br>**</p>
<h4 id="锁模式"><a href="#锁模式" class="headerlink" title="锁模式"></a>锁模式</h4><p><strong>上面是各种锁的思想，或者分类，下面是InnoDB实际使用的锁的模式</strong></p>
<ul>
<li><p>**记录锁(Record Locks，也被称为行锁)**：</p>
</li>
<li><ul>
<li>单个行记录上的锁。对索引项加锁，锁定符合条件的索引而不是真正的数据记录，如果表上没有索引，则会使用自动创建的隐藏主键索引</li>
<li>加上记录锁后，其他事务不能再获取排他锁，即不能修改和删除加锁项（但是可以快照读）；</li>
<li>记录锁分为共享锁和排他锁：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>使用共享锁：<code>SELECT ... </code>**<code>LOCK IN SHARE MODE</code>**<code>;</code></li>
<li>使用排他锁（悲观锁）：<code>SELECT ... </code>**<code>FOR UPDATE</code>**`;```</li>
<li>使用了排他锁，如果事务结束前，其他事务不能修改锁定的数据</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>使用记录锁的方法：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><strong>精准确定哪些行需要加锁时会使用记录锁</strong></li>
<li><code>SELECT * FROM table </code><strong><code>WHERE id = 1</code></strong><code> FOR UPDATE;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>它会在 id=1 的记录上加上记录锁，以阻止其他事务插入，更新，删除 id=1 这一行</p>
<p><strong>如果where中不是精准匹配，而是&gt;,&lt;,like等，那么就会转换成临建锁</strong></p>
<ul>
<li><ul>
<li><ul>
<li>在通过 主键索引 与 唯一索引 对数据行进行 UPDATE 操作时，也会对该行数据加记录锁：</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong><code>UPDATE</code></strong><code>SET age = 50</code><strong><code>WHERE id = 1</code></strong><code>;-- id 列为主键列或唯一索引列</code></p>
<ul>
<li><p><strong>间隙锁（Gap Locks）</strong>：</p>
</li>
<li><ul>
<li><strong>当检索数据是范围条件时，即不能精准确定哪些行数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁</strong>。</li>
<li>对索引项之间的“间隙”加锁，锁定记录的范围（对第一条记录前的间隙或最后一条将记录后的间隙加锁），不包含索引项本身。<strong>使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据</strong></li>
<li><strong>间隙锁基于非唯一索引，它锁定一段范围内的索引记录。间隙锁基于下面将会提到的**</strong><code>Next-Key Locking</code>** <strong>算法</strong></li>
<li>其他事务不能在锁范围内插入数据，这样就防止了别的事务新增幻影行（即，隔离级别为可重复读时解决部分幻读）。</li>
<li>如果将事务的隔离级别降级为读提交(Read Committed, RC)，间隙锁则会自动失效。</li>
<li>间隙锁是排他锁，只在UPDATE、DELETE以及特殊的SELECT语句中出现（INSERT语句采用了另外一种锁——插入意向间隙锁）</li>
<li>使用间隙锁：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><code>SELECT * FROM table</code><strong><code> WHERE id BETWEN 1 AND 10</code></strong><code> FOR UPDATE;</code></li>
<li>所有在**<code>（1，10）</code>**区间内的记录行都会被锁住，所有id 为 2-9 的数据行的插入会被阻塞，但是 1 和 10 两条记录行并不会被锁住。</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>间隙锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况</li>
</ul>
</li>
<li><p>**临键锁(Next-key Locks)**：</p>
</li>
<li><ul>
<li><strong>临键锁</strong>，是<strong>记录锁与间隙锁的组合</strong>，它的封锁范围，既包含索引记录，又包含索引区间。<br>Next-Key 可以理解为一种特殊的<strong>间隙锁</strong>，也可以理解为一种特殊的<strong>算法</strong>。</li>
<li><strong>临键锁的索引必须是非唯一索引，如果索引是唯一索引，则临键锁降级为行锁，仅锁住索引本身，而不会锁住范围</strong></li>
<li>通过临键锁可以解决幻读的问题。每个数据行上的非唯一索引列上都会存在一把临键锁，当某个事务持有该数据行的临键锁时，<strong>会锁住一段左开右闭区间的数据</strong>。</li>
<li>如果把事务的隔离级别降级为RC，临键锁则也会失效。</li>
<li>对于非唯一索引的行的查询，都是采用该方法，主要目的是解决幻读的问题。</li>
<li>例子：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>表table(id PK, age KEY, name)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1590748148197-bfa179a3-78e2-4f4f-b304-2f01083a34ca.png" alt="image.png"></p>
<ul>
<li><ul>
<li><ul>
<li>该表中 age 列潜在的临键锁有：-∞, 10], (10, 24], (24, 32], (32, 45], (45, +∞]</li>
<li>在<code>事务 A</code> 中执行如下命令：</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>– 根据非唯一索引列 UPDATE 某条记录</p>
<p>UPDATE table SET name = Vladimir WHERE age = 24;</p>
<p>– 或根据非唯一索引列 锁住某条记录</p>
<p>SELECT * FROM table WHERE age = 24 FOR UPDATE;</p>
<ul>
<li><ul>
<li><ul>
<li>不管执行了上述 SQL 中的哪一句，之后如果在<code>事务 B</code> 中执行以下命令，则该命令会被阻塞：</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>INSERT INTO table VALUES(100, 26, ‘Ezreal’);</p>
<ul>
<li><p><strong>插入意向间隙锁（Insert Intention Gap Lock）:</strong></p>
</li>
<li><ul>
<li>对于数据的修改和删除，必须使用强排他锁，而对于数据的插入不需要这么强的锁</li>
<li>如果多个事务希望对同一个索引间隙插入数据，只要插入的不是同一个位置，则可以直接执行，不用等待其他事务结束，即不会阻塞</li>
<li><strong>使用共享锁提高读读并发，使用插入意向间隙锁提高插入并发</strong></li>
<li>例子：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>表索引：t(id unique PK, name)，列name不是唯一索引</li>
<li>表中数据：</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>10, shenjian</li>
<li>20, zhangsan</li>
<li>30, lisi</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>事务A先执行，在10与20两条记录中插入了一行，还未提交：insert into t values(11, xxx);</li>
<li>事务B后执行，也在10与20两条记录中插入了一行：insert into t values(12, ooo);</li>
<li>这时使用插入意向间隙锁，事务B不会被阻塞</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li><strong>InnoDB</strong> 中的<code>行锁</code>的实现依赖于<code>索引</code>，一旦某个加锁操作没有使用到索引，那么该锁就会退化为<code>表锁</code>。</li>
<li><strong>记录锁</strong>存在于包括<code>主键索引</code>在内的<code>唯一索引</code>中，锁定单条索引记录。</li>
<li><strong>间隙锁</strong>存在于<code>非唯一索引</code>中，锁定<code>开区间</code>范围内的一段间隔，它是基于<strong>临键锁</strong>实现的。</li>
<li><strong>临键锁</strong>存在于<code>非唯一索引</code>中，该类型的每条记录的索引上都存在这种锁，它是一种特殊的<strong>间隙锁</strong>，锁定一段<code>左开右闭</code>的索引区间。</li>
</ol>
<blockquote>
<p>❝MySQL 遇到过死锁问题吗，你是如何解决的？</p>
</blockquote>
<h4 id="读取方式"><a href="#读取方式" class="headerlink" title="读取方式"></a>读取方式</h4><ul>
<li>快照读(Snapshot Read)：基于 MVCC 和 undo log 实现的，普通的select读，读数据记录的快照版本，不加锁</li>
</ul>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> xxx;</span><br></pre></td></tr></table></figure>

<ul>
<li>当前读(Current Read)：基于临键锁（记录锁 + 间隙锁）实现的，特殊的select读。读数据记录的最新版本，且在读取完成前需要保证数据不被其他事务修改，因此要加锁</li>
</ul>
<p>select * from t where xxx <strong>for update</strong>———排他锁</p>
<p>​    select * from t where xxx <strong>lock in share mode</strong>———共享锁</p>
<p>​    <strong>update / insert / delete</strong>———排他锁</p>
<h4 id="索引访问与加锁方式"><a href="#索引访问与加锁方式" class="headerlink" title="索引访问与加锁方式"></a>索引访问与加锁方式</h4><ul>
<li><p><strong>主键访问：</strong></p>
</li>
<li><ul>
<li>RC(Read Commit)模式： </li>
</ul>
</li>
</ul>
<p>只需要给主键上查询对应的记录加锁只需要给主键上查询对应的记录加锁，不存在间隙锁</p>
<ul>
<li><ul>
<li>RR(Repeatable Read)模式：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>等值查询：加Next-key LOCK，如果键值满足条件，Next-key LOCK退化为行锁，如果不满足条件，Next-key LOCK退化为GAP锁</li>
<li>范围查询：加Next-key LOCK，一直遍历到第一个不满足查询条件的键值为止，且锁不退化</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>唯一性二级索引访问：</strong></p>
<p>和主键访问的区别是一个是锁主键索引，一个是锁二级索引+对应的主键记录 </p>
</li>
<li><p><strong>非唯一性二级索引访问：</strong></p>
</li>
<li><ul>
<li>RC模式：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>只需要给二级索引上对应的记录和对应主键索引上的记录加锁只需要给主键上查询对应的记录加锁，不存在间隙锁</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>RR模式：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>等值查询：加Next-key LOCK，一直遍历到第一个不满足查询条件的键值为止，然后把这个Next-key LOCK退化为GAP锁</li>
<li>范围查询：加Next-key LOCK，一直遍历到第一个不满足查询条件的键值为止，且锁不退化</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>无索引访问</strong>(也可以叫做主键索引全扫描、全表扫描)：</p>
</li>
<li><ul>
<li>RC模式：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>主键上所有记录行加锁，返回给Server层，Server层进行过滤，对不满足条件的记录，调用unlock_row方法放锁</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>RR模式：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>主键上所有记录行和GAP加锁，返回给Server层，Server层进行过滤，且事务结束之前不会释放</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><strong>死锁产生</strong>：</p>
<ul>
<li>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环</li>
<li>当事务试图以不同的顺序锁定资源时，就可能产生死锁。多个事务同时锁定同一个资源时也可能会产生死锁</li>
<li>锁的行为和顺序和存储引擎相关。以同样的顺序执行语句，有些存储引擎会产生死锁有些不会——死锁有双重原因：真正的数据冲突；存储引擎的实现方式。</li>
</ul>
<p><strong>检测死锁</strong>：数据库系统实现了各种死锁检测和死锁超时的机制。InnoDB存储引擎能检测到死锁的循环依赖并立即返回一个错误。</p>
<p><strong>死锁恢复</strong>：死锁发生以后，只有部分或完全回滚其中一个事务，才能打破死锁，InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。所以事务型应用程序在设计时必须考虑如何处理死锁，多数情况下只需要重新执行因死锁回滚的事务即可。</p>
<p><strong>外部锁的死锁检测</strong>：发生死锁后，InnoDB 一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及表锁的情况下，InnoDB 并不能完全自动检测到死锁， 这需要通过设置锁等待超时参数 innodb_lock_wait_timeout 来解决</p>
<p><strong>死锁影响性能</strong>：死锁会影响性能而不是会产生严重错误，因为InnoDB会自动检测死锁状况并回滚其中一个受影响的事务。在高并发系统上，当许多线程等待同一个锁时，死锁检测可能导致速度变慢。有时当发生死锁时，禁用死锁检测（使用innodb_deadlock_detect配置选项）可能会更有效，这时可以依赖<code>innodb_lock_wait_timeout</code>设置进行事务回滚。</p>
<p><strong>MyISAM避免死锁</strong>：</p>
<ul>
<li><strong>在自动加锁的情况下，MyISAM 总是一次获得 SQL 语句所需要的全部锁，所以 MyISAM 表不会出现死锁。</strong></li>
</ul>
<p><strong>InnoDB避免死锁</strong>：</p>
<ul>
<li>为了在单个InnoDB表上执行多个并发写入操作时避免死锁，可以在事务开始时通过为预期要修改的每行使用<code>SELECT ... FOR UPDATE</code>语句来获取必要的锁，即使这些行的更改语句是在之后才执行的。</li>
<li>在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应先申请共享锁、更新时再申请排他锁，因为这时候当用户再申请排他锁时，其他事务可能又已经获得了相同记录的共享锁，从而造成锁冲突，甚至死锁</li>
<li>如果事务需要修改或锁定多个表，则应在每个事务中以相同的顺序使用加锁语句。在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会</li>
<li>通过<code>SELECT ... LOCK IN SHARE MODE</code>获取行的读锁后，如果当前事务再需要对该记录进行更新操作，则很有可能造成死锁。</li>
<li>改变事务隔离级别</li>
</ul>
<p>如果出现死锁，可以用 <code>show engine innodb status;</code>命令来确定最后一个死锁产生的原因。返回结果中包括死锁相关事务的详细信息，如引发死锁的 SQL 语句，事务已经获得的锁，正在等待什么锁，以及被回滚的事务等。据此可以分析死锁产生的原因和改进措施。</p>
<h3 id="with-nolock-（SQL-Server）"><a href="#with-nolock-（SQL-Server）" class="headerlink" title="with(nolock)（SQL Server）"></a>with(nolock)（SQL Server）</h3><ul>
<li><p>with(nolock)是表提示（table_hint）中的一种，等同于READUNCOMMITTED，提高并发查询性能的同时可能会导致脏读</p>
</li>
<li><p><strong>特点：</strong></p>
</li>
<li><ul>
<li>允许脏读：不发布共享锁来阻止其他事务修改当前事务读取的数据，其他事务设置的排他锁不会阻碍当前事务读取锁定数据。允许脏读可能产生较多的并发操作，但其代价是读取以后会被其他事务回滚的数据修改。这可能会使您的事务出错，向用户显示从未提交过的数据，或者导致用户两次看到记录（或根本看不到记录）</li>
<li>READUNCOMMITTED 和 NOLOCK 提示仅适用于数据锁。所有查询（包括那些带有 READUNCOMMITTED 和 NOLOCK 提示的查询）都会在编译和执行过程中获取 Sch-S（架构稳定性）锁。因此，当并发事务持有表的 Sch-M（架构修改）锁时，将阻塞查询。例如，数据定义语言 (DDL) 操作在修改表的架构信息之前获取 Sch-M 锁。所有并发查询（包括那些使用 READUNCOMMITTED 或 NOLOCK 提示运行的查询）都会在尝试获取 Sch-S 锁时被阻塞。相反，持有 Sch-S 锁的查询将阻塞尝试获取 Sch-M 锁的并发事务</li>
<li>不能为通过插入、更新或删除操作修改过的表指定 READUNCOMMITTED 和 NOLOCK。SQL Server 查询优化器忽略 FROM 子句中应用于 UPDATE 或 DELETE 语句的目标表的 READUNCOMMITTED 和 NOLOCK 提示</li>
</ul>
</li>
<li><p><strong>使用场景：</strong></p>
</li>
<li><ul>
<li>是否使用要综合考虑性能情况与业务要求来决定，大体来说一般有下面一些场景可以使用WITH(NOLOCK)</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>基础数据表，这些表的数据很少变更</li>
<li>历史数据表，这些表的数据很少变更</li>
<li>业务允许脏读情况出现涉及的表</li>
<li>数据量超大的表，出于性能考虑，而允许脏读</li>
</ul>
</li>
</ul>
</li>
<li><p>如何产生脏读</p>
</li>
<li><ul>
<li>不使用的正常情况</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>会话窗口1，开启事务修改数据但是不提交也不回滚</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li><code>BEGIN TRAN</code></li>
<li><code>UPDATE TEST SET NAME=&#39;Timmy&#39; WHERE OBJECT_ID =1;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>会话窗口2，查询数据，但是被阻塞了（会话2在等待获取共享锁）</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li><code>SELECT * FROM TEST;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>使用的情况</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>会话窗口3，可以查询结果</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li><code>SELECT * FROM TEST WITH(NOLOCK)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>会话窗口1，回滚，出现脏读</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="四、存储引擎"><a href="#四、存储引擎" class="headerlink" title="四、存储引擎"></a>四、存储引擎</h2><p>存储引擎是MySQL的组件，用于处理不同表类型的SQL操作。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以获得特定的功能。</p>
<p>使用哪一种引擎可以灵活选择，<strong>一个数据库中多个表可以使用不同引擎以满足各种性能和实际需求</strong>，使用合适的存储引擎，将会提高整个数据库的性能 。</p>
<p>MySQL服务器使用<strong>可插拔</strong>的存储引擎体系结构，可以从运行中的 MySQL 服务器加载或卸载存储引擎 。</p>
<h3 id="查看存储引擎"><a href="#查看存储引擎" class="headerlink" title="查看存储引擎"></a>查看存储引擎</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看支持的存储引擎</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">ENGINES</span></span><br><span class="line"><span class="comment">-- 查看默认存储引擎</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">&#x27;storage_engine&#x27;</span></span><br><span class="line"><span class="comment">--查看具体某一个表所使用的存储引擎，这个默认存储引擎被修改了！</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> tablename</span><br><span class="line"><span class="comment">--准确查看某个数据库中的某一表所使用的存储引擎</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">&#x27;tablename&#x27;</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> <span class="keyword">status</span> <span class="keyword">from</span> <span class="keyword">database</span> <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">&quot;tablename&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="设置存储引擎"><a href="#设置存储引擎" class="headerlink" title="设置存储引擎"></a>设置存储引擎</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 建表时指定存储引擎。默认的就是INNODB，不需要设置</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (i <span class="built_in">INT</span>) <span class="keyword">ENGINE</span> = <span class="keyword">INNODB</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t2 (i <span class="built_in">INT</span>) <span class="keyword">ENGINE</span> = CSV;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t3 (i <span class="built_in">INT</span>) <span class="keyword">ENGINE</span> = <span class="keyword">MEMORY</span>;</span><br><span class="line"><span class="comment">-- 修改存储引擎</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="comment">-- 修改默认存储引擎，也可以在配置文件my.cnf中修改默认引擎</span></span><br><span class="line"><span class="keyword">SET</span> default_storage_engine=NDBCLUSTER;</span><br></pre></td></tr></table></figure>

<p>默认情况下，每当 <code>CREATE TABLE</code> 或 <code>ALTER TABLE</code> 不能使用默认存储引擎时，都会生成一个警告。为了防止在所需的引擎不可用时出现令人困惑的意外行为，可以启用 <code>NO_ENGINE_SUBSTITUTION SQL</code> 模式。如果所需的引擎不可用，则此设置将产生错误而不是警告，并且不会创建或更改表</p>
<h3 id="存储引擎对比"><a href="#存储引擎对比" class="headerlink" title="存储引擎对比"></a>存储引擎对比</h3><p>常见的存储引擎就 InnoDB、MyISAM、Memory、NDB。</p>
<p>InnoDB 现在是 MySQL 默认的存储引擎，支持<strong>事务、行级锁定和外键</strong></p>
<h4 id="文件存储结构对比"><a href="#文件存储结构对比" class="headerlink" title="文件存储结构对比"></a>文件存储结构对比</h4><p>在 MySQL中建立任何一张数据表，在其数据目录对应的数据库目录下都有对应表的 <code>.frm</code> 文件，<code>.frm</code> 文件是用来保存每个数据表的元数据(meta)信息，包括表结构的定义等，与数据库存储引擎无关，也就是任何存储引擎的数据表都必须有<code>.frm</code>文件，命名方式为 数据表名.frm，如user.frm。</p>
<p>查看MySQL 数据保存在哪里：<code>show variables like &#39;data%&#39;</code></p>
<p><strong>MyISAM 物理文件结构为：</strong></p>
<ul>
<li><code>.frm</code>文件：与表相关的元数据信息都存放在frm文件，包括<strong>表结构的定义信息</strong>等</li>
<li><code>.MYD</code> (<code>MYData</code>) 文件：MyISAM 存储引擎专用，用于存储MyISAM <strong>表的数据</strong></li>
<li><code>.MYI</code> (<code>MYIndex</code>)文件：MyISAM 存储引擎专用，用于存储MyISAM <strong>表的索引相关信息</strong></li>
</ul>
<p><strong>InnoDB 物理文件结构为：</strong></p>
<ul>
<li><code>.frm</code> 文件：与表相关的元数据信息都存放在frm文件，包括<strong>表结构的定义信息</strong>等</li>
<li><code>.ibd</code> 文件或 <code>.ibdata</code> 文件：这两种文件都是存放 InnoDB 数据的文件，之所以有两种文件形式存放 InnoDB 的数据，是因为 InnoDB 的数据存储方式能够通过配置来决定是使用<strong>共享表空间</strong>存放存储数据，还是用<strong>独享表空间</strong>存放存储数据。<br>独享表空间存储方式使用<code>.ibd</code>文件，并且每个表一个<code>.ibd</code>文件 共享表空间存储方式使用<code>.ibdata</code>文件，所有表共同使用一个<code>.ibdata</code>文件（或多个，可自己配置）</li>
</ul>
<h4 id="MyISAM和InnoDB区别"><a href="#MyISAM和InnoDB区别" class="headerlink" title="MyISAM和InnoDB区别"></a>MyISAM和InnoDB区别</h4><ol>
<li>InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</li>
<li>InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；</li>
<li>InnoDB 是聚簇索引，MyISAM 是非聚簇索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是二级索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和二级索引是独立的。</li>
<li>InnoDB 不保存表的具体行数，执行<code>select count(*) from table</code> 时需要全表扫描。而 MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</li>
<li>InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。MyISAM一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</li>
</ol>
<table>
<thead>
<tr>
<th>对比项</th>
<th>MyISAM</th>
<th>InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td>主外键</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>事务</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>行表锁</td>
<td>表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</td>
<td>行锁,操作时只锁某一行，不对其它行有影响，适合高并发的操作</td>
</tr>
<tr>
<td>缓存</td>
<td>只缓存索引，不缓存真实数据</td>
<td>不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响</td>
</tr>
<tr>
<td>表空间</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>关注点</td>
<td>性能</td>
<td>事务</td>
</tr>
<tr>
<td>默认安装</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<blockquote>
<p>❝一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15 ？</p>
</blockquote>
<p>如果表的类型是MyISAM，那么是18。因为MyISAM表会把自增主键的最大ID 记录到数据文件中，重启MySQL自增主键的最大ID也不会丢失；</p>
<p>如果表的类型是InnoDB，那么是15。因为InnoDB 表只是把自增主键的最大ID记录到内存中，所以重启数据库或对表进行OPTION操作，都会导致最大ID丢失。</p>
<blockquote>
<p>❝哪个存储引擎执行 select count(*) 更快，为什么?</p>
</blockquote>
<p>MyISAM更快，因为MyISAM内部维护了一个计数器，可以直接调取。</p>
<ul>
<li>在 MyISAM 存储引擎中，把表的总行数存储在磁盘上，当执行 select count(*) from t 时，直接返回总数据。</li>
<li>在 InnoDB 存储引擎中，跟 MyISAM 不一样，没有将总行数存储在磁盘上，当执行 select count(*) from t 时，会先把数据读出来，一行一行的累加，最后返回总数量。</li>
</ul>
<p>InnoDB 中 count(*) 语句是在执行的时候，全表扫描统计总数量，所以当数据越来越大时，语句就越来越耗时了，为什么 InnoDB 引擎不像 MyISAM 引擎一样，将总行数存储到磁盘上？这跟 InnoDB 的事务特性有关，<strong>由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的</strong>。</p>
<p>❝为什么MyISAM读取速度更快？</p>
<ul>
<li>InnoDB 在做 SELECT 的时候，要维护的东西比 MYISAM 引擎多很多，比如检查和维护MVCC</li>
<li>innodb寻址要映射到块，再到行，MYISAM记录的直接是文件的OFFSET，定位比INNODB要快</li>
</ul>
<h2 id="五、数据类型"><a href="#五、数据类型" class="headerlink" title="五、数据类型"></a>五、数据类型</h2><h3 id="MySQL的数据类型"><a href="#MySQL的数据类型" class="headerlink" title="MySQL的数据类型"></a>MySQL的数据类型</h3><ul>
<li>整数类型：BIT、BOOL、TINY INT、SMALL INT、MEDIUM INT、 INT、 BIG INT</li>
<li>浮点数类型：FLOAT、DOUBLE、DECIMAL</li>
<li>字符串类型：CHAR、VARCHAR、TINY TEXT、TEXT、MEDIUM TEXT、LONG TEXT、TINY BLOB、BLOB、MEDIUM BLOB、LONG BLOB</li>
<li>日期类型：Date、DateTime、TimeStamp、Time、Year</li>
<li>其他数据类型：BINARY、VARBINARY、ENUM、SET、Geometry、Point、MultiPoint、LineString、MultiLineString、Polygon、GeometryCollection等</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/1590590539852-f07a129b-1bfb-4487-af9a-df13273354c2.webp" alt="image"><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539869-222256f7-421d-4ca2-b17c-ab93c141d6aa.webp" alt="image"><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539903-c0a28251-0a32-486e-b3d6-4defbb7768ea.webp?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<blockquote>
<p>❝CHAR 和 VARCHAR 的区别？</p>
</blockquote>
<p>char是固定长度，varchar长度可变：</p>
<p>char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。</p>
<p>存储时，前者不管实际存储数据的长度，直接按 char 规定的长度分配存储空间；而后者会根据实际存储的数据分配最终的存储空间</p>
<p><strong>相同点：</strong></p>
<ol>
<li>char(n)，varchar(n)中的n都代表字符的个数</li>
<li>超过char，varchar最大长度n的限制后，字符串会被截断。</li>
</ol>
<p><strong>不同点：</strong></p>
<ol>
<li>char不论实际存储的字符数都会占用n个字符的空间，而varchar只会占用实际字符应该占用的字节空间加1（实际长度length，0&lt;=length&lt;255）或加2（length&gt;255）。因为varchar保存数据时除了要保存字符串之外还会加一个字节来记录长度（如果列声明长度大于255则使用两个字节来保存长度）。</li>
<li>能存储的最大空间限制不一样：char的存储上限为255字节。</li>
<li>char在存储时会截断尾部的空格，而varchar不会。</li>
</ol>
<p>char是适合存储很短的、一般固定长度的字符串。例如，char非常适合存储密码的MD5值，因为这是一个定长的值。对于非常短的列，char比varchar在存储空间上也更有效率。</p>
<blockquote>
<p>❝列的字符串类型可以是什么？</p>
</blockquote>
<p>字符串类型是：BIT、SET、BLOB、ENUM、CHAR、TEXT、VARCHAR</p>
<p>ENUM：使用枚举代替字符串类型，将不重复的字符串存储到预定义的集合中。列中存储的是整数，这样列表值会非常紧凑，压缩到1-2个字节中。定义好了ENUM的集合后，如果想向其中添加或删除字符串必须使用ALTER TABLE，除非是向集合列表末尾添加元素。</p>
<p>BIT：二进制的多个比特串，MySQL将其作为字符串类型处理</p>
<p>SET：多个BIT合并称的数据类型，有效利用存储空间。</p>
<p>上述三种都可以使用其他数据类型达到同样的功能，而且不容易犯错。</p>
<blockquote>
<p>❝BLOB和TEXT有什么区别？</p>
</blockquote>
<p>BLOB和TEXT都是为存储很大的数据而设计的字符串数据类型，且容纳可变数量的数据。</p>
<p>BLOB存储的是二进制数据，四种类型的BLOB：TINYBLOB、BLOB、MEDIUMBLO和 LONGBLOB</p>
<p>TEXT存储的是字符数据，四种TEXT类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。</p>
<p>数据类型相关还有很多细节，在《高性能MySQL》第四章。</p>
<h3 id="范式与反范式"><a href="#范式与反范式" class="headerlink" title="范式与反范式"></a>范式与反范式</h3><ul>
<li><p>范式化的数据库中，每个事实数据只会出现一次，而反范式化的数据库中，信息是冗余的，可能会存储在多个地方。</p>
</li>
<li><p>范式的优点：</p>
</li>
<li><ul>
<li>范式化修改的数据通常更少，更新操作通常比反范式化更快</li>
<li>范式化的表通常更小，可以更好的放在内存里</li>
<li>范式化很少有多余的数据意味着检索列表数据时可能不需要DISTINCT/GROUP BY语句</li>
</ul>
</li>
<li><p>范式的缺点：</p>
</li>
<li><ul>
<li>通常需要关联，不仅代价高而且可能使得一些索引无效。比如，将列存储在不用的表中，而这些列如果在一个表中则本可以属于同一个索引</li>
</ul>
</li>
<li><p>反范式的优点：</p>
</li>
<li><ul>
<li>避免了很多关联，在没有关联的情况下，反范式执行全表扫描是顺序I/O，可能比关联要快得多</li>
</ul>
</li>
<li><p>反范式优点的例子，查看所有付费用户中最近的10个消息：</p>
</li>
<li><ul>
<li>范式：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>范式需要使用message和user两个表，并关联，SQL语句：</li>
<li>SELECT message_text,user_name</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>FROM message </p>
<p>INNER JOIN user ON <strong>message.user_id=user.id</strong></p>
<p>WHERE <strong>user.account_type</strong>=’VIP’</p>
<p>ORDER BY <strong>message.published</strong> DESC LIMIT 10;</p>
<ul>
<li><ul>
<li><ul>
<li>范式化需要先对message表的published索引进行扫描，并且每一个消息都要去user表找到对应的用户并检查是否为付费用户，如果付费用户少则需要扫面很多数据。</li>
<li>因为关联的存在，使得在索引中查找另一个表并进行过滤，使得消耗了性能</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>反范式：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>将message和user表合并，并且增加索引（account_type,published），这样就不用使用关联，而且索引覆盖：</li>
<li>SELECT message_text,user_name</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>FROM user_message</p>
<p>WHERE account_type=’VIP’</p>
<p>ORDER BY published DESC LIMIT 10;</p>
<h4 id="混合范式化和反范式化"><a href="#混合范式化和反范式化" class="headerlink" title="混合范式化和反范式化"></a>混合范式化和反范式化</h4><ul>
<li><ul>
<li>实际并不会完全的范式化和反范式化，上面完全反范式化的例子user_message的表太大了，而且如果没有消息就会丢失用户信息。可以在user表和message表中都存储account_type字段，可以同时解决前面两个问题。但是新的问题是每次更新都要更新两张表，更新代价提高了。</li>
</ul>
</li>
</ul>
<h4 id="缓存表和汇总表"><a href="#缓存表和汇总表" class="headerlink" title="缓存表和汇总表"></a>缓存表和汇总表</h4><ul>
<li>上面的混合范式化是在同一张表中保存衍生的冗余数据，而有时也需要创建完全独立的缓存表和汇总表</li>
<li>缓存表：保存比较简单的从其他表获取且速度较慢的的数据</li>
<li>汇总表：保存使用GROUP BY语句聚合的数据</li>
</ul>
<h2 id="六、索引"><a href="#六、索引" class="headerlink" title="六、索引"></a>六、索引</h2><blockquote>
<p>❝</p>
<p>说说你对 MySQL 索引的理解？</p>
<p>数据库索引的原理，为什么要用 B+树，为什么不用二叉树？</p>
<p>聚集索引与非聚集索引的区别？</p>
<p>InnoDB引擎中的索引策略，了解过吗？</p>
<p>创建索引的方式有哪些？</p>
<p>聚簇索引/非聚簇索引，mysql索引底层实现，为什么不用B-tree，为什么不用hash，叶子结点存放的是数据还是指向数据的内存地址，使用索引需要注意的几个地方？</p>
</blockquote>
<ul>
<li>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构，所以说<strong>索引的本质是：数据结构</strong></li>
<li>索引的目的在于提高查询效率，可以类比字典、 火车站的车次表、图书的目录等 </li>
<li>可以简单的理解为“排好序的快速查找数据结构”，数据本身之外，<strong>数据库还维护着一个满足特定查找算法的数据结构</strong>，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。下图是一种可能的索引方式示例<img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539862-061bbf2b-9b17-4cb6-9ec2-3c2139bbfbc1.webp?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></li>
<li>左边的数据表，一共有两列七条记录，最左边的是数据记录的物理地址。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值，和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在一定的复杂度内获取到对应的数据，从而快速检索出符合条件的记录。</li>
<li>索引本身也很大，不可能全部存储在内存中，<strong>一般以索引文件的形式存储在磁盘上</strong></li>
<li>平常说的索引，没有特别指明的话，就是B+树（多路搜索树，不一定是二叉树）结构组织的索引。其中聚集索引，次要索引，覆盖索引，符合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。此外还有哈希索引等。</li>
</ul>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ul>
<li><p>创建：</p>
</li>
<li><ul>
<li>创建索引：<code>CREATE [UNIQUE] INDEX indexName ON mytable(username(length));</code><br>如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。</li>
<li>修改表结构(添加索引)：<code>ALTER table tableName ADD [UNIQUE] INDEX indexName(columnName)</code></li>
</ul>
</li>
<li><p>删除：<code>DROP INDEX [indexName] ON mytable;</code></p>
</li>
<li><p>查看：<code>SHOW INDEX FROM table_name\G</code>       –可以通过添加 \G 来格式化输出信息。</p>
</li>
<li><p>使用ALERT命令</p>
</li>
<li><ul>
<li><code>ALTER TABLE tbl_name ADD PRIMARY KEY (column_list):</code> 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。</li>
<li><code>ALTER TABLE tbl_name ADD UNIQUE index_name (column_list</code> 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。</li>
<li><code>ALTER TABLE tbl_name ADD INDEX index_name (column_list)</code> 添加普通索引，索引值可出现多次。</li>
<li><code>ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list)</code>该语句指定了索引为 FULLTEXT ，用于全文索引。</li>
</ul>
</li>
</ul>
<h3 id="索引的优势"><a href="#索引的优势" class="headerlink" title="索引的优势"></a>索引的优势</h3><ul>
<li><strong>大大减少服务器需要扫描的数据量</strong></li>
<li><strong>B+树种按照顺序存储数据，降低执行排序操作ORDER BY/GROUP BY的成本，避免生成临时表</strong></li>
<li><strong>B+树的特点+数据顺序存储，可以将随机I/O变为顺序I/O</strong></li>
</ul>
<h3 id="索引的劣势"><a href="#索引的劣势" class="headerlink" title="索引的劣势"></a>索引的劣势</h3><ul>
<li>索引也是一张表，保存了主键和索引字段，并指向实体表的记录，所以也需要占用内存</li>
<li><strong>虽然索引大大提高了查询速度，同时却会降低更新表的速度</strong>，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要更新索引文件中对应的索引列字段， 因为这三种操作会导致索引信息发生变化</li>
<li>对于非常小的表使用全表扫描更高效，中到大型表适合使用索引，特大型表建立和使用索引代价随之增加，可以使用分区技术</li>
</ul>
<h3 id="MySQL索引分类"><a href="#MySQL索引分类" class="headerlink" title="MySQL索引分类"></a>MySQL索引分类</h3><h4 id="数据结构角度"><a href="#数据结构角度" class="headerlink" title="数据结构角度"></a>数据结构角度</h4><ul>
<li>B+树索引</li>
<li>Hash索引</li>
<li>Full-Text全文索引</li>
<li>R-Tree索引</li>
</ul>
<h4 id="从物理存储角度"><a href="#从物理存储角度" class="headerlink" title="从物理存储角度"></a>从物理存储角度</h4><ul>
<li>聚集索引（clustered index）</li>
<li>非聚集索引（non-clustered index），也叫二级索引（secondary index）<br>聚集索引和非聚集索引都是B+树结构</li>
</ul>
<h4 id="从逻辑角度"><a href="#从逻辑角度" class="headerlink" title="从逻辑角度"></a>从逻辑角度</h4><ul>
<li>主键索引：主键索引是一种特殊的唯一索引，不允许有空值</li>
<li>普通索引或者单列索引：每个索引只包含单个列，一个表可以有多个单列索引</li>
<li>联合索引（复合索引、多列索引）：联合索引指多个字段上创建的索引，使用联合索引时遵循匹配最左前缀，即联合索引必须从左至右依次使用（只有在精准匹配第一列之后才可以使用后面的列，<strong>如果出现了between则不能再使用后面的索引</strong>）</li>
<li>唯一索引或者非唯一索引</li>
<li>空间索引：空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，<strong>空间索引只能在存储引擎为MYISAM的表中创建</strong></li>
</ul>
<blockquote>
<p>❝</p>
<p>为什么MySQL 索引中用B+tree，不用B-tree 或者其他树，为什么不用 Hash 索引</p>
<p>聚簇索引/非聚簇索引，MySQL 索引底层实现，叶子结点存放的是数据还是指向数据的内存地址，使用索引需要注意的几个地方？</p>
<p>使用索引查询一定能提高查询的性能吗？为什么?</p>
</blockquote>
<h3 id="MySQL索引结构"><a href="#MySQL索引结构" class="headerlink" title="MySQL索引结构"></a>MySQL索引结构</h3><p><strong>首先要明白索引（index）是在存储引擎（storage engine）层面实现的，而不是server层面</strong>。不是所有的存储引擎都支持所有的索引类型。即使多个存储引擎支持某一索引类型，它们的实现和行为也可能有所差别。</p>
<h4 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B+Tree索引"></a>B+Tree索引</h4><p>MyISAM 和 InnoDB 存储引擎，都使用 B+Tree的数据结构，它相对与 B-Tree结构，所有的数据都存放在叶子节点上，且把叶子节点通过指针连接到一起，形成了一条数据链表，以加快相邻数据的检索效率</p>
<p><strong>先了解下 B-Tree 和 B+Tree 的区别</strong></p>
<h5 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h5><ul>
<li>B-Tree是为磁盘等外存储设备设计的一种平衡多路查找树（查找路径不止两个）。</li>
<li>系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。</li>
<li>InnoDB 存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB 存储引擎中默认每个页的大小为16KB，可通过参数 <code>innodb_page_size</code> 将页的大小设置为 4K、8K、16K，在 MySQL 中可通过如下命令查看页的大小：<code>show variables like &#39;innodb_page_size&#39;;</code></li>
<li>而系统一个磁盘块的存储空间往往没有这么大，因此 InnoDB 每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小 16KB。InnoDB 在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。</li>
<li>B-Tree 结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述 B-Tree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值，对应表中的主键值，data 为一行记录中除主键外的数据。对于不同的记录，key值互不相同。</li>
<li><strong>m阶的B-Tree的特性：</strong></li>
</ul>
<ol>
<li>每个节点最多有m个子节点</li>
<li>除了根节点和叶子节点外，其它每个节点至少有ceil(m/2)个子节点（ceil()向上取整）。</li>
<li>若根节点不是叶子节点，则至少有2个子节点</li>
<li>所有叶子节点都在同一层，且不包含其它关键字信息</li>
<li>关键字的个数n满足：ceil(m/2)-1 &lt;= n &lt;= m-1</li>
<li>每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn）</li>
<li>ki(i=1,…n)为关键字，且关键字升序排序</li>
<li>Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)</li>
</ol>
<ul>
<li><p>B-Tree 中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个 3 阶的 B-Tree：</p>
</li>
<li><ul>
<li>每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。</li>
<li>模拟查找关键字29的过程：</li>
</ul>
</li>
</ul>
<ol>
<li><ol>
<li><ol>
<li>根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】</li>
<li>比较关键字29在区间（17,35），找到磁盘块1的指针P2。</li>
<li>根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】</li>
<li>比较关键字29在区间（26,30），找到磁盘块3的指针P2。</li>
<li>根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】</li>
<li>在磁盘块8中的关键字列表中找到关键字29。</li>
</ol>
</li>
</ol>
</li>
</ol>
<ul>
<li><ul>
<li>分析上面过程，发现需要3次磁盘I/O操作，和3次内存查找操作。而3次磁盘I/O操作是影响整个B-Tree查找效率的决定因素，所以<strong>B-Tree相对于AVLTree缩减了节点个数</strong>，从而提高了查询效率。</li>
</ul>
</li>
</ul>
<h5 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h5><ul>
<li>B+Tree 是在 B-Tree 基础上的一种优化，使其更适合实现外存储索引结构，InnoDB 存储引擎就是用 B+Tree 实现其索引结构。</li>
<li>B-Tree结构图中每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。在B+Tree中，<strong>所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上**</strong>，而非叶子节点上只存储key值信息**<strong>，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度</strong>。</li>
<li>B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对B+Tree进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。</li>
<li><strong>B+Tree相对于B-Tree有几点不同：</strong></li>
</ul>
<ol>
<li>非叶子节点只存储键值信息；</li>
<li>所有叶子节点之间都有一个链指针；</li>
<li>数据记录都存放在叶子节点中</li>
</ol>
<ul>
<li>假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示：</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539886-ed20e377-d331-41d0-a2f8-1f7273b9442d.webp?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<ul>
<li><p>可能上面例子中只有22条数据记录，看不出B+Tree的优点，下面做一个推算：</p>
</li>
<li><ul>
<li>InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为10^3）。也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录。</li>
</ul>
</li>
<li><p>实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2-4层。MySQL的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。</p>
</li>
<li><p>B+Tree性质</p>
</li>
</ul>
<ol>
<li>通过上面的分析，我们知道IO次数取决于B+树的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有<img src="https://cdn.nlark.com/yuque/__latex/419c87720465f7f5a8523f3cc041af27.svg" alt="img">，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。</li>
<li>当B+树的数据项是复合的数据结构，比如(name,age,sex)的时候，B+树是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，B+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即<strong>索引的最左匹配特性</strong>。</li>
</ol>
<blockquote>
<p>❝B+树是怎么保证平衡的？</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/nullzx/p/8729425.html">B树、B+树插入删除过程</a></p>
<h5 id="MyISAM主键索引与二级索引的结构"><a href="#MyISAM主键索引与二级索引的结构" class="headerlink" title="MyISAM主键索引与二级索引的结构"></a>MyISAM主键索引与二级索引的结构</h5><ul>
<li><p>MyISAM引擎的索引文件和数据文件是分离的。<strong>MyISAM引擎索引结构的叶子节点的数据域，存放的并不是实际的数据记录，而是数据记录的地址</strong>。索引文件与数据文件分离，这样的索引称为”非聚簇索引”。MyISAM的主索引与二级索引区别并不大，只是主索引不能有重复的关键字</p>
</li>
<li><p>MyISAM索引</p>
</li>
<li><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590541902-8b1f0c77-6a43-4901-beab-7f3a2f3b0ff5.webp?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></li>
</ul>
</li>
<li><p>在MyISAM中，索引（含叶子节点）存放在单独的.myi文件中，叶子节点存放的是数据的物理地址偏移量</p>
</li>
<li><p>主索引是指主键索引，键值不可能重复；二级索引则是普通索引，键值可能重复。</p>
</li>
<li><p>通过索引查找数据的流程：先从索引文件中查找到索引节点，从中拿到数据的文件指针，再到数据文件中通过文件指针定位了具体的数据。二级索引类似。</p>
</li>
</ul>
<h5 id="InnoDB主键索引与二级索引的结构"><a href="#InnoDB主键索引与二级索引的结构" class="headerlink" title="InnoDB主键索引与二级索引的结构"></a>InnoDB主键索引与二级索引的结构</h5><ul>
<li><strong>InnoDB引擎索引结构的叶子节点的数据域，存放的就是实际的数据记录</strong>（对于主索引，此处会存放表中所有的数据记录；对于二级索引叶子节点存储的是主键，检索的时候通过叶子节点的主键到主键索引中找到对应数据行，即二级索引需要访问两次索引）</li>
<li>或者说，<strong>InnoDB的数据文件本身就是主键索引文件</strong>，这样的索引被称为“聚簇索引”，一个表只能有一个聚簇索引。</li>
<li><strong>向聚簇索引中的页插入新行，如果超出了存储容量则需要执行“页分裂”**</strong>，会导致页与页之间不连续**（分裂的页就不是聚簇的概念，会通过优化表的操作重新完成聚簇）</li>
</ul>
<h6 id="主键索引："><a href="#主键索引：" class="headerlink" title="主键索引："></a>主键索引：</h6><ul>
<li>InnoDB索引是聚集索引，它的索引和数据是存入同一个.idb文件中的，因此它的索引结构是在同一个树节点中同时存放索引和数据，如下图中最底层的叶子节点有三行数据，对应于数据表中的id、stu_id、name数据项。</li>
<li>在Innodb中，索引分叶子节点和非叶子节点，非叶子节点就像新华字典的目录，单独存放在索引段中，叶子节点则是顺序排列的，在数据段中。Innodb的数据文件可以按照表来切分（只需要开启<code>innodb_file_per_table)</code>，切分后存放在<code>xxx.ibd</code>中，默认不切分，存放在<code>xxx.ibdata</code>中。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539905-19dcb659-d0cf-440b-995d-2a62040981f3.webp?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<h6 id="二级（非主键）索引："><a href="#二级（非主键）索引：" class="headerlink" title="二级（非主键）索引："></a>二级（非主键）索引：</h6><ul>
<li>以示例中学生表中的name列建立二级索引，它的索引结构跟主键索引的结构有很大差别，在最底层的叶子结点有两行数据，第一行的字符串是二级索引，按照ASCII码进行排序，第二行的整数是主键的值。</li>
<li>这就意味着，对name列进行条件搜索，需要两个步骤：</li>
</ul>
<ol>
<li>在二级索引上检索name，到达其叶子节点获取对应的主键；</li>
<li>使用主键在主索引上再进行对应的检索操作</li>
</ol>
<p>这也就是所谓的“<strong>回表查询</strong>”</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539900-bb4d422c-e6a4-4b89-a3f0-44deb87c26cf.webp?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<h5 id="InnoDB-索引结构需要注意的点"><a href="#InnoDB-索引结构需要注意的点" class="headerlink" title="InnoDB 索引结构需要注意的点"></a>InnoDB 索引结构需要注意的点</h5><ol>
<li>数据文件本身就是索引文件</li>
<li>聚集索引中叶节点包含了完整的数据记录</li>
<li>InnoDB 表必须要有主键，并且推荐使用整型自增主键</li>
</ol>
<ul>
<li>不管是主键索引还是二级索引，所有的查询都是通过先查找到索引节点才能拿到相对应的数据，所以如果在设计表结构时没有显式指定索引列的话，MySQL 会从表中选择数据不重复的列建立索引，如果没有符合的列，则 MySQL 自动为 InnoDB 表生成一个隐含字段作为主键，并且这个字段长度为6个字节，类型为整型。</li>
</ul>
<blockquote>
<p>❝那为什么推荐使用整型自增主键而不是选择UUID？</p>
</blockquote>
<ul>
<li>UUID是字符串，比整型消耗更多的存储空间；</li>
<li>在B+树中进行查找时需要跟经过的节点值比较大小，整型数据的比较运算比字符串更快速；</li>
<li>自增的整型索引在磁盘中会连续存储，在读取一页数据时也是连续；UUID是随机产生的，读取的上下两行数据存储是分散的，不适合执行where id &gt; 5 &amp;&amp; id &lt; 20的条件查询语句。</li>
<li>在插入或删除数据时，整型自增主键会在叶子结点的末尾建立新的叶子节点，不会破坏左侧子树的结构；UUID主键很容易就破坏了原有树结构，B+树为了维持自身的特性，有可能会进行结构的重构，消耗更多的时间。</li>
</ul>
<blockquote>
<p>❝为什么非主键索引结构叶子节点存储的是主键值？</p>
</blockquote>
<p>保证数据一致性（更新数据的时候只更新主键索引中的数据即可）和节省存储空间，</p>
<h4 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h4><ul>
<li><p>主要就是通过Hash算法，将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。<br>检索算法：在检索查询时，就再次对待查关键字再次执行相同的Hash算法，得到Hash值，到对应Hash表对应位置取出数据即可，如果发生Hash碰撞，则需要在取值时进行筛选。</p>
</li>
<li><p><strong>Hash索引的限制：</strong></p>
</li>
<li><ul>
<li>value存储的是行指针，不能实现覆盖索引</li>
<li>哈希索引不是按照索引值顺序存储的，所以不能用于排序，也就不支持范围查找</li>
<li>联合索引时不支持使用部分索引进行查找，因为hash值是由全部索引列计算得到的</li>
<li>哈希冲突严重的时候相当于遍历链表，反而比不上二叉树</li>
</ul>
</li>
<li><p>MySQL目前有Memory引擎和NDB引擎支持Hash索引。</p>
</li>
<li><p>InnoDB可以创建自定义哈希索引：</p>
</li>
<li><ul>
<li>当需要根据URL进行索引时，可以将URL的hash值作为索引的列，这样可以降低索引值长度，并且是整数比较速度快</li>
<li>即使有大量的哈希冲突，但是索引仍然可以过滤很多数据，而且速度比直接使用URL快</li>
</ul>
</li>
</ul>
<h4 id="full-text全文索引"><a href="#full-text全文索引" class="headerlink" title="full-text全文索引"></a>full-text全文索引</h4><ul>
<li>全文索引也是MyISAM的一种特殊索引类型，主要用于全文索引，InnoDB从MYSQL5.6版本提供对全文索引的支持。</li>
<li>它用于替代效率较低的LIKE模糊匹配操作，而且可以通过多字段组合的全文索引一次性全模糊匹配多个字段。</li>
<li>同样使用B-Tree存放索引数据，但使用的是特定的算法，将字段数据分割后再进行索引（一般每4个字节一次分割），索引文件存储的是分割前的索引字符串集合，与分割后的索引信息，对应B-tree结构的节点存储的是分割后的词信息以及它在分割前的索引字符串集合中的位置。</li>
</ul>
<h4 id="R-Tree空间索引"><a href="#R-Tree空间索引" class="headerlink" title="R-Tree空间索引"></a>R-Tree空间索引</h4><p>空间索引是MyISAM的一种特殊索引类型，主要用于地理空间数据类型</p>
<blockquote>
<p>❝为什么Mysql索引要用B+树不是B树？</p>
</blockquote>
<p>用B+树不用B树考虑的是IO对性能的影响，B树的每个节点都存储数据，而B+树只有叶子节点才存储数据，所以查找相同数据量的情况下，B树的高度更高，IO更频繁。数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。其中在MySQL底层对B+树进行进一步优化：在叶子节点中是双向链表，且在链表的头结点和尾节点也是循环指向的。</p>
<blockquote>
<p>❝面试官：为何不采用Hash方式？</p>
</blockquote>
<p>因为Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。所以，哈希索引只适用于等值查询的场景。而B+Tree是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描。</p>
<p>哈希索引不支持多列联合索引的最左匹配规则，如果有大量重复键值的情况下，哈希索引的效率会很低，因为存在哈希碰撞问题。</p>
<h3 id="哪些情况需要创建索引"><a href="#哪些情况需要创建索引" class="headerlink" title="哪些情况需要创建索引"></a>哪些情况需要创建索引</h3><ol>
<li>主键自动建立唯一索引</li>
<li>频繁作为查询条件的字段</li>
<li>查询中与其他表关联的字段，外键关系建立索引</li>
<li>单键/组合索引的选择问题，高并发下倾向创建组合索引</li>
<li>查询中排序的字段，排序字段通过索引访问大幅提高排序速度</li>
<li>查询中统计或分组字段</li>
</ol>
<h3 id="哪些情况不要创建索引"><a href="#哪些情况不要创建索引" class="headerlink" title="哪些情况不要创建索引"></a>哪些情况不要创建索引</h3><ol>
<li>表记录太少</li>
<li>经常增删改的表</li>
<li>数据重复且分布均匀的表字段，只应该为最经常查询和最经常排序的数据列建立索引（如果某个数据类包含太多的重复数据，建立索引没有太大意义）</li>
<li>频繁更新的字段不适合创建索引（会加重I/O负担）</li>
<li>where条件里用不到的字段不创建索引</li>
</ol>
<h3 id="高性能创建索引"><a href="#高性能创建索引" class="headerlink" title="高性能创建索引"></a>高性能创建索引</h3><p>创建索引的时候有各种细节可以使得索引的使用效率进一步提高**<br>**</p>
<h4 id="列前缀索引"><a href="#列前缀索引" class="headerlink" title="列前缀索引"></a>列前缀索引</h4><ul>
<li><p>有时需要索引很长的字符列，会让索引变得大且慢。一个策略是使用哈希索引，另一种方式是使用列前缀索引，即使用该列前一部分字符建立索引，并查询时也只使用该列的前一部分字符。注意：列前缀索引和匹配最前缀索引不是一回事，前者是一个列，后者是多个列</p>
</li>
<li><ul>
<li>例如</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>建立city列字符串的前3个字符的索引：</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>ALTER TABLE sakila.city_demo ADD KEY (city(7));</p>
<ul>
<li><ul>
<li><ul>
<li>查询city列字符串的前3个字符：</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>SELECT COUNT(*) AS cnt, LEFT(city,3) AS pref</p>
<p>FROM sakila.city_demo GROUP BY pref ORDER BY cnt DESC LIMIT 10;</p>
<ul>
<li><p>查询时究竟选择几个字符需要根据实际列判断索引选择性：</p>
</li>
<li><ul>
<li><ul>
<li>索引选择性：不重复的索引项/数据表的记录总数（即，分支越多索引选择性越大）</li>
<li>选择全部的字符串时索引选择性大</li>
<li>当选择前n个字符的索引选择性接近全字符串的索引选择性时是最佳的列前缀索引</li>
</ul>
</li>
</ul>
</li>
<li><p>使用列前缀索引则不能在该列上使用ORDER BY/GROUP BY，也不能作为覆盖索引</p>
</li>
</ul>
<h4 id="联合索引中索引顺序"><a href="#联合索引中索引顺序" class="headerlink" title="联合索引中索引顺序"></a>联合索引中索引顺序</h4><ul>
<li><p>“三星”索引概念：</p>
</li>
<li><ul>
<li>与查询相关的索引行是相邻的，也就是where后面的等值谓词，可以匹配索引列顺序——where和索引匹配越多，扫描的数据行越少</li>
<li>索引行的顺序与查询语句需求一致，也就是order by 中的排序和索引顺序是否一致——避免排序</li>
<li>索引行包含查询语句中所有的列——避免扫描数据行</li>
</ul>
</li>
<li><p>一个联合索引中的索引列顺序可以影响到一个索引是否是“三星”索引</p>
</li>
<li><p>通用经验是将选择性高的列放在索引最前列，这样仅仅在where进行查找时效果较好，仅仅是一个经验，排序和分组时这样并不一定适合，实践中并不一定这么做</p>
</li>
<li><p>《高性能MySQL》P183 5.4 索引学习中有很好的设计索引的例子，例子中的选择</p>
</li>
<li><ul>
<li>例子：根据用户信息表的多个列筛选出指定的特征的一批用户</li>
<li>country,sex这种列虽然选择性不强但使用这个列进行查询的情况比较多，所以作为联合索引的头两列(sex,country)</li>
<li>如果查新时没有限定性别，则可以在WHERE中新增AND SEX IN(‘m’,’f’)，保证满足匹配最左索引，使得该索引发挥作用</li>
<li>对于age这种一般都设定为范围的列，建立索引时要放在联合索引的最右边(sex,country,…,age)</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>因为基于索引查询需要满足匹配最左前缀，直到遇到第一个范围条件列。即，如果age在第一列，那么使用WHERE AGE BETWEEN 18 AND 24，那么后面的sex,country列就不能作为索引列了，联合索引仅仅只使用了第一列age</li>
<li>当然可以转化为AND AGE IN (18,19,20,21,22,23,24)，但是不是所有的范围查询都可以转换的</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>IN(…)这种技巧不要过于依赖，由于多列IN组合的数量是乘法，所以组合数会快速增加，当组合数达到上千个时就需要小心了</li>
</ul>
</li>
</ul>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p><strong>覆盖索引</strong>（Covering Index）,或者叫索引覆盖， 可以不需要回表操作</p>
<ul>
<li>就是select查询数据列在索引中就已经完全包含，不必读取数据行，利用索引返回select列表中的字段，而不必根据索引再次读取数据文件，换句话说<strong>查询列要被所建的索引覆盖</strong>。</li>
<li>索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据，当能通过读取索引就可以得到想要的数据，那就不需要读取行了。一个索引包含（覆盖）满足查询结果的数据就叫做覆盖索引。</li>
<li><strong>判断标准</strong><br>使用explain，可以通过输出的extra列来判断，对于一个索引覆盖查询，显示为<strong>using index</strong>，MySQL查询优化器在执行查询前会决定是否有索引覆盖查询</li>
</ul>
<h2 id="七、MySQL查询"><a href="#七、MySQL查询" class="headerlink" title="七、MySQL查询"></a>七、MySQL查询</h2><ul>
<li>查询优化、索引优化、库表结构优化需要齐头并进</li>
</ul>
<h3 id="优化慢查询"><a href="#优化慢查询" class="headerlink" title="优化慢查询"></a>优化慢查询</h3><ul>
<li>是否查询了大量的结果，但是仅使用前10条——使用LIMIT</li>
<li>多表关联的时候返回了全部的列（SELECT * FROM actor INNER JOIN film_actor USING(actor_id) WHERE …）——仅返回需要的列</li>
<li>取出不需要的列（SELECT * FROM xxx）</li>
</ul>
<p>取出不需要的列会导致优化器无法使用索引覆盖进行优化，同时还会带来额外的I/O、内存和CPU消耗</p>
<h3 id="索引效果与优化"><a href="#索引效果与优化" class="headerlink" title="索引效果与优化"></a>索引效果与优化</h3><p>使用WHERE条件的三种方式，从好到坏：</p>
<ul>
<li>索引中使用WHERE条件过滤不匹配的记录。在存储引擎层完成</li>
<li>使用索引覆盖扫描返回记录（Explain中Extra列为Using index）。在MySQL服务器层完成，不需要回表查询</li>
<li>从数据表中返回记录，然后根据WHERE过滤不满足条件的记录（Explain中Extra列为Using Where）。在MySQL服务器层完成，需要先从数据表读出记录再过滤</li>
</ul>
<p>发现扫描大量数据，但只返回需要的少量数据，优化方式：</p>
<ul>
<li>从索引角度入手，使用索引覆盖扫描</li>
<li>从库表结构入手，例如使用单独的汇总表（优化count()语句）</li>
<li>从查询语句入手，重写查询语句，下面会介绍</li>
</ul>
<h3 id="重构查询的方式"><a href="#重构查询的方式" class="headerlink" title="重构查询的方式"></a>重构查询的方式</h3><h4 id="切分查询"><a href="#切分查询" class="headerlink" title="切分查询"></a>切分查询</h4><ul>
<li><p>有时候可以将一个大查询切分成小查询</p>
</li>
<li><p>例如，删除旧数据</p>
</li>
<li><ul>
<li>一次删除大量数据可能锁住很多数据，占满整个事务日志、耗尽资源、阻塞很多重要查询</li>
<li>将要删除的数据分为多次小删除对服务器影响较小</li>
<li>原SQL语句一次删除大量数据：DELETE FROM messages WHERE created &lt; DATE_SUB(NOW(),INTERVAL 3 MONTH);</li>
<li>一次只删除10000行数据：rows_affected = 0</li>
</ul>
</li>
</ul>
<p>do {</p>
<p> rows_affected = do_query{</p>
<p>“DELETE FROM messages WHERE created &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH)</p>
<p>LIMIT 10000”)</p>
<p>} while rows_affected &gt; 0</p>
<h4 id="分解关联查询"><a href="#分解关联查询" class="headerlink" title="分解关联查询"></a>分解关联查询</h4><ul>
<li><p><strong>将一条关联查询分解成多个独立的单表查询，可以具有如下优势：</strong></p>
</li>
<li><ul>
<li>缓存的效率更高。缓存单表查询的话重复查询的频率会更高</li>
<li>执行单个查询可以减少锁竞争</li>
<li>持久层分解，应用层关联，可以更容易拆分数据库，提高可伸缩性</li>
</ul>
</li>
</ul>
<h3 id="查询执行的基础"><a href="#查询执行的基础" class="headerlink" title="查询执行的基础"></a>查询执行的基础</h3><ul>
<li><p>客户端向服务器发送请求时的步骤：</p>
</li>
<li><ul>
<li>客户端发送一条查询给服务器</li>
<li>服务器先检查<strong>查询缓存</strong>，如果命中缓存则立即返回缓存中的结果，否则进入下一阶段</li>
<li>服务器端进行SQL<strong>解析、预处理</strong>，再由<strong>优化器</strong>生成对应的<strong>执行计划</strong></li>
<li>根据执行计划调用存储引擎的API来执行查询</li>
<li>将结果返回给客户端</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1590917863447-22c656bd-a4c5-4b08-8c99-7b39215b5f4f.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image.png"></li>
</ul>
</li>
</ul>
<h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><ul>
<li>解析查询语句前MySQL会解析查询是否命中缓存中的数据。检查是通过大小写敏感的哈希查找，即使查询语句有一个字节不同也不会匹配</li>
<li>如果匹配了则检查权限，并直接返回缓存中的结果</li>
<li>如果没有匹配则执行下面的步骤</li>
</ul>
<h4 id="查询优化处理"><a href="#查询优化处理" class="headerlink" title="查询优化处理"></a>查询优化处理</h4><ul>
<li>查询在查询缓存后的下一个生命周期是将SQL转换成一个执行计划，具体步骤包括：<strong>解析SQL、预处理、优化SQL执行计划</strong></li>
</ul>
<h5 id="语法解析器和预处理"><a href="#语法解析器和预处理" class="headerlink" title="语法解析器和预处理"></a>语法解析器和预处理</h5><ul>
<li>解析器根据SQL关键字解析，并生成“解析树”。这个步骤会进行验证和解析查询，例如，验证是否错误的关键字，关键字顺序是否正确</li>
<li>预处理器进一步检查解析树是否合法，例如，查询数据表和数据列是否存在。同时会验证权限。</li>
</ul>
<h5 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h5><ul>
<li><p>优化器将这个合法的语法树转化成执行计划</p>
</li>
<li><p>一条查询语句可以有多种执行方式，返回相同的结果，优化器的作用就是找到其中最好的执行计划</p>
</li>
<li><p>MySQL使用基于成本的优化器，主要是完成查询需要读取数据页的数量。受限于统计信息不准确（MVCC架构），没有考虑并发情况等，最终的执行计划并不一定是最优的</p>
</li>
<li><p>优化策略可以分为两种：</p>
</li>
<li><ul>
<li>静态优化：直接对解析树进行优化，例如通过简单的代数变换将where条件转换成另一种等价形式（下面有例子）</li>
<li>动态优化：与查询的上下文有关，也可能和很多其他因素有关，例如where条件中的取值、索引中条目对应的数据行数。因为不是固定的优化策略，所以每次查询都要重新评估。</li>
</ul>
</li>
<li><p>MySQL能够处理的优化类型：</p>
</li>
<li><ul>
<li><strong>重新定义关联表的顺序：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>下面会说</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>将外连接转化成内连接：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>有些外连接LEFT OUTER JOIN 可以转换成内连接INNER JOIN，这样就可以调整管关联顺序了</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>优化COUNT()、MIN()、MAX()：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>例如最小值可以直接查询B-Tree最左端记录</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>预估并转换为常数表达式：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>检测到表达式可以转化成常数时会将其当作常数进行优化处理</li>
<li>此外，有时候一个查询也可以转化为一个常数，例子：</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>EXPLAIN SELECT film.film_id, film_actor.actor_id</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>FROM sakila.film</p>
<p>INNER JOIN sakila.film_actor USING(film_id)</p>
<p>WHERE film.film_id=1;</p>
<ul>
<li><ul>
<li><ul>
<li><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1590914393242-1ebaea4c-d929-4b6a-820e-b21c8c6de7a9.png" alt="image.png"></li>
<li>上面查询分为两步：</li>
<li>①：先从film表找到需要的行，因为film_id字段上有主键索引，所以MySQL知道只会返回一行数据，所以表的访问类型是const</li>
<li>②：因为第一步返回的film_id列当作已知取值的列，那么对表film_actor的访问类型也是const</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>覆盖索引扫描：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>索引中的列包含所有查询中需要的列时就可以使用索引返回需要的数据，无须查询对应的数据行</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>子查询优化：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>某些情况下会将子查询转换一种形式，从而减少多个查询多次对数据进行访问的次数</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>提前终止查询：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>发现已经满足查询需求时候会立刻终止查询，比如使用LIMIT的时候，或者发现一个不成立的条件时（SELECT  film.film_id FROM sakila.film WHERE film_id = -1）</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>等值传播：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>如果两个列通过等式关联，那么MySQL能够把其中一个列的WHERE条件传递到另一个列上，例如：</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>SELECT film.film_id</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>FROM sakila.film</p>
<p>INNER JOIN sakila.film_actor USING(film_id)</p>
<p>WHERE film.film_id&gt;500;</p>
<ul>
<li><ul>
<li><ul>
<li><ul>
<li>由于WHERE 子句中的film_id字段同样适用于film_actor表，那么MySQL会优化成下面的形式：</li>
<li>… WHERE film.film_id &gt; 500 AND film_actor.film_id &gt; 500</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>列表IN()</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>很多数据库系统中，IN()完全等同于多个OR条件的子句，复杂度O(n)。但是MySQL会将IN()中的数据先排序，然后通过二分查找确定IN()中的值是否满足条件，复杂度O(logn)。IN()中有大量取值时，MySQL处理速度会快一定</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="数据和索引的统计信息"><a href="#数据和索引的统计信息" class="headerlink" title="数据和索引的统计信息"></a>数据和索引的统计信息</h5><ul>
<li><p>统计信息由存储引擎实现</p>
</li>
<li><p>查询优化器在生成查询计划时，需要向存储引擎获取相应的统计信息，包括</p>
</li>
<li><ul>
<li>每个表或索引有多少页</li>
<li>每个表的每个索引的基数是多少（索引选择性）</li>
<li>数据行和索引长度、索引的分布信息等</li>
</ul>
</li>
</ul>
<h5 id="如何执行关联查询"><a href="#如何执行关联查询" class="headerlink" title="如何执行关联查询"></a>如何执行关联查询</h5><ul>
<li><p>MySQL概念中不仅仅是查询需要到两个表才叫关联，，每个查询都是一次关联。</p>
</li>
<li><p>MySQL关联执行的策略：</p>
</li>
<li><ul>
<li>嵌套循环关联：先在一个表中循环取出单条数据，然后再执行嵌套循环到下一个表中匹配的行，依次下去，直到找到所有表中匹配的行。然后根据各表匹配的行，返回查询中需要的各个列。先在最后一个关联表尝试找到所有匹配的行，然后再回溯到上一个表。</li>
<li>即，循环+嵌套获取所有匹配的行，然后回溯返回数据</li>
</ul>
</li>
<li><p>MySQL多表关联示意图：</p>
</li>
<li><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1590918172760-399cd7a4-0411-4da4-8812-47e69bb74014.png" alt="image.png"></li>
</ul>
</li>
<li><p>MySQL关联查询示例图</p>
</li>
<li><ul>
<li>SQL语句：SELECT tbl1.col1, tbl2.col2 FROM tbl1 INNER JOIN tbl2 USING(col3) WHERE tbl1.col1 IN(5,6);</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1590917828821-0399668d-00d1-4c66-8d35-70e18754ede5.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image.png"></li>
</ul>
</li>
</ul>
<h5 id="关联查询优化器"><a href="#关联查询优化器" class="headerlink" title="关联查询优化器"></a>关联查询优化器</h5><ul>
<li><p>MySQL优化器最重要的部分就是关联查询优化，多表关联时可以有多种不同的关联顺序来获取相同的结果，关联查询优化器就是通过评估不同顺序时的成本来选择代价最小的关联顺序</p>
</li>
<li><p>例子：</p>
</li>
<li><ul>
<li>SQL语句：SELECT film_id, film.title, film.release_year, actor.actor_id, actor.first_name, actor.last_name</li>
</ul>
</li>
</ul>
<p>FROM sakila.<strong>film</strong></p>
<p>INNER JOIN sakila.<strong>film_actor</strong> USING(film_id)</p>
<p>INNER JOIN sakila.<strong>actor</strong> USING(actor_id);</p>
<ul>
<li><ul>
<li>MySQL没有按照SQL关联的顺序，而是优化了关联顺序，EXPLAIN结果如下：</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1590918875519-95211bf1-b239-4546-924d-652fd842d47d.png" alt="image.png"></li>
<li>如果让MySQL强行按照SQL顺序执行，在SELECT后加STRAIGHT_JOIN，EXPLAIN结果如下：</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1590919015592-d17f26a1-03b9-416c-966d-b313c527d900.png" alt="image.png"></li>
<li>可以发现修改关联顺序可以减少扫描的行数，让查询进行更少的嵌套循环和回溯操作</li>
<li>如果可以的话，优化器会遍历每一个表然后逐个做嵌套循环计算成本，然后返回最优的执行计划</li>
<li>但是n个表的关联种数是阶乘，所以会使用“启发式”优化策略，并不会遍历计算所有可能的执行计划</li>
<li>（注意：各个查询的顺序不能随意安排，因为后面的表的查询需要依赖于前面表的查询结果。比如左外连接、相关子查询）</li>
</ul>
</li>
</ul>
<h5 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h5><ul>
<li><p>MySQL排序规则：</p>
</li>
<li><ul>
<li>当不能使用索引生成排序结果时，MySQL会使用filesort进行排序</li>
<li><strong>如果数据量小于“排序缓冲区”会在内存中使用快排进行排序。如果数据量大于则会在磁盘中进行排序，先将数据分块，对每个独立的块使用快排，然后将各个块的排序结果存放在磁盘上，然后将各个排好序的块进行合并，最后返回结果</strong></li>
</ul>
</li>
<li><p>MySQL排序算法：</p>
</li>
<li><ul>
<li>两次传输排序：① 读取行指针和需要排序的字段，并对其排序。② 然后根据排序结果读取所需要的数据行</li>
<li>单次传输排序：① 读取查询需要的所有列，然后根据给定列进行排序，最后直接返回排序结果</li>
<li>两种算法各有优劣</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>两次传输排序：因为排序后再读取数据行，会产生大量的随机I/O</li>
<li>顺序读取数据行，不会随机I/O，缺点是如果需要返回的列非常多，会额外占用大量的空间，而这些列对排序本身没有帮助</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="查询执行计划"><a href="#查询执行计划" class="headerlink" title="查询执行计划"></a>查询执行计划</h4><ul>
<li>查询执行引擎根据执行计划调用API完成查询</li>
</ul>
<h4 id="返回结果给客户端"><a href="#返回结果给客户端" class="headerlink" title="返回结果给客户端"></a>返回结果给客户端</h4><ul>
<li>将查询结果返回给客户端，如果缓存开启，则将结果存放到查询缓存中</li>
<li>并不是查询彻底完成后才开始返回的，一旦服务器处理完最后一个关联表，开始生成第一条结果时，就开始向客户端逐步返回结果集</li>
<li>好处：服务器端不用存储太多了结果，客户端可以第一时间获得返回的结果</li>
</ul>
<h3 id="几个查询语句的区别"><a href="#几个查询语句的区别" class="headerlink" title="几个查询语句的区别"></a>几个查询语句的区别</h3><h5 id="count-和count-列名-查询"><a href="#count-和count-列名-查询" class="headerlink" title="count(*)和count(列名)查询"></a>count(*)和count(列名)查询</h5><ul>
<li>count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL</li>
<li>count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数，即某个字段值为NULL时，不统计。</li>
</ul>
<h5 id="in和-exists-的区别？"><a href="#in和-exists-的区别？" class="headerlink" title="in和 exists 的区别？"></a>in和 exists 的区别？</h5><ul>
<li>exists：exists对外表用loop逐条查询，每次查询都会查看exists的条件语句，当exists里的条件语句能够返回记录行时（无论记录行是的多少，只要能返回），条件就为真，返回当前loop到的这条记录；反之，如果exists里的条件语句不能返回记录行，则当前loop到的这条记录被丢弃，exists的条件就像一个bool条件，当能返回结果集则为true，不能返回结果集则为false</li>
<li>in：in查询相当于多个or条件的叠加</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> A.id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> B);</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> * <span class="keyword">from</span> B <span class="keyword">WHERE</span> B.id = A.id);</span><br></pre></td></tr></table></figure>

<ul>
<li>如果查询的两个表大小相当，那么用in和exists差别不大</li>
<li>如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in</li>
</ul>
<h5 id="UNION和UNION-ALL的区别"><a href="#UNION和UNION-ALL的区别" class="headerlink" title="UNION和UNION ALL的区别?"></a>UNION和UNION ALL的区别?</h5><p>UNION和UNION ALL都是将两个结果集合并为一个，<strong>两个要联合的SQL语句 字段个数必须一样，而且字段类型要“相容”（一致）；</strong></p>
<ul>
<li>UNION在进行表连接后会筛选掉重复的数据记录（效率较低），而UNION ALL则不会去掉重复的数据记录；</li>
<li>UNION会按照字段的顺序进行排序，而UNION ALL只是简单的将两个结果合并就返回；</li>
</ul>
<h3 id="SQL执行顺序"><a href="#SQL执行顺序" class="headerlink" title="SQL执行顺序"></a>SQL执行顺序</h3><ul>
<li>手写</li>
</ul>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> &lt;select_list&gt;</span><br><span class="line"><span class="keyword">FROM</span>  &lt;left_table&gt; &lt;join_type&gt;</span><br><span class="line"><span class="keyword">JOIN</span>  &lt;right_table&gt; <span class="keyword">ON</span> &lt;join_condition&gt;</span><br><span class="line"><span class="keyword">WHERE</span>  &lt;where_condition&gt;</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span>  &lt;group_by_list&gt;</span><br><span class="line"><span class="keyword">HAVING</span> &lt;having_condition&gt;</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;order_by_condition&gt;</span><br><span class="line"><span class="keyword">LIMIT</span> &lt;limit_number&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>机读</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span>  &lt;left_table&gt;</span><br><span class="line"><span class="keyword">ON</span> &lt;join_condition&gt;</span><br><span class="line">&lt;join_type&gt; <span class="keyword">JOIN</span>  &lt;right_table&gt;</span><br><span class="line"><span class="keyword">WHERE</span>  &lt;where_condition&gt;</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span>  &lt;group_by_list&gt;</span><br><span class="line"><span class="keyword">HAVING</span> &lt;having_condition&gt;</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">DISTINCT</span> &lt;select_list&gt;</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;order_by_condition&gt;</span><br><span class="line"><span class="keyword">LIMIT</span> &lt;limit_number&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>总结</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539949-2595b2b5-7eac-4a9f-a6ca-016a37625d12.webp" alt="image"></p>
<blockquote>
<p>❝</p>
<p>mysql 的内连接、左连接、右连接有什么区别？</p>
<p>什么是内连接、外连接、交叉连接、笛卡尔积呢？</p>
</blockquote>
<h3 id="Join图"><a href="#Join图" class="headerlink" title="Join图"></a>Join图</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539969-2ac4a686-05ba-4792-baa4-251a6c5bd854.webp?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<h2 id="八、MySQL调优"><a href="#八、MySQL调优" class="headerlink" title="八、MySQL调优"></a>八、MySQL调优</h2><blockquote>
<p>❝</p>
<p>日常工作中你是怎么优化SQL的？</p>
<p>SQL优化的一般步骤是什么，怎么看执行计划（explain），如何理解其中各个字段的含义？</p>
<p>如何写sql能够有效的使用到复合索引？</p>
<p>一条sql执行过长的时间，你如何优化，从哪些方面入手？</p>
<p>什么是最左前缀原则？什么是最左匹配原则？</p>
</blockquote>
<h3 id="影响mysql的性能因素"><a href="#影响mysql的性能因素" class="headerlink" title="影响mysql的性能因素"></a>影响mysql的性能因素</h3><ul>
<li><p>业务需求对MySQL的影响(合适合度)</p>
</li>
<li><p>存储定位对MySQL的影响</p>
</li>
<li><ul>
<li>系统各种配置及规则数据</li>
<li>活跃用户的基本信息数据</li>
<li>活跃用户的个性化定制信息数据</li>
<li>准实时的统计信息数据</li>
<li>其他一些访问频繁但变更较少的数据</li>
<li>二进制多媒体数据</li>
<li>流水队列数据</li>
<li>超大文本数据</li>
<li>不适合放进MySQL的数据</li>
<li>需要放进缓存的数据</li>
</ul>
</li>
<li><p>Schema设计对系统的性能影响</p>
</li>
<li><ul>
<li>尽量减少对数据库访问的请求</li>
<li>尽量减少无用数据的查询请求</li>
</ul>
</li>
<li><p>硬件环境对系统性能的影响</p>
</li>
</ul>
<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><h4 id="MySQL-Query-Optimizer"><a href="#MySQL-Query-Optimizer" class="headerlink" title="MySQL Query Optimizer"></a>MySQL Query Optimizer</h4><ol>
<li>MySQL 中有专门负责优化 SELECT 语句的优化器模块，主要功能：通过计算分析系统中收集到的统计信息，为客户端请求的 Query 提供他认为最优的执行计划（他认为最优的数据检索方式，但不见得是 DBA 认为是最优的，这部分最耗费时间）</li>
<li>当客户端向 MySQL 请求一条 Query，命令解析器模块完成请求分类，区别出是 SELECT 并转发给 MySQL Query Optimize r时，MySQL Query Optimizer 首先会对整条 Query 进行优化，处理掉一些常量表达式的预算，直接换算成常量值。并对 Query 中的查询条件进行简化和转换，如去掉一些无用或显而易见的条件、结构调整等。然后分析 Query 中的 Hint 信息（如果有），看显示 Hint 信息是否可以完全确定该 Query 的执行计划。如果没有 Hint 或 Hint 信息还不足以完全确定执行计划，则会读取所涉及对象的统计信息，根据 Query 进行写相应的计算分析，然后再得出最后的执行计划。</li>
</ol>
<h4 id="MySQL常见瓶颈"><a href="#MySQL常见瓶颈" class="headerlink" title="MySQL常见瓶颈"></a>MySQL常见瓶颈</h4><ul>
<li>CPU：CPU在饱和的时候一般发生在数据装入内存或从磁盘上读取数据时候</li>
<li>IO：磁盘I/O瓶颈发生在装入数据远大于内存容量的时候</li>
<li>服务器硬件的性能瓶颈：top，free，iostat 和 vmstat来查看系统的性能状态</li>
</ul>
<h4 id="性能下降SQL慢-执行时间长-等待时间长-原因分析"><a href="#性能下降SQL慢-执行时间长-等待时间长-原因分析" class="headerlink" title="性能下降SQL慢 执行时间长 等待时间长 原因分析"></a>性能下降SQL慢 执行时间长 等待时间长 原因分析</h4><ul>
<li>查询语句写的烂</li>
<li>索引失效（单值、复合）</li>
<li>关联查询太多join（设计缺陷或不得已的需求）</li>
<li>服务器调优及各个参数设置（缓冲、线程数等）</li>
</ul>
<h4 id="MySQL常见性能分析手段"><a href="#MySQL常见性能分析手段" class="headerlink" title="MySQL常见性能分析手段"></a>MySQL常见性能分析手段</h4><p>在优化MySQL时，通常需要对数据库进行分析，常见的分析手段有<strong>慢查询日志</strong>，<strong>EXPLAIN 分析查询</strong>，<strong>profiling分析</strong>以及<strong>show命令查询系统状态及系统变量</strong>，通过定位分析性能的瓶颈，才能更好的优化数据库系统的性能。</p>
<h5 id="性能瓶颈定位"><a href="#性能瓶颈定位" class="headerlink" title="性能瓶颈定位"></a>性能瓶颈定位</h5><p>我们可以通过 show 命令查看 MySQL 状态及变量，找到系统的瓶颈：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Mysql&gt; <span class="keyword">show</span> status ——显示状态信息（扩展<span class="keyword">show</span> status <span class="keyword">like</span> ‘XXX’）</span><br><span class="line">Mysql&gt; <span class="keyword">show</span> variables ——显示系统变量（扩展<span class="keyword">show</span> variables <span class="keyword">like</span> ‘XXX’）</span><br><span class="line">Mysql&gt; <span class="keyword">show</span> innodb status ——显示InnoDB存储引擎的状态</span><br><span class="line">Mysql&gt; <span class="keyword">show</span> processlist ——查看当前<span class="keyword">SQL</span>执行，包括执行状态、是否锁表等</span><br><span class="line">Shell&gt; mysqladmin variables -u username -p <span class="keyword">password</span>——显示系统变量</span><br><span class="line">Shell&gt; mysqladmin extended-status -u username -p <span class="keyword">password</span>——显示状态信息</span><br></pre></td></tr></table></figure>

<h5 id="Explain-执行计划"><a href="#Explain-执行计划" class="headerlink" title="Explain(执行计划)"></a>Explain(执行计划)</h5><p>是什么：使用 <strong>Explain</strong> 关键字可以模拟优化器执行SQL查询语句，从而知道 MySQL 是如何处理你的 SQL 语句的。分析你的查询语句或是表结构的性能瓶颈</p>
<p>能干什么：</p>
<ul>
<li>表的读取顺序</li>
<li>数据读取操作的操作类型</li>
<li>哪些索引可以使用</li>
<li>哪些索引被实际使用</li>
<li>表之间的引用</li>
<li>每张表有多少行被优化器查询</li>
</ul>
<p>怎么玩：</p>
<ul>
<li>Explain + SQL语句</li>
<li>执行计划包含的信息（如果有分区表的话还会有<strong>partitions</strong>）</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539945-f25d6d79-1cb8-42b6-a6fa-b57a1ba9b5c9.webp" alt="image">expalin</p>
<p>各字段解释</p>
<ul>
<li><p><strong>id</strong>（select 查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序）</p>
</li>
<li><ul>
<li>id相同，执行顺序从上往下</li>
<li>id全不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</li>
<li>id部分相同，执行顺序是先按照数字大的先执行，然后数字相同的按照从上往下的顺序执行</li>
</ul>
</li>
<li><p><strong>select_type</strong>（查询类型，用于区别普通查询、联合查询、子查询等复杂查询）</p>
</li>
<li><ul>
<li><strong>SIMPLE</strong> ：简单的select查询，查询中不包含子查询或UNION</li>
<li><strong>PRIMARY</strong>：查询中若包含任何复杂的子部分，最外层查询被标记为PRIMARY</li>
<li><strong>SUBQUERY</strong>：在select或where列表中包含了子查询</li>
<li><strong>DERIVED</strong>：在from列表中包含的子查询被标记为DERIVED，MySQL会递归执行这些子查询，把结果放在临时表里</li>
<li><strong>UNION</strong>：若第二个select出现在UNION之后，则被标记为UNION，若UNION包含在from子句的子查询中，外层select将被标记为DERIVED</li>
<li><strong>UNION RESULT</strong>：从UNION表获取结果的select</li>
</ul>
</li>
<li><p><strong>table</strong>（显示这一行的数据是关于哪张表的）</p>
</li>
<li><p><strong>type</strong>（显示查询使用了那种类型，从最好到最差依次排列 <strong>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</strong> ）<br>tip: 一般来说，得保证查询至少达到range级别，最好到达ref</p>
</li>
<li><ul>
<li>system：表只有一行记录（等于系统表），是 const 类型的特例，平时不会出现</li>
<li>const：表示通过索引一次就找到了，const 用于比较 primary key 或 unique 索引，因为只要匹配一行数据，所以很快，如将主键置于 where 列表中，mysql 就能将该查询转换为一个常量</li>
<li>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常见于主键或唯一索引扫描</li>
<li>ref：非唯一性索引扫描，范围匹配某个单独值得所有行。本质上也是一种索引访问，他返回所有匹配某个单独值的行，然而，它可能也会找到多个符合条件的行，多以他应该属于查找和扫描的混合体</li>
<li>range：只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引，一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询，这种范围扫描索引比全表扫描要好，因为它只需开始于索引的某一点，而结束于另一点，不用扫描全部索引</li>
<li>index：Full Index Scan，index于ALL区别为index类型只遍历索引树。通常比ALL快，因为索引文件通常比数据文件小。（<strong>也就是说虽然all和index都是读全表，但index是从索引中读取的，而all是从硬盘中读的</strong>）</li>
<li>ALL：Full Table Scan，将遍历全表找到匹配的行</li>
</ul>
</li>
<li><p><strong>possible_keys</strong>（显示可能应用在这张表中的索引，一个或多个，查询涉及到的字段若存在索引，则该索引将被列出，但不一定被查询实际使用）</p>
</li>
<li><p><strong>key</strong></p>
</li>
<li><ul>
<li>实际使用的索引，如果为NULL，则没有使用索引</li>
<li><strong>查询中若使用了覆盖索引，则该索引和查询的 select 字段重叠，仅出现在key列表中</strong></li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539958-bcf79915-a194-4c29-9bb0-f8a828626624.webp" alt="image">explain-key</p>
<ul>
<li><p><strong>key_len</strong></p>
</li>
<li><ul>
<li>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好</li>
<li>key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的</li>
</ul>
</li>
<li><p><strong>ref</strong>（显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值）</p>
</li>
<li><p><strong>rows</strong>（根据表统计信息及索引选用情况，大致估算找到所需的记录所需要读取的行数）</p>
</li>
<li><p><strong>Extra</strong>（包含不适合在其他列中显示但十分重要的额外信息）</p>
</li>
</ul>
<ol>
<li><ol>
<li>using filesort: 说明mysql会对数据使用一个外部的索引排序，不是按照表内的索引顺序进行读取。mysql中无法利用索引完成的排序操作称为“文件排序”。常见于order by和group by语句中</li>
<li>Using temporary：使用了临时表保存中间结果，mysql在对查询结果排序时使用临时表。常见于排序order by和分组查询group by。</li>
<li>using index：表示相应的select操作中使用了覆盖索引，避免访问了表的数据行，效率不错，如果同时出现using where，表明索引被用来执行索引键值的查找；否则索引被用来读取数据而非执行查找操作</li>
<li>using where：使用了where过滤</li>
<li>using join buffer：使用了连接缓存</li>
<li>impossible where：where子句的值总是false，不能用来获取任何元祖</li>
<li>select tables optimized away：在没有group by子句的情况下，基于索引优化操作或对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化</li>
<li>distinct：优化distinct操作，在找到第一匹配的元祖后即停止找同样值的动作</li>
</ol>
</li>
</ol>
<p><strong>case</strong>:</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539975-a8ae7858-047b-4816-a2d7-c5b3cab09fab.webp" alt="image">explain-demo</p>
<ol>
<li>第一行（执行顺序4）：id列为1，表示是union里的第一个select，select_type列的primary表示该查询为外层查询，table列被标记为，表示查询结果来自一个衍生表，其中derived3中3代表该查询衍生自第三个select查询，即id为3的select。【select d1.name……】</li>
<li>第二行（执行顺序2）：id为3，是整个查询中第三个select的一部分。因查询包含在from中，所以为derived。【select id,name from t1 where other_column=’’】</li>
<li>第三行（执行顺序3）：select列表中的子查询select_type为subquery，为整个查询中的第二个select。【select id from t3】</li>
<li>第四行（执行顺序1）：select_type为union，说明第四个select是union里的第二个select，最先执行【select name,id from t2】</li>
<li>第五行（执行顺序5）：代表从union的临时表中读取行的阶段，table列的&lt;union1,4&gt;表示用第一个和第四个select的结果进行union操作。【两个结果union操作】</li>
</ol>
<h5 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h5><p>MySQL 的慢查询日志是 MySQL 提供的一种日志记录，它用来记录在 MySQL 中响应时间超过阈值的语句，具体指运行时间超过 <code>long_query_time</code> 值的 SQL，则会被记录到慢查询日志中。</p>
<ul>
<li><code>long_query_time</code> 的默认值为10，意思是运行10秒以上的语句</li>
<li>默认情况下，MySQL数据库没有开启慢查询日志，需要手动设置参数开启</li>
</ul>
<p><strong>查看开启状态</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">&#x27;%slow_query_log%&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>开启慢查询日志</strong></p>
<ul>
<li>临时配置：</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="builtin-name">set</span> global <span class="attribute">slow_query_log</span>=<span class="string">&#x27;ON&#x27;</span>;</span><br><span class="line">mysql&gt; <span class="builtin-name">set</span> global <span class="attribute">slow_query_log_file</span>=<span class="string">&#x27;/var/lib/mysql/hostname-slow.log&#x27;</span>;</span><br><span class="line">mysql&gt; <span class="builtin-name">set</span> global <span class="attribute">long_query_time</span>=2;</span><br></pre></td></tr></table></figure>

<p>也可set文件位置，系统会默认给一个缺省文件host_name-slow.log</p>
<p>使用set操作开启慢查询日志只对当前数据库生效，如果MySQL重启则会失效。</p>
<ul>
<li>永久配置<br>修改配置文件my.cnf或my.ini，在[mysqld]一行下面加入两个配置参数</li>
</ul>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">slow_query_log</span> = <span class="literal">ON</span></span><br><span class="line"><span class="attr">slow_query_log_file</span> = /var/lib/mysql/hostname-slow.log</span><br><span class="line"><span class="attr">long_query_time</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>注：log-slow-queries 参数为慢查询日志存放的位置，一般这个目录要有 MySQL 的运行帐号的可写权限，一般都将这个目录设置为 MySQL 的数据存放目录；long_query_time=2 中的 2 表示查询超过两秒才记录；在my.cnf或者 my.ini 中添加 log-queries-not-using-indexes 参数，表示记录下没有使用索引的查询。</p>
<p>可以用 <code>select sleep(4)</code> 验证是否成功开启。</p>
<p>在生产环境中，如果手工分析日志，查找、分析SQL，还是比较费劲的，所以MySQL提供了日志分析工具<strong>mysqldumpslow</strong>。</p>
<p>通过 mysqldumpslow –help 查看操作帮助信息</p>
<ul>
<li>得到返回记录集最多的10个SQL<br><code>mysqldumpslow -s r -t 10 /var/lib/mysql/hostname-slow.log</code></li>
<li>得到访问次数最多的10个SQL<br><code>mysqldumpslow -s c -t 10 /var/lib/mysql/hostname-slow.log</code></li>
<li>得到按照时间排序的前10条里面含有左连接的查询语句<br><code>mysqldumpslow -s t -t 10 -g &quot;left join&quot; /var/lib/mysql/hostname-slow.log</code></li>
<li>也可以和管道配合使用<br><code>mysqldumpslow -s r -t 10 /var/lib/mysql/hostname-slow.log | more</code></li>
</ul>
<p><strong>也可使用 pt-query-digest 分析 RDS MySQL 慢查询日志</strong></p>
<h5 id="Show-Profile-分析查询"><a href="#Show-Profile-分析查询" class="headerlink" title="Show Profile 分析查询"></a>Show Profile 分析查询</h5><p>通过慢日志查询可以知道哪些 SQL 语句执行效率低下，通过 explain 我们可以得知 SQL 语句的具体执行情况，索引使用等，还可以结合<code>Show Profile</code>命令查看执行状态。</p>
<ul>
<li><p>Show Profile 是 MySQL 提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于SQL的调优的测量</p>
</li>
<li><p>默认情况下，参数处于关闭状态，并保存最近15次的运行结果</p>
</li>
<li><p>分析步骤<br>mysql&gt; show profiles; +———-+————+———————————+ | Query_ID | Duration  | Query              | +———-+————+———————————+ |     1 | 0.00385450 | show variables like “profiling” | |     2 | 0.00170050 | show variables like “profiling” | |     3 | 0.00038025 | select * from t_base_user    | +———-+————+———————————+</p>
</li>
<li><ul>
<li>converting HEAP to MyISAM 查询结果太大，内存都不够用了往磁盘上搬了。</li>
<li>create tmp table 创建临时表，这个要注意</li>
<li>Copying to tmp table on disk  把内存临时表复制到磁盘</li>
<li>locked</li>
</ul>
</li>
</ul>
<ol>
<li><ol>
<li>诊断SQL，show profile cpu,block io for query  id(上一步前面的问题SQL数字号码)</li>
<li>日常开发需要注意的结论</li>
<li>是否支持，看看当前的mysql版本是否支持</li>
</ol>
</li>
</ol>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;Show  <span class="keyword">variables</span> like <span class="comment">&#x27;profiling&#x27;</span>;  --默认是关闭，使用前需要开启</span><br></pre></td></tr></table></figure>

<ol>
<li><ol>
<li>开启功能，默认是关闭，使用前需要开启</li>
</ol>
</li>
</ol>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;<span class="builtin-name">set</span> <span class="attribute">profiling</span>=1;</span><br></pre></td></tr></table></figure>

<ol>
<li><ol>
<li>运行SQL</li>
<li>查看结果</li>
</ol>
</li>
</ol>
<blockquote>
<p>❝查询中哪些情况不会使用索引？</p>
</blockquote>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><h4 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h4><ol>
<li>全值匹配我最爱</li>
<li>最佳左前缀法则，比如建立了一个联合索引(a,b,c)，那么其实我们可利用的索引就有(a), (a,b), (a,b,c)</li>
<li>不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描</li>
<li>存储引擎不能使用索引中范围条件右边的列</li>
<li>尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致))，减少select</li>
<li>is null ,is not null 也无法使用索引</li>
<li>like “xxxx%” 是可以用到索引的，like “%xxxx” 则不行(like “%xxx%” 同理)。like以通配符开头(‘%abc…’)索引失效会变成全表扫描的操作，</li>
<li>字符串不加单引号索引失效</li>
<li>少用or，用它来连接时会索引失效</li>
<li>&lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN 可用到索引，&lt;&gt;，not in ，!= 则不行，会导致全表扫描</li>
</ol>
<p><strong>一般性建议</strong></p>
<ul>
<li>对于单键索引，尽量选择针对当前query过滤性更好的索引</li>
<li>在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。</li>
<li>在选择组合索引的时候，尽量选择可以能够包含当前query中的where字句中更多字段的索引</li>
<li>尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的</li>
<li>少用Hint强制索引</li>
</ul>
<h4 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h4><p><strong>永远小表驱动大表（小的数据集驱动大的数据集）</strong></p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slect * <span class="keyword">from</span> A <span class="keyword">where</span> <span class="built_in">id</span> <span class="keyword">in</span> (select <span class="built_in">id</span> <span class="keyword">from</span> B)`等价于</span><br><span class="line"><span class="comment">#等价于</span></span><br><span class="line">select <span class="built_in">id</span> <span class="keyword">from</span> B</span><br><span class="line">select * <span class="keyword">from</span> A <span class="keyword">where</span> A.<span class="built_in">id</span>=B.<span class="built_in">id</span></span><br></pre></td></tr></table></figure>

<p>当 B 表的数据集必须小于 A 表的数据集时，用 in 优于 exists</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> B <span class="keyword">where</span> B.id=A.id)</span><br><span class="line"><span class="comment">#等价于</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> B <span class="keyword">where</span> B.id = A.id<span class="string">`</span></span><br></pre></td></tr></table></figure>

<p>当 A 表的数据集小于B表的数据集时，用 exists优于用 in</p>
<p>注意：A表与B表的ID字段应建立索引。</p>
<p><strong>order by关键字优化</strong></p>
<ul>
<li><p>order by子句，尽量使用 Index 方式排序，避免使用 FileSort 方式排序</p>
</li>
<li><p>MySQL 支持两种方式的排序，FileSort 和 Index，Index效率高，它指 MySQL 扫描索引本身完成排序，FileSort 效率较低；</p>
</li>
<li><p>ORDER BY 满足两种情况，会使用Index方式排序；①ORDER BY语句使用索引最左前列 ②使用where子句与ORDER BY子句条件列组合满足索引最左前列</p>
</li>
<li><p>尽可能在索引列上完成排序操作，遵照索引建的最佳最前缀</p>
</li>
<li><p>如果不在索引列上，filesort 有两种算法，mysql就要启动双路排序和单路排序</p>
</li>
<li><ul>
<li>双路排序：MySQL 4.1之前是使用双路排序,字面意思就是两次扫描磁盘，最终得到数据</li>
<li>单路排序：从磁盘读取查询需要的所有列，按照order by 列在 buffer对它们进行排序，然后扫描排序后的列表进行输出，效率高于双路排序</li>
</ul>
</li>
<li><p>优化策略</p>
</li>
<li><ul>
<li>增大sort_buffer_size参数的设置</li>
<li>增大max_lencth_for_sort_data参数的设置</li>
</ul>
</li>
</ul>
<p><strong>GROUP BY关键字优化</strong></p>
<ul>
<li>group by实质是先排序后进行分组，遵照索引建的最佳左前缀</li>
<li>当无法使用索引列，增大 <code>max_length_for_sort_data</code> 参数的设置，增大<code>sort_buffer_size</code>参数的设置</li>
<li>where高于having，能写在where限定的条件就不要去having限定了</li>
</ul>
<h4 id="数据类型优化"><a href="#数据类型优化" class="headerlink" title="数据类型优化"></a>数据类型优化</h4><p>MySQL 支持的数据类型非常多，选择正确的数据类型对于获取高性能至关重要。不管存储哪种类型的数据，下面几个简单的原则都有助于做出更好的选择。</p>
<ul>
<li>更小的通常更好：一般情况下，应该尽量使用可以正确存储数据的最小数据类型。<br>简单就好：简单的数据类型通常需要更少的CPU周期。例如，整数比字符操作代价更低，因为字符集和校对规则（排序规则）使字符比较比整型比较复杂。</li>
<li>尽量避免NULL：通常情况下最好指定列为NOT NULL</li>
</ul>
<h2 id="九、分区、分表、分库"><a href="#九、分区、分表、分库" class="headerlink" title="九、分区、分表、分库"></a>九、分区、分表、分库</h2><h3 id="MySQL分区"><a href="#MySQL分区" class="headerlink" title="MySQL分区"></a>MySQL分区</h3><p>一般情况下我们创建的表对应一组存储文件，使用<code>MyISAM</code>存储引擎时是一个<code>.MYI</code>和<code>.MYD</code>文件，使用<code>Innodb</code>存储引擎时是一个<code>.ibd</code>和<code>.frm</code>（表结构）文件。</p>
<p>当数据量较大时（一般千万条记录级别以上），MySQL的性能就会开始下降，这时我们就需要将数据分散到多组存储文件，保证其单个文件的执行效率</p>
<p><strong>能干嘛</strong></p>
<ul>
<li>逻辑数据分割</li>
<li>提高单一的写和读应用速度</li>
<li>提高分区范围读查询的速度</li>
<li>分割数据能够有多个不同的物理文件路径</li>
<li>高效的保存历史数据</li>
</ul>
<p><strong>怎么玩</strong></p>
<p>首先查看当前数据库是否支持分区</p>
<ul>
<li>MySQL5.6以及之前版本：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">&#x27;%partition%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>MySQL5.6：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> plugins;</span><br></pre></td></tr></table></figure>

<p><strong>分区类型及操作</strong></p>
<ul>
<li><strong>RANGE分区</strong>：基于属于一个给定连续区间的列值，把多行分配给分区。mysql将会根据指定的拆分策略，,把数据放在不同的表文件上。相当于在文件上,被拆成了小块.但是,对外给客户的感觉还是一张表，透明的。<br>按照 range 来分，就是每个库一段连续的数据，这个一般是按比如<strong>时间范围</strong>来的，比如交易表啊，销售表啊等，可以根据年月来存放数据。可能会产生热点问题，大量的流量都打在最新的数据上了。<br>range 来分，好处在于说，扩容的时候很简单。</li>
<li><strong>LIST分区</strong>：类似于按RANGE分区，每个分区必须明确定义。它们的主要区别在于，LIST分区中每个分区的定义和选择是基于某列的值从属于一个值列表集中的一个值，而RANGE分区是从属于一个连续区间值的集合。</li>
<li><strong>HASH分区</strong>：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL 中有效的、产生非负整数值的任何表达式。<br>hash 分发，好处在于说，可以平均分配每个库的数据量和请求压力；坏处在于说扩容起来比较麻烦，会有一个数据迁移的过程，之前的数据需要重新计算 hash 值重新分配到不同的库或表</li>
<li><strong>KEY分区</strong>：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL服务器提供其自身的哈希函数。必须有一列或多列包含整数值。</li>
</ul>
<p><strong>看上去分区表很帅气，为什么大部分互联网还是更多的选择自己分库分表来水平扩展咧？</strong></p>
<ul>
<li>分区表，分区键设计不太灵活，如果不走分区键，很容易出现全表锁</li>
<li>一旦数据并发量上来，如果在分区表实施关联，就是一个灾难</li>
<li>自己分库分表，自己掌控业务场景与访问模式，可控。分区表，研发写了一个sql，都不确定mysql是怎么玩的，不太可控</li>
</ul>
<blockquote>
<p>❝</p>
<p>随着业务的发展，业务越来越复杂，应用的模块越来越多，总的数据量很大，高并发读写操作均超过单个数据库服务器的处理能力怎么办？</p>
</blockquote>
<p>这个时候就出现了<strong>数据分片</strong>，数据分片指按照某个维度将存放在单一数据库中的数据分散地存放至多个数据库或表中。数据分片的有效手段就是对关系型数据库进行分库和分表。</p>
<p>区别于分区的是，分区一般都是放在单机里的，用的比较多的是时间范围分区，方便归档。只不过分库分表需要代码实现，分区则是mysql内部实现。分库分表和分区并不冲突，可以结合使用。</p>
<blockquote>
<p>❝</p>
<p>说说分库与分表的设计</p>
</blockquote>
<h3 id="MySQL分表"><a href="#MySQL分表" class="headerlink" title="MySQL分表"></a>MySQL分表</h3><p>分表有两种分割方式，一种垂直拆分，另一种水平拆分。</p>
<ul>
<li><p><strong>垂直拆分</strong><br>垂直分表，通常是按照业务功能的使用频次，把主要的、热门的字段放在一起做为主要表。然后把不常用的，按照各自的业务属性进行聚集，拆分到不同的次要表中；主要表和次要表的关系一般都是一对一的。</p>
</li>
<li><p><strong>水平拆分(数据分片)</strong><br>单表的容量不超过500W，否则建议水平拆分。是把一个表复制成同样表结构的不同表，然后把数据按照一定的规则划分，分别存储到这些表中，从而保证单表的容量不会太大，提升性能；当然这些结构一样的表，可以放在一个或多个数据库中。<br>水平分割的几种方法：</p>
</li>
<li><ul>
<li>使用MD5哈希，做法是对UID进行md5加密，然后取前几位（我们这里取前两位），然后就可以将不同的UID哈希到不同的用户表（user_xx）中了。</li>
<li>还可根据时间放入不同的表，比如：article_201601，article_201602。</li>
<li>按热度拆分，高点击率的词条生成各自的一张表，低热度的词条都放在一张大表里，待低热度的词条达到一定的贴数后，再把低热度的表单独拆分成一张表。</li>
<li>根据ID的值放入对应的表，第一个表user_0000，第二个100万的用户数据放在第二 个表user_0001中，随用户增加，直接添加用户表就行了。</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539957-9e85fd78-eebe-4644-a408-80ff3dfc87cd.webp?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<h3 id="MySQL分库"><a href="#MySQL分库" class="headerlink" title="MySQL分库"></a>MySQL分库</h3><blockquote>
<p>❝为什么要分库?</p>
</blockquote>
<p>数据库集群环境后都是多台 slave，基本满足了读取操作;  但是写入或者说大数据、频繁的写入操作对master性能影响就比较大，这个时候，单库并不能解决大规模并发写入的问题，所以就会考虑分库。</p>
<blockquote>
<p>❝分库是什么？</p>
</blockquote>
<p>一个库里表太多了，导致了海量数据，系统性能下降，把原本存储于一个库的表拆分存储到多个库上， 通常是将表按照功能模块、关系密切程度划分出来，部署到不同库上。</p>
<p>优点：</p>
<ul>
<li>减少增量数据写入时的锁对查询的影响</li>
<li>由于单表数量下降，常见的查询操作由于减少了需要扫描的记录，使得单表单次查询所需的检索行数变少，减少了磁盘IO，时延变短</li>
</ul>
<p>但是它无法解决单表数据量太大的问题</p>
<p><strong>分库分表后的难题</strong></p>
<p>分布式事务的问题，数据的完整性和一致性问题。</p>
<p>数据操作维度问题：用户、交易、订单各个不同的维度，用户查询维度、产品数据分析维度的不同对比分析角度。跨库联合查询的问题，可能需要两次查询 跨节点的count、order by、group by以及聚合函数问题，可能需要分别在各个节点上得到结果后在应用程序端进行合并 额外的数据管理负担，如：访问数据表的导航定位 额外的数据运算压力，如：需要在多个节点执行，然后再合并计算程序编码开发难度提升，没有太好的框架解决，更多依赖业务看如何分，如何合，是个难题。</p>
<blockquote>
<p>❝配主从，正经公司的话，也不会让 Javaer 去搞的，但还是要知道</p>
</blockquote>
<h2 id="十、主从复制"><a href="#十、主从复制" class="headerlink" title="十、主从复制"></a>十、主从复制</h2><h3 id="复制的基本原理"><a href="#复制的基本原理" class="headerlink" title="复制的基本原理"></a>复制的基本原理</h3><ul>
<li>slave 会从 master 读取 binlog 来进行数据同步</li>
<li>三个步骤<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590540019-3b79bd00-05a5-47a9-a4bb-c594e451c33c.webp?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image">img</li>
</ul>
<ol>
<li><ol>
<li>master将改变记录到二进制日志（binary log）。这些记录过程叫做二进制日志事件，binary log events；</li>
<li>salve 将 master 的 binary log events 拷贝到它的中继日志（relay log）;</li>
<li>slave 重做中继日志中的事件，将改变应用到自己的数据库中。MySQL 复制是异步且是串行化的。</li>
</ol>
</li>
</ol>
<h3 id="复制的基本原则"><a href="#复制的基本原则" class="headerlink" title="复制的基本原则"></a>复制的基本原则</h3><ul>
<li>每个 slave只有一个 master</li>
<li>每个 salve只能有一个唯一的服务器 ID</li>
<li>每个master可以有多个salve</li>
</ul>
<h3 id="复制的最大问题"><a href="#复制的最大问题" class="headerlink" title="复制的最大问题"></a>复制的最大问题</h3><ul>
<li>延时</li>
</ul>
<h2 id="十一、其他问题"><a href="#十一、其他问题" class="headerlink" title="十一、其他问题"></a>十一、其他问题</h2><h3 id="说一说三个范式"><a href="#说一说三个范式" class="headerlink" title="说一说三个范式"></a>说一说三个范式</h3><ul>
<li>第一范式（1NF）：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。</li>
<li>第二范式（2NF）：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。</li>
<li>第三范式（3NF）：在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。所谓传递函数依赖，指的是如 果存在”A → B → C”的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系：关键字段 → 非关键字段 x → 非关键字段y</li>
</ul>
<h3 id="百万级别或以上的数据如何删除"><a href="#百万级别或以上的数据如何删除" class="headerlink" title="百万级别或以上的数据如何删除"></a>百万级别或以上的数据如何删除</h3><p>关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。</p>
<ol>
<li>所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）</li>
<li>然后删除其中无用数据（此过程需要不到两分钟）</li>
<li>删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。</li>
<li>与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">X_ray</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://xray1025.github.io/2020/10/13/0000.%E6%95%B0%E6%8D%AE%E5%BA%93/">https://xray1025.github.io/2020/10/13/0000.%E6%95%B0%E6%8D%AE%E5%BA%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://xray1025.github.io" target="_blank">X_ray's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/10/14/0000.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">计算机网络</div></div></a></div><div class="next-post pull-right"><a href="/2020/10/12/0220.%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A03/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">0220.存在重复元素3</div></div></a></div></nav></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/null" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">X_ray</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">104</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL"><span class="toc-number">1.</span> <span class="toc-text">MySQL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81MySQL%E6%9E%B6%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">一、MySQL架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81MySQL-%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.2.</span> <span class="toc-text">二、MySQL 事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ACID-%E2%80%94-%E4%BA%8B%E5%8A%A1%E5%9F%BA%E6%9C%AC%E8%A6%81%E7%B4%A0"><span class="toc-number">1.2.1.</span> <span class="toc-text">ACID — 事务基本要素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">1.2.2.</span> <span class="toc-text">事务隔离级别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%AF%94%E8%BE%83"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">隔离级别比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVCC-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-number">1.2.3.</span> <span class="toc-text">MVCC 多版本并发控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97"><span class="toc-number">1.2.4.</span> <span class="toc-text">InnoDB事务日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.5.</span> <span class="toc-text">事务的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%86%99%E5%85%A5%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.6.</span> <span class="toc-text">事务的写入过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E5%AF%B9%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%94%AF%E6%8C%81"><span class="toc-number">1.2.7.</span> <span class="toc-text">MySQL对分布式事务的支持</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81MySQL%E9%94%81%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.</span> <span class="toc-text">三、MySQL锁机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.3.1.</span> <span class="toc-text">锁的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyISAM-%E8%A1%A8%E9%94%81"><span class="toc-number">1.3.2.</span> <span class="toc-text">MyISAM 表锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB-%E8%A1%8C%E9%94%81"><span class="toc-number">1.3.3.</span> <span class="toc-text">InnoDB 行锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E9%94%81%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">加锁机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">锁模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">读取方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%AE%BF%E9%97%AE%E4%B8%8E%E5%8A%A0%E9%94%81%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.3.5.</span> <span class="toc-text">索引访问与加锁方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">1.3.4.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#with-nolock-%EF%BC%88SQL-Server%EF%BC%89"><span class="toc-number">1.3.5.</span> <span class="toc-text">with(nolock)（SQL Server）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">1.4.</span> <span class="toc-text">四、存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">1.4.1.</span> <span class="toc-text">查看存储引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">1.4.2.</span> <span class="toc-text">设置存储引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%AF%B9%E6%AF%94"><span class="toc-number">1.4.3.</span> <span class="toc-text">存储引擎对比</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">文件存储结构对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MyISAM%E5%92%8CInnoDB%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">MyISAM和InnoDB区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.5.</span> <span class="toc-text">五、数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.5.1.</span> <span class="toc-text">MySQL的数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8C%83%E5%BC%8F%E4%B8%8E%E5%8F%8D%E8%8C%83%E5%BC%8F"><span class="toc-number">1.5.2.</span> <span class="toc-text">范式与反范式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E8%8C%83%E5%BC%8F%E5%8C%96%E5%92%8C%E5%8F%8D%E8%8C%83%E5%BC%8F%E5%8C%96"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">混合范式化和反范式化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E8%A1%A8%E5%92%8C%E6%B1%87%E6%80%BB%E8%A1%A8"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">缓存表和汇总表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E7%B4%A2%E5%BC%95"><span class="toc-number">1.6.</span> <span class="toc-text">六、索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">1.6.1.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">1.6.2.</span> <span class="toc-text">索引的优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8A%A3%E5%8A%BF"><span class="toc-number">1.6.3.</span> <span class="toc-text">索引的劣势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB"><span class="toc-number">1.6.4.</span> <span class="toc-text">MySQL索引分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%A7%92%E5%BA%A6"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">数据结构角度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E7%89%A9%E7%90%86%E5%AD%98%E5%82%A8%E8%A7%92%E5%BA%A6"><span class="toc-number">1.6.4.2.</span> <span class="toc-text">从物理存储角度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E9%80%BB%E8%BE%91%E8%A7%92%E5%BA%A6"><span class="toc-number">1.6.4.3.</span> <span class="toc-text">从逻辑角度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.5.</span> <span class="toc-text">MySQL索引结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#B-Tree%E7%B4%A2%E5%BC%95"><span class="toc-number">1.6.5.1.</span> <span class="toc-text">B+Tree索引</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#B-Tree"><span class="toc-number">1.6.5.1.1.</span> <span class="toc-text">B-Tree</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-Tree-1"><span class="toc-number">1.6.5.1.2.</span> <span class="toc-text">B+Tree</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#MyISAM%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E4%B8%8E%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.5.1.3.</span> <span class="toc-text">MyISAM主键索引与二级索引的结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#InnoDB%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E4%B8%8E%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.5.1.4.</span> <span class="toc-text">InnoDB主键索引与二级索引的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%EF%BC%9A"><span class="toc-number">1.6.5.1.4.1.</span> <span class="toc-text">主键索引：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%EF%BC%88%E9%9D%9E%E4%B8%BB%E9%94%AE%EF%BC%89%E7%B4%A2%E5%BC%95%EF%BC%9A"><span class="toc-number">1.6.5.1.4.2.</span> <span class="toc-text">二级（非主键）索引：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#InnoDB-%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9"><span class="toc-number">1.6.5.1.5.</span> <span class="toc-text">InnoDB 索引结构需要注意的点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hash%E7%B4%A2%E5%BC%95"><span class="toc-number">1.6.5.2.</span> <span class="toc-text">Hash索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#full-text%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95"><span class="toc-number">1.6.5.3.</span> <span class="toc-text">full-text全文索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#R-Tree%E7%A9%BA%E9%97%B4%E7%B4%A2%E5%BC%95"><span class="toc-number">1.6.5.4.</span> <span class="toc-text">R-Tree空间索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E9%9C%80%E8%A6%81%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">1.6.6.</span> <span class="toc-text">哪些情况需要创建索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8D%E8%A6%81%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">1.6.7.</span> <span class="toc-text">哪些情况不要创建索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E6%80%A7%E8%83%BD%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">1.6.8.</span> <span class="toc-text">高性能创建索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95"><span class="toc-number">1.6.8.1.</span> <span class="toc-text">列前缀索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E4%B8%AD%E7%B4%A2%E5%BC%95%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.6.8.2.</span> <span class="toc-text">联合索引中索引顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">1.6.8.3.</span> <span class="toc-text">覆盖索引</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81MySQL%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.7.</span> <span class="toc-text">七、MySQL查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%85%A2%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.7.1.</span> <span class="toc-text">优化慢查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%95%88%E6%9E%9C%E4%B8%8E%E4%BC%98%E5%8C%96"><span class="toc-number">1.7.2.</span> <span class="toc-text">索引效果与优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E6%9E%84%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.7.3.</span> <span class="toc-text">重构查询的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E5%88%86%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">切分查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E8%A7%A3%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.7.3.2.</span> <span class="toc-text">分解关联查询</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C%E7%9A%84%E5%9F%BA%E7%A1%80"><span class="toc-number">1.7.4.</span> <span class="toc-text">查询执行的基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="toc-number">1.7.4.1.</span> <span class="toc-text">查询缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%A4%84%E7%90%86"><span class="toc-number">1.7.4.2.</span> <span class="toc-text">查询优化处理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E8%A7%A3%E6%9E%90%E5%99%A8%E5%92%8C%E9%A2%84%E5%A4%84%E7%90%86"><span class="toc-number">1.7.4.2.1.</span> <span class="toc-text">语法解析器和预处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8"><span class="toc-number">1.7.4.2.2.</span> <span class="toc-text">查询优化器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%92%8C%E7%B4%A2%E5%BC%95%E7%9A%84%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF"><span class="toc-number">1.7.4.2.3.</span> <span class="toc-text">数据和索引的统计信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.7.4.2.4.</span> <span class="toc-text">如何执行关联查询</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8"><span class="toc-number">1.7.4.2.5.</span> <span class="toc-text">关联查询优化器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96"><span class="toc-number">1.7.4.2.6.</span> <span class="toc-text">排序优化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92"><span class="toc-number">1.7.4.3.</span> <span class="toc-text">查询执行计划</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E7%BB%99%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">1.7.4.4.</span> <span class="toc-text">返回结果给客户端</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%A0%E4%B8%AA%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.7.5.</span> <span class="toc-text">几个查询语句的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#count-%E5%92%8Ccount-%E5%88%97%E5%90%8D-%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.7.5.0.1.</span> <span class="toc-text">count(*)和count(列名)查询</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#in%E5%92%8C-exists-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.7.5.0.2.</span> <span class="toc-text">in和 exists 的区别？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#UNION%E5%92%8CUNION-ALL%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.7.5.0.3.</span> <span class="toc-text">UNION和UNION ALL的区别?</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.7.6.</span> <span class="toc-text">SQL执行顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Join%E5%9B%BE"><span class="toc-number">1.7.7.</span> <span class="toc-text">Join图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81MySQL%E8%B0%83%E4%BC%98"><span class="toc-number">1.8.</span> <span class="toc-text">八、MySQL调优</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%B1%E5%93%8Dmysql%E7%9A%84%E6%80%A7%E8%83%BD%E5%9B%A0%E7%B4%A0"><span class="toc-number">1.8.1.</span> <span class="toc-text">影响mysql的性能因素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">1.8.2.</span> <span class="toc-text">性能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL-Query-Optimizer"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">MySQL Query Optimizer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL%E5%B8%B8%E8%A7%81%E7%93%B6%E9%A2%88"><span class="toc-number">1.8.2.2.</span> <span class="toc-text">MySQL常见瓶颈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%B8%8B%E9%99%8DSQL%E6%85%A2-%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E9%95%BF-%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4%E9%95%BF-%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90"><span class="toc-number">1.8.2.3.</span> <span class="toc-text">性能下降SQL慢 执行时间长 等待时间长 原因分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL%E5%B8%B8%E8%A7%81%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%89%8B%E6%AE%B5"><span class="toc-number">1.8.2.4.</span> <span class="toc-text">MySQL常见性能分析手段</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88%E5%AE%9A%E4%BD%8D"><span class="toc-number">1.8.2.4.1.</span> <span class="toc-text">性能瓶颈定位</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Explain-%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92"><span class="toc-number">1.8.2.4.2.</span> <span class="toc-text">Explain(执行计划)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-number">1.8.2.4.3.</span> <span class="toc-text">慢查询日志</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Show-Profile-%E5%88%86%E6%9E%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.8.2.4.4.</span> <span class="toc-text">Show Profile 分析查询</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">1.8.3.</span> <span class="toc-text">性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96"><span class="toc-number">1.8.3.1.</span> <span class="toc-text">索引优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">1.8.3.2.</span> <span class="toc-text">查询优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BC%98%E5%8C%96"><span class="toc-number">1.8.3.3.</span> <span class="toc-text">数据类型优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E5%88%86%E5%8C%BA%E3%80%81%E5%88%86%E8%A1%A8%E3%80%81%E5%88%86%E5%BA%93"><span class="toc-number">1.9.</span> <span class="toc-text">九、分区、分表、分库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E5%88%86%E5%8C%BA"><span class="toc-number">1.9.1.</span> <span class="toc-text">MySQL分区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E5%88%86%E8%A1%A8"><span class="toc-number">1.9.2.</span> <span class="toc-text">MySQL分表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E5%88%86%E5%BA%93"><span class="toc-number">1.9.3.</span> <span class="toc-text">MySQL分库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">1.10.</span> <span class="toc-text">十、主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">1.10.1.</span> <span class="toc-text">复制的基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99"><span class="toc-number">1.10.2.</span> <span class="toc-text">复制的基本原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%9A%84%E6%9C%80%E5%A4%A7%E9%97%AE%E9%A2%98"><span class="toc-number">1.10.3.</span> <span class="toc-text">复制的最大问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98"><span class="toc-number">1.11.</span> <span class="toc-text">十一、其他问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%B8%89%E4%B8%AA%E8%8C%83%E5%BC%8F"><span class="toc-number">1.11.1.</span> <span class="toc-text">说一说三个范式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BE%E4%B8%87%E7%BA%A7%E5%88%AB%E6%88%96%E4%BB%A5%E4%B8%8A%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4"><span class="toc-number">1.11.2.</span> <span class="toc-text">百万级别或以上的数据如何删除</span></a></li></ol></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2020/12/23/0000.Java%E6%BA%90%E7%A0%81/" title="JDK源码"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JDK源码"/></a><div class="content"><a class="title" href="/2020/12/23/0000.Java%E6%BA%90%E7%A0%81/" title="JDK源码">JDK源码</a><time datetime="2020-12-23T07:32:47.662Z" title="发表于 2020-12-23 15:32:47">2020-12-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/11/23/%E5%BF%AB%E9%80%9F%E7%90%86%E8%A7%A3%20volatile%20%E5%85%B3%E9%94%AE%E5%AD%97/" title="快速理解 volatile 关键字"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="快速理解 volatile 关键字"/></a><div class="content"><a class="title" href="/2020/11/23/%E5%BF%AB%E9%80%9F%E7%90%86%E8%A7%A3%20volatile%20%E5%85%B3%E9%94%AE%E5%AD%97/" title="快速理解 volatile 关键字">快速理解 volatile 关键字</a><time datetime="2020-11-23T11:11:08.654Z" title="发表于 2020-11-23 19:11:08">2020-11-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/11/12/0000.SpringBoot%E9%9D%A2%E8%AF%95%E9%A2%98/" title="SpringBoot面试题"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringBoot面试题"/></a><div class="content"><a class="title" href="/2020/11/12/0000.SpringBoot%E9%9D%A2%E8%AF%95%E9%A2%98/" title="SpringBoot面试题">SpringBoot面试题</a><time datetime="2020-11-12T02:46:43.400Z" title="发表于 2020-11-12 10:46:43">2020-11-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/11/12/0000.%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B0%83%E4%BC%98/" title="数据库调优"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库调优"/></a><div class="content"><a class="title" href="/2020/11/12/0000.%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B0%83%E4%BC%98/" title="数据库调优">数据库调优</a><time datetime="2020-11-12T01:51:41.182Z" title="发表于 2020-11-12 09:51:41">2020-11-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/11/11/0503.%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%20II/" title="0503. 下一个更大元素 II"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="0503. 下一个更大元素 II"/></a><div class="content"><a class="title" href="/2020/11/11/0503.%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%20II/" title="0503. 下一个更大元素 II">0503. 下一个更大元素 II</a><time datetime="2020-11-11T02:17:54.572Z" title="发表于 2020-11-11 10:17:54">2020-11-11</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 By X_ray</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>