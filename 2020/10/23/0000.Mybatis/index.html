<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="X_ray">


    <meta name="subtitle" content="yesterday you said tomorrow">




<title>Mybatis | X_ray&#39;s blog</title>



    <link rel="icon" href="/image/kebi.svg">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.1.1"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Xray&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Xray&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Mybatis</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">X_ray</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">十月 23, 2020&nbsp;&nbsp;8:16:45</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Java/">Java</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><ul>
<li>Mybatis是一个orm类型的半自动框架，执行了对JDBC的封装，是一个持久层框架，它可以通过XML文件或者注解来配置原生信息，不在需要去做更多繁琐重复的过程，如创建连接，加载驱动！</li>
</ul>
<h1 id="Mybatis的优缺点"><a href="#Mybatis的优缺点" class="headerlink" title="Mybatis的优缺点"></a>Mybatis的优缺点</h1><h3 id="Mybaits的优点："><a href="#Mybaits的优点：" class="headerlink" title="Mybaits的优点："></a>Mybaits的优点：</h3><ul>
<li><p>基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用。</p>
</li>
<li><p>与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接；</p>
</li>
<li><p>很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）</p>
</li>
<li><p>能够与Spring很好的集成；</p>
</li>
<li><p>提供映射标签，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护。</p>
</li>
</ul>
<h3 id="MyBatis框架的缺点："><a href="#MyBatis框架的缺点：" class="headerlink" title="MyBatis框架的缺点："></a>MyBatis框架的缺点：</h3><ul>
<li><p>SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求。</p>
</li>
<li><p>SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</p>
</li>
</ul>
<h1 id="和-的区别是什么"><a href="#和-的区别是什么" class="headerlink" title="#{}和${}的区别是什么"></a>#{}和${}的区别是什么</h1><ul>
<li>#{}：是预编译处理。</li>
<li>${}：是字符串替换。</li>
<li>Mybatis在处理#{}时，会将sql中的#{}替换为？号，调用PreparedStatement的set方法来赋值；</li>
<li>mybatis在处理${}时，就是将${}替换成变量的值.</li>
<li>使用#{}可以有效的防止SQL注入，提高系统的安全性！</li>
</ul>
<blockquote>
<p>sql注入：</p>
</blockquote>
<h1 id="如何在在mapper中如何传递多个参数"><a href="#如何在在mapper中如何传递多个参数" class="headerlink" title="如何在在mapper中如何传递多个参数?"></a>如何在在mapper中如何传递多个参数?</h1><p>答：多个参数封装成map</p>
<blockquote>
<ol>
<li>映射文件的命名空间，SQL片段的ID，就可以调用对应的映射文件的SQL，</li>
<li>由于我们的参数超过两个，而方法只有一个Object参数收集，因此我们使用Map集合来装载我们的参数</li>
</ol>
</blockquote>
<h1 id="Mybatis全局配置文件中有哪些标签-分别代表什么意思"><a href="#Mybatis全局配置文件中有哪些标签-分别代表什么意思" class="headerlink" title="Mybatis全局配置文件中有哪些标签?分别代表什么意思?"></a>Mybatis全局配置文件中有哪些标签?分别代表什么意思?</h1><blockquote>
<p>configuration 配置<br>properties 属性:可以加载properties配置文件的信息<br>settings 设置：可以设置mybatis的全局属性<br>typeAliases 类型命名<br>typeHandlers 类型处理器<br>objectFactory 对象工厂<br>plugins 插件<br>environments 环境<br>environment 环境变量<br>transactionManager 事务管理器<br>dataSource 数据源<br>mappers 映射器</p>
</blockquote>
<h1 id="属性优化"><a href="#属性优化" class="headerlink" title="属性优化"></a>属性优化</h1><p>为符合高内聚低耦合的思想，在mybatis中属性可以采用外部引入的方式获得，方式为创建一个properties后缀的文件，然后再mybatis项目的配置文件中使用properties标签，引用外部属性</p>
<figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!--引入外部配置文件--&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;db.properties&quot;</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--使用“$&#123;&#125;”来引用--&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>与此同时也可以再properties标签中创建property标签来定义name和value值，但是当外部引入文件和内部配置文件的name值相同时，优先使用外部配置文件</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties resource=<span class="string">&quot;db.properties&quot;</span>&gt;</span><br><span class="line">       &lt;property name=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;root&quot;</span>/&gt;</span><br><span class="line">       &lt;property name=<span class="string">&quot;password&quot;</span> value=<span class="string">&quot;123456&quot;</span>/&gt;</span><br><span class="line">   &lt;/properties&gt;</span><br></pre></td></tr></table></figure>

<p>同时再mybatis中存在着标签的默认顺序，当配置文件中的标签顺序不符合规定时，会发生错误，默认顺序为<br>(properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,reflectorFactory?,plugins?,environments?,databaseIdProvider?,mappers?)”，顺序错误即报错</p>
<h1 id="别名优化"><a href="#别名优化" class="headerlink" title="别名优化"></a>别名优化</h1><p>别名优化有多种实现方式，可以通过注解的方式实现，也可以通过配置文件中的typeAliases标签中的typeAlias标签来实现，或者使用typeAliases标签中的package标签来实现</p>
<h2 id="注解的方式实现别名优化"><a href="#注解的方式实现别名优化" class="headerlink" title="注解的方式实现别名优化"></a>注解的方式实现别名优化</h2><p>定义一个实体类，然后在实体类上创建注解，使用注解：@Alias来实现<br>例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.type.Alias;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Alias(&quot;User&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span>  String name;</span><br><span class="line">    <span class="keyword">private</span>  String pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此代码便将实体类com.pojo.User类的别名定义为User，在mybatis中访问时只需要使用User即可访问该实体类</p>
<h2 id="typeAliases标签的子标签package来实现"><a href="#typeAliases标签的子标签package来实现" class="headerlink" title="typeAliases标签的子标签package来实现"></a>typeAliases标签的子标签package来实现</h2><p>指定一个包名，MyBatis 会在包名下面搜索需要的 Java实体类。适合实体类比较多时使用，无法自定义名称，使用时默认名称为这个类类名的首字母小写，官方建议是小写字母，但大写也是可行的</p>
<h2 id="typeAliases标签的子标签typeAlias来实现"><a href="#typeAliases标签的子标签typeAlias来实现" class="headerlink" title="typeAliases标签的子标签typeAlias来实现"></a>typeAliases标签的子标签typeAlias来实现</h2><p>适合实体类比较少时使用，可以自定义名称,例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;typeAlias type=<span class="string">&quot;com.pojo.User&quot;</span> alias=<span class="string">&quot;User&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<h1 id="映射器（mappers）"><a href="#映射器（mappers）" class="headerlink" title="映射器（mappers）"></a>映射器（mappers）</h1><p>既然 MyBatis 的行为已经由上述元素配置完了，我们现在就要来定义 SQL 映射语句了。 但首先，我们需要告诉 MyBatis 到哪里去找到这些语句。 在自动查找资源方面，Java 并没有提供一个很好的解决方案，所以最好的办法是直接告诉 MyBatis 到哪里去找映射文件。 你可以使用相对于类路径的资源引用，或完全限定资源定位符（包括 <code>file:///</code> 形式的 URL），或类名和包名等。例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 使用相对于类路径的资源引用 --&gt;</span><br><span class="line">&lt;mappers&gt;</span><br><span class="line">  &lt;mapper resource=<span class="string">&quot;org/mybatis/builder/AuthorMapper.xml&quot;</span>/&gt;</span><br><span class="line">  &lt;mapper resource=<span class="string">&quot;org/mybatis/builder/BlogMapper.xml&quot;</span>/&gt;</span><br><span class="line">  &lt;mapper resource=<span class="string">&quot;org/mybatis/builder/PostMapper.xml&quot;</span>/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 使用完全限定资源定位符（URL） --&gt;</span><br><span class="line">&lt;mappers&gt;</span><br><span class="line">  &lt;mapper url=<span class="string">&quot;file:///var/mappers/AuthorMapper.xml&quot;</span>/&gt;</span><br><span class="line">  &lt;mapper url=<span class="string">&quot;file:///var/mappers/BlogMapper.xml&quot;</span>/&gt;</span><br><span class="line">  &lt;mapper url=<span class="string">&quot;file:///var/mappers/PostMapper.xml&quot;</span>/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;</span><br><span class="line">&lt;mappers&gt;</span><br><span class="line">  &lt;mapper <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.mybatis.builder.AuthorMapper&quot;</span>/&gt;</span><br><span class="line">  &lt;mapper <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.mybatis.builder.BlogMapper&quot;</span>/&gt;</span><br><span class="line">  &lt;mapper <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.mybatis.builder.PostMapper&quot;</span>/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;</span><br><span class="line">&lt;mappers&gt;</span><br><span class="line">  &lt;<span class="keyword">package</span> name=<span class="string">&quot;org.mybatis.builder&quot;</span>/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>方法三、四需要接口和Mapper配置文件同名，并在同一包下</li>
</ul>
<h1 id="生命周期和作用域"><a href="#生命周期和作用域" class="headerlink" title="生命周期和作用域"></a>生命周期和作用域</h1><p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201022192606.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201022192618.png" alt="img"></p>
<h4 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h4><p>这个类可以被实例化、使用和丢弃，一旦创建了 <code>SqlSessionFactory</code>，就不再需要它了。因此 <code>SqlSessionFactoryBuilder</code> 实例的最佳作用域是方法作用域（也就是局部方法变量）。你可以重用 <code>SqlSessionFactoryBuilder</code> 来创建多个 <code>SqlSessionFactory</code> 实例，但最好还是不要一直保留着它，以保证所有的 <code>XML</code> 解析资源可以被释放给更重要的事情。</p>
<h4 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h4><p><code>SqlSessionFactory</code> 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。使用<code>SqlSessionFactory</code> 的最佳实践是在应用运行期间不要重复创建多次，多次重建<code>SqlSessionFactory</code> 被视为一种代码“坏习惯”。因此<code>SqlSessionFactory</code> 的最佳作用域是应用作用域。有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。</p>
<h4 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h4><p>每个线程都应该有它自己的 <code>SqlSession</code> 实例。<code>SqlSession</code>的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。绝对不能将 <code>SqlSession</code> 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。也绝不能将 <code>SqlSession</code> 实例的引用放在任何类型的托管作用域中，比如 <code>Servlet</code> 框架中的 <code>HttpSession</code>。如果你现在正在使用一种 <code>Web</code> 框架，考虑将 <code>SqlSession</code> 放在一个和 <code>HTTP</code> 请求相似的作用域中。换句话说，每次收到 <code>HTTP</code> 请求，就可以打开一个 <code>SqlSession</code>，返回一个响应后，就关闭它。这个关闭操作很重要，为了确保每次都能执行关闭操作，你应该把这个关闭操作放到 <code>finally</code> 块中。下面的示例就是一个确保 <code>SqlSession</code> 关闭的标准模式：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (SqlSession session = sqlSessionFactory.<span class="keyword">open</span><span class="constructor">Session()</span>) &#123;</span><br><span class="line">  <span class="comment">// 你的应用逻辑代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在所有代码中都遵循这种使用模式，可以保证所有数据库资源都能被正确地关闭。</p>
<h4 id="映射器实例"><a href="#映射器实例" class="headerlink" title="映射器实例"></a>映射器实例</h4><p>映射器是一些绑定映射语句的接口。映射器接口的实例是从 <code>SqlSession</code> 中获得的。虽然从技术层面上来讲，任何映射器实例的最大作用域与请求它们的 <code>SqlSession</code> 相同。但方法作用域才是映射器实例的最合适的作用域。也就是说，映射器实例应该在调用它们的方法中被获取，使用完毕之后即可丢弃。映射器实例并不需要被显式地关闭。尽管在整个请求作用域保留映射器实例不会有什么问题，但是你很快会发现，在这个作用域上管理太多像<code>SqlSession</code> 的资源会让你忙不过来。因此，最好将映射器放在方法作用域内。就像下面的例子一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  BlogMapper mapper = session.getMapper(BlogMapper.class);</span><br><span class="line">  <span class="comment">// 你的应用逻辑代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="当实体类中的属性名和表中的字段名不一样-，怎么办-？"><a href="#当实体类中的属性名和表中的字段名不一样-，怎么办-？" class="headerlink" title="当实体类中的属性名和表中的字段名不一样 ，怎么办 ？"></a>当实体类中的属性名和表中的字段名不一样 ，怎么办 ？</h1><p>第1种：通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=”selectorder” parametertype=”int” resultetype=”me.gacl.domain.order”&gt;       </span><br><span class="line">      <span class="keyword">select</span> order_id <span class="keyword">id</span>, order_no orderno ,order_price price </span><br><span class="line">            <span class="keyword">form</span> orders </span><br><span class="line">            <span class="keyword">where</span> order_id=<span class="comment">#&#123;id&#125;;    </span></span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure>

<p>第2种：通过来映射字段名和实体类属性名的一一对应的关系。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;getOrder&quot; parameterType=&quot;int&quot; resultMap=&quot;orderresultmap&quot;&gt;</span><br><span class="line">        <span class="keyword">select</span> * <span class="keyword">from</span> orders <span class="keyword">where</span> order_id=<span class="comment">#&#123;id&#125;</span></span><br><span class="line">    &lt;/<span class="keyword">select</span>&gt;</span><br><span class="line"></span><br><span class="line">   &lt;resultMap <span class="keyword">type</span>=”me.gacl.domain.order” <span class="keyword">id</span>=”orderresultmap”&gt;</span><br><span class="line">        &lt;!–用<span class="keyword">id</span>属性来映射主键字段–&gt;</span><br><span class="line">        &lt;<span class="keyword">id</span> property=”<span class="keyword">id</span>” <span class="keyword">column</span>=”order_id”&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!–用<span class="keyword">result</span>属性来映射非主键字段，property为实体类属性名，<span class="keyword">column</span>为数据表中的属性–&gt;</span><br><span class="line">        &lt;<span class="keyword">result</span> property = “orderno” <span class="keyword">column</span> =”order_no”/&gt;</span><br><span class="line">        &lt;<span class="keyword">result</span> property=”price” <span class="keyword">column</span>=”order_price” /&gt;</span><br><span class="line">    &lt;/reslutMap&gt;</span><br></pre></td></tr></table></figure>

<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h2 id="日志工厂"><a href="#日志工厂" class="headerlink" title="日志工厂"></a>日志工厂</h2><p>如果程序出现了错误，需要排错，那么就需要用到日志。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201022192637.png" alt="在这里插入图片描述"></p>
<ul>
<li>SLF4J</li>
<li>LOG4J 【常用】</li>
<li>LOG4J2</li>
<li>JDK_LOGGING</li>
<li>COMMONS_LOGGING</li>
<li>STDOUT_LOGGING 【常用】</li>
<li>NO_LOGGING</li>
</ul>
<h2 id="STDOUT-LOGGING"><a href="#STDOUT-LOGGING" class="headerlink" title="STDOUT_LOGGING"></a>STDOUT_LOGGING</h2><p><strong>STDOUT_LOGGING标准日志输出</strong><br>标准日志，不需要其余操作，只需在mybatis核心配置文件中配置即可</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--日志--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201022192647.png" alt="在这里插入图片描述"></p>
<h2 id="Log4j"><a href="#Log4j" class="headerlink" title="Log4j"></a>Log4j</h2><ul>
<li>Log4j是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Apache/8512995">Apache</a>的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E5%8F%B0/2438626">控制台</a>、文件、<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/GUI">GUI</a>组件</li>
<li>我们也可以控制每一条日志的输出格式；</li>
<li>通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。</li>
<li>通过一个<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/286550">配置文件</a>来灵活地进行配置，而不需要修改应用的代码。</li>
</ul>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>1.导入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.编写配置文件log4j.properties</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码</span><br><span class="line">log4j.rootLogger&#x3D;DEBUG,console,file</span><br><span class="line"></span><br><span class="line">#控制台输出的相关设置</span><br><span class="line">log4j.appender.console &#x3D; org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.console.Target &#x3D; System.out</span><br><span class="line">log4j.appender.console.Threshold&#x3D;DEBUG</span><br><span class="line">log4j.appender.console.layout &#x3D; org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.console.layout.ConversionPattern&#x3D;[%c]-%m%n</span><br><span class="line"></span><br><span class="line">#文件输出的相关设置</span><br><span class="line">log4j.appender.file &#x3D; org.apache.log4j.RollingFileAppender</span><br><span class="line">log4j.appender.file.File&#x3D;.&#x2F;log&#x2F;xr.log</span><br><span class="line">log4j.appender.file.MaxFileSize&#x3D;10mb</span><br><span class="line">log4j.appender.file.Threshold&#x3D;DEBUG</span><br><span class="line">log4j.appender.file.layout&#x3D;org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.file.layout.ConversionPattern&#x3D;[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n</span><br><span class="line"></span><br><span class="line">#日志输出级别</span><br><span class="line">log4j.logger.org.mybatis&#x3D;DEBUG</span><br><span class="line">log4j.logger.java.sql&#x3D;DEBUG</span><br><span class="line">log4j.logger.java.sql.Statement&#x3D;DEBUG</span><br><span class="line">log4j.logger.java.sql.ResultSet&#x3D;DEBUG</span><br><span class="line">log4j.logger.java.sql.PreparedStatement&#x3D;DEBUG</span><br></pre></td></tr></table></figure>

<p>3.在mybatis核心配置文件中配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意顺序</p>
<p>测试<br><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201022193000.png" alt="在这里插入图片描述"></p>
<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>1.在要使用Log4j 的类中，导入包 import org.apache.log4j.Logger;<br>2.创建日志对象，参数为当前的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Logger logger = Logger.getLogger(UserDaoTest.class);</span><br></pre></td></tr></table></figure>

<p>3.使用和日志级别</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">logger.info(<span class="string">&quot;info:进入了testLog4j&quot;</span>);</span><br><span class="line">logger.debug(<span class="string">&quot;debug:进入了testLog4j&quot;</span>);</span><br><span class="line">logger.error(<span class="string">&quot;error:进入了testLog4j&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="Mybatis动态sql有什么用？执行原理？有哪些动态sql？"><a href="#Mybatis动态sql有什么用？执行原理？有哪些动态sql？" class="headerlink" title="Mybatis动态sql有什么用？执行原理？有哪些动态sql？"></a>Mybatis动态sql有什么用？执行原理？有哪些动态sql？</h1><blockquote>
<p>有九种动态sql标签：trim,where,set,foreach,if,choose,when,bind,otherwise<br>Mybatis的动态sql可以在xml映射文件内，以标签的形式编写动态sql，执行原理是根据表达式的值，完成逻辑判断并动态拼接sql的功能！</p>
<h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>使用动态 SQL 最常见情景是根据条件包含 where 子句的一部分</p>
<h3 id="choose、when、otherwise"><a href="#choose、when、otherwise" class="headerlink" title="choose、when、otherwise"></a>choose、when、otherwise</h3><p>有时候，我们不想使用所有的条件，而只是想从多个条件中选择一个使用。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。</p>
<h3 id="trim、where、set"><a href="#trim、where、set" class="headerlink" title="trim、where、set"></a>trim、where、set</h3><p><em>where</em> 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，<em>where</em> 元素也会将它们去除。</p>
<p><em>set</em> 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）。</p>
<h3 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h3><p>这个元素可以用来定义可重用的 SQL 代码片段，以便在其它语句中使用。 参数可以静态地（在加载的时候）确定下来，并且可以在不同的 include 元素中定义不同的参数值。比如：</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;sql id=<span class="string">&quot;userColumns&quot;</span>&gt; $&#123;<span class="keyword">alias</span>&#125;<span class="string">.id</span>,$&#123;<span class="keyword">alias</span>&#125;<span class="string">.username</span>,$&#123;<span class="keyword">alias</span>&#125;<span class="string">.password</span> &lt;<span class="string">/sql</span>&gt;</span><br></pre></td></tr></table></figure>

<p>这个 SQL 片段可以在其它语句中使用，例如：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">select</span> id=&quot;selectUsers&quot; resultType=&quot;map&quot;&gt;</span><br><span class="line">  <span class="keyword">select</span></span><br><span class="line">    &lt;<span class="keyword">include</span> refid=&quot;userColumns&quot;&gt;&lt;property <span class="type">name</span>=&quot;alias&quot; <span class="keyword">value</span>=&quot;t1&quot;/&gt;&lt;/<span class="keyword">include</span>&gt;,</span><br><span class="line">    &lt;<span class="keyword">include</span> refid=&quot;userColumns&quot;&gt;&lt;property <span class="type">name</span>=&quot;alias&quot; <span class="keyword">value</span>=&quot;t2&quot;/&gt;&lt;/<span class="keyword">include</span>&gt;</span><br><span class="line">  <span class="keyword">from</span> some_table t1</span><br><span class="line">    <span class="keyword">cross</span> <span class="keyword">join</span> some_table t2</span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><p>动态 SQL 的另一个常见使用场景是对集合进行遍历（尤其是在构建 IN 条件语句的时候）。比如：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">select</span> id=&quot;selectPostIn&quot; resultType=&quot;domain.blog.Post&quot;&gt;</span><br><span class="line">  <span class="keyword">SELECT</span> *</span><br><span class="line">  <span class="keyword">FROM</span> POST P</span><br><span class="line">  <span class="keyword">WHERE</span> ID <span class="keyword">in</span></span><br><span class="line">  &lt;<span class="keyword">foreach</span> item=&quot;item&quot; <span class="keyword">index</span>=&quot;index&quot; collection=&quot;list&quot;</span><br><span class="line">      <span class="keyword">open</span>=&quot;(&quot; separator=&quot;,&quot; <span class="keyword">close</span>=&quot;)&quot;&gt;</span><br><span class="line">        #&#123;item&#125;</span><br><span class="line">  &lt;/<span class="keyword">foreach</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure>

<p><em>foreach</em> 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及集合项迭代之间的分隔符。这个元素也不会错误地添加多余的分隔符</p>
</blockquote>
<h1 id="什么是Mybatis的一级、二级缓存-如何开启-什么样的数据适合缓存"><a href="#什么是Mybatis的一级、二级缓存-如何开启-什么样的数据适合缓存" class="headerlink" title="什么是Mybatis的一级、二级缓存,如何开启?什么样的数据适合缓存?"></a>什么是Mybatis的一级、二级缓存,如何开启?什么样的数据适合缓存?</h1><p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201022212413.png" alt="img"></p>
<h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><h3 id="一级缓存介绍"><a href="#一级缓存介绍" class="headerlink" title="一级缓存介绍"></a>一级缓存介绍</h3><ul>
<li><p>在应用运行过程中，我们有可能在一次数据库会话中，执行多次查询条件完全相同的SQL，MyBatis提供了一级缓存的方案优化这部分场景，如果是相同的SQL语句，会优先命中一级缓存，避免直接对数据库进行查询，提高性能。</p>
</li>
<li><p>每个SqlSession中持有了Executor，每个Executor中有一个LocalCache。当用户发起查询时，MyBatis根据当前执行的语句生成<code>MappedStatement</code>，在Local Cache进行查询，如果缓存命中的话，直接返回结果给用户，如果缓存没有命中的话，查询数据库，结果写入<code>Local Cache</code>，最后返回结果给用户。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201022213005.png" alt="img"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>MyBatis一级缓存的生命周期和SqlSession一致。</li>
<li>MyBatis一级缓存内部设计简单，只是一个没有容量限定的HashMap，在缓存的功能性上有所欠缺。</li>
<li>MyBatis的一级缓存最大范围是SqlSession内部，有多个SqlSession或者分布式的环境下，数据库写操作会引起脏数据，建议设定缓存级别为Statement。</li>
<li>会话提交或退出时，一级缓存会提交到二级缓存。</li>
</ol>
<h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><h3 id="二级缓存介绍"><a href="#二级缓存介绍" class="headerlink" title="二级缓存介绍"></a>二级缓存介绍</h3><p>在上文中提到的一级缓存中，其最大的共享范围就是一个SqlSession内部，如果多个SqlSession之间需要共享缓存，则需要使用到二级缓存。开启二级缓存后，会使用CachingExecutor装饰Executor，进入一级缓存的查询流程前，先在CachingExecutor进行二级缓存的查询，具体的工作流程如下所示。</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/28399eba.png" alt="img"></p>
<p>二级缓存开启后，同一个namespace下的所有操作语句，都影响着同一个Cache，即二级缓存被多个SqlSession共享，是一个全局的变量。</p>
<p>当开启缓存后，数据的查询执行的流程就是 二级缓存 -&gt; 一级缓存 -&gt; 数据库。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol>
<li>MyBatis的二级缓存相对于一级缓存来说，实现了<code>SqlSession</code>之间缓存数据的共享，同时粒度更加的细，能够到<code>namespace</code>级别，通过Cache接口实现类不同的组合，对Cache的可控性也更强。</li>
<li>MyBatis在多表查询时，极大可能会出现脏数据，有设计上的缺陷，安全使用二级缓存的条件比较苛刻。</li>
<li>在分布式环境下，由于默认的MyBatis Cache实现都是基于本地的，分布式环境下必然会出现读取到脏数据，需要使用集中式缓存将MyBatis的Cache接口实现，有一定的开发成本，直接使用Redis、Memcached等分布式缓存可能成本更低，安全性也更高。</li>
</ol>
<h2 id="全文总结"><a href="#全文总结" class="headerlink" title="全文总结"></a>全文总结</h2><h1 id="什么是MyBatis的接口绑定？有哪些实现方式？"><a href="#什么是MyBatis的接口绑定？有哪些实现方式？" class="headerlink" title="什么是MyBatis的接口绑定？有哪些实现方式？"></a>什么是MyBatis的接口绑定？有哪些实现方式？</h1><blockquote>
<p>接口绑定就是在mybatis中任意定义接口，然后把接口里面的方法和sql语句绑定，我们直接调用接口方法就可以，这样比起原来sqlsession提供的方法我们可以有更加灵活的选择和设置！<br>有两种实现方式：</p>
<ol>
<li>在接口的方法上面加上@select，@update等注解，里面包含sql语句来绑定</li>
<li>通过xml里面写sql语句来绑定，在这种情况下，要指定xml映射文件里面的namespace必须为接口的全路径名，当sql语句比较简单的时候，用注解绑定，当sql语句比较复杂的时候，用xml绑定，一般使用xml绑定的比较多！</li>
</ol>
</blockquote>
<h1 id="使用MyBatis的mapper接口调用时有哪些要求？"><a href="#使用MyBatis的mapper接口调用时有哪些要求？" class="headerlink" title="使用MyBatis的mapper接口调用时有哪些要求？"></a>使用MyBatis的mapper接口调用时有哪些要求？</h1><blockquote>
<p>1.接口实现类继承sqlsessionDaosupport，需要编写mapper接口，mapper接口实现类，mapper.xml文件！<br>    mapper.xml中的namespace为mapper接口的地址<br>    mapper接口中的方法名和mapper.xml中的定义的statement的id保持一致<br>    Spring中定义<br>2.使用mapper扫描器</p>
</blockquote>

        </div>

        
            <section class="post-copyright">
                
                
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>年与时驰，意与日去，遂成枯落，多不接世，悲守穷庐，将复何及</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/Mybatis/"># Mybatis</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2020/10/26/%E5%BE%AA%E7%8E%AF%E4%B8%AD%E5%88%A0%E9%99%A4Arraylist%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E5%AE%89%E5%85%A8%E5%90%97%EF%BC%9F/">循环中删除掉ArrayList中的元素安全吗？</a>
            
            
            <a class="next" rel="next" href="/2020/10/22/Mybatis%E7%9A%84%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E5%92%8C%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98/">Mybatis的一级缓存和二级缓存</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© X_ray | Powered by <a href="https://xray1025.top" target="_blank">Xray</a></span>
    </div>
</footer>

    </div>
</body>
</html>
