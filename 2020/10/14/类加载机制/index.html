<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="X_ray">


    <meta name="subtitle" content="yesterday you said tomorrow">




<title>类加载机制 | X_ray&#39;s blog</title>



    <link rel="icon" href="/image/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.1.1"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Xray&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Xray&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">类加载机制</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">X_ray</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">十月 14, 2020&nbsp;&nbsp;16:53:07</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Java/">Java</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><h2 id="类加载的优势"><a href="#类加载的优势" class="headerlink" title="类加载的优势"></a>类加载的优势</h2><ul>
<li>类的加载、连接、初始化都是在程序运行期间完成的，虽然会令类加载时稍微增加一些性能开销，但是会为Java程序提供高度的灵活性</li>
<li>例如，面向接口的应用程序可以等到运行时再指定其实际实现类。用户可以通过Java预定义/自定义类加载器在运行时从网络或其他地方加载一个二进制流作为程序代码的一部分</li>
</ul>
<h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><ul>
<li><p>类从加载到虚拟机内存开始，到卸载出内存为止，整个生命周期包括</p>
</li>
<li><ul>
<li>加载(Loading)(和类加载不一样)</li>
<li>验证(Verification)</li>
<li>准备(Preparation)</li>
<li>解析(Resolution)</li>
<li>初始化(Initialization)</li>
<li>使用(Using)</li>
<li>卸载(Unloading)</li>
<li>其中验证、准备、解析统称为连接</li>
</ul>
</li>
<li><p>类加载过程必须按照顺序按部就班的开始，但是不用按照顺序完成</p>
</li>
<li><p>解析阶段某些情况下可以在初始化阶段之后开始</p>
</li>
<li><ul>
<li>为了支持Java运行时绑定(动态绑定/晚期绑定)</li>
</ul>
</li>
<li><p>加载的时机</p>
</li>
<li><ul>
<li>什么时候开始加载虚拟机规范没有强制约束</li>
</ul>
</li>
<li><p>初始化的时机</p>
</li>
<li><ul>
<li>虚拟机规范严格规定有且只有5种情况必须立即对类进行初始化(加载、验证、准备自然要在其之前)</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>1.遇到new, getstatic, putstatic, invokestatic四条字节码时，常见的场景：new实例化对象，读取或设置类的静态字段</li>
<li>2.使用java.lang.reflect包的方法对类进行反射调用时</li>
<li>3.初始化一个类但是父类还没初始化时先初始化父类</li>
<li>4.虚拟机启动时，main()方法的类</li>
<li>5.java.lang.invoke.MethodHandle实例后解析结果REF_getStatic, REF_putStatic, REF_inokeStatic的方法句柄，并且句柄对应的类没有初始化时</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><ul>
<li><p>加载阶段需要完成三件事</p>
</li>
<li><ul>
<li>1.通过类的全限定名来获取定义此类的二进制字节流</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>没有限制从什么地方获取，可以使用自定义类加载器，这是众多Java技术的基础（PowerMockito使用了自定义类加载器）</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>1.从jar包获取</li>
<li>2.从网络获取，如Applet</li>
<li>3.运算时计算生成，如动态代理技术完成对原功能的增强，在java.lang.reflect.Proxy中，就是利用ProxyGenerator.generateProxyClass来为特定的接口生成形式为”*$Proxy”的代理类的二进制字节流</li>
<li>4.其他文件生成，如由JSP文件生成Class类</li>
<li>5.从数据库中读取，把程序安装到数据库完成程序代码在集群间的分发</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>2.将这个字节流所代表的静态存储结构转化为方法区运行时的数据结构</li>
<li>3.<strong>在内存中生成一个代表此类的java.lang.Class对象</strong>，作为方法区这个类的各种数据的访问入口(HotSpot虚拟机将其存放在方法区，比较特殊，对象存在方法区)</li>
</ul>
</li>
<li><p>加载阶段尚未完成，连接阶段就可能开始了，如验证</p>
</li>
</ul>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><ul>
<li><p>1.文件格式验证</p>
</li>
<li><ul>
<li>如是否以魔数开头，指向常量池的索引值中是否有指向不存在的常量或不符合类型的常量，等</li>
</ul>
</li>
<li><p>2.元数据验证</p>
</li>
<li><ul>
<li>语义校验，如，是否继承了final类，这个类不是抽象类是否实现了父类或接口中要求的所有方法，等</li>
</ul>
</li>
<li><p>3.字节码验证</p>
</li>
<li><ul>
<li>对方法体进行校验，如，类型转换是否有效，是否用long类型操作int类型数据，等</li>
</ul>
</li>
<li><p>4.符号引用验证</p>
</li>
<li><ul>
<li>将在连接的解析阶段发生，符号引用确定的全限定名是否能找到对应的类，符号引用的类、字段、方法是否可以被当前类访问</li>
</ul>
</li>
<li><p>如果确定加载的类没问题可以使用 -Xverify:none来关闭验证，缩短类加载时间</p>
</li>
</ul>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul>
<li>正式为类变量(static)分配内存并设置初始值为0(不包括实例变量)</li>
</ul>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><ul>
<li><strong>将常量池中的符号引用替换为直接引用，即**</strong>从偏移量翻译成内存地址**</li>
<li>虚拟机可以将第一次解析的结果缓存(在运行时常量池中记录直接引用，并把常量标记为已解析状态)，避免反复解析</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul>
<li>类初始化阶段是类加载过程的最后一步，是类构造器方法的执行过程，由类变量的赋值(static) 和静态代码块(static{ }) 合并而成</li>
</ul>
<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><ul>
<li><p>Class作为JVM中的一个特殊对象，也会被GC回收卸载</p>
</li>
<li><p>Class的卸载就是清空方法区中Class的信息和堆区中的java.lang.Class对象。这时Class的声明周期就结束了</p>
</li>
<li><p>Class被回收要满足以下三个条件:</p>
</li>
<li><ul>
<li>No Instance：该类所有的实例都已经被GC;也就是java堆中不存在该类的任何实例</li>
<li>No ClassLoader：加载该类的ClassLoader实例已经被GC</li>
<li>No Reference：该类的java.lang.Class对象没有被引用。(XXX.class,静态变量/方法),即没有反射来使用class对象，</li>
</ul>
</li>
</ul>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><ul>
<li>执行获取类的二进制字节流的操作的代码模块称为类加载器</li>
<li>任意一个类需要和它的加载器一起确定唯一性，每一个类加载器，都有独立的类名称空间。即，即使是同一个Class文件，只要类加载器不同，那么这两个类不相等</li>
</ul>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><ul>
<li><p>类加载器分两种</p>
</li>
<li><ul>
<li>启动类加载器/引导类加载器(Bootstrap ClassLoader),使用C++实现</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>无法被Java程序直接引用</li>
<li>自定义类加载器可以把加载请求委托给引导类加载器</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>所有其他类加载器，使用Java实现，独立于虚拟机外部，全都继承抽象类java.lang.ClassLoader</li>
</ul>
</li>
<li><p>系统提供了3中类加载器</p>
</li>
<li><ul>
<li>1.引导类加载器</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>加载<JAVA_HOME>\lib目录中的类库</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>2.扩展类加载器(Extension ClassLoader)</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>加载<JAVA_HOME>\lib\ext中的类库</li>
<li>开发者可以直接使用这个类加载器</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>3.应用程序类加载器</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>加载用户路径(ClassPath)上的类库</li>
<li>开发者可以直接使用这个类加载器</li>
<li>如果应用程序没有自定义加载器，一般情况下默认使用这个类加载器</li>
</ul>
</li>
</ul>
</li>
<li><p>双亲委派模型</p>
</li>
<li><ul>
<li>要求除顶层的启动类加载器外，其余的类加载器当有自己的父类加载器</li>
<li>类加载器之间的父子关系不是用继承实现的，而是用组合关系复用父加载器</li>
<li>只有父加载器反馈自己无法完成加载请求(搜索范围内没有找到所需的类)时，子加载器才会尝试自己去加载</li>
<li>双亲委派模型保证了，无论哪个加载器要加载某个类，都是由同一个类加载器进行加载，保证了某个类在各种类加载器环境中都是同一个类</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>例如，用户自己写了java.lang.Object类放在ClassPath下，不使用该模型的话，就有可能加载到不同的Object类</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>双亲委派模型保证了越基础的类越上层的加载器进行加载</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1586834262259-688884e9-8898-41a9-a488-267efb94f1dd.png" alt="双亲委派模型.png"></li>
</ul>
</li>
<li><p>破坏双亲委派模型</p>
</li>
<li><ul>
<li>第一次破环：JDK1.2引入该模型，之前用的时java.lang.ClassLoader，现在不用管了</li>
<li>第二次破坏：历史原因，出现了基础类调用用户类的代码，使用线程上下文类加载器。Java中的JDBC就是这样的(ˉ▽ˉ；)…</li>
<li>第三次被破坏：OSGi模块化技术中不使用双亲委派模型，体统了代码热替换(HotSwap)，模块热部署(Hot Deplotment)技术</li>
</ul>
</li>
</ul>

        </div>

        
            <section class="post-copyright">
                
                
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>年与时驰，意与日去，遂成枯落，多不接世，悲守穷庐，将复何及</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/JVM/"># JVM</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2020/10/14/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/">线程安全与锁优化</a>
            
            
            <a class="next" rel="next" href="/2020/10/14/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/">垃圾收集器与内存分配策略</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© X_ray | Powered by <a href="https://xray1025.top" target="_blank">Xray</a></span>
    </div>
</footer>

    </div>
</body>
</html>
