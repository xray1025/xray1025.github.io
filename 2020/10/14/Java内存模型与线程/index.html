<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="X_ray">


    <meta name="subtitle" content="yesterday you said tomorrow">




<title>Java内存模型与线程 | X_ray&#39;s blog</title>



    <link rel="icon" href="/image/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.1.1"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Xray&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Xray&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Java内存模型与线程</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">X_ray</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">十月 14, 2020&nbsp;&nbsp;16:57:32</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Java/">Java</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="Java内存模型与线程"><a href="#Java内存模型与线程" class="headerlink" title="Java内存模型与线程"></a>Java内存模型与线程</h1><h1 id="CPU缓存"><a href="#CPU缓存" class="headerlink" title="CPU缓存"></a>CPU缓存</h1><ul>
<li><p>CPU缓存的出现主要是为了解决<strong>CPU运算速度与内存读写速度不匹配</strong>的矛盾，因为CPU运算速度要比内存读写速度快得多。1GHz的CPU一秒钟可以执行10亿个时钟周期，举个例子：</p>
</li>
<li><ul>
<li>一次L1高速缓存的读写只需要1~2个时钟周期</li>
<li>一次L2高速缓存的读写也只需要数十个时钟周期</li>
<li>一次主内存的访问通常在几十到几百个时钟周期</li>
</ul>
</li>
<li><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1266758/1587041489862-46700600-56f9-4f18-9474-1ed905344819.jpeg" alt="image"></p>
</li>
</ul>
<h1 id="使用CPU缓存带来的问题"><a href="#使用CPU缓存带来的问题" class="headerlink" title="使用CPU缓存带来的问题"></a>使用CPU缓存带来的问题</h1><ul>
<li>缓存不一致问题：</li>
</ul>
<ol>
<li><ol>
<li>核0读取了一个字节，根据局部性原理，它相邻的字节同样被被读入核0的缓存</li>
<li>核3做了上面同样的工作，这样核0与核3的缓存拥有同样的数据</li>
<li>核0修改了那个字节，被修改后，那个字节被写回核0的缓存，但是该信息并没有写回主存</li>
<li>核3访问该字节，由于核0并未将数据写回主存，数据不同步</li>
</ol>
</li>
</ol>
<h1 id="缓存一致性协议"><a href="#缓存一致性协议" class="headerlink" title="缓存一致性协议"></a>缓存一致性协议</h1><h2 id="MESI协议"><a href="#MESI协议" class="headerlink" title="MESI协议"></a>MESI协议</h2><ul>
<li><p>要求每个缓存行(Cache Line，缓存的基本数据单位，64位CPU缓存行一般是64字节)处于一下四个状态之一，CAS/volatile和这些都有关：</p>
</li>
<li><ul>
<li><strong>已修改**</strong>Modified (M)**</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>缓存行是脏的(dirty*)*，与主存的值不同。如果别的CPU内核要读主存这块数据，该缓存行必须回写到主存，状态变为共享(S).</li>
<li>必须时刻监听所有试图读取该缓存行对应的主存地址的操作，如果监听到，则必须在此操作执行前把其缓存行中的数据写回CPU</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>独占Exclusive (E)</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>缓存行只在当前缓存中，但是干净的(clean)–缓存数据同于主存数据。当别的缓存读取它时，状态变为共享；当前写数据时，变为已修改状态。</li>
<li>必须时刻监听其他试图读取该缓存行对应的主存地址的操作，如果监听到，则必须把其缓存行状态设置为S</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>共享Shared (S)</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>缓存行也存在于其它缓存中且是干净的。缓存行可以在任意时刻抛弃。</li>
<li>必须时刻监听使该缓存行无效或者独享该缓存行的请求，如果监听到，则必须把其缓存行状态设置为I</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>无效Invalid (I)</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>缓存行是无效的</li>
</ul>
</li>
</ul>
</li>
<li><p>当CPU需要读取数据时</p>
</li>
<li><ul>
<li>如果其缓存行的状态是I的，则需要从内存中读取，并把自己状态变成S，如果不是I，则可以直接读取缓存中的值，但在此之前，必须要等待其他CPU的监听结果，如其他CPU也有该数据的缓存且状态是M，则需要等待其把缓存更新到内存之后，再读取。</li>
</ul>
</li>
<li><p>当CPU需要写数据时</p>
</li>
<li><ul>
<li>只有在其缓存行是M或者E的时候才能执行，否则需要发出特殊的RFO指令(Read Or Ownership，这是一种总线事务)，通知其他CPU置缓存无效(I)，这种情况下性能开销是相对较大的。在写入完成后，修改其缓存状态为M</li>
</ul>
</li>
<li><p>Core1和Core2可能会同时把主存中某个位置的值Load到自己的L1 Cache中，当Core1在自己的L1 Cache中修改这个位置的值时，会通过总线，使Core2中L1 Cache对应的值“失效”，而Core2一旦发现自己L1 Cache中的值失效则会通过总线从内存中加载该地址最新的值</p>
</li>
</ul>
<h1 id="硬件的效率与一致性"><a href="#硬件的效率与一致性" class="headerlink" title="硬件的效率与一致性"></a>硬件的效率与一致性</h1><ul>
<li>由于计算机的存储设备与处理器的运算速度有几个数据级的，所以不得不加入高速缓存(Cache)作为内存和处理器之间的缓冲：将运算需要的数据赋值到缓存中，让运算能够快速进行，当运算结束后再从缓存同步回内存中</li>
<li>但是会引入一个新的问题：缓存一致性</li>
<li>每个处理器都有自己的高速缓存，而他们又共享同一主内存</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1266758/1587020706438-9772d217-2d35-49db-9bbb-f7bacf748f23.jpeg" alt="image"></li>
</ul>
<h1 id="Java内存模型-JMM"><a href="#Java内存模型-JMM" class="headerlink" title="Java内存模型(JMM)"></a>Java内存模型(JMM)</h1><h2 id="JMM概述"><a href="#JMM概述" class="headerlink" title="JMM概述"></a>JMM概述</h2><ul>
<li>JMM来屏蔽掉各种硬件和操作系统的内存访问差异，使得Java程序在各种平台下都能达到一致的内存访问效果</li>
<li>主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节</li>
<li>这里的变量和Java编程中的变量不一样，不包括局部变量和方法参数，这个是线程私有的不会被共享不会存在竞争问题(局部变量引用的对象可以是线程共享的)</li>
<li>JMM规定所有变量都存储在主内存中，每条线程都有自己的工作内存(高速缓存)</li>
<li>线程堆变量的所有操作都必须在工作内存中而不能直接操作主内存的变量，不同的线程也无法直接访问对方内存中的变量，线程间变量值的传递均需要通过主内存完成</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1266758/1587031316596-c73f993f-3bf8-46f8-980c-af9194671336.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></li>
</ul>
<h2 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h2><ul>
<li><p>主内存和工作内存之间操作有8种，每一种操作都是原子性的</p>
</li>
<li><p>这些操作和字节码不是一个概念，这里应该说是JVM和物理内存与CPU打交道的操作</p>
</li>
<li><p>具体操作如下：</p>
</li>
<li><ul>
<li>lock：作用于主内存的变量，把一个变量标识为一个线程独占</li>
<li>unlock：作用域主内存的变量，把锁定状态的变量释放出来，释放后的变量才能被其他线程锁定</li>
<li>read：作用于主内存的变量，把一个变量的值从主内存传输到工作内存中</li>
<li>load：作用于工作内存的变量，把read操作从主内存得到的变量值放入工作内存的变量副本中(不是拷贝对象)</li>
<li>use：作用于工作内存的变量，把工作内存中的一个变量的值传递给执行引擎</li>
<li>assign：作用于工作内存的变量，把从执行引擎接收到的值赋给工作内存中的变量</li>
<li>store：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存</li>
<li>write：作用于主内存的变量，把store操作从工作内存得到的变量的值放入主内存的变量中</li>
</ul>
</li>
<li><p>如果要把一个变量从主内存复制到工作内存，就要顺序地执行read和load，反之为store和write</p>
</li>
<li><p>JMM规定这些操作必须遵守的规则：</p>
</li>
<li><ul>
<li>lock操作可以被同一个线程执行多次，且执行相同次数的unlock后变量才会解锁</li>
<li>对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值(保证加锁前后变量值都是最新状态)</li>
<li>对一个变量执行unlock之前，必须把此变量同步回主内存中(执行store,write操作)(保证加锁前后变量值都是最新状态)</li>
<li>lock/unlock操作并没有直接开放给用户使用，提供了更高层次的字节码指令 monitorenter/monitorexit来隐式地使用这两个操作，对应到Java代码就是synchronized，因此synchronized块之间的操作也具备原子性</li>
</ul>
</li>
</ul>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><ul>
<li><p>volatile是JVM提供的最轻量级的同步机制</p>
</li>
<li><p>具备两种特性：可见性和禁止指令重排序优化(有序性)</p>
</li>
<li><p>volatile修饰的变量和非volatile修饰的变量相比：写操作更加消耗性能，但是读操作差不多</p>
</li>
<li><p><strong>volatile这两个特性的原理：</strong></p>
<ul>
<li>以volatile修饰对象的赋值为例，如下面的 <code>instance=new Single()</code> 这句的部分汇编代码如下(不是字节码)：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><strong>mov %eax,0x150(%esi)</strong></li>
<li>shr $0x9,%esi</li>
<li>movb $0x0,0x1104800(%esi)</li>
<li><strong>lock addl $0x0,(%esp)</strong> </li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>volatile起到了<strong>内存屏障</strong>的作用：lock会锁住总线/缓存，使其他线程的缓存无效，刷新缓存，刷新硬件的写缓存，以及间接作用：在指令重排序中无法进行跨越lock两边的重排序操作</li>
<li>lock后面的操作意是是给ESP寄存器的值加0，显然是空操作(lock前缀的空操作不会被优化)</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>作用是将本CPU的Cache写入内存，同时该写入操作会引起别的CPU的Cache中该变量处于Invalid状态，即上文提到的MESI协议</li>
<li>这种操作相当于对Cache变量做了一个JMM内存间交互操作中的<strong>store和write操作</strong></li>
<li>汇编中lock的作用是：</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>早期的CPU中lock指令会锁住总线，在lock操作执行期间不允许其他占用总线的行为，且不允许线程切换，所以能保证lock修饰的操作的原子性</li>
<li>锁住总线的开销大，锁住期间其他CPU没法访问内存。现在的CPU使用Ringbus + MESI协议优化，通过锁缓存(Cache Locking)的方式优化锁总线（只是优化，锁总线不能完全避免）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>两个线程同时操作volatile类型变量时：</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>Thread-A写了变量i，那么</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li><ul>
<li>Thread-A发出LOCK#指令锁总线(或锁缓存行)，同时让Thread-B高速缓存中的缓存行内容失效</li>
<li>Thread-A向主存回写最新修改的i</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>Thread-B读取变量i，那么：</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li><ul>
<li>Thread-B发现对应地址的缓存行被锁了，等待锁的释放，缓存一致性协议会保证它读取到最新的值</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>例子：双重检查锁定——单例设计模式</p>
</li>
<li><ul>
<li>instance对象用volatile修饰的原因：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>synchronized可以保证代码块原子性和可见性，但是不能保证有序性</li>
<li>new对象可以分为三个步骤</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>分配对象内存空间</li>
<li>初始化对象</li>
<li>设置instance指向该内存空间</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>如果发生了重排序，变成</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>分配对象内存空间</li>
<li>设置instance指向该内存空间</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li><ul>
<li>这一步完成后跳转到另一个线程，发现instance有指向对象，即!=null，那么会访问该对象，但是该对象还没初始化</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>初始化对象</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双锁检测单例Demo</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Single</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Single instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Single.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance=<span class="keyword">new</span> Single();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Single.getInstance();<span class="comment">//Single@677327b6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原子性、可见性与有序性"><a href="#原子性、可见性与有序性" class="headerlink" title="原子性、可见性与有序性"></a>原子性、可见性与有序性</h2><ul>
<li><p>这时JMM中的重要特征，也是Java并发的三大核心问题</p>
</li>
<li><p>原子性：JMM直接保证原子性变量操作包括read,load,assign,user,store,write，大致可以认为基本数据类型的访问读写是具备原子性的，更大范围的原子性保证由lock/unlock操作实现，对应到Java代码就是synchronized</p>
</li>
<li><p>可见性：JMM通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的方式来实现可见性。synchronized也能实现可见性</p>
</li>
<li><ul>
<li>final可以在某些情况下保证可见性</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>如果下面的代码中没有obj=this，则可以保证其他线程不会看到i=0(未初始化)的情况。JMM会保证final域初始化的安全性，即禁止把final域的写操作重排序到构造函数之外，所以其他线程在能看到FinalTest对象的时候final域的i变量已经初始化好了</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>解释：FinalTest ft=new FinalTest();可以分为两步：</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li><ul>
<li>FinalTest ft=null</li>
<li>FinalTest()类的实例化初始化</li>
<li>ft=初始化结果</li>
<li>所以ft要么==null，要么能看到i变量的时候就已经初始化好了</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>但是如果多了obj=this，即this逃逸，如果该语句被重排序到i初始化之前，其他线程就会看到没被初始化的final域的i变量</li>
<li>结论：构造函数中不要出现this逃逸，可以使用工厂方法解决，即getInstance，不暴露构造函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">FinalTest</span>&#123;</span><br><span class="line">   <span class="keyword">final</span> <span class="built_in">int</span> i;</span><br><span class="line">   static FinalTest obj;</span><br><span class="line">   <span class="keyword">public</span> FinalTest()&#123;</span><br><span class="line">       i=<span class="number">1</span>;</span><br><span class="line">       <span class="comment">//这里会使正在被构造的对象逸出</span></span><br><span class="line">       <span class="comment">//如果和上一句做了重排序，那么其他线程就可以通过obj访问到还为被初始化的变量i。</span></span><br><span class="line">       <span class="comment">//obj = this; </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>有序性：volatile和synchronized两个关键字保证线程之间操作的有序性。volatile关键字本身就包含禁止指令重排序的语义，而synchronized是由“一个变量在同一时刻只允许一条线程对其进行lock操作”这条规则获得的</li>
</ul>
<h2 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h2><ul>
<li>程序顺序原则： 一个线程内保证语义的串行性</li>
<li>volatile 规则： volatile 变量的写先于读发生， 这保证了volatile 变量的可见性</li>
<li>锁规则： 解锁(unlock)必然发生在随后的加锁(lock)前</li>
<li>传递性： A 先于B, B 先于C ， 那么A 必然先于C </li>
<li>线程的start()方法先于它的每一个动作</li>
<li>线程的所有操作先于线程的终结( Thread.join() )</li>
<li>线程的中断(interrupt())先于被中断线程的代码</li>
<li>对象的构造函数的执行、结束先于finalize()方法</li>
</ul>
<h2 id="volatile-final实现线程安全"><a href="#volatile-final实现线程安全" class="headerlink" title="volatile+final实现线程安全"></a>volatile+final实现线程安全</h2><ul>
<li>下面例子是根据输入进行质因数分解，并且保存上一次的质因数和分解结果，如果本次输入的质因数相同则使用缓存中的结果</li>
<li>OneValueCache类用来缓存分解结果，有两个变量，如果希望OneValueCache类的操作是原子性的，必须使用某种手段使得两个变量的写操作具有原子性</li>
<li>在某些情况下，不可变对象能提供一种弱形式的原子性，每当需要对一组相关数据以原子方式执行某个操作时，就可以考虑创建一个不可变的类来包含这些数据</li>
<li>访问和更新多个相关变量时出现竞争条件问题，可以通过将这些变量全部保存在一个不可变对象中来消除</li>
<li>如果是一个可变的对象，那么就必须使用锁来确保原子性</li>
<li><strong>如果是一个不可变对象，那么当线程获得了对该对象的引用后，就不必担心另一个线程会修改对象的状态。**</strong>如果要更新这些变量，那么可以创建一个新的容器对象**，但其他使用原有对象的线程仍然会看到对象处于一致的状态</li>
<li>VolatileCachedFactorizer使用了OneValueCache来保存缓存的数值及其因数。当一个线程将volatile类型的cache设置为引用一个新的OneValueCache时，其他线程就会立即看到新缓存的数据</li>
<li><strong>通过使用包含多个状态变量的容器对象来维持不变性条件，并使用一个volatile类型的引用来确保可见性，使得VolatileCachedFactorizer在没有显式地使用锁的情况下仍然是线程安全的</strong></li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@Immutable  </span><br><span class="line"><span class="keyword">class</span> OneValueCache &#123;  </span><br><span class="line">   <span class="keyword">private</span> final BigInteger lastNumber;  </span><br><span class="line">   <span class="keyword">private</span> final BigInteger<span class="literal">[]</span> lastFactors;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//在构造函数中进行初始化，并且使用了final，在没有this逃逸的情况下可以认为是原子性操作</span></span><br><span class="line">   public <span class="constructor">OneValueCache(BigInteger <span class="params">i</span>, BigInteger[] <span class="params">factors</span>)</span> &#123;  </span><br><span class="line">       lastNumber = i;  </span><br><span class="line">       <span class="comment">//这里必须是Arrays.copyOf(),不然就会引用外部对象，导致对象不是完全final</span></span><br><span class="line">       lastFactors = <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>copy<span class="constructor">Of(<span class="params">factors</span>, <span class="params">factors</span>.<span class="params">length</span>)</span>;  </span><br><span class="line">   &#125;  </span><br><span class="line"> </span><br><span class="line">   public BigInteger<span class="literal">[]</span> get<span class="constructor">Factors(BigInteger <span class="params">i</span>)</span> &#123;  </span><br><span class="line">       <span class="keyword">if</span> (lastNumber<span class="operator"> == </span>null<span class="operator"> || </span>!lastNumber.equals(i))  </span><br><span class="line">           return null;  </span><br><span class="line">       <span class="keyword">else</span>  </span><br><span class="line">           return <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>copy<span class="constructor">Of(<span class="params">lastFactors</span>, <span class="params">lastFactors</span>.<span class="params">length</span>)</span>;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@ThreadSafe  </span><br><span class="line">public <span class="keyword">class</span> VolatileCachedFactorizer implements Servlet &#123;  </span><br><span class="line">   <span class="keyword">private</span> volatile OneValueCache cache = <span class="keyword">new</span> <span class="constructor">OneValueCache(<span class="params">null</span>, <span class="params">null</span>)</span>;  </span><br><span class="line"> </span><br><span class="line">   public void service(ServletRequest req, ServletResponse resp) &#123;  </span><br><span class="line">       BigInteger i = extract<span class="constructor">FromRequest(<span class="params">req</span>)</span>;  </span><br><span class="line">       BigInteger<span class="literal">[]</span> factors = cache.get<span class="constructor">Factors(<span class="params">i</span>)</span>;  </span><br><span class="line">       <span class="keyword">if</span> (factors<span class="operator"> == </span>null) &#123;  </span><br><span class="line">           factorfactors = factor(i);  </span><br><span class="line">           <span class="comment">//每次更新状态都是新建一个对象，并且使用volatile保证可见性，后一个调用进来可以立即使用内存中的cache</span></span><br><span class="line">           cache = <span class="keyword">new</span> <span class="constructor">OneValueCache(<span class="params">i</span>, <span class="params">factors</span>)</span>;</span><br><span class="line">       &#125;  </span><br><span class="line">       encode<span class="constructor">IntoResponse(<span class="params">resp</span>, <span class="params">factors</span>)</span>;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h1 id="Java与线程"><a href="#Java与线程" class="headerlink" title="Java与线程"></a>Java与线程</h1><h2 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h2><ul>
<li><p>使用内核线程实现</p>
</li>
<li><ul>
<li>内核线程(Kernel-Level Thread,KLT)直接由操作系统内核(Kernel)支持的线程，由内核通过操纵调度器完成线程切换，每个内核线程可以视为内核的一个分身</li>
<li>程序一般不直接使用内核线程，而是使用内核线程的接口——轻量级进程(Light Weight Process,LWP)，轻量级进程就是我们通常意义上的线程，每一个轻量级进程都由一个内核线程支持，即1：1关系。</li>
<li>由于内核线程的支持，每个轻量级进程都是一个独立的调度单元，即一个阻塞了也不会影响整个进程</li>
<li>但是线程的创建、析构和同步需要在用户态和内核态来回切换，并且由于消耗内核资源，一个系统支持轻量级进程有限</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1587091981602-55973be2-2d15-424d-bc3c-81a7603c24bf.png" alt="image"></li>
</ul>
</li>
<li><p>使用用户线程实现</p>
</li>
<li><ul>
<li>用户线程(User Thread,UT)的创建、同步、销毁和调度都在用户态完成</li>
<li>进程和用户线程之间的关系为1:N</li>
<li>Java现在并不支持这玩意</li>
</ul>
</li>
<li><p>使用用户线程加轻量级线程混合实现</p>
</li>
</ul>
<h2 id="Java线程的调度"><a href="#Java线程的调度" class="headerlink" title="Java线程的调度"></a>Java线程的调度</h2><ul>
<li><p>协同式调度</p>
</li>
<li><ul>
<li>线程的执行时间由线程本身控制，线程自己执行完了就主动通知系统切换到另外一个线程上</li>
<li>实现简单，没什么线程同步问题</li>
</ul>
</li>
<li><p>抢占式调度</p>
</li>
<li><ul>
<li>每个线程由系统分配执行时间(Java使用这种)</li>
<li>可以设置线程优先级</li>
</ul>
</li>
</ul>
<h2 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1587092733266-cacc335c-d8c3-442c-b298-1ca052550ed2.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10/resize,w_643" alt="img"></p>

        </div>

        
            <section class="post-copyright">
                
                
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>年与时驰，意与日去，遂成枯落，多不接世，悲守穷庐，将复何及</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/JUC/"># JUC</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2020/10/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
            
            
            <a class="next" rel="next" href="/2020/10/14/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/">垃圾收集器与内存分配策略</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© X_ray | Powered by <a href="https://xray1025.top" target="_blank">Xray</a></span>
    </div>
</footer>

    </div>
</body>
</html>
