<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="X_ray">


    <meta name="subtitle" content="yesterday you said tomorrow">




<title>并发程序基础 | X_ray&#39;s blog</title>



    <link rel="icon" href="/image/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.1.1"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Xray&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Xray&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">并发程序基础</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">X_ray</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">十月 14, 2020&nbsp;&nbsp;21:09:49</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Java/">Java</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="并行程序基础"><a href="#并行程序基础" class="headerlink" title="并行程序基础"></a>并行程序基础</h1><h1 id="线程状态和转换图"><a href="#线程状态和转换图" class="headerlink" title="线程状态和转换图"></a>线程状态和转换图</h1><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1266758/1588731697846-effecd8a-ccef-48bb-b401-b5bdc9d136ea.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<h2 id="1-初始状态"><a href="#1-初始状态" class="headerlink" title="1. 初始状态"></a>1. 初始状态</h2><ul>
<li>实现Runnable接口和继承Thread可以得到一个线程类，new一个实例出来，线程就进入了初始状态。</li>
</ul>
<h2 id="2-1-就绪状态"><a href="#2-1-就绪状态" class="headerlink" title="2.1. 就绪状态"></a>2.1. 就绪状态</h2><ul>
<li>处于工作队列中（只要抢到运行资格就可以运行）</li>
<li>就绪状态只是说你资格运行，调度程序没有挑选到你，你就永远是就绪状态。</li>
<li>调用线程的start()方法，此线程进入就绪状态。</li>
<li>当前线程sleep()方法结束、其他线程join()结束、等待用户输入完毕、某个线程拿到对象锁，这些线程也将进入就绪状态。</li>
<li>当前线程时间片用完了、调用当前线程的yield()方法，当前线程进入就绪状态。</li>
<li>锁池里的线程拿到对象锁后，进入就绪状态。</li>
</ul>
<h2 id="2-2-运行中状态"><a href="#2-2-运行中状态" class="headerlink" title="2.2. 运行中状态"></a>2.2. 运行中状态</h2><ul>
<li>线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一一种方式。</li>
</ul>
<h2 id="3-阻塞状态"><a href="#3-阻塞状态" class="headerlink" title="3. 阻塞状态"></a>3. 阻塞状态</h2><ul>
<li>例如线程阻塞在进入synchronized关键字修饰的方法或代码块(获取锁)时的状态。</li>
</ul>
<h2 id="4-等待"><a href="#4-等待" class="headerlink" title="4. 等待"></a>4. 等待</h2><ul>
<li>处于等待队列中，需要被唤醒才可以执行</li>
<li>处于这种状态的线程不会被分配CPU执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态。</li>
</ul>
<h2 id="5-超时等待"><a href="#5-超时等待" class="headerlink" title="5. 超时等待"></a>5. 超时等待</h2><ul>
<li>处于这种状态的线程不会被分配CPU执行时间，不过无须无限期等待被其他线程显示地唤醒，在达到一定时间后它们会自动唤醒。</li>
</ul>
<h2 id="6-终止状态"><a href="#6-终止状态" class="headerlink" title="6. 终止状态"></a>6. 终止状态</h2><ul>
<li>当线程的run()方法完成时，或者主线程的main()方法完成时，我们就认为它终止了。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦终止了，就不能复生。</li>
<li>在一个终止的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。</li>
</ul>
<h1 id="线程操作的API"><a href="#线程操作的API" class="headerlink" title="线程操作的API"></a>线程操作的API</h1><h2 id="线程执行"><a href="#线程执行" class="headerlink" title="线程执行"></a>线程执行</h2><ul>
<li>线程由Thread对象表示，并且像其他对象一样可以被自由共享</li>
<li>线程的所有者是创建这个线程的类</li>
<li>线程的所有权是不可传递的</li>
<li>例子</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> CreateThread());</span><br><span class="line">        t1.start() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        Systerm.out.println (<span class="string">&quot;I am Runnable&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>类如何并发：该类实现Runnable接口，并重写run方法</p>
</li>
<li><p>启动线程：</p>
</li>
<li><ul>
<li>new Thread对象，同时使用其构造函数传入一个该类的实例对象</li>
<li>Thread对象调用start()方法</li>
</ul>
</li>
<li><p>调用star() 方法时会执行 run() 方法，为什么不能直接调用 run() 方法？</p>
</li>
<li><ul>
<li>调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</li>
</ul>
</li>
</ul>
<h2 id="结束线程"><a href="#结束线程" class="headerlink" title="结束线程"></a>结束线程</h2><ul>
<li>一般来说线程执行完毕会自动结束</li>
<li>stop()方法可以停止线程，会直接释放锁强行停止线程，非常危险已经被弃用</li>
<li>线程while()循环的判断中可以检查一个标志位，如果改变了则终止线程</li>
<li>例子：循环生成素数，直到收到取消信号为止，取消标志位需要使用volatile保证可见性</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeGenerator</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;BigInteger&gt; primes=<span class="keyword">new</span> ArrayList&lt;BigInteger&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> cancelled;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        BigInteger p=BigInteger.ONE;</span><br><span class="line">        <span class="keyword">while</span>(!cancelled)&#123;</span><br><span class="line">            p=p.nextProbablePrime();</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">                primes.add(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">publi <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>&#123;cancelled=<span class="keyword">true</span>;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> List&lt;BigInteger&gt; <span class="title">get</span><span class="params">()</span></span>;&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;BigInteger&gt;(primes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h2><ul>
<li><p>上面的操作可以实现线程退出，但是如果while(){}循环中调用的方法阻塞了，则不会检查取消标志位，线程不能退出</p>
</li>
<li><p>线程中断类似上面通过检查标志位终止线程的操作类似，解决了方法阻塞的问题</p>
</li>
<li><p><strong>线程中断并不会使线程立即退出， 而是给线程发送一个通知，具体怎么操作完全是线程自行决定(Java规范没有规定中断具有取消的语义)</strong></p>
</li>
<li><p>每个线程都有一个boolean类型的中断状态，同时Thread类提供了相关的操作方法：</p>
</li>
<li><ul>
<li><strong>t1.interrupt()</strong>;//t1是要中断的Thread<br>实例方法，通知目标线程中断，即设置中断标志位</li>
<li><strong>t1.isInterrupted():</strong><br>实例方法，判断当前线程是否被中断（通过检查中断标志位）</li>
<li><strong>Thread.interrupted():</strong><br>静态方法，判断当前线程的中断状态， 但同时会清除当前线程的中断标志位状态。上面的循环生成素数例子就可以使用这个静态方法作为while循环的判断</li>
</ul>
</li>
<li><p>应用</p>
</li>
</ul>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Thread</span> t1=<span class="literal">new</span> <span class="keyword">Thread</span>(&#125; &#123;</span><br><span class="line">    @Override  </span><br><span class="line">    <span class="keyword">public</span> <span class="literal">void</span> run()&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">Thread</span>.currentThread().isInterrupted()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Interrupted!&quot;</span>） ；</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">Thread</span>.<span class="keyword">yield</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li>本例中，调用实例对象t1的interrupt实例方法后，t1线程会停止</li>
<li>t1.start() ;<br>Thread.sleep(2000) ;<br>t1.interrupt() ;</li>
</ul>
</li>
</ul>
<h2 id="中断阻塞方法"><a href="#中断阻塞方法" class="headerlink" title="中断阻塞方法"></a>中断阻塞方法</h2><ul>
<li><p>线程可能会阻塞或暂停执行，原因包括：</p>
</li>
<li><ul>
<li>等待I/O操作结束</li>
<li>等待获得一个锁</li>
<li>等待从Thread.sleep方法中醒来</li>
<li>等待另一个线程的计算结果</li>
</ul>
</li>
<li><p>阻塞操作的特点：必须等待某个不受它控制的事件发生后才能继续执行</p>
</li>
<li><p>阻塞状态不会被分配CPU时间，但是方法阻塞时响应中断的速度很快，应该是：内核负责处理处于阻塞态线程的中断标志位，如果设置中断标志位的线程处于阻塞状态就抛出InterruptedException</p>
</li>
<li><p>当某方法抛出InterruptedException时，表示该方法是一个阻塞方法。如，</p>
</li>
<li><ul>
<li>BlockingQueue的put()和take()方法</li>
<li>Thread.sleep静态方法，需要try-catch，如果线程在休眠时被中断会抛出InterruptedException异常</li>
<li>一个方法调用将抛出InterruptedException异常的方法时，该方法也就变成阻塞方法</li>
</ul>
</li>
<li><p>必须处理这些阻塞方法对中断的响应，包括</p>
</li>
<li><ul>
<li>传递InterruptedException：把异常传递给调用者，即不处理异常</li>
<li>恢复中断：有时不能抛出InterruptedException或者希望处理该异常时（比如代码是Runnable的一部分时）。可以通过调用当前线程上的interrupt方法恢复中断状态，这样在调用栈中更高层的代码将看到引发了一个中断（抛出这种异常时会清除中断标记，需要手动再设置中断标志，恢复中断状态，否则会报sleep interrupted异常）</li>
</ul>
</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">TaskRunnable</span> <span class="symbol">implements</span> <span class="symbol">Runnable</span>&#123;</span><br><span class="line">    BlockingQueue&lt;Task&gt; queue;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> run()&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            processTask(queue.take());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            <span class="comment">//恢复被中断的状态</span></span><br><span class="line">            Thread.currentThread().<span class="built_in">int</span>errupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果不在catch中恢复中断状态：</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="title">implements</span> <span class="title">Runnable</span>&#123;</span></span><br><span class="line">        @Override</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000000000L</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">Task</span> task=<span class="keyword">new</span> <span class="built_in">Task</span>();</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(task);</span><br><span class="line">        t1.start();</span><br><span class="line">        t1.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1588040703310-3b08495d-8625-440d-bf95-a76d044c6115.png" alt="image.png"></li>
</ul>
</li>
<li><p>如果恢复中断状态，即e.printStackTrace()–&gt;Thread.<em>currentThread</em>().interrupt();</p>
</li>
<li><ul>
<li>不会报异常，啥事没有，相当于无视中断但是保存中断标志位，留给调用栈中的上层代码获取中断信息</li>
<li>对于中断状态不能乱处理，如果不知道怎么处理就将异常抛给调用者处理，这是可阻塞的库函数都只是抛出InterruptedException的原因</li>
</ul>
</li>
<li><p>Thread.sleep()或抛出InterruptedException的阻塞方法会转换为阻塞状态</p>
</li>
<li><p>上面的例子中，执行到t1.interrupt()时，Task类会捕捉到这个中断，然后执行e.printStackTrace()输出InterruptedException异常信息</p>
</li>
<li><p>而catch中换成了Thread.<em>currentThread</em>().interrupt()意思是t1线程知道被中断了，而t1处于sleep状态，我就结束sleep阻塞状态，并且将t1线程恢复成中断状态（到这里整个程序就没有别的任务了，就结束了）</p>
</li>
</ul>
<h2 id="等待-wait-和通知-notify"><a href="#等待-wait-和通知-notify" class="headerlink" title="等待(wait)和通知(notify)"></a>等待(wait)和通知(notify)</h2><ul>
<li><p>当在一个对象实例上调用wait()方法后，当前线程就会在这个对象上等待<br>比如，线程A调用了obj.wait()方法，那么线程A就会停止继续执行，转为等待状态<br>线程A会一直等到其他线程调用了obj.notify()方法为止<br>注意：notify()从休眠队列中随机唤醒，notifyAll()唤醒全部休眠线程</p>
</li>
<li><p>sleep() 方法和 wait() 方法区别</p>
</li>
<li><ul>
<li>sleep 方法没有释放锁，而 wait 方法释放了锁</li>
<li>wait() 方法被调用后，线程不会自动苏醒，sleep() 方法执行完成后，线程会自动苏醒</li>
</ul>
</li>
<li><p>注意：</p>
</li>
<li><ul>
<li>obj.wait()需要在synchronzied语句中才可以调用</li>
<li>obj.wait()和obj.notify()都需要获得监视器(obj对象)才可以执行</li>
<li>obj.wait()执行后会释放监视器(obj.notify()就不会释放监视器)</li>
<li>线程1 obj.wait()后接受到了线程2 obj.notify()后会尝试获取监视器，获取不到不会真正被唤醒</li>
</ul>
</li>
</ul>
<h2 id="挂起-suspend-和继续执行-resume-线程"><a href="#挂起-suspend-和继续执行-resume-线程" class="headerlink" title="挂起(suspend)和继续执行(resume)线程"></a>挂起(suspend)和继续执行(resume)线程</h2><ul>
<li>和stop()一样都已经被弃用</li>
<li>suspend()暂停线程的同时不会释放任何资源，会影响其他线程的正常运行</li>
<li>如果resume()因为某种原因在suspend()前执行的话就很难继续执行，同时线程状态居然是Runnable</li>
</ul>
<h2 id="等待线程结束-join-和谦让-yeild"><a href="#等待线程结束-join-和谦让-yeild" class="headerlink" title="等待线程结束(join)和谦让(yeild)"></a>等待线程结束(join)和谦让(yeild)</h2><ul>
<li><p>join()：</p>
</li>
<li><ul>
<li>两种join实例方法：<br>public final void join() throws InterruptedException<br>public final synchronized void join(long millis) throws InterruptedException<br>前者无限等待，后者设定最大等待时间</li>
<li>1.理解：main语句 obj.join()，main线程加到obj对象的线程中，要等到obj对象的线程执行完成才会执行main的线程</li>
</ul>
</li>
<li><p>Thread.yield()</p>
</li>
<li><ul>
<li>静态方法：<br>public static native void yield() ;</li>
<li>执行后会使当前线程让出CPU<br>注意，让出CPU不表示当前线程不执行了。<br>当前线程在让出CPU后，还会进行CPU 资源的争夺</li>
</ul>
</li>
</ul>
<h1 id="volatile与Java内存模型-JMM"><a href="#volatile与Java内存模型-JMM" class="headerlink" title="volatile与Java内存模型(JMM)"></a>volatile与Java内存模型(JMM)</h1><ul>
<li><p>关键字volatile声明一个变量时，就等于告诉了虚拟机，这个变量极有可能会被某些程序或者线程修改，这样虚拟机就会使用特殊的手段使得这个变量改动后被所有线程看到</p>
</li>
<li><p>volatile详细原理与单例模式应用见笔记<a target="_blank" rel="noopener" href="https://www.yuque.com/luka/note/jmm/edit">Java内存模型与线程</a>)</p>
</li>
<li><p>volatile可以保证long/double类型的读写是原子性的，对原子性的唯一贡献(基本类型的读写时原子性的，不用volatile)。其实不用管，商用的JVM不会出现这种问题</p>
</li>
<li><p>volitile无法保证原子性，比如一些复合操作，如i++()，锁是可以满足原子性的，如：</p>
</li>
<li><ul>
<li>比如下面的操作，如果i++操作是原子性的那么最终输出一定是100000(10个线程各加10000次)，但实际上小于100000</li>
<li>原因：i++是i=i+1，翻译成字节码是4条语句，不能保证执行4条语句时不切换到其他线程</li>
</ul>
</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">volatileTest</span> &#123;</span><br><span class="line">    static volatile <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">class</span> <span class="symbol">PlusTask</span> <span class="symbol">implements</span> <span class="symbol">Runnable</span> &#123;</span><br><span class="line">        @Override  </span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">void</span> run() &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10000</span>; k++) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread[] threads = new Thread[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            threads[i] = new Thread(new PlusTask());</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            threads[i].join();</span><br><span class="line">        &#125;</span><br><span class="line">        System.<span class="keyword">out</span>.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h1><ul>
<li><p>如果线程数量很多，而且功能分配比较明确， 就可以将相同功能的线程放置在同一个线程组里</p>
</li>
<li><p>线程组的方法</p>
</li>
<li><ul>
<li>activeCount()获取活动线程的总数</li>
<li>list()以打印这个线程组中所有的线程信息</li>
</ul>
</li>
</ul>
<h1 id="守护线程-Daemon"><a href="#守护线程-Daemon" class="headerlink" title="守护线程(Daemon)"></a>守护线程(Daemon)</h1><ul>
<li>线程分为两种：普通线程和守护线程</li>
<li>JVM启动时创建的所有线程中，除了主线程以外，其他的线程都是守护线程（例如垃圾收集器等）</li>
<li>守护线程是辅助用户线程的一种线程，如果Java程序中只有守护线程JVM就会停止</li>
<li>下面的例子：t设置位守护线程后，整个程序只有main是用户线程，当用户线程结束后Java应用就结束了，如果不设t为守护线程的话会一直打印，应用不会停止</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonT</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>&#125; &#123;</span><br><span class="line">                System.out.println (<span class="string">&quot;I am alive&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e&#125; &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t=<span class="keyword">new</span> DaemonT(&#125; ;</span><br><span class="line">        t.setDaemon(<span class="keyword">true</span>);<span class="comment">//设t为守护线程</span></span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h1><ul>
<li><p>Java中线程优先级分为1级-10级，优先级高的线程在竞争资源时会更有优势</p>
</li>
<li><ul>
<li>public final static int MIN_PRIORITY = 1;</li>
<li>public final static int NORM PRIORITY= 5;</li>
<li>public final static int MAX PRIORITY= 10;</li>
</ul>
</li>
</ul>
<h1 id="关键字synchronized"><a href="#关键字synchronized" class="headerlink" title="关键字synchronized"></a>关键字synchronized</h1><ul>
<li><p>volatile不能真正解决多线程修改同一个变量的问题，使用synchronized关键字可以使线程A写入数据时，线程B不仅不能写，同时也不能读</p>
</li>
<li><p>关键字synchronized对同步的代码加锁，使得同一时间只能有一个线程进入同步块(想进入同步块就需要获得对应的锁)</p>
</li>
<li><p>synchronized可以作用三个地方：</p>
</li>
<li><ul>
<li>指定加锁对象： 对给定对象加锁，进入同步代码前要获得给定对象的锁，锁住的是代码块</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>同步语句块的实现使用的是monitorenter和monitorexit指令<br>monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>直接作用于实例方法： 相当于对当前实例加锁，进入同步代码前要获得当前实例的锁，锁住的是对象实例(this)</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>修饰方法没monitorenter指令，有ACC_SYNCHRONIZED 标识，JVM通过标识辨别一个方法是否声明为同步方法</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>直接作用于静态方法： 相当于对当前类加锁，进入同步代码前要获得当前类的锁，锁住的是类的Class对象</li>
</ul>
</li>
<li><p>例子：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountingSync</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> AccountingSync instance=<span class="keyword">new</span> AccountingSync() ;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10000000</span>;j++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (instance) &#123;</span><br><span class="line">               i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//创建线程的构造函数需要传入锁对象</span></span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(instance) ;</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(instance) ;</span><br><span class="line">        t1.start(); t2.start() ;</span><br><span class="line">        t1.join(); t2.join() ;</span><br><span class="line">        System.out.println(i) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>synchronized的锁对象错误例子：</p>
</li>
<li><ul>
<li>下面的输出结果不会是期望的20000000，会小得多。</li>
<li>原因：synchronized的锁对象是Integer，属于不变对象。所以两个线程每次加锁的对象都不同，导致同步失效。将加锁对象改成instance就行了</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BadLockOnInteger</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">static</span> BadLockOnInteger instance=<span class="keyword">new</span> BadLockOnInteger();</span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10000000</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(i)&#123;</span><br><span class="line">              i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(instance);</span><br><span class="line">        t1.start();t2.start();</span><br><span class="line">        t1.join();t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="synchronized和ReentrantLock区别"><a href="#synchronized和ReentrantLock区别" class="headerlink" title="synchronized和ReentrantLock区别"></a>synchronized和ReentrantLock区别</h1><ul>
<li><p>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</p>
</li>
<li><p>ReentrantLock 比 synchronized 增加了一些高级功能</p>
</li>
<li><ul>
<li>ReentrantLock提供了一种能够中断等待锁的线程的机制</li>
<li>ReentrantLock可以指定是公平锁还是非公平锁</li>
<li>ReentrantLock可以为线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活</li>
</ul>
</li>
</ul>
<h1 id="synchronized和volatile的区别"><a href="#synchronized和volatile的区别" class="headerlink" title="synchronized和volatile的区别"></a>synchronized和volatile的区别</h1><ul>
<li>volatile关键字是线程同步的轻量级实现，所以volatile性能比synchronized关键字好</li>
<li>是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块</li>
<li>多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞</li>
<li>volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证</li>
<li>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性</li>
</ul>

        </div>

        
            <section class="post-copyright">
                
                
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>年与时驰，意与日去，遂成枯落，多不接世，悲守穷庐，将复何及</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/JUC/"># JUC</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2020/10/14/%E6%AD%BB%E9%94%81/">死锁</a>
            
            
            <a class="next" rel="next" href="/2020/10/14/%E5%B9%B6%E5%8F%91%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/">并发相关概念</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© X_ray | Powered by <a href="https://xray1025.top" target="_blank">Xray</a></span>
    </div>
</footer>

    </div>
</body>
</html>
