<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="X_ray">


    <meta name="subtitle" content="yesterday you said tomorrow">




<title>线程安全与锁优化 | X_ray&#39;s blog</title>



    <link rel="icon" href="/image/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.1.1"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Xray&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Xray&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">线程安全与锁优化</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">X_ray</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">十月 14, 2020&nbsp;&nbsp;16:56:06</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Java/">Java</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="线程安全与锁优化"><a href="#线程安全与锁优化" class="headerlink" title="线程安全与锁优化"></a>线程安全与锁优化</h1><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><ul>
<li>定义：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。</li>
</ul>
<h2 id="Java中的线程安全类型"><a href="#Java中的线程安全类型" class="headerlink" title="Java中的线程安全类型"></a>Java中的线程安全类型</h2><p>由Brian Goetz发表的论文中提出</p>
<ul>
<li>不可变：final修饰的的数据就是不可变的</li>
<li>绝对线程安全：不管运行时环境如何，调用者都不需要任何额外的同步措施(Java API中标注是线程安全的类大都不满足这一条)</li>
<li>相对线程安全：通常意义上的线程安全</li>
<li>线程兼容：对象本身不是线程安全的，但是可以通过在调用端正确地使用同步手段保证对象在并发环境中可以安全地使用</li>
<li>线程对立：无论调用段是否采用同步措施，都无法在多线程环境下并发使用。Java中这种很少见，如，Thread类的suspend()和resume()，所以被弃用了</li>
</ul>
<h2 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h2><h3 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h3><ul>
<li>互斥是方法，同步是目的</li>
<li>互斥同步手段包括synchronized,ReentrantLock</li>
<li>synchronized编译后会在同步块前后分别形成monitorenter指令，首先尝试获取对象的锁，如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，则锁的计数器加1，相应的，执行monitorexit指令时锁计数器减1</li>
<li>其他细节在并发相关笔记中</li>
</ul>
<h3 id="非阻塞同步-CAS"><a href="#非阻塞同步-CAS" class="headerlink" title="非阻塞同步(CAS)"></a>非阻塞同步(CAS)</h3><ul>
<li><p>互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步</p>
</li>
<li><p>互斥同步属于悲观并发策略，随着硬件指令集的发展，有了新的选择：基于冲突检测的乐观并发策略。即，先进行操作，如果共享数据不争用则成功，如果争用则不断尝试直到成功，由于这种策略不需要挂起线程，所以称为非阻塞同步</p>
</li>
<li><p>上述策略实现需要硬件指令集的支持，需要操作和冲突检测这两个逻辑上两个步骤具备原子性(即一次完成两个操作)</p>
</li>
<li><p><strong>非阻塞同步中，CAS是最著名的代表</strong></p>
</li>
<li><p>CAS(Compare-and-Swap)当且仅当内存中变量的值等于旧预期值时才会写入新的值，原理基于MESI协议：</p>
</li>
<li><ul>
<li>CAS翻译的汇编指令时：lock cmpxchg a,b,c</li>
<li>例如core0和core1同时执行针对同一地址的CAS指令</li>
<li>实际上他们是在试图修改每个core自己持有的cache line</li>
<li>假设两个core各自对应的cache line状态都是S，这时如果要想成功修改,就首先需要把S转为E或者M, 则需要是的其它core invalidate这个地址的cache line</li>
<li>则两个core都会向ring bus发出 invalidate这个操作, 那么在ringbus上就会根据特定的设计协议仲裁是core0,还是core1能赢得这个invalidate</li>
<li>胜者完成操作, 失败者需要接受结果, invalidate自己对应的cacheline,再读取胜者修改后的值, 回到起点</li>
</ul>
</li>
<li><p><strong>对于CAS操作来说, 其实锁并没有消失,只是转移到了ring bus的总线仲裁协议中**</strong>. 而且大量的多核同时针对一个地址的CAS操作会引起反复的互相invalidate 同一c**<strong>ache line**</strong>,同样会降低性能**</p>
</li>
<li><p><strong>CAS对应的汇编命令</strong></p>
</li>
<li><ul>
<li>单核CPU时CAS翻译的汇编命令没有lock，即：cmpxchg a,b,c ，这个操作也是原子性的</li>
<li>多核时使用命令增加lock是让总线仲裁器工作，决定执行哪个核的CAS操作</li>
<li>单CPU系统中，CAS通常只需要很少的时钟周期，多CPU系统中需要10-150个时钟周期</li>
<li>一个经验法则：大多数处理器上，无竞争的锁获取和释放的“快速代码路径”上的开销，大约是CAS开销的两倍</li>
<li>但是CAS可以实现更细粒度的操作，所以我相信实际使用肯定不是慢2倍</li>
</ul>
</li>
<li><p><strong>CAS与ABA问题</strong></p>
</li>
<li><ul>
<li><strong>CAS不会导致ABA问题，但是CAS没法发现ABA问题</strong></li>
<li>实际上CAS和cmpxchg压根就没处理过ABA问题。严格来说CAS就不会有ABA的问题，它只是一个简单的，原子的”比较-设置值”的指令而已</li>
<li>ABA问题的危害</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>如果CAS操作的是链表头，ABA问题使得链表后面的元素发生了变化，但是链表头没变，这样就会出现问题</li>
<li>大部分情况下ABA并不影响并发的正确性</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>解决ABA问题，需要上层代码来处理，如使用版本戳</li>
</ul>
</li>
<li><p><strong>CAS可能会造成饥饿，如果多个线程修改对同一个变量执行CAS操作的话</strong></p>
</li>
<li><p>CAS的特性使得他称为实现任何高层“锁”的必要的构建。几乎所有的“锁”，如Mutex，ReentrantLock等都得用CAS让线程先原子性的抢到一个东西（比如一个队列的头部——阻塞队列），然后才能维护其他锁相关的数据</p>
</li>
<li><p><strong>CAS与volatile相同与区别：</strong></p>
</li>
<li><ul>
<li>volatile修饰的变量翻译成汇编后会多以来一个命令：<strong>lock addl $0x0,(%esp)</strong> </li>
</ul>
</li>
<li><ul>
<li><ul>
<li>执行一个lock修饰的给寄存器+0的空命令，目的是利用lock的性质，锁缓存然后将本CPU的Cache写入内存</li>
<li>这里完全没有考虑并发问题，就单纯的锁住缓存行然后写入</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>CAS对应的汇编命令是：<strong>lock cmpxchg …</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>不仅使用了lock，还有cmpxchg，多了一个对竞态条件的检测，考虑到并发问题了</li>
<li>volatile不能满足原子性，因为根本没考虑到并发，而CAS的目的就是解决并发，所以满足原子性</li>
<li>使用lock语句就会满足可见性和有序性（不难理解，详见笔记《Java内存模型与线程》)</li>
<li><strong>那么：</strong>CAS满足原子性+可见性+有序性</li>
<li>synchronized可以广义上满足这三个条件，但是synchronized代码块内部不满足有序性</li>
</ul>
</li>
</ul>
</li>
<li><p>应用：多线程执行i++</p>
</li>
<li><ul>
<li>主要问题是让i++操作具备原子性，用synchronized肯定可以，但是使用CAS性能更好</li>
<li>JDK1.5以后sun.misc.Unsafe类中的compareAndSwapInt()和compareAndSwapLong()等几个方法包装提供CAS操作</li>
<li>这个类需要使用Bootstrap ClassLoader加载才可以访问，所以一般使用J.U.C包里的整数原子类其中的compareAndSet()和getAndIncrement()等方法间接使用Unsafe类的CAS操作</li>
</ul>
</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicTest</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AtomicInteger i=<span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i.incrementAndGet();<span class="comment">//使用原子类的incrementAndGet()方法间接调用compareAndSet()</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREADS_COUNT=<span class="number">20</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws Exception</span>&#123;</span><br><span class="line">        Thread[] threads=<span class="keyword">new</span> Thread[THREADS_COUNT];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;THREADS_COUNT;i++)&#123;</span><br><span class="line">            threads[i]=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">                @Overrie</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>()&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">                        increase();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)</span><br><span class="line">            Thread.<span class="built_in">yield</span>();<span class="comment">//等待执行完成</span></span><br><span class="line">        System.out.<span class="built_in">println</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li>能实现原子性是调用了incrementAndGet()方法，源码：</li>
</ul>
</li>
</ul>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> incrementAndGet()&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;<span class="comment">//对应CAS操作不成功无限循环</span></span><br><span class="line">        <span class="keyword">int</span> current =get();</span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">next</span>=current+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(compareAndSet(current,<span class="keyword">next</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h3><p>保证线程安全并不一定需要同步，二者没有因果关系</p>
<ul>
<li><p>可重入代码：任何时刻中断，在返回后都不会出现错误。</p>
</li>
<li><ul>
<li>特点：不依赖存储在堆上的数据和公用的系统资源，用到的状态量都是参数中传入，不调用非可重入的方法等</li>
</ul>
</li>
<li><p>线程本地存储：ThreadLocal，细节在其他并发笔记中</p>
</li>
</ul>
<h1 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h1><h2 id="自旋锁与自适应自旋"><a href="#自旋锁与自适应自旋" class="headerlink" title="自旋锁与自适应自旋"></a>自旋锁与自适应自旋</h2><ul>
<li>许多应用中，共享数据的锁定状态只会持续很短的时间，为了这段时间去挂起和恢复线程并不值得</li>
<li>所以引入自旋锁，通过自旋等待自身避免线程切换的开销</li>
<li>使用自适应的自旋锁的自旋等待时间不固定，由前一次在同一个锁上的自旋时间决定</li>
</ul>
<h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><ul>
<li>通过逃逸分析，如果一段代码中，堆上的所有数据都不会逃逸被其他线程访问到，那就可以把它们当作栈上数据对待，认为是线程私有的，同步加锁自然就不用了</li>
</ul>
<h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><ul>
<li>在<strong>没有多线程竞争的前提下</strong>，减少传统的重量级锁的性能消耗（即<strong>可以多线程交替加锁</strong>）</li>
<li>理解轻量级锁和下面的偏向锁必须理解HotSpot虚拟机的对象的内存布局</li>
</ul>
<h3 id="对象头的内存布局"><a href="#对象头的内存布局" class="headerlink" title="对象头的内存布局"></a>对象头的内存布局</h3><ul>
<li><p>对象头分为两部分信息：</p>
</li>
<li><ul>
<li>第一部分Mark Word：用于存储对象自身运行时数据，如哈希码、GC分代年龄等，32位/64位JVM分别是32bit/64bit</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>Mark Word根据对象的状态复用自己的存储空间</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1266758/1586828407799-ef6dbfba-a2af-4b45-bde8-8a47ec078357.jpeg" alt="image"></li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>第二部分：用于存储指向方法区对象类型数据的指针，如果是数据对象的话还会由一个额外的部分用于存储数组长度</li>
</ul>
</li>
</ul>
<h3 id="轻量级锁的执行过程"><a href="#轻量级锁的执行过程" class="headerlink" title="轻量级锁的执行过程"></a>轻量级锁的执行过程</h3><ul>
<li><p>加锁</p>
</li>
<li><ul>
<li>代码进入同步块时，如果此同步对象没有被锁定(锁标志位为01)，虚拟机首先在当前线程的栈帧中建立一个锁记录(Lock Record)空间，用于存储锁对象目前的Mark Word拷贝</li>
<li>然后，虚拟机使用CAS操作尝试将该对象的Mark Word更新为指向Lock Record的指针，如果操作成功，则这个线程就拥有了该对象的锁，并且锁标志变为00</li>
<li>CAS更新Mark Word操作如果失败了，虚拟机会首先检查对象的Mark Word是否指向当前线程的栈帧，如果是说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程抢占了。</li>
<li>这样轻量级锁就不再有效，要膨胀为重量级锁，锁标志的状态值变为10</li>
</ul>
</li>
<li><p>解锁</p>
</li>
<li><ul>
<li>解锁也是通过CAS操作来进行的，如果对象的Mark Word仍然指向线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程中加锁时复制的<strong>Mark Word替换回来</strong></li>
<li>如果替换成功则整个同步完成了，如果替换失败则说明其他线程尝试过获取该锁，那么释放锁的同时唤醒被挂起的线程</li>
</ul>
</li>
</ul>
<h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><ul>
<li>目的是消除数据在无竞争下的同步原语，和轻量级锁相比连CAS都不做了</li>
<li><strong>偏向锁是在单线程执行代码块时使用的机制</strong>，如果在多线程并发的环境下（即线程A尚未执行完同步代码块，线程B发起了申请锁的申请），则一定会转化为轻量级锁或者重量级锁</li>
<li>引入偏向锁主要目的是：为了在没有多线程竞争的情况下尽量减少不必要的轻量级锁执行路径。因为轻量级锁的加锁解锁操作是需要依赖多次CAS原子指令的，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗也必须小于节省下来的CAS原子指令的性能消耗）</li>
<li>偏向锁设计者<a target="_blank" rel="noopener" href="https://blogs.oracle.com/dave/biased-locking-in-hotspot">Dave Dice</a>原话：一旦设置了偏见锁，该线程便可以对该对象执行lock和unlock操作，而无需诉诸昂贵的原子指令(即CAS) (Once biased, that thread can subsequently lock and unlock the object without resorting to expensive atomic instructions)</li>
</ul>
<h3 id="偏向锁的执行过程"><a href="#偏向锁的执行过程" class="headerlink" title="偏向锁的执行过程"></a>偏向锁的执行过程</h3><ul>
<li>在JVM启动偏向锁情况下(默认启动)，当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为01，同时使用CAS操作把获取到这个锁的的线程ID记录在Mark Word里，如果操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作(例如Locking、unlocking、更新Mark Word等)</li>
<li>当有另外一个线程尝试获取这个锁时，偏向模式结束，后续的同步操作按照轻量级锁执行</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1596512292682-650bf930-4811-4816-bf7b-b5f5f40557ae.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image.png"></li>
</ul>
<h2 id="轻量级锁和偏向锁区别"><a href="#轻量级锁和偏向锁区别" class="headerlink" title="轻量级锁和偏向锁区别"></a>轻量级锁和偏向锁区别</h2><ul>
<li>轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能</li>
<li>偏向锁是锁对象中的对象头包含线程ID</li>
<li>轻量级锁是锁对象中的对象头是一个指向一个线程栈帧的指针</li>
</ul>

        </div>

        
            <section class="post-copyright">
                
                
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>年与时驰，意与日去，遂成枯落，多不接世，悲守穷庐，将复何及</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/JUC/"># JUC</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2020/10/14/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/">Java内存模型与线程</a>
            
            
            <a class="next" rel="next" href="/2020/10/14/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">类加载机制</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© X_ray | Powered by <a href="https://xray1025.top" target="_blank">Xray</a></span>
    </div>
</footer>

    </div>
</body>
</html>
