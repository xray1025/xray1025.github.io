<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JVM | X_ray's blog</title><meta name="keywords" content="Java,JVM"><meta name="author" content="X_ray"><meta name="copyright" content="X_ray"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="一、JVM概述0.JVM作用： ①：将.class字节码文件生成为操作系统指令，传递给操作系统后通过计算机运行。  1.jvm的位置   2.Jvm的整体结构（HotSpot虚拟机）   3.Java代码的执行流程    ①：首先java程序经过前端编译器生成.class字节码文件；   ②：虚拟机将字节码文件生成为对应的操作系统指令   ③：操作系统处理成计算机能够运行的指令  4.jvm的运行">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM">
<meta property="og:url" content="https://xray1025.github.io/2020/10/14/0000.%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/index.html">
<meta property="og:site_name" content="X_ray&#39;s blog">
<meta property="og:description" content="一、JVM概述0.JVM作用： ①：将.class字节码文件生成为操作系统指令，传递给操作系统后通过计算机运行。  1.jvm的位置   2.Jvm的整体结构（HotSpot虚拟机）   3.Java代码的执行流程    ①：首先java程序经过前端编译器生成.class字节码文件；   ②：虚拟机将字节码文件生成为对应的操作系统指令   ③：操作系统处理成计算机能够运行的指令  4.jvm的运行">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2020-10-14T13:45:29.720Z">
<meta property="article:modified_time" content="2020-11-12T01:52:59.946Z">
<meta property="article:author" content="X_ray">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://xray1025.github.io/2020/10/14/0000.%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-11-12 09:52:59'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/null" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">105</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archive/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tag/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/category/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">X_ray's blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archive/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tag/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/category/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JVM</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-10-14T13:45:29.720Z" title="发表于 2020-10-14 21:45:29">2020-10-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-11-12T01:52:59.946Z" title="更新于 2020-11-12 09:52:59">2020-11-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、JVM概述"><a href="#一、JVM概述" class="headerlink" title="一、JVM概述"></a>一、JVM概述</h1><h2 id="0-JVM作用："><a href="#0-JVM作用：" class="headerlink" title="0.JVM作用："></a>0.JVM作用：</h2><p> ①：将.class字节码文件生成为操作系统指令，传递给操作系统后通过计算机运行。 </p>
<h2 id="1-jvm的位置"><a href="#1-jvm的位置" class="headerlink" title="1.jvm的位置"></a>1.jvm的位置</h2><p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096238270_1594978982297-5b94a27f-24c0-4fc2-9743-9202639164db.png" alt="219fc992d2a1c658983097f4874dd06.png"> </p>
<h2 id="2-Jvm的整体结构（HotSpot虚拟机）"><a href="#2-Jvm的整体结构（HotSpot虚拟机）" class="headerlink" title="2.Jvm的整体结构（HotSpot虚拟机）"></a>2.Jvm的整体结构（HotSpot虚拟机）</h2><p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096238161_1595165056570-83f37444-0a7f-4456-8823-c1de088bde3c.png" alt="fb4daaaad358812f41e46fbb30fb049.png"> </p>
<h2 id="3-Java代码的执行流程"><a href="#3-Java代码的执行流程" class="headerlink" title="3.Java代码的执行流程"></a>3.Java代码的执行流程</h2><p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096238156_1594981518143-13b0c554-60fa-49c1-b1ae-6839750466bc.png" alt="8dc485e46117f2b68cf768d1650be8f.png"> </p>
<p> ①：首先java程序经过<a href="">前端</a>编译器生成.class字节码文件； </p>
<p> ②：虚拟机将字节码文件生成为对应的操作系统指令 </p>
<p> ③：操作系统处理成计算机能够运行的指令 </p>
<h2 id="4-jvm的运行周期"><a href="#4-jvm的运行周期" class="headerlink" title="4.jvm的运行周期"></a>4.jvm的运行周期</h2><p> ①启动:通过类引导加载器创建一个初始类来完成； </p>
<p> ②执行：程序开始执行的时候，Jvm启动，程序执行结束的时候，Jvm就停止； </p>
<p> 执行一个java程序的时候，真真正正执行的是一个java虚拟机的进程 </p>
<p> ③停止： </p>
<p> a.程序正常执行结束； </p>
<p> b.程序因为异常终止； </p>
<p> c.程序因为操作系统的异常而终止； </p>
<p> d.自己调用了System类中的exit(）方法使程序退出； </p>
<h1 id="二、类加载子系统-☆"><a href="#二、类加载子系统-☆" class="headerlink" title="二、类加载子系统(☆)"></a>二、类加载子系统(☆)</h1><h2 id="1-作用："><a href="#1-作用：" class="headerlink" title="1.作用："></a>1.作用：</h2><p> 将.class文件加载到内存，并对数据进行检验、解析及初始化，最终形成虚拟机能够直接使用的java类型，加载的类信息存放在方法区中。 </p>
<p> 注：只负责加载，能不能运行，由执行引擎决定。 </p>
<h2 id="2-类加载分为哪些过程："><a href="#2-类加载分为哪些过程：" class="headerlink" title="2.类加载分为哪些过程："></a>2.类加载分为哪些过程：</h2><p> ①加载 </p>
<p> ②连接：验证、准备及解析 </p>
<p> ③初始化 </p>
<h2 id="3-类加载各阶段的作用："><a href="#3-类加载各阶段的作用：" class="headerlink" title="3.类加载各阶段的作用："></a>3.类加载各阶段的作用：</h2><p> ①加载： </p>
<p> a.通过一个类的全限定名来获取此类的二进制字节流； </p>
<p> b.将该二进制字节流所代表的的<strong>静态存储结构</strong>转化为方法区的<strong>运行时数据结构</strong>； </p>
<p> c.在内存中<strong>生成</strong>一个代表该类的<strong>java.lang.Class对象</strong>，作为方法区这个类的数据访问入口。 </p>
<p> ②连接： </p>
<p> a.验证：确保Class文件的字节流（二进制）中包含的信息符合规范，保证这些信息被当做代码运行后不会对虚拟机造成危害。分为：文件格式验证、元数据验证、字节码验证。符号引用验证四个方面。 </p>
<p> b.准备：正式为类的静态变量分配内存并设置初始值（隐式初始化）。 </p>
<p>  <strong>特例</strong>：被final修饰的静态变量在准备阶段会被显式初始化。 </p>
<p> c.解析：Java虚拟机将常量池中的符号引用替换为直接引用。分为：类或接口的解析、字段解析及方法解析、接口方法解析 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096238657_1595297974543-61b880b6-8d89-4325-b88d-c492e1b2356b.png" alt="c5a38f83bd46ecf79801399430030e5.png"> </p>
<p> 如图所示：中间部分即为符号引用；//后面即为直接引用。 </p>
<p> ③初始化：在准备阶段，静态变量已经赋过一次系统要求的初始零值，而在初始化阶段，会根据程序员通过程序编码指定的主观计划去初始化静态变量和其他资源。 </p>
<h2 id="4-简单描述一下-方法"><a href="#4-简单描述一下-方法" class="headerlink" title="4.简单描述一下()方法?"></a>4.简单描述一下<clinit>()方法?</h2><p>  <strong>①定义：<clinit>()方法是由编译器自动收集类中的所有的静态变量的赋值和静态代码块语句合并产生的，没有的话则不会产生。</strong> </p>
<p>  ②顺序：编译器收集的顺序是由语句在源文件中出现的顺序决定，<strong>静态语句块中只能访问到定义在静态语句块之前的静态变量。</strong> </p>
<p>  ③其他： </p>
<p>  <strong>a.java虚拟机会保证在子类的**</strong><clinit>()执行前，父类的**<strong><clinit>()方法已经执行完毕。</strong> </p>
<p>  b.接口中不能使用静态代码块，但是仍然有赋值初始化操作，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法。 </p>
<p>  <strong>c.Java虚拟机必须保证一个类的</strong><clinit>()方法<strong>在多线程的环境中被同步加锁。如果多个线程同时去初始化一个类，必须只能其中一个去执行这个类</strong><clinit>()方法。 </p>
<h2 id="5-类加载器是什么？"><a href="#5-类加载器是什么？" class="headerlink" title="5.类加载器是什么？"></a>5.类加载器是什么？</h2><p>  在类的加载阶段中“通过一个类的全限定名来获取类的二进制字节流”实现这个动作的代码称为类加载器。 </p>
<h2 id="6-类加载器的分类："><a href="#6-类加载器的分类：" class="headerlink" title="6.类加载器的分类："></a>6.类加载器的分类：</h2><p> ①启动类加载器（引导类加载器） </p>
<p> ②扩展类加载器 </p>
<p> ③应有程序类加载器（系统类加载器） </p>
<p> ④自定义类加载器 </p>
<h2 id="7-双亲委派模型"><a href="#7-双亲委派模型" class="headerlink" title="7.双亲委派模型"></a>7.双亲委派模型</h2><p> <strong>1.双亲委派模型的工作过程：</strong> </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096238252_1595230547411-5e0691e3-d438-426a-9f0a-7c5842458afc.png" alt="image.png"> </p>
<p>  <strong>①：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委托给父类的加载器去执行；</strong> </p>
<p>  <strong>②：如果父类加载器还存在父类加载器，则会继续向上委托，请求最终达到顶层的引导类加载器；</strong> </p>
<p>  <strong>③：如果父类引导器可以完成加载任务，则成功返回；否则子加载器会尝试自己执行，这就是双亲委派机制。</strong> </p>
<p> 2.双签委派模型的优势： </p>
<p>  <strong>①：避免类的重复加载；</strong> </p>
<p>  <strong>②：沙箱安全机制：保护程序安全，防止核心类库被随意更改（举例：自定义一个java.lang.String类）</strong> </p>
<h2 id="8-破坏双亲委派模型"><a href="#8-破坏双亲委派模型" class="headerlink" title="8.破坏双亲委派模型"></a>8.破坏双亲委派模型</h2><p> ①第一次“破坏” </p>
<p> 双亲委派机制是在jdk1.2时出现的，因此在jdk1.2之前不满足双亲委派机制，即java.lang.ClassLoader抽象类，用户编写子类，然后能够重写loadClass()方法，这样就破坏了双亲委派机制； </p>
<p> 解决：在ClassLoader中添加了protected的findClass()方法，引导用户重写loadClass()方法时，尽可能重新给这个方法，而不是在loadClass()方法中进行修改。 </p>
<p> ②第二次“破坏” </p>
<p> 缺陷：越基础的类由越上层的类加载器进行加载，但是越基础的类型又需要去调用用户的代码，用户的代码一般由系统类加载器进行加载，这样引导类加载器无法调。 </p>
<p> 解决：线程上下文类加载器，启动类加载器想要调用我们的用户代码时，首先委托给线程上下文类加载器，然后线程上下文类加载器再去调用用户的程序代码。 </p>
<h1 id="三、运行时数据区（☆）"><a href="#三、运行时数据区（☆）" class="headerlink" title="三、运行时数据区（☆）"></a>三、运行时数据区（☆）</h1><h2 id="1-概述："><a href="#1-概述：" class="headerlink" title="1.概述："></a>1.概述：</h2><p> 运行时数据区的结构 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096238192_1595235271575-f488a9a8-7c71-4c2e-b254-96042bd2060e.png" alt="142facffd9e630571232c0e48b7dae6.png"> </p>
<p> 其中：<strong>方法区</strong>和<strong>堆</strong>是线程共享的；程序计数器和本地方法栈及<strong>虚拟机栈</strong>都是每个线程一份 </p>
<h2 id="2-程序计数器"><a href="#2-程序计数器" class="headerlink" title="2.程序计数器"></a>2.程序计数器</h2><p> 2.1程序计数器作用：用于存储下一条字节码指令的地址，<strong>执行引擎</strong>执行完当前指令，根据程序计数器的地址执行下一条指令。 </p>
<p> 2.2程序技术器的特点？ </p>
<p> ①线程私有：每个线程都有自己的程序计数器； </p>
<p> ②当前方法：任何时间一个线程都只有一个方法在执行，程序计数器会存储线程当前执行方法的Jvm指令的地址。 </p>
<p> ③程序计数器的特点：唯一一个没有OOM的内存区域。 </p>
<p>  <strong>2.3为什么需要使用程序计数器来记录当前线程的地址？<br> ①：CPU需要不断切换不同的线程，切换回来需要知道从哪条指令开始。</strong> </p>
<p>  <strong>②：字节码解释器需要知道下一条执行的执行地址。</strong>  </p>
<p>  <strong>2.4为什么要将程序计数器设计为线程私有的？</strong> </p>
<p>  <strong>为了能够准确记录各个线程的当前正在执行的指令地址，最好的办法就是为每一个线程设置一个程序计数器</strong> </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096238248_1595240269784-8cbde4d3-3cb8-4487-89eb-b35dddae6b4a.png" alt="80e5487f0309611166f3944d5681797.png"></strong> </p>
<h2 id="3-Java虚拟机栈"><a href="#3-Java虚拟机栈" class="headerlink" title="3.Java虚拟机栈"></a>3.Java虚拟机栈</h2><h3 id="3-1内存中的堆和栈"><a href="#3-1内存中的堆和栈" class="headerlink" title="3.1内存中的堆和栈"></a>3.1内存中的堆和栈</h3><p> 栈解决<strong>程序</strong>的<strong>运行</strong>问题，<a href="">如程</a>序如何执行，如何处理数据；堆解决<strong>数据存储</strong>问题，数据怎么放，放在哪儿等 </p>
<h3 id="3-2虚拟机栈的作用"><a href="#3-2虚拟机栈的作用" class="headerlink" title="3.2虚拟机栈的作用"></a>3.2虚拟机栈的作用</h3><p>  <strong>①每个线程在创建时都会创建一个虚拟机栈，内存存储一个一个栈帧，正在执行的方法对应着一个一个栈帧。</strong> </p>
<p>  <strong>②主管java程序的运行，保存方法的局部变量（8种基本数据类型及对象的引用地址）、部分结果参与方法的调用及返回。</strong> </p>
<h3 id="3-3虚拟机栈的声明周期"><a href="#3-3虚拟机栈的声明周期" class="headerlink" title="3.3虚拟机栈的声明周期"></a>3.3虚拟机栈的声明周期</h3><p> 与线程一致 </p>
<h3 id="3-4特点："><a href="#3-4特点：" class="headerlink" title="3.4特点："></a>3.4特点：</h3><p> 不存在垃圾回收；但是存在OOM </p>
<h3 id="3-5JVM对虚拟机栈的操作有什么？"><a href="#3-5JVM对虚拟机栈的操作有什么？" class="headerlink" title="3.5JVM对虚拟机栈的操作有什么？"></a>3.5JVM对虚拟机栈的操作有什么？</h3><p>  <strong>①每个方法执行，伴随着入栈。</strong> </p>
<p>  <strong>②方法执行结束出栈。</strong> </p>
<h3 id="3-6虚拟机栈常见两个异常"><a href="#3-6虚拟机栈常见两个异常" class="headerlink" title="3.6虚拟机栈常见两个异常"></a>3.6虚拟机栈常见两个异常</h3><p> ①：stackOverFlow:JVM允许用户自己设置虚拟机栈的大小为固定值，当方法数过多，致使栈帧数量超过虚拟机栈的大小时，就会报stackOverFlow; </p>
<p> ②：OutOfMemoryError：Java虚拟机栈容量允许扩展，当无法申请到足够的内存时，会报OOM异常。 </p>
<h3 id="3-7虚拟机栈运行的原理："><a href="#3-7虚拟机栈运行的原理：" class="headerlink" title="3.7虚拟机栈运行的原理："></a>3.7虚拟机栈运行的原理：</h3><p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096238316_1595249982615-bb92aec8-8688-40af-bc5e-e1c29e31dea3.png" alt="277ca12c3d36fad05eaed7b567d9439.png"> </p>
<p> 如果在当前方法中调用了其他方法，对应新的栈帧会被创建出来，放在栈的顶端，称为当前栈帧 </p>
<h3 id="3-8栈帧的结构"><a href="#3-8栈帧的结构" class="headerlink" title="3.8栈帧的结构"></a>3.8栈帧的结构</h3><p> 局部变量表、操作数栈、动态链接、方法返回地址及一些附加信息； </p>
<h3 id="3-9局部变量表"><a href="#3-9局部变量表" class="headerlink" title="3.9局部变量表"></a>3.9局部变量表</h3><p>  <strong>①：作用</strong> </p>
<p> 局部变量表为定义一个数字数组，<strong>存储方法参数和定义在方法内部的局部变量</strong>。<strong>数字数组中，如果是基本数据类型变量，则存储的是变量值，如果是引用数据类型，则存储的是堆内对象的地址值。</strong> </p>
<p> ②：安全性 </p>
<p> 由于是线程私有的，因此不存在安全问题。 </p>
<p> ③：大小 </p>
<p> 局部变量表的大小是在编译期就确定的，一旦确定，无法修改。 </p>
<p>  <strong>④：声明周期</strong> </p>
<p>  <strong>局部变量表中的变量只在当前的方法调用中有效，一旦方法调用结束，则随着栈帧的出栈，局部变量表随之销毁</strong>。 </p>
<p>  <strong>⑤：与垃圾回收的关系</strong> </p>
<p> 局部变量表中的变量也是垃圾回收的根结点，因为局部变量表中存在指向堆内存的对象的引用地址，一旦栈帧被弹出虚拟机栈，则相应的对象需要被回收，反之，被局部变量表中直接或者间接引用的对象都不会被回收。 </p>
<h3 id="3-10-操作数栈"><a href="#3-10-操作数栈" class="headerlink" title="3.10.操作数栈"></a>3.10.操作数栈</h3><p>  <strong>①**</strong>作用** </p>
<p>  <strong>用于保存计算过程中的中间结果，同时作为变量计算过程中的临时存储空间（可能存在逃逸分析）。</strong> </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096238191_1595295362818-a446a1ba-b6d6-44bf-bc44-b75ea6a6dbcb.png" alt="f980e127c377c44088d9845c59523a8.png"></strong> </p>
<p>  <strong>代码的具体执行过程：</strong> </p>
<p>  <strong>①首先程序计算器中的字节码指令地址为0，然后创建操作数栈，首先将局部变量i的值压入操作数栈，然后此时局部变量表中为空，然后程序计算器中的地址更改为2，执行istore_1指令，即将变量i存储到局部变量表中，然后操作数栈中的15被弹出到局部变量表中，然后继续执行下一条指令。</strong> </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096238566_1595296791418-e4b0c050-4045-44bf-b973-dcbe3f0b782c.png" alt="adc0f74643612cce39bf120aa2aa8f9.png"></strong> </p>
<h3 id="3-11操作数栈的数据结构"><a href="#3-11操作数栈的数据结构" class="headerlink" title="3.11操作数栈的数据结构"></a>3.11操作数栈的数据结构</h3><p>  <strong>底层是由数组来实现的栈，不能通过索引来操作具体的数据，只能是由栈的操作，即出栈和入栈操作。</strong> </p>
<h3 id="3-12操作数栈的创建"><a href="#3-12操作数栈的创建" class="headerlink" title="3.12操作数栈的创建"></a>3.12操作数栈的创建</h3><p> 当一个方法被执行的时候，相应的栈帧也就被创建出来，此时的操作数栈的底层数组时空的，在编译期数组的长度及操作数栈的深度也就被确定了。（<strong>因为数组的长度一旦确认，就不能更改了，只有集合类才存在动态扩容机制</strong>） </p>
<h3 id="4-动态链接"><a href="#4-动态链接" class="headerlink" title="4.动态链接"></a>4.动态链接</h3><p>  <strong>①作用：在Java源文件被编译到字节码文件时，所有的**</strong>变量和方法引用**<strong>都作为符号引用保存在字节码文件的常量池中，动态链接的作用就是转换为调用方法的直接引用（记录在方法区的运行时常量池中的方法的地址）。</strong> </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096238577_1595308822414-9cc80051-12c1-4bf1-93e5-8cf0b25b8ab0.png" alt="7848da45f9123a96fc0954916396bf1.png"></strong> </p>
<p>  <strong>②四种方法调用指令及区分虚方法与非虚方法</strong> </p>
<p>  <strong>③方法重写的本质与虚方法的使用</strong> </p>
<h3 id="5-方法的返回地址"><a href="#5-方法的返回地址" class="headerlink" title="5.方法的返回地址"></a>5.方法的返回地址</h3><p>  <strong>①作用：存放调用该方法的程序计算器的值即调用该方法的下一条指令的地址值。</strong> </p>
<p> ②正常完成出口与异常完成出口 </p>
<p> 正常完成出口:执行引擎遇到任何一个方法返回的字节码指令时，会有返回值传递给上层的方法调用者。 </p>
<p> 异常完成出口：在方法的执行过程中遇到了异常，且没有在本方法内部进行处理，就会退出。 </p>
<p> <strong>6.虚拟机栈面试题</strong> </p>
<p>  <strong>①举例虚拟机栈溢出的情况（StackOverFlow情况）</strong> </p>
<p>  <strong>答：当通过-Xss设置虚拟机栈为固定大小后，当实际运行的栈帧数量超过虚拟机栈的最大深度的时候，就会爆出stackOverFlow错误。</strong> </p>
<p>  <strong>此外还可能存在OOM异常。</strong> </p>
<p>  <strong>②调整虚拟栈的大小能够保证不溢出吗？</strong> </p>
<p>  <strong>答：不能保证，比如说出现不会停止的递归过程，调整虚拟栈的大小也没有什么用，只会让溢出的时间晚一些而已。</strong> </p>
<p>  <strong>③虚拟机栈的大小是越大越好吗？</strong> </p>
<p>  <strong>答：肯定不是的，挤占其他的内存空间。</strong> </p>
<p>  <strong>④垃圾回收是否涉及到虚拟机栈？</strong> </p>
<p>  <strong>不会</strong> </p>
<p>  <strong>⑤方法中定义的局部变量是否是线程安全的？</strong> </p>
<p>  <strong>具体问题具体分析：</strong> </p>
<p>  <strong>线程安全的情况：如果是单个线程或者说在方法内部创建内部消亡的话，则是线程安全的，</strong> </p>
<p>  <strong>线程不安全的情况：多个线程共享这个局部变量时有可能存在线程安全问题。</strong> </p>
<h2 id="4-本地方法栈"><a href="#4-本地方法栈" class="headerlink" title="4.本地方法栈"></a>4.本地方法栈</h2><p>  <strong>①虚拟机栈与本地方法栈的区别：</strong> </p>
<p>  <strong>虚拟机栈用于管理Java方法的调用，而本地方法栈用于本地方法的调用。</strong> </p>
<p>  <strong>②本地方法</strong> </p>
<p>  <strong>本地方法是有C、C++等语言编写的，是Java的拓展方法库。</strong> </p>
<p> ③其他 </p>
<p> 本地方法栈是线程私有的，Hot Spot虚拟机中将其和虚拟机栈合二为一。 </p>
<h2 id="5-堆"><a href="#5-堆" class="headerlink" title="5.堆"></a>5.堆</h2><h3 id="1-堆空间的概述"><a href="#1-堆空间的概述" class="headerlink" title="1.堆空间的概述"></a>1.堆空间的概述</h3><p>  <strong>①一个JVM实例对应着一个堆内存；</strong> </p>
<p>  <strong>②堆是进程私有的，是线程共享的；</strong> </p>
<p>  <strong>③堆随着JVM的启动而创建，堆大小一旦创建完成就不能更改；</strong> </p>
<p>  ④堆内存的大小是可以调节的。 </p>
<p>  ⑤堆在物理上是不连续的，但是在逻辑上连续的； </p>
<p> <strong>2.TLAB（Thread Local Allocation Buffer）</strong> </p>
<p> 堆是线程共享的，但是在堆中存在线程私有的缓冲区。 </p>
<p> <strong>3.作用：几乎所有的对象实例及数组都在堆分配内存</strong> </p>
<p>  <strong>数组和对象可能永远不会存储在虚拟机栈上，因为栈帧中保存的是指向堆空间的对象或者数组的地址值。</strong> </p>
<p> <strong>4.与垃圾回收的关系</strong> </p>
<p> 是垃圾回收的重点区域； </p>
<p> 在方法结束后，堆中的对象不会马上被清除，需要GC进行判断。 </p>
<p> 5.堆内存细分 </p>
<p> jdk1.7之前将堆分为：新生代+老年代+永久代；jdk1.8之后将堆从逻辑上分为：新生代+老年代+元空间 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096238519_1595490148979-ef7ad32e-cd7e-4187-a771-289177ec348c.png" alt="ed0d5bba47d31cbb470884da08e9522.png"> </p>
<p> 6.堆空间的内部结构 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096238526_1595491986858-f7e25c8a-1e34-4bb6-854a-e03581ca1a83.png" alt="1423f4c548f9718044745337328c3af.png"> </p>
<p> 注：永久代/元空间其实是归于方法区管理，堆实际上只负责前两部分（新生代+老年代） </p>
<h3 id="2-设置堆内存的大小及OOM问题"><a href="#2-设置堆内存的大小及OOM问题" class="headerlink" title="2.设置堆内存的大小及OOM问题"></a>2.设置堆内存的大小及OOM问题</h3><p>  <strong>①：设置堆内存大小</strong> </p>
<p>  <strong>a.-Xms：设置堆空间（新生代+老年代）的起始内存大小</strong>  </p>
<p>  <strong>b.-Xmx：设置堆空间（新生代+老年代）的最大内存大小</strong> </p>
<p> 补充：-X是虚拟机的运行参数；ms:memory size的意思 </p>
<p> c.默认的堆空间的起始内存大小：电脑运行内存的大小/64；默认的堆空间的最大内存大小：电脑运行内存的大小/4； </p>
<p> ②OOM问题 </p>
<p> 当堆内存使用超过设置的最大堆内存时，会出现OOM异常 </p>
<p> OOM举例： </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096238793_1595494302236-9eb265ce-5e0b-49ae-b3ec-534f6bd13b51.png" alt="22ce6927f98dbeaa86ce47926fabca8.png"> </p>
<p> 过程：创建了一个List数组，然后不断向数组中添加Picture对象，然后逐渐内存就被占满了后，会出现OOM异常 </p>
<h3 id="3-新生代与老年代"><a href="#3-新生代与老年代" class="headerlink" title="3.新生代与老年代"></a>3.新生代与老年代</h3><p>  <strong>①什么是年轻代？什么是老年代？</strong> </p>
<p>  <strong>存储在堆中的Java对象可以分类两类，一类是新生代，一类是老年代；</strong> </p>
<p>  <strong>新生代：一类是声明周期较短的瞬时对象，这类对象从创建到消亡时间较短暂；新生代包括伊甸园区，两个幸存区</strong> </p>
<p>  <strong>老年代：一类对象的声明周期比较长，在极端情况下还可能与JVM的声明周期一致；</strong> </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096238635_1595495493822-2a498574-fa89-4520-a13d-c4a271bc371c.png" alt="2d29b29a4f6252d1f150f376dc54507.png"></strong> </p>
<p> ②新生代与老年代的默认内存比例 </p>
<p> 默认的新生代与老年代的比例是1：2 </p>
<p> ③HotSpot虚拟机中，新生代与Sur<a href="">vivo</a>r的比例是多少？ </p>
<p> 通过-XX:Sur<a href="">vivo</a>rRatio的值进行调节；<strong>默认的是8：1：1；实际使用时不为8：1：1，因为存在自适应内存分配策略（默认开启）</strong> </p>
<p> ④<strong>几乎所有的</strong>Java对象都是在Eden区被new出来（如果对象查过Eden大小，则直接进入老年代）；绝大部分的java对象销毁都发生在新生代； </p>
<h3 id="4-对象内存分配的一般过程（垃圾回收的一般过程）"><a href="#4-对象内存分配的一般过程（垃圾回收的一般过程）" class="headerlink" title="4.对象内存分配的一般过程（垃圾回收的一般过程）"></a>4.对象内存分配的一般过程（垃圾回收的一般过程）</h3><p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096238902_1595497907218-66a96095-0fac-43c2-83ed-93d695988e13.png" alt="5aaac71ce942af6b38055595bbb8b1c.png"> </p>
<p>  <strong>a.：new出来的对象会被存储在伊甸园区，然后当伊甸园区的空间被占满后，此时会YGC，将没有被其他对象所引用的对象进行回收，然后将伊甸园区剩余对象加载到Sur<a href="">vivo</a>r0区（from区），并将年龄标记为1，再加载新的对象放在伊甸园区。</strong> </p>
<p>  <strong>b.：如果再次触发YGC垃圾回收，上次放在幸存者0区的对象会放在幸存者1区，年龄标记+1.然后伊甸园区幸存下来的对象会被放到幸存者1区，年龄标记为1，然后幸存者1区变为from区，幸存者0区变为to区；</strong> </p>
<p>  <strong>c.：如果再次发生YGC，则会重复此过程，当from区的幸存对象的标记年龄超过15后，则会移动到老年代中；如果存在着大于伊甸园区的对象，则会直接进入到老年代中；当老年代内存不足时，会触发GC，进行老年代回收；</strong> </p>
<p> 总结：对幸存者1区2区：<strong>复制后交换</strong>，谁空谁为to区；频繁在新生代收集，较少在老年代收集，几乎不在永久代/元空间收集 </p>
<h3 id="5-对象内存分配特殊情况（当出现超大对象的情况时）："><a href="#5-对象内存分配特殊情况（当出现超大对象的情况时）：" class="headerlink" title="5.对象内存分配特殊情况（当出现超大对象的情况时）："></a>5.对象内存分配特殊情况（当出现超大对象的情况时）：</h3><p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096238742_1595506311836-59ce7019-0c1a-480b-ab04-0b73e16c2e78.png" alt="c2c08a7c182ca524de7232e7f06153a.png"></strong> </p>
<h3 id="6-Minor-GC和Major-GC和Full-GC"><a href="#6-Minor-GC和Major-GC和Full-GC" class="headerlink" title="6.Minor GC和Major GC和Full GC"></a>6.Minor GC和Major GC和Full GC</h3><p>  <strong>1.三者的区别</strong> </p>
<p>  <strong>部分收集(Partial GC)：不是完整收集整个java堆的垃圾收集</strong> </p>
<p>  <strong>①：新生代收集（Minor GC/Young GC）:只是新生代的垃圾收集</strong> </p>
<p>  <strong>②：老年代收集（Major GC/Old GC）:只是老年代的垃圾收集</strong> </p>
<p>  <strong>目前只有**</strong>CMS**<strong>垃圾收集器**</strong>才有单独的老年代的收集** </p>
<p>  <strong>③：混合收集：收集整个新生代和部分老年代的垃圾收集</strong> </p>
<p> 目前只有G1垃圾收集器具备混合收集（因为它是基于region的垃圾收集） </p>
<p>  <strong>整堆收集（Full GC）：完整收集java堆及方法区的垃圾收集</strong> </p>
<p>  <strong>2.Minor GC</strong> </p>
<p>  <strong>①触发条件：当伊甸园区满了，就会触发Minor GC,回收整个年轻代的垃圾（s0和s1区满不会触发Minor GC）</strong> </p>
<p>  <strong>②触发后果：当进行Minor GC时，会造成STW（Stop The World）,会停止运行用户其他线程。</strong> </p>
<p>  <strong>3.Major GC</strong> </p>
<p>  <strong>①触发条件：当老年代的内存空间不足时，会优先触发Minor GC,如果之后还不足，则会触发Major GC</strong> </p>
<p>  <strong>②触发后果：Major GC比Minor GC的速度要慢十倍以上，造成更长时间的STW。</strong> </p>
<p>  <strong>4.Full GC</strong> </p>
<p>  <strong>①：触发条件：</strong> </p>
<p>  <strong>a.调用System.gc()时，系统建议执行Full GC；</strong> </p>
<p>  <strong>b.老年代的空间不足；</strong> </p>
<p>  <strong>c.方法区的空间不足时。</strong> </p>
<h3 id="7-堆空间的分代思想"><a href="#7-堆空间的分代思想" class="headerlink" title="7.堆空间的分代思想"></a>7.堆空间的分代思想</h3><p>  <strong>1.为什么分为新生代和老年代（面试重点）</strong> </p>
<p>  <strong>不同对象的生命周期是不同的，70%-90%的对象的生命周期是短暂的，在新生代主要存放生命周期短暂的对象，在老年代存放新生代中经过多次垃圾回收之后依然没有没有被回收的对象，这样做主要是为了优化GC的性能，如果不分新生代和老年代，而是将对象都放在一起，则每次GC的时候都要遍历整个堆空间，会造成STW的时间较长，影响用户性能体验。</strong> </p>
<h3 id="8-内存分配策略"><a href="#8-内存分配策略" class="headerlink" title="8.内存分配策略"></a>8.内存分配策略</h3><p>  <strong>a.优先分配到新生代</strong> </p>
<p>  <strong>b.大对象直接分配到老年代；</strong> </p>
<p>  <strong>c.长期存活的对象（s0，s1区中年龄计算器值超过设定阈值或默认阈值15）分配到老年代；</strong> </p>
<p>  <strong>d.动态对象年龄判断：如果Sur<a href="">vivo</a>r区中相同年龄的对象的总和大于等于Sur<a href="">vivo</a>r区的一半，则大于等于该年龄的对象直接进入到老年代中。</strong> </p>
<p>  <strong>补充：大对象直接进入到老年代代码（创建大小为20M的数组，设定堆空间的初始内存和最大内存都为60M，然后设置新生代与老年代的比例为1：2，即老年代40M，新生代20M，然后设定伊甸园区与幸存者区比例为8：1：1，则伊甸园区16M，不足以放下20M的数组）</strong> </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096239094_1595556640996-2e0e9eaa-7064-4fc6-99bd-c6696a898ed9.png" alt="82589a5000c758b289c0737e92395cb.png"></strong> </p>
<h3 id="9-TLAB（Thread-Local-Allocation-Buffer-线程私有缓存区）"><a href="#9-TLAB（Thread-Local-Allocation-Buffer-线程私有缓存区）" class="headerlink" title="9.TLAB（Thread Local Allocation Buffer:线程私有缓存区）"></a>9.TLAB（Thread Local Allocation Buffer:线程私有缓存区）</h3><p>  <strong>1.什么是TLAB？</strong> </p>
<p>  <strong>jvm在伊甸园区为每一个线程开辟了一块私有的缓存区，每个TLAB只占伊甸园区的1%，JVM将TLAB作为内存分配的首选</strong> </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096238863_1595557782607-7be773a5-4b43-46e7-80d2-24642905da8e.png" alt="975488eb886480bbd9dd1e537a074c9.png"></strong> </p>
<p>  <strong>2.为什么要有TLAB?</strong> </p>
<p>  <strong>因为堆空间是线程共享的，如果存在多个线程同时访问堆空间的某个对象，则可能会造成线程安全问题，可以采用加锁机制实现同步处理，但是会影响分配速度，因此采用TLAB的方式解决。</strong> </p>
<p> 3.TLAB补充 </p>
<p> a.尽管不是所有的对象都在TLAB分配内存，但是JVM会优先在TLAB为对象分配内存； </p>
<p> b.当TLAB内存空间不足时，会采用同步加锁机制在伊甸园其他区域分配内存，确保数据操作的原子性。 </p>
<p> 10.堆空间的参数设置(后期补充) </p>
<h3 id="11-堆是分配对象存储的唯一选择吗？"><a href="#11-堆是分配对象存储的唯一选择吗？" class="headerlink" title="11.堆是分配对象存储的唯一选择吗？"></a>11.堆是分配对象存储的唯一选择吗？</h3><p> 1.该问题 </p>
<p> 随着即时编译器的发展与逃逸分析技术的不断成熟，虚拟机<strong>栈上分配</strong>等技术的出现，使得对象分配在堆上就没有那么绝对了。 </p>
<p>  <strong>如果经过逃逸分析后发现，一个对象并没有逃逸出方法的话，则有可能会被优化成栈上分配。</strong> </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096238945_1595560039247-2cc3146c-22ef-439a-9f07-94c9c085b1bb.png" alt="15168d871b56754cd098b11727f722d.png"></strong> </p>
<p> 2.简述逃逸分析（只知道什么逃逸分析即可）？ </p>
<p>  <strong>①什么是逃逸分析？</strong> </p>
<p>  <strong>如果将堆上的对象分配到栈的话，需要使用逃逸分析技术。</strong> </p>
<p>  <strong>虚拟机能够通过分析来判断对象的引用范围是否在方法内部，从而决定是否将对象份分配到堆上。</strong> </p>
<p>  <strong>②如何判断是否发生了逃逸？</strong> </p>
<p>  <strong>如果一个对象在方法中被定义后，对象只在方法内部进行使用，则认为没有发生逃逸。</strong> </p>
<p>  <strong>如果一个对象在方法内被定义后，对象被外部方法所引用，则认为发生了逃逸。</strong> </p>
<h2 id="6-方法区"><a href="#6-方法区" class="headerlink" title="6.方法区"></a>6.方法区</h2><h3 id="1-堆、栈和方法区的交互关系"><a href="#1-堆、栈和方法区的交互关系" class="headerlink" title="1.堆、栈和方法区的交互关系"></a>1.堆、栈和方法区的交互关系</h3><p> ①内存层面 </p>
<p>  <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096239226_1595564024898-a68373ed-edbc-434a-a81a-755bcc1e9ba7.png" alt="b8cae0b5fe97f06a7f71ba3a407f565.png">  </p>
<p>  运行时数据区（Runtime Data Region）主要包括虚拟机栈、堆及方法区（jdk1.8后称为元空间）、程序技术器及本地方法栈。 </p>
<p> ②线程共享层面 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096239011_1595564191837-dbc6a07a-fc20-4177-a96f-11a49f49247c.png" alt="07b2006e0f6d411a73bfae16720d85a.png"> </p>
<p> 线程共享：堆和方法区 </p>
<p> 堆：GC的重点回收区，如果内存不足会报出OOM </p>
<p> 方法区：GC也会对此部分进行回收，回收的频率极低；内存不足时也会报出OOM </p>
<p> 线程私有：程序计数器、虚拟机栈及本地方法栈 </p>
<p> 程序奇数器：无GC、无异常； </p>
<p> 虚拟机栈：无GC，存在异常：StackOverFlow(栈溢出) </p>
<p> 本地方法栈：无GC，存在异常：StackOverFlow(栈溢出) </p>
<p>  <strong>③创建对象层面</strong> </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096239412_1595564454971-0b4da657-7ef5-48d1-9864-2885c195a9ac.png" alt="92e185030600f9f18c3bad3412bd303.png"></strong> </p>
<p>  如上图所示：Person类信息会存储在方法区当中，而person变量如果定义在方法内，则会存储在虚拟机栈的栈帧的局部变量表中，而右侧的new出来的对象则会存放在堆中； </p>
<p>  下面这个图为：虚拟机栈中存储着对象的引用地址，指向位于堆空间对象的实例，而堆空间中对象实例数据中包含指向存储在方法区的对象类型数据的指针。 </p>
<h3 id="2-方法区的理解"><a href="#2-方法区的理解" class="headerlink" title="2.方法区的理解"></a>2.方法区的理解</h3><p> <strong>1.jdk1.8前后的不同</strong> </p>
<p>  <strong>①：jdk1.8之前为永久代；jdk1.8之后称为元空间（MetaSpace）</strong> </p>
<p>  <strong>②：永久代处于虚拟机中的内存中，而元空间不在虚拟机设置的内存中，使用本地内存</strong> </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096239149_1595574759693-c43c17c1-309d-469d-a6ab-3a23699b05e3.png" alt="71afdd02df8339be856dbc88a9f8103.png"></strong> </p>
<p> <strong>2.补充知识点</strong> </p>
<p>  <strong>a.作用：保存类信息相关信息；</strong> </p>
<p>  b.声明周期：随着JVM的创建而创建，随着JVM的关闭而死亡； </p>
<p>  c.异常：方法区的大小决定了系统可以创建多少个类，如果创建过多的类，导致方法区溢出，就会出现OOM； </p>
<p> d.线程：是多个线程共享的区域； </p>
<h3 id="3-调节方法区的大小和OOM"><a href="#3-调节方法区的大小和OOM" class="headerlink" title="3.调节方法区的大小和OOM"></a>3.调节方法区的大小和OOM</h3><p>  <strong>1.元空间的默认大小和设置方式</strong> </p>
<p>  <strong>a.默认大小：**</strong>初始默认大小为**<strong>：21M**</strong>；**<strong>最大显示为**</strong>-1**<strong>，即**</strong>没有限制** </p>
<p>  <strong>b.设置：初始内存大小：-XX:MetaspaceSize=想设置的值；最大内存大小：MaxMetaspaceSize=设置值；</strong> </p>
<p>  <strong>2.如何解决OOM问题（后期补充）：</strong> </p>
<p> ①：内存泄露与内存溢出？ </p>
<p> ②如何解决OOM？ </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096239528_1595577955946-1cf61529-bdf7-448a-9291-347ab050c141.png" alt="b474220dab442458f16ea55353556bd.png"> </p>
<h3 id="4-方法区的内部结构"><a href="#4-方法区的内部结构" class="headerlink" title="4.方法区的内部结构"></a>4.方法区的内部结构</h3><p> <strong>1.方法区中都存储哪些信息？</strong> </p>
<p>  <strong>a.类信息</strong> </p>
<p>  <strong>①：类的名称（包名.类名）</strong> </p>
<p>  <strong>②：父类名称</strong> </p>
<p>  <strong>③：修饰符信息</strong> </p>
<p> ④：接口的有序列表 </p>
<p> ⑤：… </p>
<p>  <strong>b.常量</strong> </p>
<p>  <strong>c.静态变量（存在问题）</strong> </p>
<p>  <strong>被static修饰的变量或者静态代码块（jdk1.7之后，静态变量存储在堆空间中）</strong> </p>
<p>  <strong>d.即时编译器代码缓存</strong> </p>
<p>  <strong>将热点代码存储在方法区中，解释为机器指令后并不执行，以做备用</strong> </p>
<p>  <strong>e.域信息（属性等）</strong> </p>
<p>  <strong>域的修饰符、类型及域的名称等信息</strong> </p>
<p>  <strong>f.方法信息（方法的）</strong> </p>
<p>  <strong>方法的名称、修饰符、返回值类型、参数的类型及个数、异常表信息及字节码信息等</strong> </p>
<p>  <strong>示例代码：</strong> </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096239222_1595579280305-7661c404-cb8d-4123-abb6-cb3e7ce3c871.png" alt="ef4c97c1aa47a5150189a848001fb0b.png"></strong> </p>
<p>  <strong>方法区的存储信息（示例中）：</strong> </p>
<p> ①类型信息 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096239291_1595579583771-8127ee7f-52d3-495f-907e-f81033fa4281.png" alt="d3787e45ade1c7a0bf2b99f640c2062.png"> </p>
<p> ②域信息 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096239378_1595579601684-0fbde0af-2272-47b1-a88f-4e795c478205.png" alt="5a045b3d9e2356185adeb0fd30b3e37.png"> </p>
<p> ③方法信息 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096239517_1595579618769-9c8ecb53-213a-4ce5-86c6-434c4055a961.png" alt="a913ead9a97cd623c2b7f7c3d8acb29.png"> </p>
<p> 2.反编译字节码文件的方法 </p>
<p> ①：找到字节码所在的文件位置，然后调用javap -v -p 类名.class </p>
<p> ②：通过jclasslib插件 </p>
<p> <strong>3.运行时常量池</strong> </p>
<p>  <strong>a.什么是运行时常量池？</strong> </p>
<p>  <strong>.class字节码文件中的常量池用于存放编译后的各种字面量及符号引用，在加载类和接口到虚拟机后，这部分内容就转为了运行时常量池。</strong> </p>
<p>  <strong>b.为什么需要常量池？</strong> </p>
<p>  <strong>常量池中包含了类中各种字面量及对类型、方法及域的各种符号引用，这样可以有效减少字节码文件的大小。</strong> </p>
<p> 4.举例说明方法区的使用过程 </p>
<p> 代码： </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096239479_1595585471775-d759def1-1188-4fa3-b3b5-ed80a3837038.png" alt="461419283deb47bed84469caa83ab56.png"> </p>
<p> 字节码文件中的常量池： </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240135_1595586298053-96f2f45d-5293-497e-a989-3938ed6e1b0f.png" alt="af5f95c46a761cccab9293160938bdc.png"> </p>
<p> 程序实现的具体方法区及虚拟机栈的过程 </p>
<h3 id="5-方法区在jdk6和jdk7及jdk8的不同（重点）？"><a href="#5-方法区在jdk6和jdk7及jdk8的不同（重点）？" class="headerlink" title="5.方法区在jdk6和jdk7及jdk8的不同（重点）？"></a>5.方法区在jdk6和jdk7及jdk8的不同（重点）？</h3><p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096239553_1595585938024-f7150ec1-bff4-4e11-9256-f2d5d65fbd34.png" alt="d37808d57c2b4ac5d1abca5d2afcba4.png"></strong> </p>
<p> jdk1.6：静态变量存放在永久代上，字符串常量池存放在运行时常量池中 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096239700_1595586016957-3e16f958-69c8-4e55-af9e-022b49081fef.png" alt="9ef9a72533903bd4455ba8ed01b51f0.png"> </p>
<p> jdk1.7：逐渐已经放弃“永久代”，<strong>静态变量</strong>和<strong>字符串常量池</strong>存放在<strong>堆</strong>上 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096239758_1595586113088-73e4b170-34dc-4442-a8c2-2de8d8b4b5b3.png" alt="45abfbf4ab92d7b3fe515afa9d74f02.png"> </p>
<p> jdk1.8及以后，永久代被元空间取代，整体从JVM设置内存中移动到本地内存中，但是静态变量和字符串常量池依然保存在堆中。（在jdk1.7的基础上将方法区拿到本地内存中为元空间）。 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096239665_1595586264023-6dd6201c-24d2-4180-9b32-251dac620973.png" alt="b873b5a6ba3f00e6084800ae34b3a88.png"> </p>
<p> 6.永久代替换为元空间的好处有哪些？ </p>
<p> ①：永久代的大小比较有限，而元空间是基于本地内存，相对更大，因此OOM的发生的几率就越小； </p>
<p> ②：对永久代的调优更加困难，因此当方法区空间不足时，会引起Full GC,类型的卸载条件相当苛刻，因此尽量保证不发生Full GC。 </p>
<p> <strong>5.方法区的垃圾回收</strong> </p>
<p>  <strong>1.回收的主要对象（内容）是什么？</strong> </p>
<p> 常量池中<strong>废弃的常量</strong>（包括字面量和符号引用）及<strong>不再使用的类型</strong>； </p>
<p> 2.常量的回收策略？ </p>
<p>  <strong>常量池中的常量没有被任何对象所引用，则会被回收</strong> </p>
<p>  <strong>3.判定类不再被使用的条件？</strong> </p>
<p>  <strong>a.该类的所有实例都已经被回收</strong> </p>
<p> b.加载该类的类加载器已经被回收 </p>
<p> c.该类对应的大的Class对象没有被引用。 </p>
<h3 id="6-对象的实例化与访问"><a href="#6-对象的实例化与访问" class="headerlink" title="6.对象的实例化与访问"></a>6.对象的实例化与访问</h3><p> 1.对象的实例化 </p>
<p> ①：<strong>对象的创建方式</strong>： </p>
<p> <img src="https://uploadfiles.nowcoder.com/images/20201111/849965361_1605098533143_4DAA5E86F28EC78A300E16A0EFA13752" alt="img"> </p>
<p> <strong>②：对象的创建/实例化的步骤（Object obj=new Object()的整个过程）（面试重点）**</strong>：** </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096239773_1595642846333-844eae5b-20de-4c1d-a30f-890698d97363.png" alt="73acdcb8de4c60fde69ab1d074a7788.png"></strong> </p>
<p>  <strong>a.加载对象的类型信息</strong> </p>
<p>  <strong>b.为对象分配内存</strong> </p>
<p> 分配策略： </p>
<p> 指针碰撞： </p>
<p> 空闲列表： </p>
<p>  <strong>c.处理并发安全问题</strong> </p>
<p> CAS<a href="">算法</a>和加锁机制 </p>
<p>  <strong>d.属性的默认初始化</strong> </p>
<p> 非静态变量 </p>
<p>  <strong>e.设置对象头信息</strong> </p>
<p> 对象头中的信息包含指向方法区类型等信息的指针 </p>
<p>  <strong>f.执行init方法进行初始化</strong> </p>
<p> 属性的显式初始化 </p>
<p> 代码块的初始化 </p>
<p> 构造器中的初始化 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096239768_1595642929467-9d5bdbaa-88d2-47d7-8584-6963d7c7c775.png" alt="233d64d2cf31330548a6d3faf51fb48.png"> </p>
<h3 id="2-对象的内存布局"><a href="#2-对象的内存布局" class="headerlink" title="2.对象的内存布局"></a>2.对象的内存布局</h3><p> ①：对象的内存布局包含哪些？每部分的作用展开叙述 </p>
<p>  <strong>a.对象头（面试重点）</strong> </p>
<p>  <strong>运行时元数据：主要包含对象的哈希值、GC分代年龄（from区向to区移动，分代年龄+1）、锁信息等</strong> </p>
<p> 类型指针：指向方法区（元空间）的类元数据，确定对象所属的类 </p>
<p>  <strong>数组长度（如果为数组对象）</strong> </p>
<p> b.实例数据 </p>
<p> 它是对象真正存储的有效信息，包括程序中定义的各种字段（包括从父类继承下来的和自己拥有的字段） </p>
<p> c.对齐填充 </p>
<p> 任何对象的大小都是8字节的整数倍，如果实例数据不满足，采用对齐填充进行补齐 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096239955_1595644982536-f2acfafc-b1a1-4e2b-a904-8f0ee555fa15.png" alt="f4338c7a1776bab3540b77c14477ca4.png"> </p>
<p> ②举例子说明该过程（定义一个Customer类，然后里面有属性，代码块，调用另外一个类来创建类实例，然后创建该类的对象/实例） </p>
<p> 代码如下： </p>
<p> 创建类： </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096239912_1595645223504-4bdd33d9-fe3e-4d1f-8a3c-797313662605.png" alt="6e1fc1a3a23f08b97355da3531f0748.png"> </p>
<p> 创建类的对象/实例： </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096239895_1595645315840-34641235-01d0-4e4a-9910-8daf0409987d.png" alt="c2a54bc8d4b0fe37e196ec3bf04ef47.png"> </p>
<p> 整个内存情况： </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240039_1595645370085-bc66bb68-63fb-49c8-b549-ae0ce38c9d0a.png" alt="de8568ea309f04ddd600f6cfad44b55.png">过程： </p>
<h3 id="3-对象的访问定位"><a href="#3-对象的访问定位" class="headerlink" title="3.对象的访问定位"></a>3.对象的访问定位</h3><p> ①：对象的访问定位方式有几种（<strong>JVM是如何通过虚拟机栈中的栈帧中的局部变量表中的地址值访问到对象的实例数的呢？</strong>），两种方式的优缺点？ </p>
<p> a.句柄方式 </p>
<p> 通过局部变量表中的地址值找到堆空间中的句柄池，句柄池中存在两个指针，一个指针指向堆空间的对象实例数据；另一个指针指向方法区（元空间）中对象的类元信息。 </p>
<p>  <strong>优点：在GC环节，from区到to区对象会频繁移动，此时只需改变句柄池中的指针即可，虚拟栈中的地址不需改动;</strong> </p>
<p>  <strong>缺点：句柄池占用堆空间；对象的访问效率相对降低</strong> </p>
<p> b.直接指针（Hotspot虚拟机采用） </p>
<p> 通过局部变量表中的引用地址值找到位于堆空间的对象的实例数据，实例数据中的对象头中包含指向方法区（元空间）的类元信息的<strong>类型指针。</strong> </p>
<p> 优点和缺点与句柄访问相反。 </p>
<h1 id="四、执行引擎（☆）"><a href="#四、执行引擎（☆）" class="headerlink" title="四、执行引擎（☆）"></a>四、执行引擎（☆）</h1><h2 id="1-执行引擎概述"><a href="#1-执行引擎概述" class="headerlink" title="1.执行引擎概述"></a>1.执行引擎概述</h2><p>  <strong>①.作用：</strong> </p>
<p> 将字节码指令解释/编译为对应平台上的本地机器指令。（因为本地机器指令无法识别字节码指令） </p>
<p>  <strong>②.结构：</strong> </p>
<p>  <strong>a.解释器</strong> </p>
<p>  <strong>b.即时编译器</strong> </p>
<p>  <strong>c.GC</strong> </p>
<p>  <strong>③.执行过程：</strong> </p>
<p> a.首先通过程序计数器找到需要执行的字节码指令 </p>
<p> b.然后通过虚拟栈的栈帧中的局部变量表中的地址找到堆空间中的对象的实例数据，然后通过实例数据中的对象头中的对象的类型指针找到方法区的类元信息。 </p>
<h2 id="2-java代码的编译和执行的过程"><a href="#2-java代码的编译和执行的过程" class="headerlink" title="2.java代码的编译和执行的过程"></a>2.java代码的编译和执行的过程</h2><p> ①：java代码编译和执行的过程 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096239982_1595650138598-20800a9f-5a7e-4a12-8a46-0c5cda3447ab.png" alt="1ee7fcab6c3235a2cd85857262a1ae6.png"> </p>
<p> 橙色部分：即<a href="">前端</a>编译器将.java源文件编译为字节码文件 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240049_1595650311733-8b386688-bff6-437b-ae02-95112cced3b2.png" alt="42f588c79388fd6100fc5a530015037.png"> </p>
<p> 绿色部分：解释器将字节码文件解释为本地机器指令，并进行执行； </p>
<p> 蓝色部分：将字节码指令解释为本地机器指令，但是并不执行（解释热点代码，以备用） </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240195_1595650341470-bff04124-94e4-4802-8584-6d7d3174a802.png" alt="6444e09b44f356f605df265a70aaeae.png"> </p>
<p> ②：为什么说java语言半编译半解释型语言？ </p>
<p> 因为java虚拟中的执行引擎同时存在解释器和即时编译器 </p>
<p> 举例子： </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240264_1595651329997-7ef978e6-5ea6-4d10-baf4-d6a2a66ad9cc.png" alt="4833fc4769b5f2122a0c7df0655b2a7.png"> </p>
<h2 id="3-解释器"><a href="#3-解释器" class="headerlink" title="3.解释器"></a>3.解释器</h2><p> ①：为什么需要字节码文件 </p>
<p> 可以实现跨语言，使其他的语言生成自己码指令,JVM也能执行。 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240209_1595651657984-8a286a9e-b5cb-4741-af09-efcd8cbb8c1e.png" alt="a9ca89d0a6ebcb01a1e762399e9579c.png"> </p>
<p>  <strong>②：解释器作用：</strong> </p>
<p> 根据程序计数器的指令地址，逐条将字节码指令“翻译”为本地机器指令，以便程序能够运行。 </p>
<h2 id="4-即时编译器（JIT）"><a href="#4-即时编译器（JIT）" class="headerlink" title="4.即时编译器（JIT）"></a>4.即时编译器（JIT）</h2><p>  <strong>①：作用：</strong> </p>
<p>  <strong>将整个函数体编译成机器码，每次函数执行时，只编译机器码即可，还可以将常用的机器码进行缓存在方法区（元空间）中，从而提高效率。</strong> </p>
<h2 id="5-解释器与即时编译器的优缺点"><a href="#5-解释器与即时编译器的优缺点" class="headerlink" title="5.解释器与即时编译器的优缺点"></a>5.解释器与即时编译器的优缺点</h2><p> 解释器： </p>
<p> 优点：程序一开始执行的时候，解释器就能够逐条执行，省去编译的时间。 </p>
<p> 缺点：相对于即时编译器而言，逐条进行翻译效率较低 </p>
<p> 即时编译器 </p>
<p> 优点：因为是提前编译好的机器指令，因此效率更高； </p>
<p> 缺点：程序一开始执行的时候，需要事先对字节码指令进行编译，需要一定的时间。 </p>
<p>  <strong>综上：HotSpot虚拟机采用两者兼容的方式，虚拟机开始启动后，解释器可以立即发挥作用，不需要等到即时编译器编译完后再去执行，节省不必要的编译时间，随着时间的推移，即时编译器编译完成之后，采用即时编译器效率更高。</strong> </p>
<h2 id="6-StringTable-字符串"><a href="#6-StringTable-字符串" class="headerlink" title="6.StringTable(字符串)"></a>6.StringTable(字符串)</h2><p>  <strong>①String基本特性</strong> </p>
<p>  <strong>a.存储结构的变更</strong> </p>
<p> jdk1.8时采用char[]进行存储；jdk1.9之后采用byte[]进行存储； </p>
<p>  <strong>b.不可变特性</strong> </p>
<p> 通过字面量的方式给一个字符串赋值，此时的字符串位于堆空间的常量池中， </p>
<p>  <strong>当对字符串进行赋值时，需要重写指定内存区域进行赋值，不能使用原有的value进行赋值；</strong> </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240228_1595663886079-fb77c233-8e69-4b85-9e74-5d42e0bcea9f.png" alt="ef7ab5333645c9d8265d19b65498cf6.png"> </p>
<p> 解释：因为ex.str已经确定为了good,然后再直接赋值的话，就不会改变 </p>
<p>  <strong>c.字符串常量池中不会存储相同的字符串</strong> </p>
<p>  常量池中的字符串均是唯一的，如果两个字符串变量相等，则两个变量指向字符串常量池中的同一个地址。 </p>
<p>  <strong>String Pool（常量池）底层是一个固定大小的HashTable</strong>，默认长度为1009，可通过-XX：StringTableSize设置 </p>
<p>  <strong>②String内存分配</strong> </p>
<p>  <strong>jdk1.6时，字符串常量池位于永久代内</strong> </p>
<p>  <strong>jdk1.7之后，字符串常量池位于堆空间；</strong> </p>
<p>  <strong>移动的原因/好处：</strong> </p>
<p>  <strong>永久代几乎不进行来及回收，将其移动到堆空间后，更方便进行垃圾回收。</strong> </p>
<p>  <strong>③String基本操作</strong> </p>
<p>  <strong>a.java语言规范指出完全相同的字符串字面量，必须是指向同一个String实例。</strong> </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240281_1595666395441-3e5cec92-d5b3-4152-b192-c6125cf8e4c4.png" alt="2c28db80fb54c6785df6e409470ddf0.png"></strong> </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240403_1595666408438-62f99cb6-6d11-4473-b768-d922f51b906a.png" alt="1716e6179d02d1e650de2c3f5d3f4a8.png"></strong> </p>
<p> ④字符串的拼接 </p>
<p>  <strong>a.常量与常量拼接结果存放在常量池中</strong> </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240331_1595669832346-02cc1655-5578-49c4-a66c-71694883305c.png" alt="0d5c1278dcd928e231513c235289094.png"> </p>
<p> 首先==号判断的是两者的地址值是否相等，则两者指向的是字符串常量池中的同一个字符串，地址值相等； </p>
<p> 其次equals判断的是两个字符串序列是否相等，则也是相等的。 </p>
<p>  <strong>b.常量池中不会存在相同内容的常量。</strong> </p>
<p>  <strong>c.如果在拼接前后出现变量，则连接的结果存放在堆中字符串常量池外（相当于new一个对象），原理是StringBuilder;</strong> </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240467_1595670609119-3cf1c740-89a9-468e-bc93-8407e1c79c41.png" alt="24f1bbb42d687c2b9b259c27a36b876.png"></strong> </p>
<p>  <strong>d.如果拼接的结果调用了intern()方法，则主动将常量池中还没有的字符串常量对象放入池中，并返回地址</strong> </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240568_1595670625620-0c121ae8-b220-44a6-a7c4-da0dd5a2af75.png" alt="75ce06b75080dcf3ef18c99343c523b.png"></strong> </p>
<p> ⑤字符串拼接底层原理（后面补充） </p>
<p> ⑥intern()方法（后面补充） </p>
<h1 id="五、垃圾回收（☆）"><a href="#五、垃圾回收（☆）" class="headerlink" title="五、垃圾回收（☆）"></a>五、垃圾回收（☆）</h1><h2 id="1-垃圾回收概述"><a href="#1-垃圾回收概述" class="headerlink" title="1.垃圾回收概述"></a>1.垃圾回收概述</h2><p>  <strong>①什么是垃圾？</strong> </p>
<p> 垃圾指的是在运行程序中没有任何指针指向的对象。 </p>
<p>  <strong>②为什么需要GC？</strong> </p>
<p>  a.如果不断进行内存分配而不进行垃圾回收，内存迟早会被消耗完； </p>
<p>  b.GC可以解决内存中的碎片化问题，从而能够为较大的对象分配足够的内存空间； </p>
<p>  c.随着应用程序的不断完善，用户越来越多，更需要GC来进行性能优化。 </p>
<p>  ③垃圾回收的主要区域 </p>
<p>  a.方法区：主要回收常量池中废弃的常量（字面量及符号引用）及不再使用的类型 </p>
<p>  b.堆空间：回收垃圾（没有任何指针指向的对象） </p>
<h2 id="2-垃圾回收相关算法"><a href="#2-垃圾回收相关算法" class="headerlink" title="2.垃圾回收相关算法"></a>2.垃圾回收相关<a href="">算法</a></h2><p> 判断对象存活方式：<strong>引用计数</strong><a href="">算法</a>和<strong>可达性分析</strong><a href="">算法</a> </p>
<h3 id="①：标记阶段（表明什么对象需要回收）"><a href="#①：标记阶段（表明什么对象需要回收）" class="headerlink" title="①：标记阶段（表明什么对象需要回收）"></a>①：标记阶段（表明什么对象需要回收）</h3><p> a.引用计数<a href="">算法</a> </p>
<p>  <strong>原理：每个对象都有一个引用计数器，来记录对象被引用的次数，每增加一次引用计数器+1；每减少一次引用计数器-1，当引用计数器记录值为0时，就表名该对象没有被任何对象引用，则表名该对象为垃圾。</strong> </p>
<p> 优缺点： </p>
<p> 优点：<strong>实现简单</strong>，垃圾对象便于识别；<strong>回收效率高</strong>； </p>
<p> 缺点： </p>
<p>  <strong>①：无法处理**</strong>循环引用**<strong>的情况；从而造成内存泄露；</strong> </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240483_1595728008989-fb53f3b9-fe0d-4d89-b601-5d01b286cba9.png" alt="1081170840f3c095db45d58f6c50c01.png"></strong> </p>
<p> ②：<strong>空间</strong>：因为需要计数器，所以造成额外的空间开销； </p>
<p> ③：<strong>时间</strong>：需要频繁的加1或者减1操作，造成一定的时间开销； </p>
<p> 代码举例： </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240519_1595728600583-3a7d7e95-c52e-43f6-8eb6-1de87d7948b7.png" alt="bc79c3d75c46c47b0dcee8340e9e235.png"><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240549_1595728642091-2214436c-583b-42f8-bdd8-a0a0ad2693e8.png" alt="a95d6769dd2274680f0f51972c6007a.png"> </p>
<p>  <strong>b.可达性分析<a href="">算法</a>（根搜索<a href="">算法</a>）</strong> </p>
<p> GC Roots:<strong>一组活跃引用的根对象集合</strong> </p>
<p>  <strong>基本原理：以跟对象为起始点，从上到下搜索被根对象所连接的目标是否可以到达，内存中的存活对象都直接或者间接地与根对象集合相连，搜索所走过的路径被称为引用链，如果目标对象没有被任何引用链相连，则为不可到达，即为内存中的垃圾。</strong> </p>
<p> 优点：可以<strong>解决循环引用</strong>的问题； </p>
<p> 缺点：相较于引用计数<a href="">算法</a>来说，回收效率稍慢一些。 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240582_1595730382833-244e346f-9f7f-48bb-9b5e-08a53a985cf7.png" alt="aeb85652010215edb3b2b9b18bf6d3a.png"> </p>
<p>  <strong>c.可以被当做GC Roots的元素有哪些？（重点是堆外保存堆内对象的地址的那些区域）</strong> </p>
<p> ①：<strong>虚拟机栈中引用的对象</strong>；如：各个线程中被调用的方法的局部变量等 </p>
<p> ②：<strong>本地方法栈中引用的对象</strong>； </p>
<p> ③：<strong>方法区（元空间）静态属性引用的对象</strong>：如<strong>静态变量</strong> </p>
<p> ④：<strong>方法区（元空间）中常量引用的对象</strong>。如<strong>字符串常量池中引用的对象</strong> </p>
<p> ⑤：<strong>所有被synchronized持有的对象；</strong> </p>
<p> ⑥：基本数据类型对应的Class对象、异常类对象及系统类加载器 </p>
<p> ⑦：还需要一些<strong>“临时性”对象加入GC Roots</strong>结合中，如只针对新生代回收，则堆中新生代以外的引用对象也需要加入GC Roots集合中。 </p>
<h3 id="②：对象的finalization机制"><a href="#②：对象的finalization机制" class="headerlink" title="②：对象的finalization机制"></a>②：对象的finalization机制</h3><p>  <strong>a.什么是对象的finalization机制</strong> </p>
<p>  <strong>在gc 回收某个对象之前，会先调用对象的finalize()方法。Object类中的finalize()方法没有任何方法体，对象类可以重写这个方法。</strong> </p>
<p> b.虚拟机中的对象有哪几种可能的状态（生存还是死亡）？ </p>
<p> ①：可触及的：能够与引用连相连接的对象； </p>
<p> ②：可复活的：没有任何引用的对象，但是可以在finalize()中被复活的对象； </p>
<p> ③：不可触及的：对象的finalize()被调用，但是没有被复活的对象。<strong>finalize()方法只能被调用一次。</strong> </p>
<p>  <strong>c.判断一个对象是否可以被回收所经历的两次标记过程（如何判断一个对象是否可以被回收？）（面试重点）</strong> </p>
<p>  <strong>①：如果对象到GC Root没有引用链连接，则进行第一次标记；</strong> </p>
<p>  <strong>②：进行筛选，判断是否有必要调用对象的finalize()方法</strong> </p>
<p>  1.对象类没有重写finalize()方法或者已经调用过了finalize（）方法，则为不可触及的； </p>
<p>  2.对象重写了该方法但是还没调用过该方法，则回收前会先调用此方法； </p>
<p>  ③：<strong>执行二次标记</strong>：如果执行finalize()方法后，该对象与引用链上的任何一个对象建立连接，则为复活状态，否则判定为不可达状态。**<br>**  </p>
<h3 id="④：清除阶段-如何回收垃圾"><a href="#④：清除阶段-如何回收垃圾" class="headerlink" title="④：清除阶段(如何回收垃圾)"></a>④：清除阶段(如何回收垃圾)</h3><p> a.标记-清除<a href="">算法</a> </p>
<p>  <strong>1.原理：当需要进行GC时，会停止整个程序（STW），然后整个GC过程分为标记阶段和清除阶段</strong> </p>
<p>  <strong>标记：从引用根对象开始遍历，标记所有**</strong>被引用**<strong>的对象，一般在对象头中记录为可达对象。</strong> </p>
<p>  <strong>清除：对堆内存进行从头到尾的遍历，如果发现某个对象的对象头没有被标记为可达对象，则进行回收</strong> </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240675_1595739453595-f93ecf82-9c3d-47a0-a681-8d15ff492dcf.png" alt="c9a21a81fc7f27cc95007ebd6e9ecf8.png"></strong> </p>
<p>  <strong>2.优点</strong>：最基本的垃圾回收<a href="">算法</a> </p>
<p>  <strong>3.缺点</strong>：①：因为需要遍历，所以<strong>执行效率不高</strong>； </p>
<p> ②：在进行GC时，需要STW，效率不高的话，会<strong>影响用户体验</strong>； </p>
<p> ③：产生<strong>内存碎片化</strong>问题 </p>
<p> b.<strong>复制</strong> </p>
<p>  <strong>1.原理：将内存空间分为大小相等的两块，每次只使用其中的一块，垃圾收集时，将正在使用的内存中的存活的对象复制到另一块内存中，然后将正在使用的内存清空。交换两个内存的角色，完成垃圾回收</strong> </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240674_1595739479153-f7a3ba9e-a669-4eae-bf62-6fd26fae715f.png" alt="687a8a1bc58920ecad9f67bc2abbebf.png"></strong> </p>
<p>  <strong>2.优点：</strong> </p>
<p>  <strong>①：执行效率高，省去了清除中的遍历问题；</strong> </p>
<p>  <strong>②：解决了内存碎片化的问题</strong> </p>
<p>  <strong>3.缺点：</strong> </p>
<p>  <strong>①：空间浪费较明显，始终有一块内存无法使用；</strong> </p>
<p>  <strong>②：对于G1这种分成很多region的垃圾回收器来说，复制意味着需要维持region之间对象的引用关系，空间和时间的开销比较大。</strong> </p>
<p>  <strong>4.适用场景：</strong> </p>
<p>  <strong>比较适合于垃圾对象较多，存活对象较少的区域，如新生代中的Sur<a href="">vivo</a>r0区和Sur<a href="">vivo</a>r1区。</strong>  </p>
<p>  <strong>不适合老年代中垃圾回收。</strong>  </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240919_1595739493765-05008c3b-0016-48c1-9536-b5378d23c4bc.png" alt="dac5e4393b0782d236d092cc09f7d5b.png"></strong> </p>
<p> <strong>c.标记-整理（压缩）</strong> </p>
<p>  <strong>1.原理：</strong> </p>
<p>  <strong>第一阶段和标记-清除<a href="">算法</a>的标记阶段一样，从根结点开始标记所有被引用的对象；</strong> </p>
<p>  <strong>第二阶段将所有存活的对象压缩到内存的一端，按顺序排放，然后清除边界以外的内存空间</strong> </p>
<p>  <strong>2.优点：</strong> </p>
<p>  <strong>①：解决了标记-清除内存碎片化的问题</strong> </p>
<p>  <strong>②：解决了标记-复制空间浪费一半的问题</strong> </p>
<p>  <strong>3.缺点：</strong> </p>
<p>  <strong>①：整理过程中需要移动对象，如果对象被其他对象所引用，则需要不断调整引用的地址；</strong> </p>
<p>  <strong>②：效率相对另外两种<a href="">算法</a>较低；</strong> </p>
<p>  <strong>4.适用场景：适合于老年代中的垃圾收集</strong> </p>
<p> <strong>d.三种垃圾回收<a href="">算法</a>对比</strong> </p>
<table>
<thead>
<tr>
<th><a href="">算法</a>：</th>
<th>标记-清除</th>
<th>复制</th>
<th>标记-压缩（整理）</th>
</tr>
</thead>
<tbody><tr>
<td>执行效率</td>
<td>中等</td>
<td>最快</td>
<td>最慢</td>
</tr>
<tr>
<td>空间开销</td>
<td>少（存在内存碎片化）</td>
<td>大（浪费一半空间）</td>
<td>小（不会产生内存碎片化）</td>
</tr>
<tr>
<td>移动对象</td>
<td>不</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<p> <strong>e.分代收集理论</strong> </p>
<p>  <strong>目的：不同声明周期的对象可以采用不用的回收<a href="">算法</a>，以提高整体的回收效率。</strong> </p>
<p> HotSpot虚拟机中的回收策略： </p>
<p> ①新生代： </p>
<p>  <strong>新生代特点：区域相对老年代小，对象声明周期短，回收频繁</strong> </p>
<p>  <strong>针对这种情况应当采用复制<a href="">算法</a>，回收效率高，针对于空间利用率不高的问题，采用两个Sur<a href="">vivo</a>r区得以缓解；</strong> </p>
<p> ②老年代： </p>
<p> 老年代特点：相对于新生代大，对象的声明周期长，回收不频繁。 </p>
<p> 针对这种情况采用标记-清除+标记-整理相结合的方法，首先标记阶段还是采用两者中的标记方法，即从根对象开始，依次标记所有的存活对象，然后采用清除<a href="">算法</a>，暂时容忍碎片化问题，等到碎片化问题影响到内存分配时，再采用整理<a href="">算法</a>，整理碎片化内存。 </p>
<p> f.增量收集<a href="">算法</a> </p>
<p> 如果一次性将所有垃圾进行回收，需要造成系统长时间的停顿，影响用户体验，可以让垃圾收集线程和用户线程交替执行，每次垃圾收集线程只收集一部分的内存空间，接着切换到应用程序，依次反复，直到垃圾收集完成。 </p>
<p> 优点：低延迟，用户体验更优；缺点：吞吐量下降 </p>
<p> <strong>g.分区收集<a href="">算法</a></strong> </p>
<p> <strong>将整个堆空间划分为连续不等的小区间，根据目标的停顿时间，每次合理的回收若干个小区间，而不是整个堆空间。每一个小区间都独立使用，独立回收。</strong> </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240800_1595751084301-658eedf5-4a0a-4840-91a7-c5833ce4e50d.png" alt="2457ccd314d0dd6b07d3d68efdc5bef.png"></strong> </p>
<h2 id="3-垃圾回收相关概念"><a href="#3-垃圾回收相关概念" class="headerlink" title="3.垃圾回收相关概念"></a>3.垃圾回收相关概念</h2><h3 id="①-System-gc"><a href="#①-System-gc" class="headerlink" title="①  System.gc()"></a>①  System.gc()</h3><p> 会显示触发<strong>Full GC</strong>,但是<strong>无法保证对垃圾收集器的调用</strong>；底层调用Runtime.getRuntime().gc(）； </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240826_1595754647048-a98b157f-0f19-4268-9c11-a79c3d20a2ef.png" alt="3e948d137245d7ef6992b5004e61c83.png"> </p>
<p> 举例子：不太理解方法3和方法4（需要补充关于虚拟机栈Slot槽部分的内容） </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096241232_1595756139900-d838628b-c7db-40ad-8bb8-13a2c1470744.png" alt="573829485ec7aa301af326258a3c4e5.png"> </p>
<h3 id="②-内存溢出与内存泄露"><a href="#②-内存溢出与内存泄露" class="headerlink" title="②  内存溢出与内存泄露"></a>②  内存溢出与内存泄露</h3><p> a.内存溢出（OOM）：<strong>没有空闲内存，并且垃圾收集器也无法提供更多内存</strong>。 </p>
<p> b.没有空闲内存的原因： </p>
<p> ①：设置的堆内存太小，此时可以通过-Xms:和-Xmx来设置堆空间的起始大小和最大大小； </p>
<p> ②：代码中创建了大对象，并且长时间不能被垃圾回收器所收集； </p>
<p>  <strong>举出OOM的例子</strong>： </p>
<p>  <strong>c.内存泄露</strong>：（非常重要） </p>
<p>  <strong>①严格意义：对象不会被程序用到，但是GC又没有办法回收掉该对象，此时就称为发生了内存泄露；</strong> </p>
<p>  <strong>②宽泛意义：实际情况中，一些不好的编程实践造成了对象的声明周期变得很长甚至导致OOM，（如本来可以定义为方法内部的局部变量，定义为类的成员变量甚至定义为静态变量（随着类的加载而加载，随着类的消亡而消亡）造成变量的声明周期加长，本来方法弹栈后可能就会被释放（没有发生逃逸））。</strong> </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096241002_1595759119542-327dff3f-c48b-4787-9507-58e1ca8bd19d.png" alt="edda5dfe6bf8d2ae2093d4066e98f36.png"></strong> </p>
<p> <strong>③：举例说明内存泄露（举出关于内存泄露的例子）</strong> </p>
<p>  <strong>1.单例的生命周期和程序一样长，单例程序中如果存在对外部对象的引用，则外部对象是没有办法被回收的，会造成内存泄露</strong> </p>
<p>  <strong>2.一些提供close()的资源未关闭而导致内存泄露（如数据库的连接必须手动close,否则不能被回收）。</strong> </p>
<h3 id="③-STW"><a href="#③-STW" class="headerlink" title="③ STW"></a>③ STW</h3><p> 如论那种垃圾收集器，在进行垃圾收集的过程中，都会使程序停顿，这称为STW，被STW中断的程序在完成GC后会自动恢复。 </p>
<p> 目的：为了保证数据的一致性（不能统计垃圾的时候还一边造垃圾） </p>
<h3 id="④-垃圾回收并行与并发"><a href="#④-垃圾回收并行与并发" class="headerlink" title="④ 垃圾回收并行与并发"></a>④ 垃圾回收并行与并发</h3><p> a.程序的并行与并发 </p>
<p> 并发：从一段时间来看，有多个任务在执行，从单一的时间点上来看，只有一个任务在执行，时间上是Cpu在快速切换任务交替执行； </p>
<p> 并行：当系统有多个CPU时，一个cpu可以执行一个进程，另一个cpu可以执行另一个进程，两个进程不会互相抢cpu资源，可以同时进行，此称为并行。 </p>
<p> 对比：并发指的是同一个时间段，多个任务发生了，且抢占cpu资源； </p>
<p> 并行指的是在用一个时间点，多个任务发生了，不抢占cpu资源； </p>
<p> <strong>b.垃圾回收的并行与并发</strong> </p>
<p>  <strong>并行：**</strong>多条垃圾回收线程并行执行**<strong>，此时需要停顿用户线程</strong> </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240867_1595761521311-c4ff54ec-6b9e-4f7a-98e9-8b78de2204a5.png" alt="0aa5a774f97604365f4a1a7a134ccbb.png"></strong> </p>
<p>  <strong>串行：只有一条垃圾回收线程，当内存不够时，程序暂停，启动垃圾回收，回收完，再启动程序的线程。</strong> </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240951_1595762176553-c26533d4-711f-42b8-9963-6a2553890e3b.png" alt="3048456c12d156275562237731199e8.png"></strong> </p>
<p>  <strong>并发：用户线程与垃圾回收线程同时执行，垃圾回收线程在执行时，不会停顿用户程序的执行。(？？)</strong> </p>
<p>  <strong>用户程序在继续进行，而垃圾收集线程运行在另一个CPU，如：CMS和G1。</strong> </p>
<h3 id="⑤-安全点与安全区域-后期补充"><a href="#⑤-安全点与安全区域-后期补充" class="headerlink" title="⑤ 安全点与安全区域**(后期补充)**"></a>⑤ 安全点与安全区域**(后期补充)**</h3><h3 id="⑥-强引用（Strong-Reference）"><a href="#⑥-强引用（Strong-Reference）" class="headerlink" title="⑥ 强引用（Strong Reference）"></a>⑥ 强引用（Strong Reference）</h3><p>  <strong>a.定义：在java程序中通过new创建了一个对象，并将其赋值给一个变量，该变量就称为指向该对象的一个强引用</strong> </p>
<p>  <strong>b.适用场景</strong>：99%以上的都是强引用。 </p>
<p>  <strong>c.垃圾回收</strong>：强引用的对象都是可触及的，GC不会回收掉被强引用的对象（<strong>强引用，不回收</strong>）。 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240983_1595818842584-44aba881-26dd-4276-9aec-d0e0e3b779c2.png" alt="fb8867da1f480b45b38a5a953492d91.png"> </p>
<h3 id="⑦-软引用-Soft-Reference"><a href="#⑦-软引用-Soft-Reference" class="headerlink" title="⑦ 软引用(Soft Reference)"></a>⑦ 软引用(Soft Reference)</h3><p> a.定义：<strong>描述的是一些还在用，但是非必须的对象</strong>。 </p>
<p> b.适用场景：通常用来实现内存敏感的缓存，如高速缓存就用到软引用。 </p>
<p> c.垃圾回收：<strong>内存不足即回收</strong> </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240953_1595825486805-f0cde15d-8227-4ea6-9877-c68fbc9678eb.png" alt="319c2e165351273dff2f12c48d8a81f.png"></strong> </p>
<h3 id="⑧-弱引用-Weak-Reference"><a href="#⑧-弱引用-Weak-Reference" class="headerlink" title="⑧ 弱引用(Weak Reference)"></a>⑧ 弱引用(Weak Reference)</h3><p> a.定义：<strong>弱引用也是描述那些非必须的对象，与软引用的区别在于GC时，对于软引用来说需要判断当前内存是否不足，不足的话才进行回收，而对于弱引用不需要进行判断直接回收。</strong> </p>
<p> b.适用场景：保存那些可有可无的缓存数据。 </p>
<p> c.垃圾回收：发现即回收 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096241104_1595825502743-bc232bb6-bda0-4f0d-a272-183b00bed29d.png" alt="2d4a74df4cde830a229d8c8e944d581.png"> </p>
<p> 补充面试题：<strong>你用过weakHashMap吗</strong>？ </p>
<p> 采用weakHashMap进行存储后，当内存不足时，能够对该部分进行回收，因为内存的Entry&lt;k,v&gt;类继承了弱引用类。 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096241181_1595825700924-cee01a4d-63d4-4c7b-91b5-2b04ee0e5f52.png" alt="5f96175ed1b08c259f9798921d22811.png"> </p>
<h3 id="⑨-虚引用-Phantom-Reference"><a href="#⑨-虚引用-Phantom-Reference" class="headerlink" title="⑨ 虚引用(Phantom Reference)"></a>⑨ 虚引用(Phantom Reference)</h3><p> a.定义：<strong>所有引用中最弱的一个，为一个对象设置虚引用关联的目的是跟踪垃圾回收的过程,被回收后可以发出相应的通知。</strong> </p>
<p> b.适用场景：实现跟踪对象的垃圾回收过程 </p>
<p> c.垃圾回收：跟踪对象回收过程 </p>
<h2 id="4-垃圾回收器"><a href="#4-垃圾回收器" class="headerlink" title="4.垃圾回收器"></a>4.垃圾回收器</h2><h3 id="①垃圾回收主要性能指标"><a href="#①垃圾回收主要性能指标" class="headerlink" title="①垃圾回收主要性能指标"></a>①垃圾回收主要性能指标</h3><p> a.吞吐量：用户程序运行时间/用户程序运行时间+垃圾回收时间 </p>
<p> 吞吐量越高越好，这样会提升用户体验，认为只有应用程序在执行。 </p>
<p> b.暂停时间：执行垃圾收集时，程序被暂停的时间。 </p>
<p> 暂停时间越低越好，对于交互式应用程序，暂停时间越长，越容易出现卡顿现象，影响用户体验。 </p>
<p> c.<strong>现在标准：在最大吞吐量优先的情况下，降低停顿时间。</strong> </p>
<h3 id="②垃圾回收器概述（分类）"><a href="#②垃圾回收器概述（分类）" class="headerlink" title="②垃圾回收器概述（分类）"></a>②垃圾回收器概述（分类）</h3><p> 串行(STW时只有一个垃圾回收线程)：Serial 及Serial Old </p>
<p> 并行（STW时有多个垃圾回收线程）：ParNew、Parallel Scavenge及Parallel Old </p>
<p> 并发（垃圾回收线程和用户线程并发执行）：CMS及G1 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096241511_1595840882697-367b4ac4-b3c4-4b54-8fc9-ae6b8b8bf584.png" alt="1595840867(1).png"> </p>
<h3 id="③垃圾回收器的组合关系"><a href="#③垃圾回收器的组合关系" class="headerlink" title="③垃圾回收器的组合关系"></a>③垃圾回收器的组合关系</h3><p> 新生代：Serial ParNew Parallel Scavenge </p>
<p> 老年代：Serial Old  Parallel Old和CMS </p>
<p> 新生代和老年代：G1 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096241232_1595842219886-502f4f93-ac2c-4ed8-8a1b-e8f3ad97dd69.png" alt="29f7408242b6eaa3554dda7d1a548a7.png"> </p>
<p> 组合关系： </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096241322_1595842411433-68100b26-15bf-4b80-b852-bf2cc5653ed0.png" alt="4f1260ebe1fc7b087c38f8f024e788c.png"> </p>
<p> 补充：jdk9中移除了Serial+CMS和ParNew+Serial Old这两种组合 </p>
<p> jdk14中，删除了CMS垃圾回收器。 </p>
<p> 目前的组合：Serial +Serial Old； Parallel Scavenge+Parallel Old和G1 </p>
<h3 id="④Serial垃圾回收器（串行回收）"><a href="#④Serial垃圾回收器（串行回收）" class="headerlink" title="④Serial垃圾回收器（串行回收）"></a>④Serial垃圾回收器（串行回收）</h3><p> a.Serial垃圾回收器 </p>
<p> 采用复制<a href="">算法</a>、串行收集和Stop The World的方式来对新生代进行垃圾收集。是HotSpot虚拟机在<a href="">客户端</a>模式下默认的新生代垃圾回收器。 </p>
<p> b.Serial Old垃圾回收器 </p>
<p> 采用标记-整理<a href="">算法</a>、串行收集和Stop The World的方式来对老年代进行垃圾收集。是HotSpot虚拟机在<a href="">客户端</a>模式下默认的老年代垃圾回收器。 </p>
<p> c.回收过程 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096241308_1595843687990-e4d8fff4-2f0c-4fcb-a591-dfa0f08953ef.png" alt="9265b78a446251f6f9272d95ebf09d7.png"> </p>
<p> d.回收优势：因为是单线程，因此没有线程交换的开销，相对于其他垃圾收集器的单线程相比，简单而高效。 </p>
<p> e.参数设置：-XX:useSerialGC/useSerialOldGC设置 </p>
<h3 id="⑤ParNew垃圾回收器（并行回收）"><a href="#⑤ParNew垃圾回收器（并行回收）" class="headerlink" title="⑤ParNew垃圾回收器（并行回收）"></a>⑤ParNew垃圾回收器（并行回收）</h3><p> a**.**回收模式：采用复制<a href="">算法</a>、并行回收和STW的机制进行垃圾回收,是JVM在服务端下的默认新生代垃圾回收器。 </p>
<p> b组合搭配：可以和Serial Old搭配使用（JDK9中移除）；可以和CMS配合使用（JDK14中删除） </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096241334_1595844540740-8cf49062-0ef1-4702-888f-2a64419c5958.png" alt="18d52dde30c0ee4e38b6746e277094d.png"> </p>
<p> c.优势：对于新生代，回收次数频繁，因此采用并行方式更加高效。 </p>
<p> d.参数设置：**-XX:useParNewGC** </p>
<h3 id="⑥Parallel垃圾回收器（吞吐量优先）"><a href="#⑥Parallel垃圾回收器（吞吐量优先）" class="headerlink" title="⑥Parallel垃圾回收器（吞吐量优先）"></a>⑥Parallel垃圾回收器（吞吐量优先）</h3><p> a.Parallel Scavenge垃圾回收器 </p>
<p>  <strong>采用复制<a href="">算法</a>、并行回收及STW的机制进行垃圾收集。</strong> </p>
<p> b.Parallel Scavenge垃圾回收器与ParNew的区别： </p>
<p>  Parallel Scavenge的<strong>目标是达到一个可控吞吐量</strong>，而且具备自适应调节策略。 </p>
<p> c.Parallel Old垃圾回收器 </p>
<p>  <strong>采用标记-整理、并行回收及STW的机制进行垃圾收集，在JDK8中，默认**</strong>Parallel Scavenge+<strong>**Parallel Old</strong>为垃圾回收器。 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096241334_1595845902568-32911b65-779d-49b6-a9e1-51dbf4d2862e.png" alt="678148c114fe84d0504b6b4fb1fd576.png"> </p>
<p> d.适用场景：高吞吐量则可以高效的利用cpu的时间，来快速实现计算。主要适合<strong>在后台运行而不需要太多交互</strong>的任务 </p>
<h3 id="⑦CMS-Concurrent-Mark-Sweep-垃圾回收器（低延时）"><a href="#⑦CMS-Concurrent-Mark-Sweep-垃圾回收器（低延时）" class="headerlink" title="⑦CMS(Concurrent Mark Sweep)垃圾回收器（低延时）"></a>⑦CMS(Concurrent Mark Sweep)垃圾回收器（低延时）</h3><p> a.概念：CMS(Concurrent Mark Sweep)垃圾回收器是HotSpot虚拟机第一款并发垃圾回收器，实<strong>现了垃圾收集线程和用户线程同时工作</strong>。是<strong>基于标记-清除<a href="">算法</a>，并发回收的老年代垃圾收集器</strong>，只搭配ParNew和Serial使用，在jdk14时，CMS垃圾回收器被删除。 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096241351_1595901760026-72069930-c030-41b0-b184-7c18a5b05908.png" alt="155ee4a9f4599f5f182fce2f1fa054c.png"> </p>
<p> b.工作原理： </p>
<p> 1.初始标记:<strong>仅仅只是标记出GC Roots能够直接关联到的对象</strong>，存在<strong>STW</strong>机制。 </p>
<p> 2.并发标记:<strong>从GC Root直接关联到的对象开始，遍历整个对象图的过程</strong>，该阶段不需要停顿用户线程。 </p>
<p> 3.重新标记:<strong>修正并发标记阶段**</strong>，因用户线程运行而导致标记产生变动的那一部分对象的标记记录，存在STW机制。** </p>
<p> 4.并发清除:<strong>清除标记为已经死亡的对象，释</strong>放内存空间。 </p>
<p> c.优缺点： </p>
<p> 1.优点：并发收集；低延迟； </p>
<p> 2.缺点： </p>
<p> ①：<strong>会产生内存碎片</strong>，当老年代需要为大对象分配内存时，不得不提前触发Full GC; </p>
<p> ②：**无法处理”浮动垃圾”,可能导致”并发失败”**，从而引发Full GC </p>
<p> 浮动垃圾：因为在并发清理阶段，垃圾收集线程和用户线程在并发执行，用户线程运行过程中，会产生新的垃圾，而这部分垃圾是发生在标记阶段之后的，所以只能等到下一次GC时，才能够进行回收，这时候需要预留出一定的内存空间。 </p>
<p> ③：<strong>对CPU资源比较敏感</strong>：CMS默认的<strong>垃圾回收线程数</strong>为**(处理器核心数+3)/4**,对于处理器核心数比较少的情况，垃圾回收线程就占比较大，影响执行速度。 </p>
<p> d.使用场景：适用于<strong>强交互</strong>的应用。 </p>
<p> e.参数设置： </p>
<p> 1.-XX:+UseConcMarkSweepGC:设置使用CMS垃圾收集器； </p>
<p> 2.-XX:CMSinitialingOccupanyFraction:设置堆内存使用率阈值；jdk5,默认为68%；jdk6.默认为92%。 </p>
<p> 3.-XX:ParallelCMSThreads：设置CMS的线程数量 </p>
<p> f.面试题： </p>
<p>  <strong>1.为什么说CMS是一款低延时的垃圾回收器？</strong> </p>
<p> 因为在初始标记阶段和重新标记阶段，会发生STW，但是此部分时间很短，而在并发标记和并发清除阶段，虽然占据的时间比较长，但是在此期间，垃圾回收线程和用户线程并发执行，因此为低延时垃圾回收器 </p>
<p>  <strong>2.CMS会产生内存碎片化问题，为什么不用标记整理<a href="">算法</a>呢？</strong> </p>
<p> 因为CMS在并发标记和并发清除阶段，用户线程和垃圾回收线程并发执行，而标记整理<a href="">算法</a>中存在对象在内存中的定向移动，用户线程在执行过程中，如果发生移动，会造成安全问题。因此无法采用标记-整理<a href="">算法</a>。 </p>
<h3 id="⑧G1垃圾回收器"><a href="#⑧G1垃圾回收器" class="headerlink" title="⑧G1垃圾回收器"></a>⑧G1垃圾回收器</h3><p> a.概述： </p>
<p> 1.目标是在停顿时间可控的情况下尽可能的提高吞吐量的垃圾收集器 </p>
<p>  <strong>2.将整个堆内存分为多个region区，跟踪各个Region区的垃圾堆积的价值大小，然后后台维护一个优先级列表，每次根据允许的收集时间，优先回收价值大的region.</strong> </p>
<p>  <strong>3.基于复制<a href="">算法</a>和标记-整理<a href="">算法</a>的并行垃圾回收器，为jdk9之后默认的垃圾回收器。</strong> </p>
<p> b.回收过程（整体）： </p>
<p> 整体分为：年轻代GC（Young GC）,并发标记老年代，混合回收过程，如果G1失效，Full GC作为后备机制 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096241530_1595925903146-5f2453e5-cacf-4d99-97f5-30eeeec2896d.png" alt="39b257487f171a62cb0b2a902437910.png">当伊甸园区满之后，开始进行年轻代回收，移动存活对象到Sur<a href="">vivo</a>r区或者Old区； </p>
<p> 当堆内存到达一定阈值（默认45%）时，启动并发标记老年代； </p>
<p> 并发标记结束后，进行混合回收，收集老年代时，一次只需回收一部分老年代对象，（因为存在时间限制）。 </p>
<p> c.优缺点： </p>
<p> 优点： </p>
<p>  <strong>1.并发与并行</strong> </p>
<p>  <strong>并行性</strong>：在G1垃圾回收期间，可以有多条垃圾回收线程同时进行回收，有效利用多核计算能力。 </p>
<p>  <strong>并发性</strong>：在G1并发标记阶段，允许垃圾收集线程和用户线程并发执行。 </p>
<p>  <strong>2.分代收集</strong> </p>
<p>  <strong>G1同时兼顾了年轻代和老年代</strong>。因为G1垃圾收集器将堆空间分为不同的Region区，这些区域包含了逻辑上的新生代和老年代。 </p>
<p>  <strong>3.不存在内存碎片化问题</strong> </p>
<p>  因为G1垃圾回收器以Region为基本内存回收单元，Region之间采用复制<a href="">算法</a>，但是从整体上来说，是采用标记-整理<a href="">算法</a>，因此可以避免内存碎片问题。 </p>
<p>  <strong>4.可预测的停顿时间模型（软实时）</strong> </p>
<p>  <strong>使使用者明确在一个长度为M的时间片段内，用于垃圾回收的时间不超过N</strong> </p>
<p> 主要是因为G1跟踪各个Region的垃圾堆积价值的大小，然后后台维护一个优先级列表，在有限的时间内，优先收集价值大的Region。 </p>
<p> 缺点：由于垃圾收集产生的内存占用相对大，小内存应用上性能不如CMS。 </p>
<p> d.适用场景：面向服务端的垃圾收集器，主要针对配备多核CPU和大容量内存的机器（<strong>低延时，大内存</strong>）。 </p>
<p> <strong>e.**</strong>Region相关介绍** </p>
<p> 1.大小：G1将整个堆大小分为约2048个Region，每个Region大小相同，且为2的n次幂(一般在1M-32M之间)，且在JVM的生命周期内不会改变。 </p>
<p> 2.分布：一个Region有可能属于伊甸园区，S区或者Old区。G1还在堆内存中存放了一个Humogous区,简称H区，当对象大小超过1.5倍的Region区时，将其称为大对象，放在H区。（<strong>问题：如果是1.2倍Region大的对象放在哪儿？</strong>） </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096241660_1595924574582-ef42127c-4b3e-4680-abcc-ca68b394870c.png" alt="82c8716df791031ba5fc7615a6c3612.png"> </p>
<p> 3.设置H区的原因？ </p>
<p> 原因在于，如果不设置H区，那么大的对象则会直接进入到老年代，但是如果这个对象的声明周期比较短，则会长时间存在，并且占据着较大内存，所以将其存放在H区，如果对象大于一个H区大小，则会存在在连续的H区中。如果整个H区都装不下，则会触发Full GC. </p>
<p> 4.内存分配 </p>
<p> Region区采用<strong>指针碰撞</strong>的方式进行内存分配，并且每个Region内部存在<strong>TLAB</strong>(线程本地分配缓冲区)。 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096241680_1595924916288-70f9d0c7-52e9-47d8-99f5-70dfe0a5c53b.png" alt="cd99478dc4eb68428f8c94fc37ae4bb.png"> </p>
<p> f.Remembered Set(记忆集) </p>
<p> 1.存在必要性：因为存在跨Region引用的存在，判断存活时，如果挨个遍历每个Region的话，势必造成效率降低，于是引进了记忆集。 </p>
<p> 2.原理：每个Region都有一个记忆集，当进行引用数据写入时，先判断是否存在其他Region的引用关系，如果存在的话，则将该引用关系对应的对象写入记忆集的卡表（CardTable）中，然后在GC过程中将Rset加入到GC Roots中。 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096241709_1595926767353-bfcba122-575e-429c-86bc-8c38d5b5bfaf.png" alt="f8d46f61a7e678d5c923ba5471bc5ef.png"> </p>
<p> g.回收过程（具体） </p>
<p> 1.年轻代GC（与之前讲的一样，只不过是基于分区思想） </p>
<p> JVM优先分配对象到伊甸园区，当伊甸园区满了之后，开始进行年轻代GC，然后，存活下来的对象进入到S区，当S区的对象分代年龄达到阈值后，进入到老年代中，清理过程中的<a href="">算法</a>采用复制<a href="">算法</a>。 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096241685_1595931307451-9fb33e57-fa59-412b-96ac-1bb4a9ed2067.png" alt="f1f522537de43b21e70c00dacd794fd.png"> </p>
<p> 2.标记老年代（<strong>深入理解java虚拟机中此部分为G1的收集过程</strong>） </p>
<p> ①：<strong>初始标记</strong>：只标记GC Roots直接关联到的对象，此过程需要STW； </p>
<p> ②：<strong>并发标记</strong>：从GC Root关联到的对象开始，递归遍历整个对象图，此时垃圾收集线程和用户线程并发执行 </p>
<p> ③：<strong>最终标记</strong>：由于在并发标记阶段，用户线程在执行，需要对标记结果进行修正，此时需要STW. </p>
<p> ④：<strong>筛选回收</strong>：根据用户设置停顿时间，采用复制<a href="">算法</a>进行清理（将决定回收的Region中的存活对象复制到空的Region中，然后清空旧的Region空间），此过程需要STW。 </p>
<p> 3.混合回收： </p>
<p> ⑨垃圾回收器总结 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096242007_1595929229402-e808dabf-7309-4aea-883a-a386efeeb271.png" alt="5155a2a511700fe398f8aded4ce4b40.png"> </p>
<p> ⑩如何选择垃圾回收器 </p>
<p>  <strong>a.优先调整堆的大小，让JVM能够适应；</strong> </p>
<p>  <strong>b.如果是内存比较小，选择Serial +Serial Old垃圾回收器；</strong> </p>
<p>  <strong>c.如果是单核，没有停顿时间要求，**</strong>选择Serial +Serial Old垃圾回收器；** </p>
<p>  <strong>d.如果是多核CPU,需要高吞吐量，并且停顿时间不长，选择Parallel+Parallel Old垃圾回收器；</strong> </p>
<p>  <strong>e.如果是多核CPU,低停顿时间</strong> </p>
<p>  <strong>如果是jdk14以前，则可以选用ParNew+CMS或者G1;jdk14后，选择G1；</strong> </p>
<h1 id="六、补充面试题总结"><a href="#六、补充面试题总结" class="headerlink" title="六、补充面试题总结"></a>六、补充面试题总结</h1><h2 id="1-JVM调优"><a href="#1-JVM调优" class="headerlink" title="1.JVM调优"></a>1.JVM调优</h2><p> 1.调优参数 </p>
<p>  <strong>1.**</strong>设置堆区的大小** </p>
<p>  -Xms:设置初始堆大小； </p>
<p>  -Xmx:设置最大堆大小； </p>
<p>  <strong>2.**</strong>设置新生代和老年代的比例** </p>
<p>  -XX:NewRatio:设置年轻代和老年代的比例； </p>
<p>  <strong>3.设置伊甸园区和幸存者区的比例</strong> </p>
<p>  -XX：Sur<a href="">vivo</a>rRatio=n; </p>
<p>  <strong>4.**</strong>设置永久代/元空间的大小** </p>
<p>  -XX：permSize；-XX：permMax; </p>
<p>  -XX：metaSpaceSize；-XX：metaSpaceMax； </p>
<p>  <strong>5.**</strong>设置垃圾回收器** </p>
<p>  -XX：useG1GC； </p>
<p>  -XX：useCMSGC; </p>
<p>  <strong>6.打印相关日志</strong> </p>
<p>  -XX：+printGC:打印垃圾回收 </p>
<p>  -XX：+printGCDetails:打印垃圾回收细节信息； </p>
<p> 2.调优目的 </p>
<p>  减少GC的频次和Full GC的次数 </p>
<p> 3.调优过程 </p>
<p>  a.首选需要监控GC的状态,查看当前的堆内存快照及gc日志，根据实际的各区域划分和GC执行时间，判断是否需要优化。 </p>
<p>  b.生成堆的dump文件 </p>
<p>  c.分析dump文件 </p>
<p>  可以通过eclipse的工具Memory Analyzer </p>
<p>  d.分析结果，判断是否需要优化 </p>
<p>  e.调整GC的类型和内存分配 </p>
<p>  -XX:use+垃圾回收器+GC； </p>
<p>  f.不断分析和调整参数 </p>
<h2 id="2-OOM及其解决？"><a href="#2-OOM及其解决？" class="headerlink" title="2.OOM及其解决？"></a>2.OOM及其解决？</h2><p> 1.OOM场景有哪些？ </p>
<p>  a.java堆内存溢出 </p>
<p>  原因：堆内存设置小或者内存泄露问题 </p>
<p>  解决：对于内存泄露的话，可以使用内存监控查找程序中的内存泄露的地方           加以更正； </p>
<p>​    对于堆内存设置问题，可以通过-Xms或者-Xmx来进行设置； </p>
<p>  b.方法区溢出： </p>
<p>  原因:出现大量的Class或者jsp页面，过多的常量等会导致方法区溢出; </p>
<p>  解决：可以通过设置方法区的大小来调节 </p>
<p>  -XX:Permsize；-XX：MaxPermSize设置永久代的大小； </p>
<p>  -XX：metaSpaceSize;-XX:MaxmetaSpace设置元空间的大小； </p>
<p> 2.OOM的解决方法 </p>
<p>  a.首先采用内存映像分析工具如（MAT）对dump出来的堆转储快照进行分析，确认内存中的对象是否是必要的，查明到底是内存泄露还是内存溢出 </p>
<p>  b.如果是内存泄露，可进一步通过工具查看泄露对象到GC Roots的引用链，准确定位到泄漏代码的位置； </p>
<p>  c.如果不存在泄漏的话，分析是堆内存溢出还是方法区溢出； </p>
<p>  如果是堆内存溢出，则适当调整堆的大小：通过-Xms或者-Xmx来进行设置； </p>
<p>  如果是方法区溢出，适当调整方法区的大小：通过-XX:Permsize；-XX：MaxPermSize设置永久代的大小；-XX：metaSpaceSize;-XX:MaxmetaSpace设置元空间的大小； </p>
<h2 id="3-jdk1-7和jdk1-8比较？"><a href="#3-jdk1-7和jdk1-8比较？" class="headerlink" title="3.jdk1.7和jdk1.8比较？"></a>3.jdk1.7和jdk1.8比较？</h2><p> 1.字符串放在什么位置？ </p>
<p>  均放在堆空间的字符串常量池中； </p>
<p> 2.默认的垃圾回收器？ </p>
<p>  是一样的，都是Parallel scavenge+parallel old垃圾回收器。jdk1.9之后是G1垃圾回收器。 </p>
<h2 id="4-Full-GC与Minor-GC"><a href="#4-Full-GC与Minor-GC" class="headerlink" title="4.Full GC与Minor GC"></a>4.Full GC与Minor GC</h2><p> ①Full GC触发条件 </p>
<p>  a.老年代内存被占满; </p>
<p>  b.永久代/元空间内存被占满; </p>
<p>  c.System.gc()时会显式调用Full GC; </p>
<p>  d.空间担保失败 </p>
<p>  当老年代的剩余空间小于等于S区的平均对象大小时，表示空间担保失败； </p>
<p> ②Full GC定义 </p>
<p>  完整收集整个堆和方法区的垃圾 </p>
<p> ③Minor GC </p>
<p>  定义：只发生在新生代的垃圾回收 </p>
<p> ④Minor GC触发条件 </p>
<p>  当新生代的伊甸园区满了之后，就会触发Minor GC，回收整个年轻代的垃圾； </p>
<p> ⑤Minor GC出发结果 </p>
<p>  当进行Minor GC时，会产生STW，存活的对象移动到幸存者区；</p>
<h2 id="5-垃圾回收相关"><a href="#5-垃圾回收相关" class="headerlink" title="5.垃圾回收相关"></a>5.垃圾回收相关</h2><h3 id="1-CMS和G1垃圾回收器比较"><a href="#1-CMS和G1垃圾回收器比较" class="headerlink" title="1.CMS和G1垃圾回收器比较"></a>1.CMS和G1垃圾回收器比较</h3><p>  ①CMS垃圾回收器（主打低延时） </p>
<p>  a.介绍 </p>
<p>  是hotspot虚拟机第一款并发的垃圾回收器，垃圾回收线程和用户线程可以并发执行，不需要STW，因此能够提升用户体验，降低延迟性，适合于频繁交互的场景。 </p>
<p>  b.执行过程 </p>
<p>  初始标记：仅仅标记被GC Roots直接关联到的对象，存在STW。 </p>
<p>  并发标记：从GC Roots直接关联的对象开始，遍历整个对象图的过程。此过程不需要停顿用户线程； </p>
<p>  重新标记：重新标记那些在并发标记阶段，由于用户线程的执行标记记录产生变动的对象； </p>
<p>  并发回收：采用标记-清除<a href="">算法</a>，并发清除垃圾对象  </p>
<p>  c.缺点： </p>
<p>  ①内存碎片化 </p>
<p>  产生<strong>内存碎片化</strong>问题，当老年代需要为大对象分配内存时，不得不提前触发Full GC; </p>
<p>  ②浮动垃圾 </p>
<p>  无法处理”<strong>浮动垃圾</strong>“，可能导致并发失败，从而引发Full GC </p>
<p>  浮动垃圾：因为在并发清理阶段，垃圾回收线程和用户线程并发执行，因此该  过程会产生新的垃  圾，这部分垃圾是再标记阶段之后产生的，因此这部分垃圾只能等到下一次垃圾回收时才能被回收，这个时候需要预留出一部分的内存空间。 </p>
<p>  ③对Cpu比较敏感：（核心数+3）/4 </p>
<p>  CMS默认的垃圾回收线程的数量是：（处理器核数+3）/4，对于处理器核心数较少的情况，垃圾回收线程所占的比较较大，影响运行效率。 </p>
<p>  d.使用场景 </p>
<p>  主打低延时，用于频繁交互的场景； </p>
<p>  ②G1垃圾回收器 </p>
<p>  a.概述 </p>
<p>  1.目标是在停顿时间可控的情况下，尽可能提高吞吐量的垃圾回收器 </p>
<p>  2.将整个堆内存分为多个region区域，跟踪每个Region区的垃圾堆积的价值大小，然后后台维护一个优先级列表，每次根据允许的收集时间，优先回收价值大的region； </p>
<p>  3.基于复制<a href="">算法</a>和标记整理的<a href="">算法</a>的并行垃圾回收器，为jdk1.9默认的垃圾回收器； </p>
<p>  b.G1的回收过程 </p>
<p>  ①初始标记：只标记GC Roots直接关联到的对象，此过程需要STW； </p>
<p>  ②并发标记：从GC Root直接关联到的对象开始，递归遍历整个对象图，此时垃圾回收线程和用户线程交替执行； </p>
<p>  ③最终标记：由于并发标记阶段，用于线程在执行，需要对标记结果进行修正，此时需要STW； </p>
<p>  ④<strong>筛选回收</strong>：根据用户设置停顿时间，采用复制<a href="">算法</a>进行清理（将决定回收的Region中的存活对象复制到空的region中，然后清空旧的Region空间），因为涉及到引用的变更，因此需要STW； </p>
<p>  c.G1的优点 </p>
<p>  <strong>1.并行和并发</strong> </p>
<p>  <strong>并行性</strong>：在G1垃圾回收期间，可以允许多条垃圾回收线程同时进行回收，有效利用多核计算能力； </p>
<p> 并发性：在G1并发标记阶段，允许垃圾收集线程和用户线程并发执行； </p>
<p>  <strong>2.**</strong>分代收集** </p>
<p> G1同时兼顾了老年代和新生代。因为G1垃圾收集器将堆空间分为不同的region区，这些区域包含了逻辑上的新生代和老年代。 </p>
<p>  <strong>3.**</strong>不存在内存碎片化的问题** </p>
<p> 因为G1垃圾回收器以Region为基本单元进行回收，Region之间采用的是复制<a href="">算法</a>，但是从整体上看是基于标记整理<a href="">算法</a>，因此可以避免内存碎片化的问题。 </p>
<p>  <strong>4.**</strong>可预测的停顿时间模型** </p>
<p> 使得使用者明确在一个长度为M的时间片段内，用于垃圾回收的时间不超过N；<strong>原因在于G1垃圾回收器跟踪每个region区垃圾堆积的大小，然后后台维护一个优先级列表，在规定的时间内，优先回收价值大的region区。</strong> </p>
<p>  **d.**缺点： </p>
<p>  由于<strong>垃圾收集产生的内存占用大</strong>，小内存上性能不如CMS； </p>
<p>  f.应用场景： </p>
<p>  <strong>面向服务端的垃圾收集器，适用于配备多核CPU和大容量内存的机器。</strong> </p>
<p>  <strong>③什么是垃圾</strong> </p>
<p>  <strong>对于那些没有任何引用指向的对象称之为垃圾</strong> </p>
<h3 id="2-其他垃圾回收器"><a href="#2-其他垃圾回收器" class="headerlink" title="2.其他垃圾回收器"></a>2.其他垃圾回收器</h3><p> ①serial及serial old垃圾回收器（串行回收） </p>
<p>  serial是复制<a href="">算法</a>、串行的，需要STW的针对新生代的垃圾回收器，是hs在<a href="">客户端</a>模式下默认的新生代垃圾回收器 </p>
<p> serial old是标记-整理<a href="">算法</a>，串行的，需要STW的针对老年代的垃圾回收器，是hs在<a href="">客户端</a>默认的老年代垃圾回收器 </p>
<p> 优点：因为是单线程，因此没有线程交换的开销，相对于其他垃圾回收器的单线程相比，简单而且高效 </p>
<p> ②parNew垃圾回收器（并行回收） </p>
<p> parNew是复制<a href="">算法</a>，并行回收，需要STW的针对新生代的垃圾回收器，是hs在服务端默认的新生代垃圾回收器； </p>
<p>  优点：对于新生代，回收次数频繁，比较高效； </p>
<p> ③parallel scavenge和parallel old垃圾回收器(吞吐量优先) </p>
<p>  parallel scavenge采用复制<a href="">算法</a>、并行回收，需要STW的针对新生代的垃圾回收器，注重吞吐量优先； </p>
<p>  parallel old垃圾回收器是标记整理、并行回收，需要STW的针对老年代的垃圾回收器； </p>
<p>  使用场景：高吞吐量则可以高效利用cpu的时间，来实现快速计算，主要适合于在后台运行而不需要进行太多交互的场景。 </p>
<p>  以上两种组合是jdk1.7和1.8中默认的垃圾回收器，适用于后台大量计算而不需要太多交互的场景；</p>
<h3 id="3-为什么要分代？"><a href="#3-为什么要分代？" class="headerlink" title="3.为什么要分代？"></a>3.为什么要分代？</h3><p>  因为java对象的生命周期是不同的，大部分对象的声明周期是比较短暂的，少部分对象的声明周期是比较长的，甚至是伴随着JVM的消亡而消亡，通过分为新生代和老年代两种内存区域，将声明周期短暂的对象放在新生代，将声明周期较长的对象放在老年代，在进行垃圾回收的时候，能够提高效率；如果不采用分代的话，在进行垃圾回收的时候，需要遍历整个堆空间，造成STW时间过长，影响用户体验。 </p>
<h2 id="6-内存泄漏与内存溢出问题及解决方式"><a href="#6-内存泄漏与内存溢出问题及解决方式" class="headerlink" title="6.内存泄漏与内存溢出问题及解决方式"></a>6.内存泄漏与内存溢出问题及解决方式</h2><p> 内存泄漏场景： </p>
<p> ①单例模式中，存在对其他对象的引用，这个对象已经用不到了，但是因为单例的存在没法释放该对象。 </p>
<p> ②将某些对象添加到集合中，集合中的某些对象可能已经用不到了，但是因为集合对该对象还存在引用关系，导致无法被及时回收； </p>
<h2 id="7-JVM内存结构"><a href="#7-JVM内存结构" class="headerlink" title="7.JVM内存结构"></a>7.JVM内存结构</h2><p> ①类加载子系统 </p>
<p> ②运行时数据区 </p>
<p>  a.程序计数器 </p>
<p>  1.作用：记录虚拟机字节码指令的下一条地址，当一个线程再次获得CPU执行权的时候，能够保证下一条执行从哪儿继续； </p>
<p>  b.虚拟机栈 </p>
<p>  1.作用：主管java程序的运行，虚拟机栈中存储着栈帧，对应着一个一个执行的方法，当方法执行的时候，会进行压栈操作，方法执行完后进行弹栈。 </p>
<p>  2.组成： </p>
<p>  ①局部变量表 </p>
<p>  存储方法的参数及局部变量，如果是基本数据类型，则会存储变量值，如果是引用数据类型的话，则存储的是引用地址值。 </p>
<p>  ②操作数栈 </p>
<p>  临时存储变量，作为变量计算的中间结果的临时存储区域 </p>
<p>  ③动态链接 </p>
<p>  将虚拟机栈中的符号引用转为方法区中的方法的直接引用； </p>
<p>  ④方法返回地址 </p>
<p>  存储方法的返回地址，方便调用者能够获取到方法的返回值。 </p>
<p>  3.与本地方法栈的区别： </p>
<p>  虚拟机栈负责java程序的执行；本地方法栈作用类似于虚拟机栈，负责本地方法的执行，本地方法指的的用C/C++编写的程序，作为方法的扩展库；hotSpot虚拟机将两者合二为一。 </p>
<p>  c.堆 </p>
<p>  1.作用：绝大多数的创建的对象将会存储在堆中；jdk1.7之后静态变量及字符串常量存储在堆空间中 </p>
<p>  d.方法区 </p>
<p>  1.作用：存储类信息，域信息，方法信息，常量，即时编译器的代码缓存，jdk1.6及之前存储静态变量。 </p>
<p>  e.本地方法栈 </p>
<p>  1.作用:负责本地方法的运行，本地方法指的是用C/C++编写的程序，作为方法的扩展库。 </p>
<p> ③执行引擎 </p>
<p> ④本地方法接口/本地方法库 </p>
<h2 id="8-JVM类加载过程"><a href="#8-JVM类加载过程" class="headerlink" title="8.JVM类加载过程"></a>8.JVM类加载过程</h2><p> a.加载阶段 </p>
<p>  作用： </p>
<p>  ①根据类的全限定名获取类的二进制字节流； </p>
<p>  ②将该二进制字节流所代表的静态存储结构转换为方法区的运行时的数据结构； </p>
<p>  ③在内存中生成一个代表该类的大的Class对象，作为方法区这个类的数据访问入口。 </p>
<p> b.链接阶段： </p>
<p>  1.验证： </p>
<p>  验证该二进制字节码文件是否符合虚拟机规范，确保在运行过程中不会对虚拟机造成伤害； </p>
<p>  2.准备： </p>
<p>  对类的静态变量及静态代码块进行隐式的初始化，但是有final修饰的变量会进行过显示初始化 </p>
<p>  3.解析： </p>
<p>  将常量池中的符号引用转换为直接引用 </p>
<p> c.初始化： </p>
<p>  根据程序显示初始化类的静态变量及其他资源。 </p>
<h2 id="9-类加载如何保证线程安全"><a href="#9-类加载如何保证线程安全" class="headerlink" title="9.类加载如何保证线程安全"></a>9.类加载如何保证线程安全</h2><p>  类加载器在加载类时采用的loadClass()方法使用了Synchronized关键字进行修饰。 </p>
<h2 id="10-双亲委派机制"><a href="#10-双亲委派机制" class="headerlink" title="10.双亲委派机制"></a>10.双亲委派机制</h2><p> 1.定义： </p>
<p>  当一个类需要加载时，负责加载此类的加载器不会立即对其进行加载，而是递归的委托给其父类加载，父类收到这个加载任务后也会向上进行委托，直到引导类加载器，如果引导类加载器能够加载此类，则会进行加载，如果无法实现加载此类，则会返回给其子类进行加载。 </p>
<p> 2.好处 </p>
<p>  ①：这样做可以有效地防止类被重复加载 </p>
<p>  ②：能够保护java的核心类库，放置核心的API被随意篡改 </p>
<p> 3.各个类加载器加载的类的文件名 </p>
<p> a,引导类加载器 </p>
<p>  java的<strong>核心类库</strong>都是使用引导类加载器加载的，加载的文件存放在**<JAVA_HOME> /lib**文件夹中； </p>
<p>  b.扩展类加载器 </p>
<p>  扩展类加载器负责加载**<JAVA_HOME>/lib/ext**目录中的jar文件 </p>
<p>  c.应用程序类加载器 </p>
<p>  应用程序类加载器加载的是<strong>用户类路径上的类库</strong> </p>
<h2 id="11-垃圾回收算法"><a href="#11-垃圾回收算法" class="headerlink" title="11.垃圾回收算法"></a>11.垃圾回收<a href="">算法</a></h2><p> 1.标记-清除<a href="">算法</a> </p>
<p>  a.<a href="">算法</a>概述 </p>
<p>  当进行垃圾回收时，会停止整个程序（stw）,然后整个过程分为标记阶段和清除阶段 </p>
<p>  <strong>标记阶段</strong>：从引用根对象开始遍历，标记所有被引用的对象，一般在对象头中纪录为可达对象； </p>
<p>  <strong>清除阶段</strong>：对堆内存从头到尾遍历，如果发现某个对象的对象头没有被标记为可达对象，则进行回收； </p>
<p>  b.优点： </p>
<p>  最早的比较经典的<a href="">算法</a> </p>
<p>  c.缺点： </p>
<p>  ①无法解决<strong>内存碎片化</strong>的问题 </p>
<p>  ②在进行GC时，<strong>需要STW</strong>，效率不高的话，会影响用户的体验 </p>
<p>  ③因为需要遍历，所以<strong>执行效率</strong>不高 </p>
<p> 2.复制<a href="">算法</a> </p>
<p>  a.<a href="">算法</a>概述： </p>
<p>  将内存分为大小相等的两部分，每次只使用其中的一块，当进行垃圾回收时，将正在使用的内存中的存活对象复制到另一块内存空间中，然后将正在使用的内存清除，交换两内存空间，继续执行上述操作，完成垃圾回收 </p>
<p>  b.优点： </p>
<p>  ①可以解决<strong>内存碎片化</strong>的问题； </p>
<p>  ②执行效率高，<strong>省去了清除阶段的遍历过程</strong>； </p>
<p>  c.缺点： </p>
<p>  ①内存<strong>空间利用率不高</strong>，因为总是需要一块空的内存； </p>
<p>  ②对于G1这种多个region的垃圾回收器来说，复制并且移动意味着需要维持多个region间的引用关系，<strong>时间和空间消耗比较大</strong>。 </p>
<p>  d.适用场景：比较适合于垃圾对象较多，存活对象较少的区域；新生代中得S区；不适合老年代中的垃圾回收 </p>
<p> 3.标记-整理<a href="">算法</a> </p>
<p>  a.<a href="">算法</a>概述 </p>
<p>  标记阶段与标记-清除<a href="">算法</a>中的标记阶段是一样的 </p>
<p>  整理阶段：将所有存活的对象移动到内存一侧，按顺序存放，然后清除边界以外的内存空间。 </p>
<p>  b.优点： </p>
<p>  ①解决内存碎片化的问题； </p>
<p>  ②空间利用率更高 </p>
<p>  c.缺点： </p>
<p>  ①整理过程中需要移动对象，如果对象被其他对象所引用，需要不断调整引用地址； </p>
<p>  ②效率相对另外两种<a href="">算法</a>较低 </p>
<p>  d.适用场景： </p>
<p>  适用于<strong>老年代</strong>的垃圾回收。 </p>
<h2 id="12-如何选择垃圾回收器"><a href="#12-如何选择垃圾回收器" class="headerlink" title="12.如何选择垃圾回收器"></a>12.如何选择垃圾回收器</h2><p>  **a.**优先调整堆的大小，让jvm能够适应；</p>
<p>  **b.**如果是内存比较小，选择serial+serial Old垃圾回收器</p>
<p>  **c.**如果是单核，没有停顿时间要求，选择serial+serial Old垃圾回收器</p>
<p>  **d.**如果是多核CPU,需要高的吞吐量，选择parallel scanvenge+parallel Old垃圾回收器；</p>
<p>  **e.**如果是多核cpu,低停顿时间</p>
<p>  如果是jdk14以前，可以选用CMS+ParNew；jdk14后，G1垃圾回收器 </p>
<h2 id="13-对象的内存分配策略"><a href="#13-对象的内存分配策略" class="headerlink" title="13.对象的内存分配策略"></a>13.对象的内存分配策略</h2><p>  a.优先分配到新生代 </p>
<p>  b.大对象直接分配在老年代 </p>
<p>  c.长期存活的对象（新生代中的S区的对象年龄达到了设定的阈值）分配到老年代； </p>
<p>  d.动态判断对象年龄：如果相同年龄的对象所占的空间大于等于S区的一半，则大于等于该年龄的对象则会被分配到老年代中。 </p>
<h2 id="14-垃圾判定方法"><a href="#14-垃圾判定方法" class="headerlink" title="14.垃圾判定方法"></a>14.垃圾判定方法</h2><p> a.引用计数<a href="">算法</a>（python中采用） </p>
<p>  ①概述 </p>
<p>  每个对象都有一个引用计数器，对象每增加一次引用，计数器的值就增加1，没减少一次引用，则计数器就-1，当引用计数器的值为0时，判定为对象不存在引用，即认为是垃圾。 </p>
<p>  ②<a href="">算法</a>的优/缺点 </p>
<p>  优点：实现简单，执行效率高； </p>
<p>  缺点： </p>
<p>  1.最大的缺点是不能够解决循环引用问题，如果几个对象存在循环引用，但是这几个对象已经没有其他引用指向他们，但是因为其相互引用，则引用计数器的值也不为零，因此会造成内存泄露的问题。 </p>
<p>  2.因为是计数器，所以也占用一定的空间开销。 </p>
<p> b,可达性分析<a href="">算法</a>（java采用） </p>
<p>  ①概述 </p>
<p>  可达性分析<a href="">算法</a>的思想为：首先说一下GC Roots,一组活跃引用的跟对象集合，以跟对象为起始点，从上向下搜索被根对象所连接的目标是否可达，内存中对象都直接或者间接的与根对象相连，搜索所走过的路径称为引用链，没有被引用链所连接的对象即为不可达，即被判定为垃圾。 </p>
<p>  ②<a href="">算法</a>优/缺点 </p>
<p>  优点：可以解决循环引用的问题 </p>
<p>  缺点：相较于引用计数<a href="">算法</a>而言，判定效率低一些。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">X_ray</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://xray1025.github.io/2020/10/14/0000.%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/">https://xray1025.github.io/2020/10/14/0000.%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://xray1025.github.io" target="_blank">X_ray's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/JVM/">JVM</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/10/15/0000.Spring/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Spring</div></div></a></div><div class="next-post pull-right"><a href="/2020/10/14/0000.%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">多线程和JVM</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/11/12/0000.数据库调优/" title="数据库调优"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-12</div><div class="title">数据库调优</div></div></a></div><div><a href="/2020/10/30/000001.SpringBoot面试题/" title="SpringBoot面试题"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-30</div><div class="title">SpringBoot面试题</div></div></a></div><div><a href="/2020/10/26/EXPLAIN执行计划中要重点关注哪些要素/" title="EXPLAIN执行计划中要重点关注哪些要素"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-26</div><div class="title">EXPLAIN执行计划中要重点关注哪些要素</div></div></a></div><div><a href="/2020/10/18/JAVA集合/" title="Java集合"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-18</div><div class="title">Java集合</div></div></a></div><div><a href="/2020/10/22/Mybatis的一级缓存和二级缓存/" title="Mybatis的一级缓存和二级缓存"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-22</div><div class="title">Mybatis的一级缓存和二级缓存</div></div></a></div><div><a href="/2020/11/04/Spring、SpringMvc、MyBatis用到的设计模式/" title="Spring、SpringMVC、MyBatis用到的设计模式"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-04</div><div class="title">Spring、SpringMVC、MyBatis用到的设计模式</div></div></a></div></div></div></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/null" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">X_ray</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">105</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81JVM%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">一、JVM概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0-JVM%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="toc-number">1.1.</span> <span class="toc-text">0.JVM作用：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-jvm%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.2.</span> <span class="toc-text">1.jvm的位置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Jvm%E7%9A%84%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84%EF%BC%88HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">2.Jvm的整体结构（HotSpot虚拟机）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Java%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.4.</span> <span class="toc-text">3.Java代码的执行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-jvm%E7%9A%84%E8%BF%90%E8%A1%8C%E5%91%A8%E6%9C%9F"><span class="toc-number">1.5.</span> <span class="toc-text">4.jvm的运行周期</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E2%98%86"><span class="toc-number">2.</span> <span class="toc-text">二、类加载子系统(☆)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="toc-number">2.1.</span> <span class="toc-text">1.作用：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%88%86%E4%B8%BA%E5%93%AA%E4%BA%9B%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-number">2.2.</span> <span class="toc-text">2.类加载分为哪些过程：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%90%84%E9%98%B6%E6%AE%B5%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="toc-number">2.3.</span> <span class="toc-text">3.类加载各阶段的作用：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8B-%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.</span> <span class="toc-text">4.简单描述一下()方法?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.5.</span> <span class="toc-text">5.类加载器是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9A"><span class="toc-number">2.6.</span> <span class="toc-text">6.类加载器的分类：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.7.</span> <span class="toc-text">7.双亲委派模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.8.</span> <span class="toc-text">8.破坏双亲委派模型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">三、运行时数据区（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0%EF%BC%9A"><span class="toc-number">3.1.</span> <span class="toc-text">1.概述：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">3.2.</span> <span class="toc-text">2.程序计数器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-number">3.3.</span> <span class="toc-text">3.Java虚拟机栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%A0%86%E5%92%8C%E6%A0%88"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.1内存中的堆和栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.2虚拟机栈的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E7%9A%84%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9F"><span class="toc-number">3.3.3.</span> <span class="toc-text">3.3虚拟机栈的声明周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">3.3.4.</span> <span class="toc-text">3.4特点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5JVM%E5%AF%B9%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E7%9A%84%E6%93%8D%E4%BD%9C%E6%9C%89%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.3.5.</span> <span class="toc-text">3.5JVM对虚拟机栈的操作有什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%B8%B8%E8%A7%81%E4%B8%A4%E4%B8%AA%E5%BC%82%E5%B8%B8"><span class="toc-number">3.3.6.</span> <span class="toc-text">3.6虚拟机栈常见两个异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E8%BF%90%E8%A1%8C%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">3.3.7.</span> <span class="toc-text">3.7虚拟机栈运行的原理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8%E6%A0%88%E5%B8%A7%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">3.3.8.</span> <span class="toc-text">3.8栈帧的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8"><span class="toc-number">3.3.9.</span> <span class="toc-text">3.9局部变量表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-10-%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88"><span class="toc-number">3.3.10.</span> <span class="toc-text">3.10.操作数栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-11%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.3.11.</span> <span class="toc-text">3.11操作数栈的数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-12%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">3.3.12.</span> <span class="toc-text">3.12操作数栈的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">3.3.13.</span> <span class="toc-text">4.动态链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80"><span class="toc-number">3.3.14.</span> <span class="toc-text">5.方法的返回地址</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-number">3.4.</span> <span class="toc-text">4.本地方法栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%A0%86"><span class="toc-number">3.5.</span> <span class="toc-text">5.堆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%A0%86%E7%A9%BA%E9%97%B4%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="toc-number">3.5.1.</span> <span class="toc-text">1.堆空间的概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AE%BE%E7%BD%AE%E5%A0%86%E5%86%85%E5%AD%98%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%8F%8AOOM%E9%97%AE%E9%A2%98"><span class="toc-number">3.5.2.</span> <span class="toc-text">2.设置堆内存的大小及OOM问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%96%B0%E7%94%9F%E4%BB%A3%E4%B8%8E%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="toc-number">3.5.3.</span> <span class="toc-text">3.新生代与老年代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E4%B8%80%E8%88%AC%E8%BF%87%E7%A8%8B%EF%BC%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E4%B8%80%E8%88%AC%E8%BF%87%E7%A8%8B%EF%BC%89"><span class="toc-number">3.5.4.</span> <span class="toc-text">4.对象内存分配的一般过程（垃圾回收的一般过程）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5%EF%BC%88%E5%BD%93%E5%87%BA%E7%8E%B0%E8%B6%85%E5%A4%A7%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%83%85%E5%86%B5%E6%97%B6%EF%BC%89%EF%BC%9A"><span class="toc-number">3.5.5.</span> <span class="toc-text">5.对象内存分配特殊情况（当出现超大对象的情况时）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Minor-GC%E5%92%8CMajor-GC%E5%92%8CFull-GC"><span class="toc-number">3.5.6.</span> <span class="toc-text">6.Minor GC和Major GC和Full GC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%A0%86%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E4%BB%A3%E6%80%9D%E6%83%B3"><span class="toc-number">3.5.7.</span> <span class="toc-text">7.堆空间的分代思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-number">3.5.8.</span> <span class="toc-text">8.内存分配策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-TLAB%EF%BC%88Thread-Local-Allocation-Buffer-%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89%E7%BC%93%E5%AD%98%E5%8C%BA%EF%BC%89"><span class="toc-number">3.5.9.</span> <span class="toc-text">9.TLAB（Thread Local Allocation Buffer:线程私有缓存区）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%A0%86%E6%98%AF%E5%88%86%E9%85%8D%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%9A%84%E5%94%AF%E4%B8%80%E9%80%89%E6%8B%A9%E5%90%97%EF%BC%9F"><span class="toc-number">3.5.10.</span> <span class="toc-text">11.堆是分配对象存储的唯一选择吗？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">3.6.</span> <span class="toc-text">6.方法区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%A0%86%E3%80%81%E6%A0%88%E5%92%8C%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E4%BA%A4%E4%BA%92%E5%85%B3%E7%B3%BB"><span class="toc-number">3.6.1.</span> <span class="toc-text">1.堆、栈和方法区的交互关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">3.6.2.</span> <span class="toc-text">2.方法区的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%B0%83%E8%8A%82%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%92%8COOM"><span class="toc-number">3.6.3.</span> <span class="toc-text">3.调节方法区的大小和OOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.6.4.</span> <span class="toc-text">4.方法区的内部结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%96%B9%E6%B3%95%E5%8C%BA%E5%9C%A8jdk6%E5%92%8Cjdk7%E5%8F%8Ajdk8%E7%9A%84%E4%B8%8D%E5%90%8C%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89%EF%BC%9F"><span class="toc-number">3.6.5.</span> <span class="toc-text">5.方法区在jdk6和jdk7及jdk8的不同（重点）？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E4%B8%8E%E8%AE%BF%E9%97%AE"><span class="toc-number">3.6.6.</span> <span class="toc-text">6.对象的实例化与访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">3.6.7.</span> <span class="toc-text">2.对象的内存布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D"><span class="toc-number">3.6.8.</span> <span class="toc-text">3.对象的访问定位</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">四、执行引擎（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E6%A6%82%E8%BF%B0"><span class="toc-number">4.1.</span> <span class="toc-text">1.执行引擎概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-java%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E6%89%A7%E8%A1%8C%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">4.2.</span> <span class="toc-text">2.java代码的编译和执行的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%A7%A3%E9%87%8A%E5%99%A8"><span class="toc-number">4.3.</span> <span class="toc-text">3.解释器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E5%99%A8%EF%BC%88JIT%EF%BC%89"><span class="toc-number">4.4.</span> <span class="toc-text">4.即时编译器（JIT）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%A7%A3%E9%87%8A%E5%99%A8%E4%B8%8E%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">4.5.</span> <span class="toc-text">5.解释器与即时编译器的优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-StringTable-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">4.6.</span> <span class="toc-text">6.StringTable(字符串)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">五、垃圾回收（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0"><span class="toc-number">5.1.</span> <span class="toc-text">1.垃圾回收概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95"><span class="toc-number">5.2.</span> <span class="toc-text">2.垃圾回收相关算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%EF%BC%9A%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5%EF%BC%88%E8%A1%A8%E6%98%8E%E4%BB%80%E4%B9%88%E5%AF%B9%E8%B1%A1%E9%9C%80%E8%A6%81%E5%9B%9E%E6%94%B6%EF%BC%89"><span class="toc-number">5.2.1.</span> <span class="toc-text">①：标记阶段（表明什么对象需要回收）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%EF%BC%9A%E5%AF%B9%E8%B1%A1%E7%9A%84finalization%E6%9C%BA%E5%88%B6"><span class="toc-number">5.2.2.</span> <span class="toc-text">②：对象的finalization机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A3%EF%BC%9A%E6%B8%85%E9%99%A4%E9%98%B6%E6%AE%B5-%E5%A6%82%E4%BD%95%E5%9B%9E%E6%94%B6%E5%9E%83%E5%9C%BE"><span class="toc-number">5.2.3.</span> <span class="toc-text">④：清除阶段(如何回收垃圾)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">5.3.</span> <span class="toc-text">3.垃圾回收相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0-System-gc"><span class="toc-number">5.3.1.</span> <span class="toc-text">①  System.gc()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="toc-number">5.3.2.</span> <span class="toc-text">②  内存溢出与内存泄露</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2-STW"><span class="toc-number">5.3.3.</span> <span class="toc-text">③ STW</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A3-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="toc-number">5.3.4.</span> <span class="toc-text">④ 垃圾回收并行与并发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A4-%E5%AE%89%E5%85%A8%E7%82%B9%E4%B8%8E%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F-%E5%90%8E%E6%9C%9F%E8%A1%A5%E5%85%85"><span class="toc-number">5.3.5.</span> <span class="toc-text">⑤ 安全点与安全区域**(后期补充)**</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A5-%E5%BC%BA%E5%BC%95%E7%94%A8%EF%BC%88Strong-Reference%EF%BC%89"><span class="toc-number">5.3.6.</span> <span class="toc-text">⑥ 强引用（Strong Reference）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A6-%E8%BD%AF%E5%BC%95%E7%94%A8-Soft-Reference"><span class="toc-number">5.3.7.</span> <span class="toc-text">⑦ 软引用(Soft Reference)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A7-%E5%BC%B1%E5%BC%95%E7%94%A8-Weak-Reference"><span class="toc-number">5.3.8.</span> <span class="toc-text">⑧ 弱引用(Weak Reference)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A8-%E8%99%9A%E5%BC%95%E7%94%A8-Phantom-Reference"><span class="toc-number">5.3.9.</span> <span class="toc-text">⑨ 虚引用(Phantom Reference)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">5.4.</span> <span class="toc-text">4.垃圾回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B8%BB%E8%A6%81%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">5.4.1.</span> <span class="toc-text">①垃圾回收主要性能指标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%A6%82%E8%BF%B0%EF%BC%88%E5%88%86%E7%B1%BB%EF%BC%89"><span class="toc-number">5.4.2.</span> <span class="toc-text">②垃圾回收器概述（分类）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB"><span class="toc-number">5.4.3.</span> <span class="toc-text">③垃圾回收器的组合关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A3Serial%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%88%E4%B8%B2%E8%A1%8C%E5%9B%9E%E6%94%B6%EF%BC%89"><span class="toc-number">5.4.4.</span> <span class="toc-text">④Serial垃圾回收器（串行回收）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A4ParNew%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%88%E5%B9%B6%E8%A1%8C%E5%9B%9E%E6%94%B6%EF%BC%89"><span class="toc-number">5.4.5.</span> <span class="toc-text">⑤ParNew垃圾回收器（并行回收）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A5Parallel%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%88%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88%EF%BC%89"><span class="toc-number">5.4.6.</span> <span class="toc-text">⑥Parallel垃圾回收器（吞吐量优先）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A6CMS-Concurrent-Mark-Sweep-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%88%E4%BD%8E%E5%BB%B6%E6%97%B6%EF%BC%89"><span class="toc-number">5.4.7.</span> <span class="toc-text">⑦CMS(Concurrent Mark Sweep)垃圾回收器（低延时）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A7G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">5.4.8.</span> <span class="toc-text">⑧G1垃圾回收器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E8%A1%A5%E5%85%85%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">六、补充面试题总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-JVM%E8%B0%83%E4%BC%98"><span class="toc-number">6.1.</span> <span class="toc-text">1.JVM调优</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-OOM%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">6.2.</span> <span class="toc-text">2.OOM及其解决？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-jdk1-7%E5%92%8Cjdk1-8%E6%AF%94%E8%BE%83%EF%BC%9F"><span class="toc-number">6.3.</span> <span class="toc-text">3.jdk1.7和jdk1.8比较？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Full-GC%E4%B8%8EMinor-GC"><span class="toc-number">6.4.</span> <span class="toc-text">4.Full GC与Minor GC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3"><span class="toc-number">6.5.</span> <span class="toc-text">5.垃圾回收相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-CMS%E5%92%8CG1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%AF%94%E8%BE%83"><span class="toc-number">6.5.1.</span> <span class="toc-text">1.CMS和G1垃圾回收器比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%85%B6%E4%BB%96%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">6.5.2.</span> <span class="toc-text">2.其他垃圾回收器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E4%BB%A3%EF%BC%9F"><span class="toc-number">6.5.3.</span> <span class="toc-text">3.为什么要分代？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F"><span class="toc-number">6.6.</span> <span class="toc-text">6.内存泄漏与内存溢出问题及解决方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">6.7.</span> <span class="toc-text">7.JVM内存结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">6.8.</span> <span class="toc-text">8.JVM类加载过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">6.9.</span> <span class="toc-text">9.类加载如何保证线程安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">6.10.</span> <span class="toc-text">10.双亲委派机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">6.11.</span> <span class="toc-text">11.垃圾回收算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">6.12.</span> <span class="toc-text">12.如何选择垃圾回收器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-number">6.13.</span> <span class="toc-text">13.对象的内存分配策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E5%9E%83%E5%9C%BE%E5%88%A4%E5%AE%9A%E6%96%B9%E6%B3%95"><span class="toc-number">6.14.</span> <span class="toc-text">14.垃圾判定方法</span></a></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/01/03/0086.%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/" title="0086.分隔链表"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="0086.分隔链表"/></a><div class="content"><a class="title" href="/2021/01/03/0086.%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/" title="0086.分隔链表">0086.分隔链表</a><time datetime="2021-01-03T13:29:27.637Z" title="发表于 2021-01-03 21:29:27">2021-01-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/23/0000.Java%E6%BA%90%E7%A0%81/" title="JDK源码"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JDK源码"/></a><div class="content"><a class="title" href="/2020/12/23/0000.Java%E6%BA%90%E7%A0%81/" title="JDK源码">JDK源码</a><time datetime="2020-12-23T07:32:47.662Z" title="发表于 2020-12-23 15:32:47">2020-12-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/11/23/%E5%BF%AB%E9%80%9F%E7%90%86%E8%A7%A3%20volatile%20%E5%85%B3%E9%94%AE%E5%AD%97/" title="快速理解 volatile 关键字"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="快速理解 volatile 关键字"/></a><div class="content"><a class="title" href="/2020/11/23/%E5%BF%AB%E9%80%9F%E7%90%86%E8%A7%A3%20volatile%20%E5%85%B3%E9%94%AE%E5%AD%97/" title="快速理解 volatile 关键字">快速理解 volatile 关键字</a><time datetime="2020-11-23T11:11:08.654Z" title="发表于 2020-11-23 19:11:08">2020-11-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/11/12/0000.SpringBoot%E9%9D%A2%E8%AF%95%E9%A2%98/" title="SpringBoot面试题"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringBoot面试题"/></a><div class="content"><a class="title" href="/2020/11/12/0000.SpringBoot%E9%9D%A2%E8%AF%95%E9%A2%98/" title="SpringBoot面试题">SpringBoot面试题</a><time datetime="2020-11-12T02:46:43.400Z" title="发表于 2020-11-12 10:46:43">2020-11-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/11/12/0000.%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B0%83%E4%BC%98/" title="数据库调优"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库调优"/></a><div class="content"><a class="title" href="/2020/11/12/0000.%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B0%83%E4%BC%98/" title="数据库调优">数据库调优</a><time datetime="2020-11-12T01:51:41.182Z" title="发表于 2020-11-12 09:51:41">2020-11-12</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By X_ray</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>