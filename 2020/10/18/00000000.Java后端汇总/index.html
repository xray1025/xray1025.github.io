<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java汇总 | X_ray's blog</title><meta name="keywords" content="Java"><meta name="author" content="X_ray"><meta name="copyright" content="X_ray"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="Java语法Java特点 面向对象： 类：类是现实世界在计算机中的反映，它将数据和对这些数据的操作封装在一起。 对象：类的实例。 抽象：在定义一个类的时候，实际上就是把一类事物的公有的属性和行为提取出来，形成一个物理模型，这种研究问题的方法称为抽象。 封装：把对象的属性和行为（数据）结合为一个独立的整体，并尽可能隐藏对象的内部实现细节。 1、通过隐藏对象的属性来保护对象的内部状态 2、提高代码的可">
<meta property="og:type" content="article">
<meta property="og:title" content="Java汇总">
<meta property="og:url" content="https://xray1025.github.io/2020/10/18/00000000.Java%E5%90%8E%E7%AB%AF%E6%B1%87%E6%80%BB/index.html">
<meta property="og:site_name" content="X_ray&#39;s blog">
<meta property="og:description" content="Java语法Java特点 面向对象： 类：类是现实世界在计算机中的反映，它将数据和对这些数据的操作封装在一起。 对象：类的实例。 抽象：在定义一个类的时候，实际上就是把一类事物的公有的属性和行为提取出来，形成一个物理模型，这种研究问题的方法称为抽象。 封装：把对象的属性和行为（数据）结合为一个独立的整体，并尽可能隐藏对象的内部实现细节。 1、通过隐藏对象的属性来保护对象的内部状态 2、提高代码的可">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2020-10-18T08:24:42.712Z">
<meta property="article:modified_time" content="2020-10-20T00:41:47.244Z">
<meta property="article:author" content="X_ray">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://xray1025.github.io/2020/10/18/00000000.Java%E5%90%8E%E7%AB%AF%E6%B1%87%E6%80%BB/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-10-20 08:41:47'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/null" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">105</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archive/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tag/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/category/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">X_ray's blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archive/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tag/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/category/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java汇总</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-10-18T08:24:42.712Z" title="发表于 2020-10-18 16:24:42">2020-10-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-10-20T00:41:47.244Z" title="更新于 2020-10-20 08:41:47">2020-10-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Java语法"><a href="#Java语法" class="headerlink" title="Java语法"></a>Java语法</h1><h2 id="Java特点"><a href="#Java特点" class="headerlink" title="Java特点"></a>Java特点</h2><ul>
<li><strong>面向对象：</strong><ul>
<li>类：类是现实世界在计算机中的反映，它将数据和对这些数据的操作封装在一起。</li>
<li>对象：类的实例。</li>
<li>抽象：在定义一个类的时候，实际上就是把一类事物的公有的属性和行为提取出来，形成一个物理模型，这种研究问题的方法称为抽象。</li>
<li>封装：把对象的属性和行为（数据）结合为一个独立的整体，并尽可能隐藏对象的内部实现细节。<ul>
<li>1、通过隐藏对象的属性来保护对象的内部状态</li>
<li>2、提高代码的可用性和可维护性</li>
<li>3、禁止对象之间的不良交互来提高模块化</li>
</ul>
</li>
<li>继承：继承是从已有的类中派生出新的类称为子类，子类继承父类的数据属性和行为，并能根据自己的需求扩展出新的行为，提高了代码的复用性。</li>
<li>多态：指允许不同的对象对同一消息做出相应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式（发送消息就是函数调用）。<ul>
<li>多态存在的三个必要条件<ul>
<li>继承</li>
<li>重写</li>
<li>父类引用指向子类对象</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>健壮性：</strong>吸收C/C++语言的优点，去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等），提供了一个相对安全的内存管理和访问机制。</li>
<li><strong>跨平台性：</strong>通过Java语言编写的应用程序在不同的系统平台上都可以运行【JVM】</li>
</ul>
<h2 id="JDK，-JRE和JVM的区别"><a href="#JDK，-JRE和JVM的区别" class="headerlink" title="JDK， JRE和JVM的区别"></a>JDK， JRE和JVM的区别</h2><ul>
<li>JDK（Java Development Kid，Java 开发开源工具包），是针对 Java 开发人员的产品，是整个 Java 的核心，包括了 Java 运行环境 JRE、Java 工具和 Java 基础类库。</li>
<li>JRE（Java Runtime Environment，Java 运行环境）是运行 JAVA 程序所必须的环境的集合，包含 JVM 标准实现及 Java 核心类库。</li>
<li>JVM（Java Virtual Machine，Java 虚拟机）是整个 Java 实现跨平台的最核心的部分，能够运行以 Java 语言写作的软件程序。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018090519.png"></p>
<h2 id="Java基本数据类型"><a href="#Java基本数据类型" class="headerlink" title="Java基本数据类型"></a>Java基本数据类型</h2><p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018095519.png" alt="image-20201018095515731"></p>
<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><ul>
<li><p>让基本类型也具有对象的特征</p>
</li>
<li><p><strong>装箱</strong>：由基本数据类型构造出一个包装类的对象。</p>
</li>
<li><p><strong>拆箱</strong>：由一个包装类对象转换到相应的基本数据类型。</p>
</li>
</ul>
<h3 id="基本类型和包装类的区别"><a href="#基本类型和包装类的区别" class="headerlink" title="基本类型和包装类的区别"></a>基本类型和包装类的区别</h3><ol>
<li>声明方式不同：基本类型不使用new关键字，而包装类型需要使用new关键字来在<strong>堆中分配存储空间</strong>；</li>
<li>存储方式及位置不同：基本类型是直接将变量值存储在栈中，而包装类型是将对象放在堆中，然后通过引用来使用；</li>
<li>初始值不同：基本类型的初始值如int为0，boolean为false，而包装类型的初始值为null；</li>
<li>使用方式不同：基本类型直接赋值直接使用就好，而包装类型在集合如Collection、Map时会使用到。</li>
</ol>
<h2 id="“-”-和-equals-的区别"><a href="#“-”-和-equals-的区别" class="headerlink" title="“==” 和 equals() 的区别"></a>“==” 和 equals() 的区别</h2><ul>
<li>对于基本数据类型的变量，只能使用 == 判断值是否相等，不能使用equals();</li>
<li>对于引用数据类型，<ul>
<li>如果没有对 equals() 进行重写，== 和equals() 比较的都是引用类型的变量所指向的对象的地址；</li>
<li>诸如String、Date等类对equals方法进行了重写的话，equals() 比较的是所指向的对象的内容。</li>
</ul>
</li>
</ul>
<h2 id="equals-与-hashcode-的区别"><a href="#equals-与-hashcode-的区别" class="headerlink" title="equals() 与 hashcode() 的区别"></a>equals() 与 hashcode() 的区别</h2><ul>
<li>equals()相等的两个对象他们的hashCode()肯定相等。</li>
<li>hashCode()相等的两个对象他们的equals()不一定相等。</li>
</ul>
<h2 id="String、StringBuilder、StringBuffer的区别"><a href="#String、StringBuilder、StringBuffer的区别" class="headerlink" title="String、StringBuilder、StringBuffer的区别"></a>String、StringBuilder、StringBuffer的区别</h2><table>
<thead>
<tr>
<th>String</th>
<th>StringBuffer</th>
<th>StringBuilder</th>
</tr>
</thead>
<tbody><tr>
<td>String的值是不可变的，这就导致每次对String的操作都会生成新的String对象，不仅效率低下，而且浪费大量优先的内存空间</td>
<td>StringBuffer是可变类，和线程安全的字符串操作类，任何对它指向的字符串的操作都不会产生新的对象。每个StringBuffer对象都有一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会自动增加容量</td>
<td>可变类，速度更快</td>
</tr>
<tr>
<td>不可变</td>
<td>可变</td>
<td>可变</td>
</tr>
<tr>
<td></td>
<td>线程安全</td>
<td>线程不安全</td>
</tr>
</tbody></table>
<h2 id="String-s-“hello”和String-s-new-String-“hello”-区别"><a href="#String-s-“hello”和String-s-new-String-“hello”-区别" class="headerlink" title="String s = “hello”和String s = new String(“hello”);区别"></a>String s = “hello”和String s = new String(“hello”);区别</h2><ul>
<li><p><code>String s = &quot;hello&quot;</code>，JVM会直接检查字符串常量池是否已有”hello”字符串对象，如没有，就分配一个内存存放”hello”，如果有，则直接将字符串常量池中的地址返回给栈。(没有new，没有堆的操作)</p>
</li>
<li><p><code>String s = new String(&quot;hello&quot;);</code>可能创建两个对象也可能创建一个对象。如果常量池中有<code>hello</code>字符串常量的话，则仅仅在堆中创建一个对象。如果常量池中没有<code>hello</code>对象，则堆上和常量池都需要创建。</p>
</li>
</ul>
<h2 id="static和final区别"><a href="#static和final区别" class="headerlink" title="static和final区别"></a>static和final区别</h2><table>
<thead>
<tr>
<th align="left">关键词</th>
<th align="left">修饰物</th>
<th align="left">影响</th>
</tr>
</thead>
<tbody><tr>
<td align="left">final</td>
<td align="left">变量</td>
<td align="left">分配到常量池中，程序不可改变其值（引用变量不能变，引用对象可以变）</td>
</tr>
<tr>
<td align="left">final</td>
<td align="left">方法</td>
<td align="left">子类中将不能被重写</td>
</tr>
<tr>
<td align="left">final</td>
<td align="left">类</td>
<td align="left">不能被继承</td>
</tr>
<tr>
<td align="left">static</td>
<td align="left">变量</td>
<td align="left">分配在内存堆上，引用都会指向这一个地址而不会重新分配内存</td>
</tr>
<tr>
<td align="left">static</td>
<td align="left">方法块</td>
<td align="left">虚拟机优先加载</td>
</tr>
<tr>
<td align="left">static</td>
<td align="left">类</td>
<td align="left">可以直接通过类来调用而不需要new</td>
</tr>
</tbody></table>
<h2 id="引用类型是占用几个字节？"><a href="#引用类型是占用几个字节？" class="headerlink" title="引用类型是占用几个字节？"></a>引用类型是占用几个字节？</h2><p>hotspot在64位平台上，占8个字节，在32位平台上占4个字节。</p>
<h3 id="java中的-switch-e-选择结构可以使用数据类型的数据-JDK1-8"><a href="#java中的-switch-e-选择结构可以使用数据类型的数据-JDK1-8" class="headerlink" title="java中的 switch(e) 选择结构可以使用数据类型的数据(JDK1.8)"></a>java中的 switch(e) 选择结构可以使用数据类型的数据(JDK1.8)</h3><ul>
<li><p>在switch（e）中，e只能是一个整数表达式或者枚举常量（更大字体），整数表达式可以是int基本类型或Integer包装类型，由于byte,short,char都可以隐含转换为int，所以，这些类型以及这些类型的包装类型也是可以的。显然，boolean、double和long类型都不符合switch的语法规定，并且不能被隐式转换成int类型，所以，它们不能作用于swtich语句中。</p>
</li>
<li><p>1.7后支持String。</p>
</li>
<li><p>基本类型中，没有<code>boolean</code>和<code>浮点类型</code>+<code>长类型long</code>及其相应的包装类型。外加<code>String</code>和<code>enum</code>。</p>
</li>
</ul>
<h2 id="标识符的构成规则"><a href="#标识符的构成规则" class="headerlink" title="标识符的构成规则"></a>标识符的构成规则</h2><ul>
<li>标识符由数字（0<del>9）和字母（A</del>Z 和 a~z）、美元符号（$）和下划线（_）组合构成。</li>
<li>标识符不能使用数字作为第一个字符。</li>
<li>标识符不能是java的关键字和保留字，但可以包含关键字和保留字，不能包含空格</li>
<li>标识符不允许单独使用下划线作为分隔符。</li>
</ul>
<h2 id="amp-和-amp-amp-的区别"><a href="#amp-和-amp-amp-的区别" class="headerlink" title="&amp;和&amp;&amp;的区别"></a>&amp;和&amp;&amp;的区别</h2><ul>
<li>逻辑与，用&amp;连接的两个条件的最后结果计算第一个表达式为false也会计算第二个表达式</li>
<li>短路与，如果第一个表达式为false整个表达式直接为false跳过第二个判断表达式</li>
</ul>
<h2 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h2><ul>
<li><p>重载 Overload：表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）。</p>
</li>
<li><p>重写 Override：表示子类中的方法覆盖父类中的方法</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018092249.png"></p>
<h2 id="final、finally、finalize的区别"><a href="#final、finally、finalize的区别" class="headerlink" title="final、finally、finalize的区别"></a>final、finally、finalize的区别</h2><ul>
<li>final用于声明属性、方法和类，分别表示属性不可变、方法不可覆盖、类不可被继承（不能再派生出新的子类）</li>
<li>finally作为异常处理的一部分，它只能用在try/catch语句中，并且附带着一个语句块，表示这段语句最终一定被执行，经常被用在需要释放资源的情况下。</li>
<li>finalize是Object类中的一个方法，一旦垃圾回收器准备好释放对象占用的空间，将首先调用其 finalize() 方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。</li>
</ul>
<h2 id="Java修饰符"><a href="#Java修饰符" class="headerlink" title="Java修饰符"></a>Java修饰符</h2><table>
<thead>
<tr>
<th><strong>访问级别</strong></th>
<th><strong>访问控制修饰符</strong></th>
<th><strong>同类</strong></th>
<th><strong>同包</strong></th>
<th><strong>子类(不同包)</strong></th>
<th><strong>不同包(其他类)</strong></th>
</tr>
</thead>
<tbody><tr>
<td>公共</td>
<td>public</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>受保护</td>
<td>protected</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
<td>✖</td>
</tr>
<tr>
<td>默认</td>
<td>default</td>
<td>✔</td>
<td>✔</td>
<td>✖</td>
<td>✖</td>
</tr>
<tr>
<td>私有</td>
<td>private</td>
<td>✔</td>
<td>✖</td>
<td>✖</td>
<td>✖</td>
</tr>
</tbody></table>
<h2 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h2><ul>
<li><p>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</p>
</li>
<li><p>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。</p>
</li>
<li><p>抽象类是可以有静态代码块和静态方法，接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)。</p>
</li>
<li><p>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p>
</li>
</ul>
<h2 id="泛型、反射和注解"><a href="#泛型、反射和注解" class="headerlink" title="泛型、反射和注解"></a>泛型、反射和注解</h2><ul>
<li>泛型类型是通过类型参数化的泛型类或接口。数据类型是数据的参数化，而泛型就是数据类型的参数化，来解决程序的通用性设计和实现的若干问题。</li>
<li>反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</li>
<li>注解的本质就是一个继承了 Annotation 接口的接口，注解是代码里的特殊标记，这些标记可以在编译，类加载，运行时被读取，并执行相应的处理。<ul>
<li>元注解：注解的注解，分别有@Retention、 @Target、 @Document、 @Inherited和@Repeatable（JDK1.8加入）五种。</li>
<li>JDK注解：<ul>
<li>@Override 它是用来描述当前方法是一个重写的方法，在编译阶段对方法进行检查 jdk1.5中它只能描述继承中的重写，jdk1.6中它可以描述接口实现的重写,也能描述类的继承的重写  </li>
<li>@Deprecated 它是用于描述当前方法是一个过时的方法 </li>
<li>@SuppressWarnings 对程序中的警告去除。 </li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018101623.png"></p>
<h3 id="Error和Exception的区别"><a href="#Error和Exception的区别" class="headerlink" title="Error和Exception的区别"></a>Error和Exception的区别</h3><ul>
<li><p>Error，指程序中无法处理的错误，表示运行应用程序中出现了严重的错误。</p>
</li>
<li><p>Exception，程序本身可以捕获并且可以处理的异常。</p>
<ul>
<li><p>运行时异常</p>
<ul>
<li><p><strong>定义</strong>：RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。</p>
</li>
<li><p><strong>特点</strong>：Java 编译器不会检查它。也就是说，当程序中可能出现这类异常时，倘若既”没有通过throws声明抛出它”，也”没有用try-catch语句捕获它”，还是会编译通过。</p>
</li>
</ul>
</li>
<li><p>编译时异常</p>
<ul>
<li><p><strong>定义</strong>: Exception 中除 RuntimeException 及其子类之外的异常。</p>
</li>
<li><p><strong>特点</strong>: Java 编译器会检查它。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="受检异常与非受检异常"><a href="#受检异常与非受检异常" class="headerlink" title="受检异常与非受检异常"></a>受检异常与非受检异常</h3><ul>
<li><p>受检异常</p>
<ul>
<li>编译器要求必须处理的异常。正确的程序在运行过程中，经常容易出现的、符合预期的异常情况。一旦发生此类异常，就必须采用某种方式进行处理。</li>
<li><strong>除 RuntimeException 及其子类外，其他的 Exception 异常都属于受检异常</strong>。</li>
</ul>
</li>
<li><p>非受检异常</p>
<ul>
<li>编译器不会进行检查并且不要求必须处理的异常。</li>
<li><strong>该类异常包括运行时异常（RuntimeException极其子类）和错误（Error）。</strong></li>
</ul>
</li>
</ul>
<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018103150.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018103200.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018103228.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018103300.png"></p>
<h1 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h1><p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/JAVA-283.jpg" alt="img"></p>
<h2 id="ArrayList和Vector的区别"><a href="#ArrayList和Vector的区别" class="headerlink" title="ArrayList和Vector的区别"></a><strong>ArrayList和Vector的区别</strong></h2><p>​    这两个类都实现了List接口，都是有序可重复的。</p>
<ul>
<li>（1）同步性：</li>
</ul>
<p>​    Vector是线程安全的，而ArrayList是线程序不安全的。</p>
<ul>
<li><p>（2）数据增长：</p>
<p> Vector默认扩容为原来两倍，而ArrayList扩容为原来的1.5倍。</p>
</li>
</ul>
<h2 id="ArrayList的扩容机制？"><a href="#ArrayList的扩容机制？" class="headerlink" title="ArrayList的扩容机制？"></a>ArrayList的扩容机制？</h2><ul>
<li><p>默认初始大小为10；</p>
</li>
<li><p>底层其实是调用<code>Arrays.copyOf</code>方法来进行扩充数组容量。</p>
</li>
<li><p>默认情况下，新的容量会是原容量的1.5倍，这里用了位运算提高效率。一般情况下，如果扩容1.5倍后就大于期望容量，那就返回这个1.5倍旧容量的值。而如果小于期望容量，那就返回期望容量。</p>
</li>
<li><p>使用1.5倍这个数值而不是直接使用期望容量，是为了防止频繁扩容影响性能。试想如果每次add操作都要扩容一次，那性能将会非常低下。</p>
</li>
<li><p>可以手动扩容，没有缩容。</p>
</li>
</ul>
<h2 id="HashMap和HashTable的区别"><a href="#HashMap和HashTable的区别" class="headerlink" title="HashMap和HashTable的区别"></a>HashMap和HashTable的区别</h2><ul>
<li><strong>线程是否安全：</strong>HashMap是非线程安全的，HashTable使用synchronized修饰，是线程安全的；</li>
<li><strong>效率：</strong>HashTable的效率低，已被淘汰；</li>
<li><strong>Null值：</strong>HashMap的Key和Value可以为null，HashTab的Key如果为null，则会跑出NullPointerException。</li>
<li><strong>初始容量和扩容：</strong>HashMap的初始大小为16，扩容因子为0.75，每次扩容变为2倍，HashTable的初始大小为11，每次扩容变为原来的2n+1;</li>
<li><strong>底层实现不同</strong>，HashSet以HashMap的key作为value，并将HashMap的value默认为present。</li>
</ul>
<h2 id="HashMap的底层实现"><a href="#HashMap的底层实现" class="headerlink" title="HashMap的底层实现"></a>HashMap的底层实现</h2><ul>
<li>JDK1.8以前，HashMap的底层是数组和链表组合在一起。HashMap计算key的hashCode经过扰动函数处理后得到hash值，然后通过 (n-1) &amp; hash判断当前元素存放的位置，如果当前位置存在元素，则判断该元素与要存入的元素的hash值和key是否相等，如果相等则覆盖，否则通过<strong>拉链法</strong>解决冲突。</li>
</ul>
<blockquote>
<p>扰动函数：即hash方法</p>
</blockquote>
<ul>
<li>JDK1.7的hash方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span></span>&#123;</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt;<span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>JDK1.8以后，当数组长度大于64，链表长度大于8时，将链表转化为红黑树；链表长度小于7时，红黑树转化为链表。</p>
</li>
<li><p>JDK1.8的hash方法：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HashMap的长度为什么是2的幂次方？"><a href="#HashMap的长度为什么是2的幂次方？" class="headerlink" title="HashMap的长度为什么是2的幂次方？"></a>HashMap的长度为什么是2的幂次方？</h2><p>hash % length == hash &amp; (length - 1)的前提是length == 2 的幂次方。</p>
<h2 id="ConcurrentHashMap和HashTable的区别？"><a href="#ConcurrentHashMap和HashTable的区别？" class="headerlink" title="ConcurrentHashMap和HashTable的区别？"></a>ConcurrentHashMap和HashTable的区别？</h2><p>1）实现线程安全的方式不同：</p>
<ul>
<li>JDK1.7的ConcurrentHashMap使用分段锁对整个数组进行分段加锁（Segment，16个，0–15），多线程访问不同数据段的数据就不会发生锁竞争，提高并发效率；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018131121.webp"></p>
<ul>
<li><p>JDK1.8的ConcurrentHashMap使用node、synchronized和CAS进行并发控制；</p>
<p>  <img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018131216.png" alt="img"></p>
</li>
<li><p>HashTable使用synchronized保证线程安全，效率低下。</p>
</li>
</ul>
<p>2）底层数据结构不同。</p>
<blockquote>
<p>Segment：实现了ReentrantLock，是可重入锁。</p>
</blockquote>
<h2 id="Comparable和Comparator接口"><a href="#Comparable和Comparator接口" class="headerlink" title="Comparable和Comparator接口"></a><code>Comparable</code>和<code>Comparator</code>接口</h2><p>在 Java 中。 所有具有自动排序功能的集合都使用比较方法来确保元素的正确排序。 例如，使用排序的类为<code>TreeSet</code>，<code>TreeMap</code>等。</p>
<p><strong>为了对一个类的数据元素进行排序，需要实现<code>Comparator</code>或<code>Comparable</code>接口</strong>。 这就是所有包装器类（例如<code>Integer</code>，<code>Double</code>和<code>String</code>类）都实现<code>Comparable</code>接口的原因。</p>
<p><strong><code>Comparable</code>帮助保留默认的自然排序，而<code>Comparator</code>帮助以某些特殊的必需排序模式对元素进行排序。</strong> 比较器的实例，通常在支持集合时作为集合的构造器参数传递。</p>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><ul>
<li>类装载器子系统</li>
<li>运行时数据区域</li>
<li>执行引擎</li>
</ul>
<h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018210001.jpeg" alt="运行时数据区域"></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><ul>
<li>程序计数器是一块较小的内存空间,它的作用可以看作是当前线程所执行的字节码行号指示器。</li>
</ul>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><ul>
<li>虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会创建一个栈帧用于存储局部变量表，操作栈，动态链接，方法出口等信息。</li>
</ul>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><ul>
<li>本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。 </li>
</ul>
<h3 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h3><ul>
<li><code>Java</code> 堆是整个虚拟机所管理的最大内存区域，所有的对象创建都是在这个区域进行内存分配。</li>
<li>这块区域也是垃圾回收器重点管理的区域，由于大多数垃圾回收器都采用<code>分代回收算法</code>，所有堆内存也分为 <code>新生代</code>、<code>老年代</code>，可以方便垃圾的准确回收。</li>
</ul>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><ul>
<li>方法区主要用于存放已经被虚拟机加载的类信息，如<code>常量，静态变量</code>，即时编译器编译后的代码等。和Java堆一样不需要连续的内存，并且可以动态扩展。</li>
<li>对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。</li>
</ul>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><ul>
<li>运行时常量池是方法区的一部分。class文件除了有类的版本，字段，方法，接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，会在类加载后放入这个区域。</li>
</ul>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><ul>
<li>直接内存并不是虚拟机运行时数据区域的一部分。</li>
<li>在 JDK 1.4 中新加入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。</li>
</ul>
<h2 id="Minor-GC和Full-GC"><a href="#Minor-GC和Full-GC" class="headerlink" title="Minor GC和Full GC"></a>Minor GC和Full GC</h2><ul>
<li>Minor GC：指发生在新生代的垃圾收集动作。<code> Minor GC</code> 非常频繁，一般回收速度也比较快。</li>
<li>Major GC或Full GC：指发生在老年代的 GC，出现了 Major GC，经常会伴随至少一次的 Minor GC（但非绝对的，在 ParallelScavenge 收集器的收集策略里就有直接进行 <code>Major GC</code> 的策略选择过程） 。<code>MajorGC</code> 的速度一般会比 Minor GC 慢 10倍以上。</li>
</ul>
<h3 id="Minor-GC触发机制"><a href="#Minor-GC触发机制" class="headerlink" title="Minor GC触发机制"></a>Minor GC触发机制</h3><p>当年轻代满时就会触发Minor GC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC</p>
<h3 id="Full-GC触发机制"><a href="#Full-GC触发机制" class="headerlink" title="Full GC触发机制"></a>Full GC触发机制</h3><ul>
<li>当年老代满时会引发Full GC，Full GC将会同时回收年轻代、年老代，</li>
<li>当永久代满时也会引发Full GC，会导致Class、Method元信息的卸载</li>
</ul>
<h2 id="Java中的四种引用"><a href="#Java中的四种引用" class="headerlink" title="Java中的四种引用"></a>Java中的四种引用</h2><p>强引用,软引用,弱引用,虚引用</p>
<h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>就是指在程序代码中普遍存在的，类似Object obj=new Object()这类的引用，只要强引用还存在，垃圾回收期永远不会回收掉被引用的对象</p>
<h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>用来描述一些还有用，但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出前，将会把这些对象列进回收范围之内并进行第二次回收，如果这此次回收还是没有足够的内存，才会抛出内存溢出。</p>
<h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>用来描述非必须的对象，但是它的强度比软引用更弱一下，被弱引用关联的对象，只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收被弱引用关联的对象</p>
<h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>被称为幽灵引用或幻引用，是最弱的一种引用关系，为一个对象设置虚引用的目的就是在对象被回收时收到一个系统通知。</p>
<h2 id="怎样判断对象是否存活"><a href="#怎样判断对象是否存活" class="headerlink" title="怎样判断对象是否存活"></a>怎样判断对象是否存活</h2><ul>
<li><p>引用计数法：</p>
<ul>
<li>给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1，当引用失效时，计数器减1；</li>
<li>任何时刻计数器都为0的对象就是不可能再被使用的。客观的来说，引用计数法的实现简单，判定效率也很高，很难解决对象之间的互循环引用问题。</li>
</ul>
</li>
<li><p>可达性分析：</p>
<ul>
<li>这个算法的思路就是通过一系列的名为“GC roots”的对象作为起点，从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象的GC roots没有任何引用链相连时，则证明此对象是不可用的。</li>
</ul>
</li>
</ul>
<h2 id="作为GC-roots的几种对象"><a href="#作为GC-roots的几种对象" class="headerlink" title="作为GC roots的几种对象"></a>作为GC roots的几种对象</h2><ul>
<li>虚拟机栈(栈中的本地变量表)中的引用对象。</li>
<li>方法区中的类静态属性引用对象。</li>
<li>方法区中的常量引用的对象。</li>
<li>本地方法栈中 native 方法的引用对象。</li>
</ul>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><ul>
<li><p>算法分为标记和清除两个阶段。首先先标记所有要被回收的对象，标记完成后再统一清除被标记的对象。</p>
<p><strong>主要缺点有两个，</strong> </p>
</li>
<li><p>一是效率问题，标记和清除的过程效率都不高。二是空间问题，标记清除后会产生大量不连续的内存碎片，空间碎片太多,可能会导致当程序在以后的运行过程中需要分配较大的对象时无法找到足够的连续内存，而不得不提前出发另一次垃圾收集动作</p>
</li>
</ul>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><ul>
<li>为了解决效率问题，一种复制收集的算法出现了。它将可用内存按容量划分为大小相等的两块，每次只用其中的一块。当这一块内存用完，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对其中一块进行内存回收，内存分配时也就不用内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半未免太高了一点。</li>
</ul>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><ul>
<li>复制手机算法在对象存活率较高的时要执行多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要额外的空间进行分配担保，以应对被使用的内存中对象都100%存货的极端情况，所以在老年代一般不能直接选用这种算法。根据老年代的特点，有人提出了另一种 标记-整理的算法，标记过程仍然与 标记-清楚算法一样。但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存</li>
</ul>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><ul>
<li>把Java堆分为新生代和老年代，根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法。而老年代中因为对象存活率高，没有额外空间对它进行分配担保，就必须使用标记-清理或标记-整理算法来进行回收。</li>
</ul>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><ul>
<li>一个单线程的收集器，只会使用一个CPU或一条收集线程去完成垃圾收集工作。在进行垃圾收集时必须暂停其它所有的工作线程，直接到结束。(Stop The Word)这项工作是虚拟机在后台自动发起和完成的。</li>
<li>JDK1.3之前是新生代收集的唯一选择。</li>
<li>它依然是虚拟机运行在Client模式下的默认新手代收集器，简单而高效。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018132608.jpeg" alt="img"></p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>Serial收集器的多线程版本，使用多条线程收集。其余的和Serial一样，是许多运行在Server模式下的虚拟机首选新生代收集器。且目前除了Serial收集器，只有它可以与CMS收集器配合工作</p>
<p><img src="http://blogimg.chenhaoxiang.cn/18-11-7/69174322.jpg" alt="img"></p>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><ul>
<li>它是一款新生代收集器。使用复制算法收集，又是并行的多线程收集器</li>
<li>特点是达到一个可控制的吞吐量，也被称为“吞吐量优先”收集器。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018132752.jpeg" alt="img"></p>
<h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><ul>
<li>它是Serial收集器的老年代版本，是一个单线程收集器，使用标记-整理算法收集。</li>
<li>主要意义是给Client模式下虚拟机使用。如果是Server模式，则有两种用途，一是在JDK1.5之前与Parallel Scavenge收集器搭配使用。二是作为CMS收集器的后背预案</li>
</ul>
<h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>它是Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法。JDK1.6才开始提供。</p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><ul>
<li>是一种以获取最短回收停顿时间的为目标的收集器。</li>
<li>基于标记-清除算法实现。</li>
<li>运作过程分为四个阶段：初始标记,并发标记,重新标记,并发清除。</li>
<li>初始标记和重新标记仍然需要”Stop The Word”.初始标记只是记录下GC Roots能直接关联到对象，速度快。并发标记就是进行GC Roots Tracing过程。重新标记修正并发标记期间因程序继续运作导致标记产生变动的一部分对象的标记记录。整个过程耗时最长是并发标记和并发清除过程。</li>
<li>优点是并发收集，低停顿。缺点是：对CPU资源非常敏感，无法处理浮动垃圾。收集结束时会产生大量空间碎片</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018132849.jpeg" alt="img"></p>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><ul>
<li><p>将整个Java堆分为多个大小相等的独立区域。</p>
</li>
<li><p>虽然保留新生代和老年代，但它们不再是物理隔离，都是一部分不需要连续的集合。</p>
</li>
<li><p>G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。</p>
</li>
<li><p>特点是并行与并发充分利用CPU缩短停顿时间。分代收集，空间整合不会产生内存空间碎片，可预测的停顿。有计划的避免回收整个Java堆。</p>
</li>
<li><p>运行大致分为:初始标记,并发标记,最终标记,筛选回收。</p>
</li>
<li><p>筛选回收（Live Data Counting and Evacuation）</p>
<ul>
<li><p>首先排序各个Region的回收价值和成本；</p>
</li>
<li><p>然后根据用户期望的GC停顿时间来制定回收计划；</p>
</li>
<li><p>最后按计划回收一些价值高的Region中垃圾对象；</p>
</li>
<li><p>回收时采用”复制”算法，从一个或多个Region复制存活对象到堆上的另一个空的Region，并且在此过程中压缩和释放内存；</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018133022.jpeg" alt="img"></p>
<h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><h3 id="对象优先在Eden区分配"><a href="#对象优先在Eden区分配" class="headerlink" title="对象优先在Eden区分配"></a>对象优先在Eden区分配</h3><p>对象通常在新生代的Eden区进行分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC，与Minor GC对应的是Major GC、Full GC。</p>
<ul>
<li>Minor GC:指发生在新生代的垃圾收集动作，非常频繁，速度较快。</li>
<li>Major GC:指发生在老年代的GC，出现Major GC，经常会伴随一次Minor GC，同时Minor GC也会引起Major GC，一般在GC日志中统称为GC，不频繁。</li>
<li>Full GC:指发生在老年代和新生代的GC，速度很慢，需要Stop The World。</li>
</ul>
<h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><ul>
<li>需要大量连续内存空间的Java对象称为大对象，大对象的出现会导致提前触发垃圾收集以获取更大的连续的空间来进行大对象的分配。虚拟机提供了-XX:PretenureSizeThreadshold参数来设置大对象的阈值，超过阈值的对象直接分配到老年代。</li>
</ul>
<h3 id="长期存活的对象进入老年代"><a href="#长期存活的对象进入老年代" class="headerlink" title="长期存活的对象进入老年代"></a>长期存活的对象进入老年代</h3><ul>
<li>每个对象有一个对象年龄计数器，与前面的对象的存储布局中的GC分代年龄对应。对象出生在Eden区、经过一次Minor GC后仍然存活，并能够被Survivor容纳，设置年龄为1，对象在Survivor区每次经过一次Minor GC，年龄就加1，当年龄达到一定程度（默认15），就晋升到老年代，虚拟机提供了-XX:MaxTenuringThreshold来进行设置。</li>
</ul>
<h3 id="动态对象年龄判断"><a href="#动态对象年龄判断" class="headerlink" title="动态对象年龄判断"></a>动态对象年龄判断</h3><ul>
<li>如果在survivor区中相同年龄的所有对象大小的总和大于survivor区的一半，年龄大于等于该年龄的对象就可以直接进入老年代。</li>
</ul>
<h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><ul>
<li>发生Minor GC时，只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC。</li>
<li>冒险是指经过一次Minor GC后有大量对象存活，而新生代的survivor区很小，放不下这些大量存活的对象，所以需要老年代进行分配担保，把survivor区无法容纳的对象直接进入老年代。</li>
</ul>
<h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><ul>
<li>很多人认为方法区是没有垃圾回收的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而在方法区进行垃圾收集的性价比一般比较低，在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%~96%的空间，而永久代的垃圾收集效率远低于此。</li>
<li>永久代的垃圾主要回收两部分内容：废弃常量和无用的类。</li>
</ul>
<h2 id="Java中对象访问是如何进行的"><a href="#Java中对象访问是如何进行的" class="headerlink" title="Java中对象访问是如何进行的"></a>Java中对象访问是如何进行的</h2><ul>
<li>对象访问在Java中无处不在，即时是最简单的访问也会涉及到Java栈，Java堆，方法区这三个最重要的内存区域之间的关系。</li>
</ul>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span> obj=<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>假设这段代码出现在方法体中， 那吗“<code>Object obj</code>”这部分的语义将会反应到<code>Java栈</code>的本地变量中，作为一个<code>reference</code>类型数据出现。而“<code>new Object()</code>”这部分的语义将会反应到<code>Java堆</code>中,形成一块存储了Object类型所有实例数据值的结构化内存，根据具体类型以及虚拟机实现的对象内存布局的不同，这块内存的长度是不固定的。</li>
<li>另外，在Java堆中还必须包含能查找到此对象类型数据（如对象类型，父亲，实现的接口，方法等）的地址消息，这些类型数据则存储在方法区中。</li>
</ul>
<h2 id="JVM参数设置"><a href="#JVM参数设置" class="headerlink" title="JVM参数设置"></a>JVM参数设置</h2><p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018135117.jpeg" alt="JVM参数设置.png"></p>
<ul>
<li><code>-Xms</code>:Java堆内存大小</li>
<li><code>-Xmx</code>:Java堆内存最大大小</li>
<li><code>-Xmn</code>:Java堆内存中的新生代大小，扣除新生代剩下的就是老年代的内存大小了</li>
<li><code>-XX:PermSize</code>:永久代大小</li>
<li><code>-XX:MaxPermSize</code>:永久代最大大小</li>
<li><code>-Xss</code>：每个线程的栈内存大小</li>
<li>`java -Xms512M -Xmx512M -Xmn256M -Xss1M -XX:PermSize=128M -XX:MaxPermSize=128M -jar App.jar</li>
</ul>
<h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)7个阶段。其中准备、验证、解析3个部分统称为连接（Linking）。<br><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018133815.jpeg"></p>
<h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><h4 id="1-加载"><a href="#1-加载" class="headerlink" title="1.加载"></a>1.加载</h4><ul>
<li>通过一个类的全限定名来获取定义此类的二进制字节流；</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口；</li>
</ul>
<h4 id="2-验证"><a href="#2-验证" class="headerlink" title="2.验证"></a>2.验证</h4><ul>
<li><p>确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 </p>
<ul>
<li><p>文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以魔术0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</p>
</li>
<li><p>元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。</p>
</li>
<li><p>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的 </p>
</li>
<li><p>符号引用验证：确保解析动作能正确执行。</p>
</li>
</ul>
</li>
</ul>
<h4 id="3-准备"><a href="#3-准备" class="headerlink" title="3.准备"></a>3.准备</h4><ul>
<li>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在堆中。</li>
</ul>
<h4 id="4-解析"><a href="#4-解析" class="headerlink" title="4.解析"></a>4.解析</h4><ul>
<li>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</li>
</ul>
<h4 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5.初始化"></a>5.初始化</h4><ul>
<li>如果一个类被主动引用，就会触发类的初始化。</li>
<li>在java中，直接引用的情况有，通过new关键字实例化对象、读取或设置类的静态变量、调用类的静态方法。通过反射方式执行以上三种行为。初始化子类的时候，会触发父类的初始化。</li>
</ul>
<h4 id="6-使用"><a href="#6-使用" class="headerlink" title="6.使用"></a>6.使用</h4><ul>
<li>类的使用包括主动引用和被动引用</li>
<li>被动引用：引用父类的静态字段，只会引起父类的初始化，而不会引起子类的初始化。定义类数组，不会引起类的初始化。引用类的常量，不会引起类的初始化。</li>
</ul>
<h4 id="7-卸载"><a href="#7-卸载" class="headerlink" title="7.卸载"></a>7.卸载</h4><ul>
<li>满足下面的情况，类就会被卸载：该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。加载该类的ClassLoader已经被回收。该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
<li>如果以上三个条件全部满足，jvm就会在方法区垃圾回收的时候对类进行卸载，类的卸载过程其实就是在方法区中清空类信息，java类的整个生命周期就结束了。</li>
</ul>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ul>
<li>通过一个类的全限定名来获取描述此类的二进制字节流,这个动作放到java虚拟机外部去实现。以便让应用程序自己决定如何去获取所需要的类。实现各动作的代码模块称为“类加载器”。</li>
<li>比较两个类是否相等，只有这两个类是由同一个类加载器加载的前提下才有意义，否则即使这两个；即使来源同一个class文件，但类加载器不同，他们也不相等。</li>
</ul>
<h4 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h4><p>这个类加载器负责放在<JAVA_HOME>\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库。用户无法直接使用。</p>
<h4 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h4><p>这个类加载器由sun.misc.Launcher$AppClassLoader实现。它负责<JAVA_HOME>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库。用户可以直接使用。</p>
<h4 id="应用程序类加载器"><a href="#应用程序类加载器" class="headerlink" title="应用程序类加载器"></a>应用程序类加载器</h4><p>这个类由sun.misc.Launcher$AppClassLoader实现。是ClassLoader中getSystemClassLoader()方法的返回值。它负责用户路径（ClassPath）所指定的类库。用户可以直接使用。如果用户没有自己定义类加载器，默认使用这个</p>
<h4 id="自定义加载器"><a href="#自定义加载器" class="headerlink" title="自定义加载器"></a>自定义加载器</h4><p>用户自己定义的类加载器。</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存在在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的Bootstrap ClassLoader进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。</li>
<li>相反，如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个java.lang.Object的同名类并放在ClassPath中，那系统中将会出现多个不同的Object类，程序将混乱。因此，如果开发者尝试编写一个与rt.jar类库中重名的Java类，可以正常编译，但是永远无法被加载运行。</li>
</ul>
<h2 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens-before原则"></a>happens-before原则</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>我们无法就所有场景来规定某个线程修改的变量何时对其他线程可见，但是我们可以指定某些规则，这规则就是happens-before，从JDK 5 开始，JMM就使用happens-before的概念来阐述多线程之间的内存可见性。</li>
<li>在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。<br>  happens-before原则非常重要，它是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们解决在并发环境下两操作之间是否可能存在冲突的所有问题。下面我们就一个简单的例子稍微了解下happens-before ；</li>
</ul>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">i</span> = <span class="number">1</span><span class="comment">;       //线程A执行</span></span><br><span class="line"><span class="attr">j</span> = i <span class="comment">;      //线程B执行</span></span><br></pre></td></tr></table></figure>

<p>j 是否等于1呢？假定线程A的操作（i = 1）happens-before线程B的操作（j = i）,那么可以确定线程B执行后j = 1 一定成立，如果他们不存在happens-before原则，那么j = 1 不一定成立。这就是happens-before原则的威力。</p>
<h3 id="原则定义"><a href="#原则定义" class="headerlink" title="原则定义"></a>原则定义</h3><ul>
<li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。 </li>
<li>两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。</li>
</ul>
<h3 id="规则如下"><a href="#规则如下" class="headerlink" title="规则如下"></a>规则如下</h3><h4 id="程序次序规则"><a href="#程序次序规则" class="headerlink" title="程序次序规则"></a>程序次序规则</h4><p>一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；</p>
<h4 id="锁定规则"><a href="#锁定规则" class="headerlink" title="锁定规则"></a>锁定规则</h4><p>一个unLock操作先行发生于后面对同一个锁额lock操作；</p>
<h4 id="volatile变量规则"><a href="#volatile变量规则" class="headerlink" title="volatile变量规则"></a>volatile变量规则</h4><p>对一个变量的写操作先行发生于后面对这个变量的读操作；</p>
<h4 id="传递规则"><a href="#传递规则" class="headerlink" title="传递规则"></a>传递规则</h4><p>如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；</p>
<h4 id="线程启动规则"><a href="#线程启动规则" class="headerlink" title="线程启动规则"></a>线程启动规则</h4><p>Thread对象的start()方法先行发生于此线程的每个一个动作；</p>
<h4 id="程中断规则"><a href="#程中断规则" class="headerlink" title="程中断规则"></a>程中断规则</h4><p>对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</p>
<h4 id="线程终结规则"><a href="#线程终结规则" class="headerlink" title="线程终结规则"></a>线程终结规则</h4><p>线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；</p>
<h4 id="对象终结规则"><a href="#对象终结规则" class="headerlink" title="对象终结规则"></a>对象终结规则</h4><p>一个对象的初始化完成先行发生于他的finalize()方法的开始；</p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018152146.png" alt="img"></p>
<h2 id="什么是线程死锁-如何避免死锁"><a href="#什么是线程死锁-如何避免死锁" class="headerlink" title="什么是线程死锁?如何避免死锁?"></a>什么是线程死锁?如何避免死锁?</h2><p>多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p>
<p><strong>避免死锁的几个常见方法：</strong></p>
<ul>
<li><strong>避免一个线程同时获取多个锁</strong></li>
<li><strong>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。</strong></li>
<li><strong>尝试使用定时锁，使用 lock.tryLock(timeout) 来代替使用内部锁机制。</strong></li>
<li><strong>对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。</strong></li>
</ul>
<h2 id="线程的生命周期和状态-（重要！）"><a href="#线程的生命周期和状态-（重要！）" class="headerlink" title="线程的生命周期和状态?（重要！）"></a>线程的生命周期和状态?（重要！）</h2><p>　　<strong>初始状态、运行状态、阻塞状态、等待状态、超时等待状态、终止状态</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018152505.png" alt="img"></p>
<h2 id="多线程的特性"><a href="#多线程的特性" class="headerlink" title="多线程的特性"></a>多线程的特性</h2><ul>
<li><p>原子性：是指一个操作是不可中断的。即使是多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。</p>
</li>
<li><p>可见性：是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道这个修改。显然，对于串行来说，可见性问题是不存在的。</p>
</li>
<li><p>有序性：在并发时，允许编译器和处理器对指令重排序的，但是不管怎么重排序，程序的执行结果不能改变。。</p>
</li>
</ul>
<h2 id="sleep-方法和-wait-方法区别和共同点-（重要！）"><a href="#sleep-方法和-wait-方法区别和共同点-（重要！）" class="headerlink" title="sleep() 方法和 wait() 方法区别和共同点?（重要！）"></a>sleep() 方法和 wait() 方法区别和共同点?（重要！）</h2><p> <strong>相同点：</strong></p>
<p>　　两者都可以暂停线程的执行，都会让线程进入等待状态。</p>
<p><strong>不同点：</strong></p>
<ul>
<li><strong>sleep()方法没有释放锁，而 wait()方法释放了锁。</strong></li>
<li><strong>sleep()方法属于Thread类的静态方法，作用于当前线程；而wait()方法是Object类的实例方法，作用于对象本身。</strong></li>
<li><strong>执行sleep()方法后，可以通过超时或者调用interrupt()方法唤醒休眠中的线程；执行wait()方法后，通过调用notify()或notifyAll()方法唤醒等待线程。</strong></li>
</ul>
<h2 id="notify-和-notifyAll有什么区别？"><a href="#notify-和-notifyAll有什么区别？" class="headerlink" title="notify 和 notifyAll有什么区别？"></a>notify 和 notifyAll有什么区别？</h2><ul>
<li>notify()方法不能唤醒某个具体的线程，所以只有一个线程在等待的时候它才有用武之地。</li>
<li>notifyAll()唤醒所有线程并允许他们争夺锁确保了至少有一个线程能继续运行。</li>
</ul>
<h2 id="yield-方法有什么用？"><a href="#yield-方法有什么用？" class="headerlink" title="yield()方法有什么用？"></a>yield()方法有什么用？</h2><ul>
<li>yield() 方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。</li>
<li>只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行</li>
</ul>
<h2 id="join-方法有什么用？"><a href="#join-方法有什么用？" class="headerlink" title="join()方法有什么用？"></a>join()方法有什么用？</h2><ul>
<li><strong>join方法的主要作用就是同步，它可以使得线程之间的并行执行变为串行执行。</strong> </li>
</ul>
<h2 id="使用线程池的好处？"><a href="#使用线程池的好处？" class="headerlink" title="使用线程池的好处？"></a>使用线程池的好处？</h2><ol>
<li><strong>降低资源消耗</strong>。通过<strong>重复利用已创建的线程，降低线程创建和销毁造成的消耗</strong>。</li>
<li><strong>提高响应速度</strong>。<strong>当任务到达时，任务可以不需要等到线程创建就能立即执行</strong>。</li>
<li><strong>提高线程的可管理性</strong>。<strong>线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控</strong>。</li>
</ol>
<h2 id="创建线程的几种方式？（重要）"><a href="#创建线程的几种方式？（重要）" class="headerlink" title="创建线程的几种方式？（重要）"></a>创建线程的几种方式？（重要）</h2><ul>
<li><strong>继承Thread类</strong></li>
<li><strong>实现Runnable接口</strong></li>
<li><strong>实现Callable接口</strong></li>
<li><strong>使用线程池创建线程</strong></li>
</ul>
<h2 id="常见的线程池及适用场景？（重要）"><a href="#常见的线程池及适用场景？（重要）" class="headerlink" title="常见的线程池及适用场景？（重要）"></a>常见的线程池及适用场景？（重要）</h2><ul>
<li><p>FixedThreadPool：可重用固定线程数的线程池。（适用于负载比较重的服务器）</p>
<ul>
<li><strong>FixedThreadPool使用无界队列LinkedBlockingQueue作为线程池的工作队列</strong></li>
<li>该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li>
</ul>
</li>
<li><p>SingleThreadExecutor：只会创建一个线程执行任务。（适用于需要保证顺序执行各个任务；并且在任意时间点，没有多线程活动的场景。）</p>
<ul>
<li><strong>SingleThreadExecutorl也使用无界队列LinkedBlockingQueue作为工作队列</strong></li>
<li>若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li>
</ul>
</li>
<li><p>CachedThreadPool：是一个会根据需要调整线程数量的线程池。</p>
<p>  （大小无界，适用于执行很多的短期异步任务的小程序，或负载较轻的服务器）</p>
<ul>
<li><strong>CachedThreadPool使用没有容量的SynchronousQueue作为线程池的工作队列，但CachedThreadPool的maximumPool是无界的。</strong></li>
<li>线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li>
</ul>
</li>
<li><p><strong>ScheduledThreadPool</strong>：继承自ThreadPoolExecutor。它主要用来<strong>在给定的延迟之后运行任务，或者定期执行任务</strong>。使用DelayQueue作为任务队列。</p>
</li>
</ul>
<h2 id="说一下-runnable-和-callable-有什么区别？"><a href="#说一下-runnable-和-callable-有什么区别？" class="headerlink" title="说一下 runnable 和 callable 有什么区别？"></a>说一下 runnable 和 callable 有什么区别？</h2><ul>
<li>相同点：两者都是接口。都可以用来创建多线程。都需要调用Thread.start()启动线程</li>
<li>不同点：实现Callable接口的任务线程能返回执行结果；而实现Runnable接口的任务线程不能返回结果。</li>
<li>Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛；</li>
<li>Callable接口支持返回执行结果，此时需要调用FutureTask.get()方法实现，此方法会阻塞主线程直到获取‘将来’结果；当不调用此方法时，主线程不会阻塞</li>
</ul>
<h2 id="start-方法和run-方法简介和区别？"><a href="#start-方法和run-方法简介和区别？" class="headerlink" title="start() 方法和run() 方法简介和区别？"></a><strong>start() 方法和run() 方法简介和区别？</strong></h2><p>start() 方法：</p>
<p>1）用start方法来启动线程，真正实现了多线程运行，这时无需等待run方法体代码执行完毕而直接继续执行下面的代码。</p>
<p>2）通过调用Thread类的start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到CPU时间片，就开始执行run()方法。</p>
<p>run() 方法：</p>
<p>1）run()方法只是类的一个普通方法而已，如果直接调用Run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条。</p>
<h2 id="线程池都有哪几种工作队列？（重要）"><a href="#线程池都有哪几种工作队列？（重要）" class="headerlink" title="线程池都有哪几种工作队列？（重要）"></a>线程池都有哪几种工作队列？（重要）</h2><ul>
<li><strong>ArrayBlockingQueue</strong>：是一个<strong>基于数组结构的有界阻塞队列</strong>，此队列按FIFO（先进先出）原则对元素进行排序。</li>
<li><strong>LinkedBlockingQueue</strong>：是一个<strong>基于链表结构的阻塞队列</strong>，此队列按FIFO排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。</li>
<li><strong>SynchronousQueue</strong>：是一个<strong>不存储元素的阻塞队列</strong>。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于Linked-BlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。</li>
<li><strong>PriorityBlockingQueue</strong>：一个<strong>具有优先级的无限阻塞队列</strong>。</li>
</ul>
<h2 id="线程池参数？"><a href="#线程池参数？" class="headerlink" title="线程池参数？"></a><strong>线程池参数？</strong></h2><p>①<strong>corePoolSize：线程池的基本大小</strong>，当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。说白了就是，即便是线程池里没有任何任务，也会有corePoolSize个线程在候着等任务。</p>
<p>②<strong>maximumPoolSize:最大线程数</strong>，不管你提交多少任务，线程池里最多工作线程数就是maximumPoolSize。</p>
<p>③<strong>keepAliveTime:线程的存活时间</strong>。当线程池里的线程数大于corePoolSize时，如果等了keepAliveTime时长还没有任务可执行，则线程退出。</p>
<p>⑤<strong>unit</strong>：这个用来指定keepAliveTime的单位，比如秒:TimeUnit.SECONDS。</p>
<p>⑥<strong>workQueu</strong>e：用于保存等待执行任务的<strong>阻塞队列</strong>，提交的任务将会被放到这个队列里。</p>
<p>⑦<strong>threadFactory：线程工厂，用来创建线程</strong>。主要是为了给线程起名字，默认工厂的线程名字：pool-1-thread-3。</p>
<p>⑧<strong>handler：拒绝策略</strong>，即当线程和队列都已经满了的时候，应该采取什么样的策略来处理新提交的任务。</p>
<ul>
<li>默认策略是AbortPolicy（抛出异常）</li>
<li>CallerRunsPolicy(只用调用者所在线程来运行任务)</li>
<li>DiscardOldestPolicy(丢弃队列里最老的一个任务，并执行当前任务)</li>
<li>DiscardPolicy(不处理，丢弃掉)</li>
</ul>
<h2 id="线程池ThreadPoolExecutor的工作流程？"><a href="#线程池ThreadPoolExecutor的工作流程？" class="headerlink" title="线程池ThreadPoolExecutor的工作流程？"></a>线程池ThreadPoolExecutor的工作流程？</h2><ul>
<li>当提交一个新任务到线程池后，线程池首先会判断核心线程池(corePoolSize）里的线程是否都在执行任务。</li>
<li>如果核心线程池corePoolSize的线程都被占用在执行任务，线程池判断工作队列是否已满，如果工作队列没有满：则将新提交的任务存储到工作队列中，</li>
<li>如果工作队列已满：判断线程池（maximumPoolSize）的线程是否处于工作状态，如果没有，则创建一个新的工作线程来执行任务。</li>
<li>如果线程池已满，则交给饱和策略处理这个任务</li>
</ul>
<h2 id="线程池中-execute-和-submit-方法有什么区别？"><a href="#线程池中-execute-和-submit-方法有什么区别？" class="headerlink" title="线程池中 execute() 和 submit() 方法有什么区别？"></a>线程池中 execute() 和 submit() 方法有什么区别？</h2><ul>
<li>两个方法都可以向线程池提交任务</li>
<li>execute()方法的返回类型是void，它定义在Executor接口中</li>
<li>submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中</li>
</ul>
<h2 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a>synchronized 关键字</h2><p>synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p>
<p>synchronized关键字最主要的三种使用方式：</p>
<ul>
<li><strong>对于普通同步方法，锁是当前实例对象。</strong></li>
<li><strong>对于静态同步方法，锁是当前类的Class对象。</strong></li>
<li><strong>对于同步代码块，锁是synchronized括号里配置的对象。</strong></li>
</ul>
<p><strong>synchronized在JVM里是怎么实现的？</strong></p>
<p>　　<strong>synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置</strong>。 当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor的持有权。当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p>
<p><strong>synchronized用的锁是存在哪里的？</strong></p>
<p>　　synchronized用到的锁是存在<strong>Java对象头</strong>里的。</p>
<h4 id="synchronized的锁升级流程之偏向锁"><a href="#synchronized的锁升级流程之偏向锁" class="headerlink" title="synchronized的锁升级流程之偏向锁"></a>synchronized的锁升级流程之偏向锁</h4><ul>
<li>当一个线程访问同步代码块时，会在对象头和栈帧中的锁记录里存储偏向的线程ID，以后该线程进入和退出同步块时，不需要执行CAS操作来加锁和解锁，只需要简单的测试下对象头的Mark-Word是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已获取到锁</li>
<li>如果测试失败，则需要在测试下Mark-Word中偏向锁的表示是否设置为1（表示当前是偏向锁）；如果没有设置，则使用CAS竞争；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</li>
<li>偏向锁使用了一种等到竞争出现才释放锁的机制，当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁</li>
<li>偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）：它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否存活，如果线程处于不活动状态，则会将对象头设置成无锁状态</li>
<li>如果线程仍然活着，拥有偏向锁的线程会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程</li>
</ul>
<h4 id="synchronized的锁升级流程之轻量级锁"><a href="#synchronized的锁升级流程之轻量级锁" class="headerlink" title="synchronized的锁升级流程之轻量级锁"></a>synchronized的锁升级流程之轻量级锁</h4><ul>
<li>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间,并将对象头中的Mark Word复制到锁记录中</li>
<li>然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针</li>
<li>如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁</li>
<li>轻量级解锁时，会使用原子的CAS操作将Displaced-Mark-Word替换回到对象头。如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁</li>
<li>轻量级锁的加锁和释放锁都是使用CAS操作来执行的</li>
</ul>
<h4 id="synchronized的锁升级流程之重量级锁"><a href="#synchronized的锁升级流程之重量级锁" class="headerlink" title="synchronized的锁升级流程之重量级锁"></a>synchronized的锁升级流程之重量级锁</h4><ul>
<li>重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。</li>
</ul>
<h4 id="偏向锁-轻量锁，重量级锁的优缺点对比"><a href="#偏向锁-轻量锁，重量级锁的优缺点对比" class="headerlink" title="偏向锁,轻量锁，重量级锁的优缺点对比"></a>偏向锁,轻量锁，重量级锁的优缺点对比</h4><ul>
<li>偏向锁： 加锁和解锁不需要额外的消耗，和执行非同步方法只存在纳秒级的差距。缺点是如果线程间存在锁竞争，会带来额外的锁撤销的消耗。适用于只有一个线程访问同步块</li>
<li>轻量级锁：竞争的线程不会阻塞，提高了线程的响应速度。缺点是如果始终得不到锁竞争的线程，使用自旋会消耗CPU。适用于追求响应时间，同步块执行速度非常快</li>
<li>重量级锁：线程竞争不使用自旋，不会消耗CPU。缺点是线程阻塞，响应时间慢。适用追求吞吐量，同步块执行时间过长。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/094206_5f316f33_1478371.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<h4 id="彻底搞懂synchronized-从偏向锁到重量级锁"><a href="#彻底搞懂synchronized-从偏向锁到重量级锁" class="headerlink" title="彻底搞懂synchronized(从偏向锁到重量级锁)"></a>彻底搞懂synchronized(从偏向锁到重量级锁)</h4><ul>
<li>java对象在内存中的存储结构主要有一下三个部分：对象头,实例数据,填充数据.对象头中存储的是hashCode,GC分代年龄，锁信息。</li>
<li>对象被创建出来的那一刻，就有了偏向锁的标志位，偏向锁的标志位是“01”，状态是“0”。偏向锁默认是开启的，但是创建对象时初始化状态是没生效的。</li>
<li>线程执行到临界区时，此时会利用CAS操作，将线程ID插入到Markword中，同时修改偏向锁的标志位为1。所谓临界区，就是只允许一个线程进去执行操作的区域，即同步代码块</li>
<li>这个锁会偏向于第一个获得它的线程，在接下来的执行过程中，假如该锁没有被其他线程所获取，没有其他线程来竞争该锁，那么持有偏向锁的线程将永远不需要进行同步操作。而是简单判断一下当前线程id是否与Markword当中的线程id是否一致.一致则继续执行下面代码</li>
<li>不一致，则要检查一下对象是否还是可偏向。如果还未偏向，则利用CAS操作来竞争锁，也即是第一次获取锁时的操作。</li>
<li>如果此对象已经偏向了，并且不是偏向自己，则说明存在了竞争。此时可能就要根据另外线程的情况，可能是重新偏向，也有可能是做偏向撤销，但大部分情况下就是升级成轻量级锁了。</li>
<li>由于偏向锁失效了，那么接下来就得把该锁撤销，在一个安全点停止拥有锁的线程，遍历线程栈，如果存在锁记录的话，需要修复锁记录和Markword，使其变成无锁状态。唤醒当前线程，将当前锁升级成轻量级锁。</li>
<li>锁撤销升级为轻量级锁之后，那么对象的Markword也会进行相应的的变化。线程在自己的栈桢中创建锁记录LockRecord。将锁对象的对象头中的MarkWord复制到线程的刚刚创建的锁记录中。将锁记录中的Owner指针指向锁对象。将锁对象的对象头的MarkWord替换为指向锁记录的指针。</li>
<li>轻量级锁主要有两种：自旋锁，自适应自旋锁。所谓自旋，就是指当有另外一个线程来竞争锁时，这个线程会在原地循环等待，而不是把该线程给阻塞，直到那个获得锁的线程释放锁之后，这个线程就可以马上获得锁的。</li>
<li>默认情况下，自旋的次数为10次。当线程超过了这个次数，我们就认为，继续使用自旋锁就不适合了，此时锁会再次膨胀，升级为重量级锁。</li>
<li>重量级锁是依赖对象内部的monitor锁来实现的，而monitor又依赖操作系统的MutexLock(互斥锁)来实现的，所以重量级锁也被成为互斥锁。</li>
</ul>
<h2 id="什么是乐观锁和悲观锁？"><a href="#什么是乐观锁和悲观锁？" class="headerlink" title="什么是乐观锁和悲观锁？"></a>什么是乐观锁和悲观锁？</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>Java在JDK1.5之前都是靠synchronized关键字保证同步的，这种通过使用一致的锁定协议来协调对共享状态的访问，可以确保无论哪个线程持有共享变量的锁，都采用独占的方式来访问这些变量。独占锁其实就是一种悲观锁，所以可以说synchronized是悲观锁。</p>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁（ Optimistic Locking）其实是一种思想。相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。</p>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><ul>
<li>所谓自旋锁，就是让该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。怎么等待呢？执行一段无意义的循环即可（自旋）。</li>
</ul>
<h2 id="适应性自旋（CAS）"><a href="#适应性自旋（CAS）" class="headerlink" title="适应性自旋（CAS）"></a>适应性自旋（CAS）</h2><ul>
<li>在使用 <code>CAS</code> 时，如果操作失败，<code>CAS</code> 会自旋再次尝试。由于自旋是需要消耗 <code>CPU</code> 资源的，所以如果长期自旋就白白浪费了 <code>CPU</code>。<code>JDK1.6</code>加入了适应性自旋:如果某个锁自旋很少成功获得，那么下一次就会减少自旋。</li>
<li>所谓自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定</li>
<li>线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。</li>
</ul>
<h2 id="synchronized和-Lock-的区别？（重要）"><a href="#synchronized和-Lock-的区别？（重要）" class="headerlink" title="synchronized和 Lock 的区别？（重要）"></a>synchronized和 Lock 的区别？（重要）</h2><p>1）<strong>Lock是一个接口，而synchronized是Java中的关键字</strong>；</p>
<p>2）<strong>synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生</strong>；而<strong>Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁</strong>；</p>
<p>3）<strong>Lock可以让等待锁的线程响应中断</strong>，而<strong>synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断</strong>；</p>
<p>4）<strong>通过Lock可以知道有没有成功获取锁（tryLock()方法：如果获取锁成功，则返回true）</strong>，而<strong>synchronized却无法办到</strong>。</p>
<p>5）<strong>Lock可以提高多个线程进行读操作的效率</strong>。</p>
<h2 id="synchronized和ReentrantLock（重入锁）-的区别？"><a href="#synchronized和ReentrantLock（重入锁）-的区别？" class="headerlink" title="synchronized和ReentrantLock（重入锁） 的区别？"></a>synchronized和ReentrantLock（重入锁） 的区别？</h2><ul>
<li>两者都是可重进入锁，就是能够支持一个线程对资源的重复加锁。<ul>
<li>sychnronized关键字隐式的支持重进入，比如一个sychnronized修饰的递归方法，在方法执行时，执行线程在获取了锁之后仍能连续多次地获取该锁。</li>
<li>ReentrantLock虽然没能像sychnronized关键字一样隐式的重进入，但是在调用lock()方法时，已经获取到锁的线程，能够再次调用lock()方法获取锁而不被阻塞。</li>
</ul>
</li>
<li><strong>synchronized 依赖于 JVM，而 ReentrantLock 是 JDK 层面实现的</strong></li>
<li>ReentrantLock 比 synchronized 增加了一些高级功能，主要有3点：①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）<ul>
<li><strong>ReentrantLock提供了一种能够中断等待锁的线程的机制</strong>，也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。通过lock.lockInterruptibly()来实现这个机制。</li>
<li><strong>ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。</strong>（公平锁就是先等待的线程先获得锁）</li>
<li>synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制。ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。用ReentrantLock类结合Condition实例可以实现“选择性通知” 。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程</li>
</ul>
</li>
</ul>
<h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><ul>
<li><p><strong>保证共享变量的“可见性”</strong>。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。</p>
</li>
<li><p>禁止指令重排序</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018214521.jpeg"></p>
<p>编译器不会对 volatile 读与 volatile 读后面的任意内存操作重排序；编译器不会对 volatile 写与 volatile 写前面的任意内存操作重排序。</p>
<h2 id="synchronized-关键字和-volatile-关键字的区别"><a href="#synchronized-关键字和-volatile-关键字的区别" class="headerlink" title="synchronized 关键字和 volatile 关键字的区别"></a>synchronized 关键字和 volatile 关键字的区别</h2><ul>
<li><strong>volatile关键字只能用于变量而synchronized关键字还可以修饰方法以及代码块</strong>。</li>
<li><strong>多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞</strong>。</li>
<li><strong>volatile</strong>关键字主要用于<strong>解决变量在多个线程之间的可见性</strong>，而 <strong>synchronized</strong>关键字解决的是<strong>多个线程之间访问资源的同步性</strong>。</li>
<li>volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。</li>
</ul>
<h2 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h2><p>CAS（Compare and Swap），即比较并替换，CAS的思想很简单：三个参数，一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。</p>
<h3 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h3><ul>
<li>ABA问题。 CAS操作更新的基础是如果值没有变化则更新，若有变化则不更新。但如若有一值刚开始是A，然后变为B，最后又变为A。那么CAS检查时发现它没有变化就更新了，但实际上却是已经发生了变化。</li>
<li>CAS自旋。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。 </li>
<li>只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性。</li>
</ul>
<h2 id="什么是ThreadLocal变量？"><a href="#什么是ThreadLocal变量？" class="headerlink" title="什么是ThreadLocal变量？"></a>什么是ThreadLocal变量？</h2><p>ThreadLocal是Java里一种特殊的变量。每个线程都有一个ThreadLocal就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。它是为创建代价高昂的对象获取线程安全的好方法，因为那个类创建代价高昂且每次调用都需要创建不同的实例所以不值得在局部范围使用它，如果为每个线程提供一个自己独有的变量拷贝，将大大提高效率。首先，通过复用减少了代价高昂的对象的创建个数。其次，你在没有使用高代价的同步或者不变性的情况下获得了线程安全。</p>
<h2 id="Semaphore有什么作用？"><a href="#Semaphore有什么作用？" class="headerlink" title="Semaphore有什么作用？"></a>Semaphore有什么作用？</h2><ol>
<li>Semaphore就是一个信号量，<strong>它的作用是限制某段代码块的并发数</strong>。</li>
<li><strong>如果超出了n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入</strong>。</li>
<li>由此可以看出如果Semaphore构造函数中传入的int型整数n=1，相当于变成了一个synchronized了。</li>
</ol>
<h2 id="说一下-atomic-的原理？"><a href="#说一下-atomic-的原理？" class="headerlink" title="说一下 atomic 的原理？"></a>说一下 atomic 的原理？</h2><ul>
<li>在Atomic包里一共有12个类，四种原子更新方式，分别是原子更新基本类型，原子更新数组，原子更新引用和原子更新字段。</li>
<li>Atomic包里的类基本都是使用Unsafe实现的包装类。</li>
<li>Atomic包下的类是通过CAS操作来实现原子性的。jdk8直接使用了Unsafe的getAndAddInt方法</li>
</ul>
<h2 id="CyclicBarrier和CountDownLatch的区别？"><a href="#CyclicBarrier和CountDownLatch的区别？" class="headerlink" title="CyclicBarrier和CountDownLatch的区别？"></a>CyclicBarrier和CountDownLatch的区别？</h2><ul>
<li>CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；是通过调用await()方法计数加1，若加1后的值不等于构造方法的值，则线程阻塞。通俗的将；让一组线程到达一个屏障时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活</li>
<li>CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行，调用countDown()方法计数减一，调用await()方法只进行阻塞，对计数没任何影响</li>
<li>CountDownLatch内部通过共享锁实现。在创建CountDownLatch实例时，需要传递一个int型的参数：count，该参数为计数器的初始值，也可以理解为该共享锁可以获取的总次数。当某个线程调用await()方法，程序首先判断count的值是否为0，如果不会0的话则会一直等待直到为0为止。当其他线程调用countDown()方法时，则执行释放共享锁状态，使count值 – 1。当在创建CountDownLatch时初始化的count参数，必须要有count线程调用countDown方法才会使计数器count等于0，锁才会释放，前面等待的线程才会继续运行。注意CountDownLatch不能回滚重置。</li>
<li>CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务</li>
<li>CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了</li>
</ul>
<h2 id="说一说对ReentrantReadWriteLock的理解？"><a href="#说一说对ReentrantReadWriteLock的理解？" class="headerlink" title="说一说对ReentrantReadWriteLock的理解？"></a>说一说对ReentrantReadWriteLock的理解？</h2><ul>
<li>ReentrantReadWriteLock内部维护了一对锁，读锁和写锁。支持重入和公平以及平非公平模式。读锁是共享式的，它能够被多个线程同时获取，在没有其他写线程访问（或者写状态为0）时，读锁总会被成功地获取，而所做的也只是（线程安全的）增加读状态。如果当前线程已经获取了读锁，则增加读状态。如果当前线程在获取读锁时，写锁已被其他线程获取，则进入等待状态。</li>
<li>写锁是一个支持重进入的排它锁。如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取写锁时(还未获到)，读锁已经被获取或者该线程不是已经获取写锁的线程，则当前线程进入等待状态。</li>
<li>写锁要确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。</li>
<li>锁降级：遵循获取写锁，获取读锁在释放写锁的次序，写锁可以降级为读锁</li>
<li>锁降级中读锁的获取是否必要呢？答案是必要的。主要是为了保证数据的可见性，如果当前线程不获取读锁而是直接释放写锁，获取了写锁并修改了数据，那么当前线程无法感知线程T的数据更新</li>
</ul>
<h2 id="说一说Condition的理解？"><a href="#说一说Condition的理解？" class="headerlink" title="说一说Condition的理解？"></a>说一说Condition的理解？</h2><ul>
<li><code>Condition</code>是一个接口，与<code>Lock</code>配合可以实现的等待通知模式，类似<code>Object</code>的<code>wait</code>和<code>notify</code>。获取一个<code>Condition</code>对象需要调用Lock的<code>newCondition</code>方法或得<code>ConditionObject</code>,是AQS的一个内部类。Condition操作需要获取想关联的锁</li>
<li>一个线程获取锁后，通过调用Condition的<code>await()</code>方法，会释放锁，然后构造成节点并将节点从尾部加入等待队列,并进入等待状态。</li>
<li>当线程调用<code>signal()</code>方法后，程序首先检查当前线程是否获取了锁，然后通过<code>doSignal(Node first)</code>方法唤醒同步队列的等待时间最长的节点（首节点)。在唤醒节点之前，会将节点移动到同步队列中，被唤醒的线程，将从await()方法中的while循环中退出来，然后调用acquireQueued()方法竞争同步状态。</li>
</ul>
<h2 id="说一说你对exchanger的理解？"><a href="#说一说你对exchanger的理解？" class="headerlink" title="说一说你对exchanger的理解？"></a>说一说你对exchanger的理解？</h2><ul>
<li>Exchanger类允许在两个线程之间定义同步点。当两个线程都到达同步点时，他们交换数据结构，因此第一个线程的数据结构进入到第二个线程中，第二个线程的数据结构进入到第一个线程中</li>
<li>Exchanger算法的核心是通过一个可交换数据的slot，以及一个可以带有数据item的参与者。</li>
<li>在Exchanger中，如果一个线程已经到达了exchanger节点时，如果它的伙伴节点在该线程到达之前已经调用了exchanger方法，则它会唤醒它的伙伴然后进行数据交换，得到各自数据返回。如果它的伙伴节点还没有到达交换点，则该线程将会被挂起，等待它的伙伴节点到达被唤醒，完成数据交换。如果当前线程被中断了则抛出异常，或者等待超时了，则抛出超时异常。</li>
</ul>
<h2 id="生产者和消费者模型的作用是什么？"><a href="#生产者和消费者模型的作用是什么？" class="headerlink" title="生产者和消费者模型的作用是什么？"></a><strong>生产者和消费者模型的作用是什么？</strong></h2><p>1）通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用</p>
<p>2）解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约</p>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/1590590509208-c55e311d-4d15-4bd8-8b43-5bec5a1c2193.png" alt="image"></p>
<h2 id="一、MySQL架构"><a href="#一、MySQL架构" class="headerlink" title="一、MySQL架构"></a>一、MySQL架构</h2><p>和其它数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎的架构上，<strong>插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离</strong>。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/1590590539775-66b802ba-2c1c-4c50-9cd0-a41eb54578e5.png" alt="image"></p>
<ul>
<li><strong>连接层</strong>：最上层是一些客户端和连接服务。<strong>主要完成一些类似于连接处理、授权认证、及相关的安全方案</strong>。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</li>
<li><strong>服务层</strong>：第二层服务层，主要完成大部分的核心服务功能， 包括<strong>查询解析、分析、优化、缓存**</strong>、以及所有的内置函数<strong>，所有跨存储引擎的功能也都在这一层实现，包括</strong>触发器、存储过程、视图**等</li>
<li><strong>引擎层</strong>：第三层存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取</li>
<li><strong>存储层</strong>：第四层为数据存储层，主要是将数据存储在运行于该设备的文件系统之上，并完成与存储引擎的交互</li>
</ul>
<p><strong>MySQL 的查询流程</strong></p>
<p>（所有SQL语句都可以称为查询，包括INSERT,DELETE,UPDATE）</p>
<p>—&gt; 客户端请求</p>
<p>—&gt; 连接器（验证用户身份，给予权限）  </p>
<p>—&gt; 查询缓存（存在缓存则直接返回，不存在则执行后续操作）</p>
<p>—&gt; 分析器（对SQL进行词法分析和语法分析操作）  </p>
<p>—&gt; 优化器（主要对执行的sql优化选择最优的执行方案方法）  </p>
<p>—&gt; 执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口）</p>
<p>—&gt; 去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）</p>
<h2 id="二、MySQL-事务"><a href="#二、MySQL-事务" class="headerlink" title="二、MySQL 事务"></a>二、MySQL 事务</h2><h3 id="ACID-—-事务基本要素"><a href="#ACID-—-事务基本要素" class="headerlink" title="ACID — 事务基本要素"></a>ACID — 事务基本要素</h3><ul>
<li><strong>A (Atomicity) 原子性</strong>：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样</li>
<li><strong>C (Consistency) 一致性</strong>：在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。AID是手段，C是目的，即通过种种手段保证数据库在事务执行前后都处于正确的状态（即数据库列上没有限制数据的范围，但是转账业务中不可能出现账户余额为负的情况，所以要保证事务前后要保证数据库在业务上处于正确的状态）</li>
<li><strong>I (Isolation)隔离性</strong>：一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰</li>
<li><strong>D (Durability) 持久性</strong>：在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚</li>
</ul>
<h3 id="并发事务处理带来的问题"><a href="#并发事务处理带来的问题" class="headerlink" title="并发事务处理带来的问题"></a><strong>并发事务处理带来的问题</strong></h3><ul>
<li>**更新丢失（Lost Update)**：事务A和事务B选择同一行，并基于最初选定的值更新该行时，由于两个事务都不知道彼此的存在，就会发生丢失更新问题</li>
<li>**脏读(Dirty Reads)**：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</li>
<li>**不可重复读（Non-Repeatable Reads)**：事务 A 多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。</li>
<li>**幻读（Phantom Reads)**：幻读与不可重复读类似。它发生在一个事务A读取了几行数据，接着另一个并发事务B插入了一些数据时。在随后的查询中，事务A就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>
</ul>
<h4 id="幻读和不可重复读的区别："><a href="#幻读和不可重复读的区别：" class="headerlink" title="幻读和不可重复读的区别："></a><strong>幻读和不可重复读的区别：</strong></h4><ul>
<li><strong>不可重复读的重点是修改</strong>：在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样。（因为中间有其他事务提交了修改）</li>
<li><strong>幻读的重点在于新增或者删除</strong>：在同一事务中，同样的条件,第一次和第二次读出来的记录数不一样。（因为中间有其他事务提交了插入/删除）</li>
</ul>
<h4 id="并发事务处理带来的问题的解决办法："><a href="#并发事务处理带来的问题的解决办法：" class="headerlink" title="并发事务处理带来的问题的解决办法："></a><strong>并发事务处理带来的问题的解决办法：</strong></h4><ul>
<li><p>“更新丢失”通常是应该完全避免的。但防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决，因此，防止更新丢失应该是应用的责任。</p>
</li>
<li><p><strong>“脏读” 、 “不可重复读”和“幻读” ，其实都是数据库读一致性问题</strong>，必须由数据库提供一定的事务隔离机制来解决：</p>
</li>
<li><ul>
<li>一种是加锁：在读取数据前，对其加锁，阻止其他事务对数据进行修改。<ul>
<li>另一种是数据多版本并发控制（MultiVersion Concurrency Control，<strong>MVCC</strong> ）：可以认为是行级锁的变种， 通过一定机制生成一个数据请求时间点的一致性数据快照 （Snapshot)， 并用这个快照来提供一定级别 （语句级或事务级） 的一致性读取。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><ul>
<li><strong>READ-UNCOMMITTED(读未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li>
<li><strong>READ-COMMITTED(读已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li>
<li><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li>
<li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li>
</ul>
<h3 id="隔离级别比较"><a href="#隔离级别比较" class="headerlink" title="隔离级别比较"></a>隔离级别比较</h3><table>
<thead>
<tr>
<th>事务隔离级别</th>
<th>读数据一致性</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交（read-uncommitted）</td>
<td>最低级被，只能保证不读取物理上损坏的数据</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>读已提交（read-committed）</td>
<td>语句级</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>可重复读（repeatable-read）</td>
<td>事务级</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>串行化（serializable）</td>
<td>最高级别，事务级</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
<p><strong>这里需要注意的是：</strong>与 SQL 标准不同的地方在于InnoDB 存储引擎在 <strong>REPEATABLE-READ</strong>（可重读）事务隔离级别下使用的是<strong>Next-Key Lock</strong> 算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 <strong>SERIALIZABLE</strong>(可串行化)隔离级别，而且保留了比较好的并发性能。</p>
<p>大部分数据库系统的隔离级别都是<strong>READ-COMMITTED</strong>(读已提交):，但是你要知道的是<strong>InnoDB 存储引擎默认使用 REPEATABLE-READ（可重读）并不会有任何性能损失</strong>。</p>
<h2 id="三、MySQL锁机制"><a href="#三、MySQL锁机制" class="headerlink" title="三、MySQL锁机制"></a>三、MySQL锁机制</h2><blockquote>
<p>❝</p>
<p>数据库的乐观锁和悲观锁？</p>
<p>MySQL 中有哪几种锁，列举一下？</p>
<p>MySQL中InnoDB引擎的行锁是怎么实现的？</p>
<p>MySQL 间隙锁有没有了解，死锁有没有了解，写一段会造成死锁的 sql 语句，死锁发生了如何解决，MySQL 有没有提供什么机制去解决死锁</p>
</blockquote>
<h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><p><strong>从对数据操作的类型分类</strong>：</p>
<ul>
<li><strong>读锁</strong>（共享锁）：针对同一份数据，多个读操作可以同时进行，不会互相影响</li>
<li><strong>写锁</strong>（排他锁）：当前写操作没有完成前，它会阻断其他写锁和读锁</li>
</ul>
<p><strong>从对数据操作的粒度分类</strong>：</p>
<ul>
<li><strong>表级锁</strong>：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低（MyISAM 和 MEMORY 存储引擎采用的是表级锁）；</li>
<li><strong>行级锁</strong>：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高（InnoDB 存储引擎既支持行级锁也支持表级锁，但默认情况下是采用行级锁）；</li>
<li><strong>页面锁</strong>：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>行锁</th>
<th>表锁</th>
<th>页锁</th>
</tr>
</thead>
<tbody><tr>
<td>MyISAM</td>
<td></td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>BDB</td>
<td></td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>InnoDB</td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>Memory</td>
<td></td>
<td>√</td>
<td></td>
</tr>
</tbody></table>
<h3 id="MyISAM-表锁"><a href="#MyISAM-表锁" class="headerlink" title="MyISAM 表锁"></a>MyISAM 表锁</h3><p>MyISAM 的表锁有两种模式：</p>
<ul>
<li>表共享读锁 （Table Read Lock）：不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；</li>
<li>表独占写锁 （Table Write Lock）：会阻塞其他用户对同一表的读和写操作；</li>
</ul>
<p>MyISAM 表的读操作与写操作之间，以及写操作之间是串行的。当一个线程获得对一个表的写锁后， 只有持有锁的线程可以对表进行更新操作。其他线程的读、 写操作都会等待，直到锁被释放为止。</p>
<p>默认情况下，写锁比读锁具有更高的优先级：当一个锁释放时，这个锁会优先给写锁队列中等候的获取锁请求，然后再给读锁队列中等候的获取锁请求。</p>
<h3 id="InnoDB-行锁"><a href="#InnoDB-行锁" class="headerlink" title="InnoDB 行锁"></a>InnoDB 行锁</h3><ul>
<li>InnoDB 实现了以下两种类型的<strong>行锁</strong>：<ul>
<li>共享锁（shared lock S锁，又称读锁）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</li>
<li>排他锁（exclusive lock X锁，又称写锁）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。insert ，delete ， <strong>update在事务中都会自动默认加上排它锁</strong>。</li>
</ul>
</li>
<li>同时InnoDB还实现了<strong>多粒度锁</strong>：</li>
</ul>
<p><strong>为了允许行锁和表锁共存，实现多粒度锁机制——意向锁</strong>（Intention Locks）：未来的某个时刻，事务可能要加共享/排它锁了，先提前声明一个意向</p>
<ul>
<li><p>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。</p>
</li>
<li><p>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。</p>
</li>
<li><p>“冲突—兼容”规则：</p>
<ul>
<li><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/1590745463390-4377c2d2-8ea7-4d04-8a13-a78ec84125eb.png" alt="image"></li>
<li><strong>意向锁是怎么提高检测效率的？</strong><ul>
<li><strong>在加表锁的时可立即检测到是否存在意向锁，若存在，则说明有行锁，因此无须遍历整个表即可知道发生冲突</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="加锁机制"><a href="#加锁机制" class="headerlink" title="加锁机制"></a>加锁机制</h4><ul>
<li><strong>乐观锁与悲观锁是两种并发控制的思想，可用于解决丢失更新问题</strong><ul>
<li>乐观锁会“乐观地”假定大概率不会发生并发更新冲突，访问、<strong>处理数据过程中不加锁**</strong>，只在更新数据时再根据版本号或时间戳判断是否有冲突**，有则处理，无则提交事务。用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式</li>
<li>悲观锁会“悲观地”假定大概率会发生并发更新冲突，访问、<strong>处理数据前就加排他锁</strong>，<strong>在整个数据处理过程中锁定数据，事务提交或回滚后才释放锁</strong>。另外与乐观锁相对应的，<strong>悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。</strong></li>
</ul>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li><strong>InnoDB</strong> 中的<code>行锁</code>的实现依赖于<code>索引</code>，一旦某个加锁操作没有使用到索引，那么该锁就会退化为<code>表锁</code>。</li>
<li><strong>记录锁</strong>存在于包括<code>主键索引</code>在内的<code>唯一索引</code>中，锁定单条索引记录。</li>
<li><strong>间隙锁</strong>存在于<code>非唯一索引</code>中，锁定<code>开区间</code>范围内的一段间隔，它是基于<strong>临键锁</strong>实现的。</li>
<li><strong>临键锁</strong>存在于<code>非唯一索引</code>中，该类型的每条记录的索引上都存在这种锁，它是一种特殊的<strong>间隙锁</strong>，锁定一段<code>左开右闭</code>的索引区间。</li>
</ol>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><strong>死锁产生</strong>：</p>
<ul>
<li>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环</li>
<li>当事务试图以不同的顺序锁定资源时，就可能产生死锁。多个事务同时锁定同一个资源时也可能会产生死锁</li>
<li>锁的行为和顺序和存储引擎相关。以同样的顺序执行语句，有些存储引擎会产生死锁有些不会——死锁有双重原因：真正的数据冲突；存储引擎的实现方式。</li>
</ul>
<p><strong>检测死锁</strong>：数据库系统实现了各种死锁检测和死锁超时的机制。InnoDB存储引擎能检测到死锁的循环依赖并立即返回一个错误。</p>
<p><strong>死锁恢复</strong>：死锁发生以后，只有部分或完全回滚其中一个事务，才能打破死锁，InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。</p>
<p><strong>外部锁的死锁检测</strong>：发生死锁后，InnoDB 一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及表锁的情况下，InnoDB 并不能完全自动检测到死锁， 这需要通过设置锁等待超时参数 innodb_lock_wait_timeout 来解决</p>
<p><strong>死锁影响性能</strong>：死锁会影响性能而不是会产生严重错误，因为InnoDB会自动检测死锁状况并回滚其中一个受影响的事务。在高并发系统上，当许多线程等待同一个锁时，死锁检测可能导致速度变慢。</p>
<p><strong>MyISAM避免死锁</strong>：</p>
<ul>
<li><strong>在自动加锁的情况下，MyISAM 总是一次获得 SQL 语句所需要的全部锁，所以 MyISAM 表不会出现死锁。</strong></li>
</ul>
<h2 id="四、存储引擎"><a href="#四、存储引擎" class="headerlink" title="四、存储引擎"></a>四、存储引擎</h2><h3 id="存储引擎对比"><a href="#存储引擎对比" class="headerlink" title="存储引擎对比"></a>存储引擎对比</h3><p>常见的存储引擎就 InnoDB、MyISAM、Memory、NDB。</p>
<p>InnoDB 现在是 MySQL 默认的存储引擎，支持<strong>事务、行级锁定和外键</strong></p>
<h4 id="文件存储结构对比"><a href="#文件存储结构对比" class="headerlink" title="文件存储结构对比"></a>文件存储结构对比</h4><p>在 MySQL中建立任何一张数据表，在其数据目录对应的数据库目录下都有对应表的 <code>.frm</code> 文件，<code>.frm</code> 文件是用来保存每个数据表的元数据(meta)信息，包括表结构的定义等，与数据库存储引擎无关，也就是任何存储引擎的数据表都必须有<code>.frm</code>文件，命名方式为 数据表名.frm，如user.frm。</p>
<p>查看MySQL 数据保存在哪里：<code>show variables like &#39;data%&#39;</code></p>
<p><strong>MyISAM 物理文件结构为：</strong></p>
<ul>
<li><code>.frm</code>文件：与表相关的元数据信息都存放在frm文件，包括<strong>表结构的定义信息</strong>等</li>
<li><code>.MYD</code> (<code>MYData</code>) 文件：MyISAM 存储引擎专用，用于存储MyISAM <strong>表的数据</strong></li>
<li><code>.MYI</code> (<code>MYIndex</code>)文件：MyISAM 存储引擎专用，用于存储MyISAM <strong>表的索引相关信息</strong></li>
</ul>
<p><strong>InnoDB 物理文件结构为：</strong></p>
<ul>
<li><code>.frm</code> 文件：与表相关的元数据信息都存放在frm文件，包括<strong>表结构的定义信息</strong>等</li>
<li><code>.ibd</code> 文件或 <code>.ibdata</code> 文件：这两种文件都是存放 InnoDB 数据的文件，之所以有两种文件形式存放 InnoDB 的数据，是因为 InnoDB 的数据存储方式能够通过配置来决定是使用<strong>共享表空间</strong>存放存储数据，还是用<strong>独享表空间</strong>存放存储数据。<br>  独享表空间存储方式使用<code>.ibd</code>文件，并且每个表一个<code>.ibd</code>文件 共享表空间存储方式使用<code>.ibdata</code>文件，所有表共同使用一个<code>.ibdata</code>文件（或多个，可自己配置）</li>
</ul>
<h4 id="MyISAM和InnoDB区别"><a href="#MyISAM和InnoDB区别" class="headerlink" title="MyISAM和InnoDB区别"></a>MyISAM和InnoDB区别</h4><ol>
<li>InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</li>
<li>InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；</li>
<li>InnoDB 是聚簇索引，MyISAM 是非聚簇索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是二级索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和二级索引是独立的。</li>
<li>InnoDB 不保存表的具体行数，执行<code>select count(*) from table</code> 时需要全表扫描。而 MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</li>
<li>InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。MyISAM一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</li>
</ol>
<table>
<thead>
<tr>
<th>对比项</th>
<th>MyISAM</th>
<th>InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td>主外键</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>事务</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>行表锁</td>
<td>表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</td>
<td>行锁,操作时只锁某一行，不对其它行有影响，适合高并发的操作</td>
</tr>
<tr>
<td>缓存</td>
<td>只缓存索引，不缓存真实数据</td>
<td>不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响</td>
</tr>
<tr>
<td>表空间</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>关注点</td>
<td>性能</td>
<td>事务</td>
</tr>
<tr>
<td>默认安装</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<blockquote>
<p>❝一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15 ？</p>
</blockquote>
<p>如果表的类型是MyISAM，那么是18。因为MyISAM表会把自增主键的最大ID 记录到数据文件中，重启MySQL自增主键的最大ID也不会丢失；</p>
<p>如果表的类型是InnoDB，那么是15。因为InnoDB 表只是把自增主键的最大ID记录到内存中，所以重启数据库或对表进行OPTION操作，都会导致最大ID丢失。</p>
<blockquote>
<p>❝哪个存储引擎执行 select count(*) 更快，为什么?</p>
</blockquote>
<p>MyISAM更快，因为MyISAM内部维护了一个计数器，可以直接调取。</p>
<ul>
<li>在 MyISAM 存储引擎中，把表的总行数存储在磁盘上，当执行 select count(*) from t 时，直接返回总数据。</li>
<li>在 InnoDB 存储引擎中，跟 MyISAM 不一样，没有将总行数存储在磁盘上，当执行 select count(*) from t 时，会先把数据读出来，一行一行的累加，最后返回总数量。</li>
</ul>
<p>InnoDB 中 count(*) 语句是在执行的时候，全表扫描统计总数量，所以当数据越来越大时，语句就越来越耗时了，为什么 InnoDB 引擎不像 MyISAM 引擎一样，将总行数存储到磁盘上？这跟 InnoDB 的事务特性有关，<strong>由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的</strong>。</p>
<p>❝为什么MyISAM读取速度更快？</p>
<ul>
<li>InnoDB 在做 SELECT 的时候，要维护的东西比 MYISAM 引擎多很多，比如检查和维护MVCC</li>
<li>innodb寻址要映射到块，再到行，MYISAM记录的直接是文件的OFFSET，定位比INNODB要快</li>
</ul>
<h2 id="五、数据类型"><a href="#五、数据类型" class="headerlink" title="五、数据类型"></a>五、数据类型</h2><h3 id="MySQL的数据类型"><a href="#MySQL的数据类型" class="headerlink" title="MySQL的数据类型"></a>MySQL的数据类型</h3><ul>
<li>整数类型：BIT、BOOL、TINY INT、SMALL INT、MEDIUM INT、 INT、 BIG INT</li>
<li>浮点数类型：FLOAT、DOUBLE、DECIMAL</li>
<li>字符串类型：CHAR、VARCHAR、TINY TEXT、TEXT、MEDIUM TEXT、LONG TEXT、TINY BLOB、BLOB、MEDIUM BLOB、LONG BLOB</li>
<li>日期类型：Date、DateTime、TimeStamp、Time、Year</li>
<li>其他数据类型：BINARY、VARBINARY、ENUM、SET、Geometry、Point、MultiPoint、LineString、MultiLineString、Polygon、GeometryCollection等</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/1590590539852-f07a129b-1bfb-4487-af9a-df13273354c2.webp" alt="image"><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018141809.webp" alt="image"><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018141757.webp" alt="image"></p>
<blockquote>
<p>❝CHAR 和 VARCHAR 的区别？</p>
</blockquote>
<p>char是固定长度，varchar长度可变：</p>
<p>char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。</p>
<p>存储时，前者不管实际存储数据的长度，直接按 char 规定的长度分配存储空间；而后者会根据实际存储的数据分配最终的存储空间</p>
<p><strong>相同点：</strong></p>
<ol>
<li>char(n)，varchar(n)中的n都代表字符的个数</li>
<li>超过char，varchar最大长度n的限制后，字符串会被截断。</li>
</ol>
<p><strong>不同点：</strong></p>
<ol>
<li>char不论实际存储的字符数都会占用n个字符的空间，而varchar只会占用实际字符应该占用的字节空间加1（实际长度length，0&lt;=length&lt;255）或加2（length&gt;255）。因为varchar保存数据时除了要保存字符串之外还会加一个字节来记录长度（如果列声明长度大于255则使用两个字节来保存长度）。</li>
<li>能存储的最大空间限制不一样：char的存储上限为255字节。</li>
<li>char在存储时会截断尾部的空格，而varchar不会。</li>
</ol>
<p>char是适合存储很短的、一般固定长度的字符串。例如，char非常适合存储密码的MD5值，因为这是一个定长的值。对于非常短的列，char比varchar在存储空间上也更有效率。</p>
<blockquote>
<p>❝列的字符串类型可以是什么？</p>
</blockquote>
<p>字符串类型是：BIT、SET、BLOB、ENUM、CHAR、TEXT、VARCHAR</p>
<p>ENUM：使用枚举代替字符串类型，将不重复的字符串存储到预定义的集合中。列中存储的是整数，这样列表值会非常紧凑，压缩到1-2个字节中。定义好了ENUM的集合后，如果想向其中添加或删除字符串必须使用ALTER TABLE，除非是向集合列表末尾添加元素。</p>
<p>BIT：二进制的多个比特串，MySQL将其作为字符串类型处理</p>
<p>SET：多个BIT合并称的数据类型，有效利用存储空间。</p>
<p>上述三种都可以使用其他数据类型达到同样的功能，而且不容易犯错。</p>
<blockquote>
<p>❝BLOB和TEXT有什么区别？</p>
</blockquote>
<p>BLOB和TEXT都是为存储很大的数据而设计的字符串数据类型，且容纳可变数量的数据。</p>
<p>BLOB存储的是二进制数据，四种类型的BLOB：TINYBLOB、BLOB、MEDIUMBLO和 LONGBLOB</p>
<p>TEXT存储的是字符数据，四种TEXT类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。</p>
<h3 id="范式与反范式"><a href="#范式与反范式" class="headerlink" title="范式与反范式"></a>范式与反范式</h3><ul>
<li><p>范式化的数据库中，每个事实数据只会出现一次，而反范式化的数据库中，信息是冗余的，可能会存储在多个地方。</p>
</li>
<li><p>范式的优点：</p>
</li>
<li><ul>
<li>范式化修改的数据通常更少，更新操作通常比反范式化更快<ul>
<li>范式化的表通常更小，可以更好的放在内存里</li>
<li>范式化很少有多余的数据意味着检索列表数据时可能不需要DISTINCT/GROUP BY语句</li>
</ul>
</li>
</ul>
</li>
<li><p>范式的缺点：</p>
</li>
<li><ul>
<li>通常需要关联，不仅代价高而且可能使得一些索引无效。比如，将列存储在不用的表中，而这些列如果在一个表中则本可以属于同一个索引</li>
</ul>
</li>
<li><p>反范式的优点：</p>
</li>
<li><ul>
<li>避免了很多关联，在没有关联的情况下，反范式执行全表扫描是顺序I/O，可能比关联要快得多</li>
</ul>
</li>
</ul>
<h4 id="混合范式化和反范式化"><a href="#混合范式化和反范式化" class="headerlink" title="混合范式化和反范式化"></a>混合范式化和反范式化</h4><ul>
<li>实际并不会完全的范式化和反范式化，上面完全反范式化的例子user_message的表太大了，而且如果没有消息就会丢失用户信息。可以在user表和message表中都存储account_type字段，可以同时解决前面两个问题。但是新的问题是每次更新都要更新两张表，更新代价提高了。</li>
</ul>
<h4 id="缓存表和汇总表"><a href="#缓存表和汇总表" class="headerlink" title="缓存表和汇总表"></a>缓存表和汇总表</h4><ul>
<li>上面的混合范式化是在同一张表中保存衍生的冗余数据，而有时也需要创建完全独立的缓存表和汇总表</li>
<li>缓存表：保存比较简单的从其他表获取且速度较慢的的数据</li>
<li>汇总表：保存使用GROUP BY语句聚合的数据</li>
</ul>
<h2 id="六、索引"><a href="#六、索引" class="headerlink" title="六、索引"></a>六、索引</h2><blockquote>
<p>❝</p>
<p>说说你对 MySQL 索引的理解？</p>
<p>数据库索引的原理，为什么要用 B+树，为什么不用二叉树？</p>
<p>聚集索引与非聚集索引的区别？</p>
<p>InnoDB引擎中的索引策略，了解过吗？</p>
<p>创建索引的方式有哪些？</p>
<p>聚簇索引/非聚簇索引，mysql索引底层实现，为什么不用B-tree，为什么不用hash，叶子结点存放的是数据还是指向数据的内存地址，使用索引需要注意的几个地方？</p>
</blockquote>
<ul>
<li>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构，所以说<strong>索引的本质是：数据结构</strong></li>
<li>索引的目的在于提高查询效率，可以类比字典、 火车站的车次表、图书的目录等 </li>
<li>可以简单的理解为“排好序的快速查找数据结构”，数据本身之外，<strong>数据库还维护着一个满足特定查找算法的数据结构</strong>，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。下图是一种可能的索引方式示例<img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539862-061bbf2b-9b17-4cb6-9ec2-3c2139bbfbc1.webp?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></li>
<li>左边的数据表，一共有两列七条记录，最左边的是数据记录的物理地址。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值，和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在一定的复杂度内获取到对应的数据，从而快速检索出符合条件的记录。</li>
<li>索引本身也很大，不可能全部存储在内存中，<strong>一般以索引文件的形式存储在磁盘上</strong></li>
<li>平常说的索引，没有特别指明的话，就是B+树（多路搜索树，不一定是二叉树）结构组织的索引。其中聚集索引，次要索引，覆盖索引，符合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。此外还有哈希索引等。</li>
</ul>
<h3 id="索引的优势"><a href="#索引的优势" class="headerlink" title="索引的优势"></a>索引的优势</h3><ul>
<li><strong>大大减少服务器需要扫描的数据量</strong></li>
<li><strong>B+树种按照顺序存储数据，降低执行排序操作ORDER BY/GROUP BY的成本，避免生成临时表</strong></li>
<li><strong>B+树的特点+数据顺序存储，可以将随机I/O变为顺序I/O</strong></li>
</ul>
<h3 id="索引的劣势"><a href="#索引的劣势" class="headerlink" title="索引的劣势"></a>索引的劣势</h3><ul>
<li>索引也是一张表，保存了主键和索引字段，并指向实体表的记录，所以也需要占用内存</li>
<li><strong>虽然索引大大提高了查询速度，同时却会降低更新表的速度</strong>，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要更新索引文件中对应的索引列字段， 因为这三种操作会导致索引信息发生变化</li>
<li>对于非常小的表使用全表扫描更高效，中到大型表适合使用索引，特大型表建立和使用索引代价随之增加，可以使用分区技术</li>
</ul>
<h3 id="MySQL索引分类"><a href="#MySQL索引分类" class="headerlink" title="MySQL索引分类"></a>MySQL索引分类</h3><h4 id="数据结构角度"><a href="#数据结构角度" class="headerlink" title="数据结构角度"></a>数据结构角度</h4><ul>
<li>B+树索引</li>
<li>Hash索引</li>
<li>Full-Text全文索引</li>
<li>R-Tree索引</li>
</ul>
<h4 id="从物理存储角度"><a href="#从物理存储角度" class="headerlink" title="从物理存储角度"></a>从物理存储角度</h4><ul>
<li>聚集索引（clustered index）</li>
<li>非聚集索引（non-clustered index），也叫二级索引（secondary index）<br>  聚集索引和非聚集索引都是B+树结构</li>
</ul>
<h4 id="从逻辑角度"><a href="#从逻辑角度" class="headerlink" title="从逻辑角度"></a>从逻辑角度</h4><ul>
<li>主键索引：主键索引是一种特殊的唯一索引，不允许有空值</li>
<li>普通索引或者单列索引：每个索引只包含单个列，一个表可以有多个单列索引</li>
<li>联合索引（复合索引、多列索引）：联合索引指多个字段上创建的索引，使用联合索引时遵循匹配最左前缀，即联合索引必须从左至右依次使用（只有在精准匹配第一列之后才可以使用后面的列，<strong>如果出现了between则不能再使用后面的索引</strong>）</li>
<li>唯一索引或者非唯一索引</li>
<li>空间索引：空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，<strong>空间索引只能在存储引擎为MYISAM的表中创建</strong></li>
</ul>
<blockquote>
<p>❝</p>
<p>为什么MySQL 索引中用B+tree，不用B-tree 或者其他树，为什么不用 Hash 索引</p>
<p>聚簇索引/非聚簇索引，MySQL 索引底层实现，叶子结点存放的是数据还是指向数据的内存地址，使用索引需要注意的几个地方？</p>
<p>使用索引查询一定能提高查询的性能吗？为什么?</p>
</blockquote>
<h3 id="MySQL索引结构"><a href="#MySQL索引结构" class="headerlink" title="MySQL索引结构"></a>MySQL索引结构</h3><p><strong>首先要明白索引（index）是在存储引擎（storage engine）层面实现的，而不是server层面</strong>。不是所有的存储引擎都支持所有的索引类型。即使多个存储引擎支持某一索引类型，它们的实现和行为也可能有所差别。</p>
<h4 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B+Tree索引"></a>B+Tree索引</h4><p>MyISAM 和 InnoDB 存储引擎，都使用 B+Tree的数据结构，它相对与 B-Tree结构，所有的数据都存放在叶子节点上，且把叶子节点通过指针连接到一起，形成了一条数据链表，以加快相邻数据的检索效率</p>
<p><strong>先了解下 B-Tree 和 B+Tree 的区别</strong></p>
<h5 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h5><ul>
<li>B-Tree是为磁盘等外存储设备设计的一种平衡多路查找树（查找路径不止两个）。</li>
<li>系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。</li>
<li>InnoDB 存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB 存储引擎中默认每个页的大小为16KB，可通过参数 <code>innodb_page_size</code> 将页的大小设置为 4K、8K、16K，在 MySQL 中可通过如下命令查看页的大小：<code>show variables like &#39;innodb_page_size&#39;;</code></li>
<li>而系统一个磁盘块的存储空间往往没有这么大，因此 InnoDB 每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小 16KB。InnoDB 在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。</li>
<li>B-Tree 结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述 B-Tree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值，对应表中的主键值，data 为一行记录中除主键外的数据。对于不同的记录，key值互不相同。</li>
<li><strong>m阶的B-Tree的特性：</strong></li>
</ul>
<ol>
<li>每个节点最多有m个子节点</li>
<li>除了根节点和叶子节点外，其它每个节点至少有ceil(m/2)个子节点（ceil()向上取整）。</li>
<li>若根节点不是叶子节点，则至少有2个子节点</li>
<li>所有叶子节点都在同一层，且不包含其它关键字信息</li>
<li>关键字的个数n满足：ceil(m/2)-1 &lt;= n &lt;= m-1</li>
<li>每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn）</li>
<li>ki(i=1,…n)为关键字，且关键字升序排序</li>
<li>Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)</li>
</ol>
<ul>
<li><p>B-Tree 中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个 3 阶的 B-Tree：</p>
</li>
<li><ul>
<li>每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。<ul>
<li>模拟查找关键字29的过程：</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li><ol>
<li><ol>
<li>根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】<ol start="2">
<li>比较关键字29在区间（17,35），找到磁盘块1的指针P2。</li>
<li>根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】</li>
<li>比较关键字29在区间（26,30），找到磁盘块3的指针P2。</li>
<li>根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】</li>
<li>在磁盘块8中的关键字列表中找到关键字29。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<ul>
<li><ul>
<li>分析上面过程，发现需要3次磁盘I/O操作，和3次内存查找操作。而3次磁盘I/O操作是影响整个B-Tree查找效率的决定因素，所以<strong>B-Tree相对于AVLTree缩减了节点个数</strong>，从而提高了查询效率。</li>
</ul>
</li>
</ul>
<h5 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h5><ul>
<li>B+Tree 是在 B-Tree 基础上的一种优化，使其更适合实现外存储索引结构，InnoDB 存储引擎就是用 B+Tree 实现其索引结构。</li>
<li>B-Tree结构图中每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。在B+Tree中，<strong>所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上**</strong>，而非叶子节点上只存储key值信息**<strong>，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度</strong>。</li>
<li>B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对B+Tree进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。</li>
<li><strong>B+Tree相对于B-Tree有几点不同：</strong></li>
</ul>
<ol>
<li>非叶子节点只存储键值信息；</li>
<li>所有叶子节点之间都有一个链指针；</li>
<li>数据记录都存放在叶子节点中</li>
</ol>
<ul>
<li>假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示：</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539886-ed20e377-d331-41d0-a2f8-1f7273b9442d.webp?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<ul>
<li><p>可能上面例子中只有22条数据记录，看不出B+Tree的优点，下面做一个推算：</p>
</li>
<li><ul>
<li>InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为10^3）。也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录。</li>
</ul>
</li>
<li><p>实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2-4层。MySQL的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。</p>
</li>
<li><p>B+Tree性质</p>
</li>
</ul>
<ol>
<li>通过上面的分析，我们知道IO次数取决于B+树的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有<img src="https://cdn.nlark.com/yuque/__latex/419c87720465f7f5a8523f3cc041af27.svg" alt="img">，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。</li>
<li>当B+树的数据项是复合的数据结构，比如(name,age,sex)的时候，B+树是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，B+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即<strong>索引的最左匹配特性</strong>。</li>
</ol>
<blockquote>
<p>❝B+树是怎么保证平衡的？</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/nullzx/p/8729425.html">B树、B+树插入删除过程</a></p>
<h5 id="MyISAM主键索引与二级索引的结构"><a href="#MyISAM主键索引与二级索引的结构" class="headerlink" title="MyISAM主键索引与二级索引的结构"></a>MyISAM主键索引与二级索引的结构</h5><ul>
<li><p>MyISAM引擎的索引文件和数据文件是分离的。<strong>MyISAM引擎索引结构的叶子节点的数据域，存放的并不是实际的数据记录，而是数据记录的地址</strong>。索引文件与数据文件分离，这样的索引称为”非聚簇索引”。MyISAM的主索引与二级索引区别并不大，只是主索引不能有重复的关键字</p>
</li>
<li><p>MyISAM索引</p>
</li>
<li><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590541902-8b1f0c77-6a43-4901-beab-7f3a2f3b0ff5.webp?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></li>
</ul>
</li>
<li><p>在MyISAM中，索引（含叶子节点）存放在单独的.myi文件中，叶子节点存放的是数据的物理地址偏移量</p>
</li>
<li><p>主索引是指主键索引，键值不可能重复；二级索引则是普通索引，键值可能重复。</p>
</li>
<li><p>通过索引查找数据的流程：先从索引文件中查找到索引节点，从中拿到数据的文件指针，再到数据文件中通过文件指针定位了具体的数据。二级索引类似。</p>
</li>
</ul>
<h5 id="InnoDB主键索引与二级索引的结构"><a href="#InnoDB主键索引与二级索引的结构" class="headerlink" title="InnoDB主键索引与二级索引的结构"></a>InnoDB主键索引与二级索引的结构</h5><ul>
<li><strong>InnoDB引擎索引结构的叶子节点的数据域，存放的就是实际的数据记录</strong>（对于主索引，此处会存放表中所有的数据记录；对于二级索引叶子节点存储的是主键，检索的时候通过叶子节点的主键到主键索引中找到对应数据行，即二级索引需要访问两次索引）</li>
<li>或者说，<strong>InnoDB的数据文件本身就是主键索引文件</strong>，这样的索引被称为“聚簇索引”，一个表只能有一个聚簇索引。</li>
<li><strong>向聚簇索引中的页插入新行，如果超出了存储容量则需要执行“页分裂”**</strong>，会导致页与页之间不连续**（分裂的页就不是聚簇的概念，会通过优化表的操作重新完成聚簇）</li>
</ul>
<h6 id="主键索引："><a href="#主键索引：" class="headerlink" title="主键索引："></a>主键索引：</h6><ul>
<li>InnoDB索引是聚集索引，它的索引和数据是存入同一个.idb文件中的，因此它的索引结构是在同一个树节点中同时存放索引和数据，如下图中最底层的叶子节点有三行数据，对应于数据表中的id、stu_id、name数据项。</li>
<li>在Innodb中，索引分叶子节点和非叶子节点，非叶子节点就像新华字典的目录，单独存放在索引段中，叶子节点则是顺序排列的，在数据段中。Innodb的数据文件可以按照表来切分（只需要开启<code>innodb_file_per_table)</code>，切分后存放在<code>xxx.ibd</code>中，默认不切分，存放在<code>xxx.ibdata</code>中。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539905-19dcb659-d0cf-440b-995d-2a62040981f3.webp?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<h6 id="二级（非主键）索引："><a href="#二级（非主键）索引：" class="headerlink" title="二级（非主键）索引："></a>二级（非主键）索引：</h6><ul>
<li>以示例中学生表中的name列建立二级索引，它的索引结构跟主键索引的结构有很大差别，在最底层的叶子结点有两行数据，第一行的字符串是二级索引，按照ASCII码进行排序，第二行的整数是主键的值。</li>
<li>这就意味着，对name列进行条件搜索，需要两个步骤：</li>
</ul>
<ol>
<li>在二级索引上检索name，到达其叶子节点获取对应的主键；</li>
<li>使用主键在主索引上再进行对应的检索操作</li>
</ol>
<p>这也就是所谓的“<strong>回表查询</strong>”</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539900-bb4d422c-e6a4-4b89-a3f0-44deb87c26cf.webp?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<h5 id="InnoDB-索引结构需要注意的点"><a href="#InnoDB-索引结构需要注意的点" class="headerlink" title="InnoDB 索引结构需要注意的点"></a>InnoDB 索引结构需要注意的点</h5><ol>
<li>数据文件本身就是索引文件</li>
<li>聚集索引中叶节点包含了完整的数据记录</li>
<li>InnoDB 表必须要有主键，并且推荐使用整型自增主键</li>
</ol>
<ul>
<li>不管是主键索引还是二级索引，所有的查询都是通过先查找到索引节点才能拿到相对应的数据，所以如果在设计表结构时没有显式指定索引列的话，MySQL 会从表中选择数据不重复的列建立索引，如果没有符合的列，则 MySQL 自动为 InnoDB 表生成一个隐含字段作为主键，并且这个字段长度为6个字节，类型为整型。</li>
</ul>
<blockquote>
<p>❝那为什么推荐使用整型自增主键而不是选择UUID？</p>
</blockquote>
<ul>
<li>UUID是字符串，比整型消耗更多的存储空间；</li>
<li>在B+树中进行查找时需要跟经过的节点值比较大小，整型数据的比较运算比字符串更快速；</li>
<li>自增的整型索引在磁盘中会连续存储，在读取一页数据时也是连续；UUID是随机产生的，读取的上下两行数据存储是分散的，不适合执行where id &gt; 5 &amp;&amp; id &lt; 20的条件查询语句。</li>
<li>在插入或删除数据时，整型自增主键会在叶子结点的末尾建立新的叶子节点，不会破坏左侧子树的结构；UUID主键很容易就破坏了原有树结构，B+树为了维持自身的特性，有可能会进行结构的重构，消耗更多的时间。</li>
</ul>
<blockquote>
<p>❝为什么非主键索引结构叶子节点存储的是主键值？</p>
</blockquote>
<p>保证数据一致性（更新数据的时候只更新主键索引中的数据即可）和节省存储空间，</p>
<h4 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h4><ul>
<li><p>主要就是通过Hash算法，将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。<br>  检索算法：在检索查询时，就再次对待查关键字再次执行相同的Hash算法，得到Hash值，到对应Hash表对应位置取出数据即可，如果发生Hash碰撞，则需要在取值时进行筛选。</p>
</li>
<li><p><strong>Hash索引的限制：</strong></p>
</li>
<li><ul>
<li>value存储的是行指针，不能实现覆盖索引<ul>
<li>哈希索引不是按照索引值顺序存储的，所以不能用于排序，也就不支持范围查找</li>
<li>联合索引时不支持使用部分索引进行查找，因为hash值是由全部索引列计算得到的</li>
<li>哈希冲突严重的时候相当于遍历链表，反而比不上二叉树</li>
</ul>
</li>
</ul>
</li>
<li><p>MySQL目前有Memory引擎和NDB引擎支持Hash索引。</p>
</li>
<li><p>InnoDB可以创建自定义哈希索引：</p>
</li>
<li><ul>
<li>当需要根据URL进行索引时，可以将URL的hash值作为索引的列，这样可以降低索引值长度，并且是整数比较速度快<ul>
<li>即使有大量的哈希冲突，但是索引仍然可以过滤很多数据，而且速度比直接使用URL快</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="full-text全文索引"><a href="#full-text全文索引" class="headerlink" title="full-text全文索引"></a>full-text全文索引</h4><ul>
<li>全文索引也是MyISAM的一种特殊索引类型，主要用于全文索引，InnoDB从MYSQL5.6版本提供对全文索引的支持。</li>
<li>它用于替代效率较低的LIKE模糊匹配操作，而且可以通过多字段组合的全文索引一次性全模糊匹配多个字段。</li>
<li>同样使用B-Tree存放索引数据，但使用的是特定的算法，将字段数据分割后再进行索引（一般每4个字节一次分割），索引文件存储的是分割前的索引字符串集合，与分割后的索引信息，对应B-tree结构的节点存储的是分割后的词信息以及它在分割前的索引字符串集合中的位置。</li>
</ul>
<h4 id="R-Tree空间索引"><a href="#R-Tree空间索引" class="headerlink" title="R-Tree空间索引"></a>R-Tree空间索引</h4><p>空间索引是MyISAM的一种特殊索引类型，主要用于地理空间数据类型</p>
<blockquote>
<p>❝为什么Mysql索引要用B+树不是B树？</p>
</blockquote>
<p>用B+树不用B树考虑的是IO对性能的影响，B树的每个节点都存储数据，而B+树只有叶子节点才存储数据，所以查找相同数据量的情况下，B树的高度更高，IO更频繁。数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。其中在MySQL底层对B+树进行进一步优化：在叶子节点中是双向链表，且在链表的头结点和尾节点也是循环指向的。</p>
<blockquote>
<p>❝面试官：为何不采用Hash方式？</p>
</blockquote>
<p>因为Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。所以，哈希索引只适用于等值查询的场景。而B+Tree是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描。</p>
<p>哈希索引不支持多列联合索引的最左匹配规则，如果有大量重复键值的情况下，哈希索引的效率会很低，因为存在哈希碰撞问题。</p>
<h3 id="哪些情况需要创建索引"><a href="#哪些情况需要创建索引" class="headerlink" title="哪些情况需要创建索引"></a>哪些情况需要创建索引</h3><ol>
<li>主键自动建立唯一索引</li>
<li>频繁作为查询条件的字段</li>
<li>查询中与其他表关联的字段，外键关系建立索引</li>
<li>单键/组合索引的选择问题，高并发下倾向创建组合索引</li>
<li>查询中排序的字段，排序字段通过索引访问大幅提高排序速度</li>
<li>查询中统计或分组字段</li>
</ol>
<h3 id="哪些情况不要创建索引"><a href="#哪些情况不要创建索引" class="headerlink" title="哪些情况不要创建索引"></a>哪些情况不要创建索引</h3><ol>
<li>表记录太少</li>
<li>经常增删改的表</li>
<li>数据重复且分布均匀的表字段，只应该为最经常查询和最经常排序的数据列建立索引（如果某个数据类包含太多的重复数据，建立索引没有太大意义）</li>
<li>频繁更新的字段不适合创建索引（会加重I/O负担）</li>
<li>where条件里用不到的字段不创建索引</li>
</ol>
<h3 id="高性能创建索引"><a href="#高性能创建索引" class="headerlink" title="高性能创建索引"></a>高性能创建索引</h3><h4 id="列前缀索引"><a href="#列前缀索引" class="headerlink" title="列前缀索引"></a>列前缀索引</h4><ul>
<li><p>有时需要索引很长的字符列，会让索引变得大且慢。一个策略是使用哈希索引，另一种方式是使用列前缀索引，即使用该列前一部分字符建立索引，并查询时也只使用该列的前一部分字符。注意：列前缀索引和匹配最前缀索引不是一回事，前者是一个列，后者是多个列</p>
</li>
<li><ul>
<li>例如</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>建立city列字符串的前3个字符的索引：</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>ALTER TABLE sakila.city_demo ADD KEY (city(7));</p>
<ul>
<li><ul>
<li><ul>
<li>查询city列字符串的前3个字符：</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>SELECT COUNT(*) AS cnt, LEFT(city,3) AS pref</p>
<p>FROM sakila.city_demo GROUP BY pref ORDER BY cnt DESC LIMIT 10;</p>
<ul>
<li><p>查询时究竟选择几个字符需要根据实际列判断索引选择性：</p>
</li>
<li><ul>
<li><ul>
<li>索引选择性：不重复的索引项/数据表的记录总数（即，分支越多索引选择性越大）<ul>
<li>选择全部的字符串时索引选择性大</li>
<li>当选择前n个字符的索引选择性接近全字符串的索引选择性时是最佳的列前缀索引</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>使用列前缀索引则不能在该列上使用ORDER BY/GROUP BY，也不能作为覆盖索引</p>
</li>
</ul>
<h4 id="联合索引中索引顺序"><a href="#联合索引中索引顺序" class="headerlink" title="联合索引中索引顺序"></a>联合索引中索引顺序</h4><ul>
<li><p>“三星”索引概念：</p>
</li>
<li><ul>
<li>与查询相关的索引行是相邻的，也就是where后面的等值谓词，可以匹配索引列顺序——where和索引匹配越多，扫描的数据行越少<ul>
<li>索引行的顺序与查询语句需求一致，也就是order by 中的排序和索引顺序是否一致——避免排序</li>
<li>索引行包含查询语句中所有的列——避免扫描数据行</li>
</ul>
</li>
</ul>
</li>
<li><p>一个联合索引中的索引列顺序可以影响到一个索引是否是“三星”索引</p>
</li>
<li><p>通用经验是将选择性高的列放在索引最前列，这样仅仅在where进行查找时效果较好，仅仅是一个经验，排序和分组时这样并不一定适合，实践中并不一定这么做</p>
</li>
</ul>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p><strong>覆盖索引</strong>（Covering Index）,或者叫索引覆盖， 可以不需要回表操作</p>
<ul>
<li>就是select查询数据列在索引中就已经完全包含，不必读取数据行，利用索引返回select列表中的字段，而不必根据索引再次读取数据文件，换句话说<strong>查询列要被所建的索引覆盖</strong>。</li>
<li>索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据，当能通过读取索引就可以得到想要的数据，那就不需要读取行了。一个索引包含（覆盖）满足查询结果的数据就叫做覆盖索引。</li>
<li><strong>判断标准</strong><br>  使用explain，可以通过输出的extra列来判断，对于一个索引覆盖查询，显示为<strong>using index</strong>，MySQL查询优化器在执行查询前会决定是否有索引覆盖查询</li>
</ul>
<h2 id="七、MySQL查询"><a href="#七、MySQL查询" class="headerlink" title="七、MySQL查询"></a>七、MySQL查询</h2><ul>
<li>查询优化、索引优化、库表结构优化需要齐头并进</li>
</ul>
<h3 id="优化慢查询"><a href="#优化慢查询" class="headerlink" title="优化慢查询"></a>优化慢查询</h3><ul>
<li>是否查询了大量的结果，但是仅使用前10条——使用LIMIT</li>
<li>多表关联的时候返回了全部的列（SELECT * FROM actor INNER JOIN film_actor USING(actor_id) WHERE …）——仅返回需要的列</li>
<li>取出不需要的列（SELECT * FROM xxx）</li>
</ul>
<p>取出不需要的列会导致优化器无法使用索引覆盖进行优化，同时还会带来额外的I/O、内存和CPU消耗</p>
<h3 id="索引效果与优化"><a href="#索引效果与优化" class="headerlink" title="索引效果与优化"></a>索引效果与优化</h3><p>使用WHERE条件的三种方式，从好到坏：</p>
<ul>
<li>索引中使用WHERE条件过滤不匹配的记录。在存储引擎层完成</li>
<li>使用索引覆盖扫描返回记录（Explain中Extra列为Using index）。在MySQL服务器层完成，不需要回表查询</li>
<li>从数据表中返回记录，然后根据WHERE过滤不满足条件的记录（Explain中Extra列为Using Where）。在MySQL服务器层完成，需要先从数据表读出记录再过滤</li>
</ul>
<p>发现扫描大量数据，但只返回需要的少量数据，优化方式：</p>
<ul>
<li>从索引角度入手，使用索引覆盖扫描</li>
<li>从库表结构入手，例如使用单独的汇总表（优化count()语句）</li>
<li>从查询语句入手，重写查询语句，下面会介绍</li>
</ul>
<h3 id="重构查询的方式"><a href="#重构查询的方式" class="headerlink" title="重构查询的方式"></a>重构查询的方式</h3><h4 id="切分查询"><a href="#切分查询" class="headerlink" title="切分查询"></a>切分查询</h4><ul>
<li><p>有时候可以将一个大查询切分成小查询</p>
</li>
<li><p>例如，删除旧数据</p>
</li>
<li><ul>
<li>一次删除大量数据可能锁住很多数据，占满整个事务日志、耗尽资源、阻塞很多重要查询<ul>
<li>将要删除的数据分为多次小删除对服务器影响较小</li>
<li>原SQL语句一次删除大量数据：DELETE FROM messages WHERE created &lt; DATE_SUB(NOW(),INTERVAL 3 MONTH);</li>
<li>一次只删除10000行数据：rows_affected = 0</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>do {</p>
<p> rows_affected = do_query{</p>
<p>“DELETE FROM messages WHERE created &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH)</p>
<p>LIMIT 10000”)</p>
<p>} while rows_affected &gt; 0</p>
<h4 id="分解关联查询"><a href="#分解关联查询" class="headerlink" title="分解关联查询"></a>分解关联查询</h4><ul>
<li><p><strong>将一条关联查询分解成多个独立的单表查询，可以具有如下优势：</strong></p>
</li>
<li><ul>
<li>缓存的效率更高。缓存单表查询的话重复查询的频率会更高<ul>
<li>执行单个查询可以减少锁竞争</li>
<li>持久层分解，应用层关联，可以更容易拆分数据库，提高可伸缩性</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="查询执行的基础"><a href="#查询执行的基础" class="headerlink" title="查询执行的基础"></a>查询执行的基础</h3><ul>
<li><p>客户端向服务器发送请求时的步骤：</p>
</li>
<li><ul>
<li>客户端发送一条查询给服务器<ul>
<li>服务器先检查<strong>查询缓存</strong>，如果命中缓存则立即返回缓存中的结果，否则进入下一阶段</li>
<li>服务器端进行SQL<strong>解析、预处理</strong>，再由<strong>优化器</strong>生成对应的<strong>执行计划</strong></li>
<li>根据执行计划调用存储引擎的API来执行查询</li>
<li>将结果返回给客户端</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1590917863447-22c656bd-a4c5-4b08-8c99-7b39215b5f4f.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><ul>
<li>解析查询语句前MySQL会解析查询是否命中缓存中的数据。检查是通过大小写敏感的哈希查找，即使查询语句有一个字节不同也不会匹配</li>
<li>如果匹配了则检查权限，并直接返回缓存中的结果</li>
<li>如果没有匹配则执行下面的步骤</li>
</ul>
<h4 id="查询优化处理"><a href="#查询优化处理" class="headerlink" title="查询优化处理"></a>查询优化处理</h4><ul>
<li>查询在查询缓存后的下一个生命周期是将SQL转换成一个执行计划，具体步骤包括：<strong>解析SQL、预处理、优化SQL执行计划</strong></li>
</ul>
<h5 id="语法解析器和预处理"><a href="#语法解析器和预处理" class="headerlink" title="语法解析器和预处理"></a>语法解析器和预处理</h5><ul>
<li>解析器根据SQL关键字解析，并生成“解析树”。这个步骤会进行验证和解析查询，例如，验证是否错误的关键字，关键字顺序是否正确</li>
<li>预处理器进一步检查解析树是否合法，例如，查询数据表和数据列是否存在。同时会验证权限。</li>
</ul>
<h5 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h5><ul>
<li><p>优化器将这个合法的语法树转化成执行计划</p>
</li>
<li><p>一条查询语句可以有多种执行方式，返回相同的结果，优化器的作用就是找到其中最好的执行计划</p>
</li>
<li><p>MySQL使用基于成本的优化器，主要是完成查询需要读取数据页的数量。受限于统计信息不准确（MVCC架构），没有考虑并发情况等，最终的执行计划并不一定是最优的</p>
</li>
<li><p>优化策略可以分为两种：</p>
</li>
<li><ul>
<li>静态优化：直接对解析树进行优化，例如通过简单的代数变换将where条件转换成另一种等价形式（下面有例子）<ul>
<li>动态优化：与查询的上下文有关，也可能和很多其他因素有关，例如where条件中的取值、索引中条目对应的数据行数。因为不是固定的优化策略，所以每次查询都要重新评估。</li>
</ul>
</li>
</ul>
</li>
<li><p>MySQL能够处理的优化类型：</p>
</li>
<li><ul>
<li><strong>重新定义关联表的顺序：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>下面会说</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>将外连接转化成内连接：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>有些外连接LEFT OUTER JOIN 可以转换成内连接INNER JOIN，这样就可以调整管关联顺序了</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>优化COUNT()、MIN()、MAX()：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>例如最小值可以直接查询B-Tree最左端记录</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>预估并转换为常数表达式：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>检测到表达式可以转化成常数时会将其当作常数进行优化处理<ul>
<li>此外，有时候一个查询也可以转化为一个常数，例子：</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>EXPLAIN SELECT film.film_id, film_actor.actor_id</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>FROM sakila.film</p>
<p>INNER JOIN sakila.film_actor USING(film_id)</p>
<p>WHERE film.film_id=1;</p>
<ul>
<li><ul>
<li><ul>
<li><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1590914393242-1ebaea4c-d929-4b6a-820e-b21c8c6de7a9.png" alt="image.png"><pre><code>- 上面查询分为两步：
- ①：先从film表找到需要的行，因为film_id字段上有主键索引，所以MySQL知道只会返回一行数据，所以表的访问类型是const
- ②：因为第一步返回的film_id列当作已知取值的列，那么对表film_actor的访问类型也是const</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>覆盖索引扫描：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>索引中的列包含所有查询中需要的列时就可以使用索引返回需要的数据，无须查询对应的数据行</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>子查询优化：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>某些情况下会将子查询转换一种形式，从而减少多个查询多次对数据进行访问的次数</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>提前终止查询：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>发现已经满足查询需求时候会立刻终止查询，比如使用LIMIT的时候，或者发现一个不成立的条件时（SELECT  film.film_id FROM sakila.film WHERE film_id = -1）</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>等值传播：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>如果两个列通过等式关联，那么MySQL能够把其中一个列的WHERE条件传递到另一个列上，例如：</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>SELECT film.film_id</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>FROM sakila.film</p>
<p>INNER JOIN sakila.film_actor USING(film_id)</p>
<p>WHERE film.film_id&gt;500;</p>
<ul>
<li><ul>
<li><ul>
<li><ul>
<li>由于WHERE 子句中的film_id字段同样适用于film_actor表，那么MySQL会优化成下面的形式：<pre><code>- ... WHERE film.film_id &gt; 500 AND film_actor.film_id &gt; 500</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>列表IN()</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>很多数据库系统中，IN()完全等同于多个OR条件的子句，复杂度O(n)。但是MySQL会将IN()中的数据先排序，然后通过二分查找确定IN()中的值是否满足条件，复杂度O(logn)。IN()中有大量取值时，MySQL处理速度会快一定</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="数据和索引的统计信息"><a href="#数据和索引的统计信息" class="headerlink" title="数据和索引的统计信息"></a>数据和索引的统计信息</h5><ul>
<li><p>统计信息由存储引擎实现</p>
</li>
<li><p>查询优化器在生成查询计划时，需要向存储引擎获取相应的统计信息，包括</p>
</li>
<li><ul>
<li>每个表或索引有多少页<ul>
<li>每个表的每个索引的基数是多少（索引选择性）</li>
<li>数据行和索引长度、索引的分布信息等</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="如何执行关联查询"><a href="#如何执行关联查询" class="headerlink" title="如何执行关联查询"></a>如何执行关联查询</h5><ul>
<li><p>MySQL概念中不仅仅是查询需要到两个表才叫关联，，每个查询都是一次关联。</p>
</li>
<li><p>MySQL关联执行的策略：</p>
</li>
<li><ul>
<li>嵌套循环关联：先在一个表中循环取出单条数据，然后再执行嵌套循环到下一个表中匹配的行，依次下去，直到找到所有表中匹配的行。然后根据各表匹配的行，返回查询中需要的各个列。先在最后一个关联表尝试找到所有匹配的行，然后再回溯到上一个表。<ul>
<li>即，循环+嵌套获取所有匹配的行，然后回溯返回数据</li>
</ul>
</li>
</ul>
</li>
<li><p>MySQL多表关联示意图：</p>
</li>
<li><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1590918172760-399cd7a4-0411-4da4-8812-47e69bb74014.png" alt="image.png"></li>
</ul>
</li>
<li><p>MySQL关联查询示例图</p>
</li>
<li><ul>
<li>SQL语句：SELECT tbl1.col1, tbl2.col2 FROM tbl1 INNER JOIN tbl2 USING(col3) WHERE tbl1.col1 IN(5,6);<ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1590917828821-0399668d-00d1-4c66-8d35-70e18754ede5.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="关联查询优化器"><a href="#关联查询优化器" class="headerlink" title="关联查询优化器"></a>关联查询优化器</h5><ul>
<li><p>MySQL优化器最重要的部分就是关联查询优化，多表关联时可以有多种不同的关联顺序来获取相同的结果，关联查询优化器就是通过评估不同顺序时的成本来选择代价最小的关联顺序</p>
</li>
<li><p>例子：</p>
</li>
<li><ul>
<li>SQL语句：SELECT film_id, film.title, film.release_year, actor.actor_id, actor.first_name, actor.last_name</li>
</ul>
</li>
</ul>
<p>FROM sakila.<strong>film</strong></p>
<p>INNER JOIN sakila.<strong>film_actor</strong> USING(film_id)</p>
<p>INNER JOIN sakila.<strong>actor</strong> USING(actor_id);</p>
<ul>
<li><ul>
<li>MySQL没有按照SQL关联的顺序，而是优化了关联顺序，EXPLAIN结果如下：<ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1590918875519-95211bf1-b239-4546-924d-652fd842d47d.png" alt="image.png"></li>
<li>如果让MySQL强行按照SQL顺序执行，在SELECT后加STRAIGHT_JOIN，EXPLAIN结果如下：</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1590919015592-d17f26a1-03b9-416c-966d-b313c527d900.png" alt="image.png"></li>
<li>可以发现修改关联顺序可以减少扫描的行数，让查询进行更少的嵌套循环和回溯操作</li>
<li>如果可以的话，优化器会遍历每一个表然后逐个做嵌套循环计算成本，然后返回最优的执行计划</li>
<li>但是n个表的关联种数是阶乘，所以会使用“启发式”优化策略，并不会遍历计算所有可能的执行计划</li>
<li>（注意：各个查询的顺序不能随意安排，因为后面的表的查询需要依赖于前面表的查询结果。比如左外连接、相关子查询）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h5><ul>
<li><p>MySQL排序规则：</p>
</li>
<li><ul>
<li>当不能使用索引生成排序结果时，MySQL会使用filesort进行排序<ul>
<li><strong>如果数据量小于“排序缓冲区”会在内存中使用快排进行排序。如果数据量大于则会在磁盘中进行排序，先将数据分块，对每个独立的块使用快排，然后将各个块的排序结果存放在磁盘上，然后将各个排好序的块进行合并，最后返回结果</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>MySQL排序算法：</p>
</li>
<li><ul>
<li>两次传输排序：① 读取行指针和需要排序的字段，并对其排序。② 然后根据排序结果读取所需要的数据行<ul>
<li>单次传输排序：① 读取查询需要的所有列，然后根据给定列进行排序，最后直接返回排序结果</li>
<li>两种算法各有优劣</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>两次传输排序：因为排序后再读取数据行，会产生大量的随机I/O<ul>
<li>顺序读取数据行，不会随机I/O，缺点是如果需要返回的列非常多，会额外占用大量的空间，而这些列对排序本身没有帮助</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="查询执行计划"><a href="#查询执行计划" class="headerlink" title="查询执行计划"></a>查询执行计划</h4><ul>
<li>查询执行引擎根据执行计划调用API完成查询</li>
</ul>
<h4 id="返回结果给客户端"><a href="#返回结果给客户端" class="headerlink" title="返回结果给客户端"></a>返回结果给客户端</h4><ul>
<li>将查询结果返回给客户端，如果缓存开启，则将结果存放到查询缓存中</li>
<li>并不是查询彻底完成后才开始返回的，一旦服务器处理完最后一个关联表，开始生成第一条结果时，就开始向客户端逐步返回结果集</li>
<li>好处：服务器端不用存储太多了结果，客户端可以第一时间获得返回的结果</li>
</ul>
<h3 id="几个查询语句的区别"><a href="#几个查询语句的区别" class="headerlink" title="几个查询语句的区别"></a>几个查询语句的区别</h3><h5 id="count-和count-列名-查询"><a href="#count-和count-列名-查询" class="headerlink" title="count(*)和count(列名)查询"></a>count(*)和count(列名)查询</h5><ul>
<li>count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL</li>
<li>count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数，即某个字段值为NULL时，不统计。</li>
</ul>
<h5 id="in和-exists-的区别？"><a href="#in和-exists-的区别？" class="headerlink" title="in和 exists 的区别？"></a>in和 exists 的区别？</h5><ul>
<li>exists：exists对外表用loop逐条查询，每次查询都会查看exists的条件语句，当exists里的条件语句能够返回记录行时（无论记录行是的多少，只要能返回），条件就为真，返回当前loop到的这条记录；反之，如果exists里的条件语句不能返回记录行，则当前loop到的这条记录被丢弃，exists的条件就像一个bool条件，当能返回结果集则为true，不能返回结果集则为false</li>
<li>in：in查询相当于多个or条件的叠加</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> A.id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> B);</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> * <span class="keyword">from</span> B <span class="keyword">WHERE</span> B.id = A.id);</span><br></pre></td></tr></table></figure>

<ul>
<li>如果查询的两个表大小相当，那么用in和exists差别不大</li>
<li>如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in</li>
</ul>
<h5 id="UNION和UNION-ALL的区别"><a href="#UNION和UNION-ALL的区别" class="headerlink" title="UNION和UNION ALL的区别?"></a>UNION和UNION ALL的区别?</h5><p>UNION和UNION ALL都是将两个结果集合并为一个，<strong>两个要联合的SQL语句 字段个数必须一样，而且字段类型要“相容”（一致）；</strong></p>
<ul>
<li>UNION在进行表连接后会筛选掉重复的数据记录（效率较低），而UNION ALL则不会去掉重复的数据记录；</li>
<li>UNION会按照字段的顺序进行排序，而UNION ALL只是简单的将两个结果合并就返回；</li>
</ul>
<h3 id="SQL执行顺序"><a href="#SQL执行顺序" class="headerlink" title="SQL执行顺序"></a>SQL执行顺序</h3><ul>
<li>手写</li>
</ul>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> &lt;select_list&gt;</span><br><span class="line"><span class="keyword">FROM</span>  &lt;left_table&gt; &lt;join_type&gt;</span><br><span class="line"><span class="keyword">JOIN</span>  &lt;right_table&gt; <span class="keyword">ON</span> &lt;join_condition&gt;</span><br><span class="line"><span class="keyword">WHERE</span>  &lt;where_condition&gt;</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span>  &lt;group_by_list&gt;</span><br><span class="line"><span class="keyword">HAVING</span> &lt;having_condition&gt;</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;order_by_condition&gt;</span><br><span class="line"><span class="keyword">LIMIT</span> &lt;limit_number&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>机读</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span>  &lt;left_table&gt;</span><br><span class="line"><span class="keyword">ON</span> &lt;join_condition&gt;</span><br><span class="line">&lt;join_type&gt; <span class="keyword">JOIN</span>  &lt;right_table&gt;</span><br><span class="line"><span class="keyword">WHERE</span>  &lt;where_condition&gt;</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span>  &lt;group_by_list&gt;</span><br><span class="line"><span class="keyword">HAVING</span> &lt;having_condition&gt;</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">DISTINCT</span> &lt;select_list&gt;</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;order_by_condition&gt;</span><br><span class="line"><span class="keyword">LIMIT</span> &lt;limit_number&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>总结</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539949-2595b2b5-7eac-4a9f-a6ca-016a37625d12.webp" alt="image"></p>
<blockquote>
<p>❝</p>
<p>mysql 的内连接、左连接、右连接有什么区别？</p>
<p>什么是内连接、外连接、交叉连接、笛卡尔积呢？</p>
</blockquote>
<h3 id="Join图"><a href="#Join图" class="headerlink" title="Join图"></a>Join图</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539969-2ac4a686-05ba-4792-baa4-251a6c5bd854.webp?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<h2 id="八、MySQL调优"><a href="#八、MySQL调优" class="headerlink" title="八、MySQL调优"></a>八、MySQL调优</h2><blockquote>
<p>❝</p>
<p>日常工作中你是怎么优化SQL的？</p>
<p>SQL优化的一般步骤是什么，怎么看执行计划（explain），如何理解其中各个字段的含义？</p>
<p>如何写sql能够有效的使用到复合索引？</p>
<p>一条sql执行过长的时间，你如何优化，从哪些方面入手？</p>
<p>什么是最左前缀原则？什么是最左匹配原则？</p>
</blockquote>
<h3 id="影响mysql的性能因素"><a href="#影响mysql的性能因素" class="headerlink" title="影响mysql的性能因素"></a>影响mysql的性能因素</h3><ul>
<li><p>业务需求对MySQL的影响(合适合度)</p>
</li>
<li><p>存储定位对MySQL的影响</p>
</li>
<li><ul>
<li>系统各种配置及规则数据<ul>
<li>活跃用户的基本信息数据</li>
<li>活跃用户的个性化定制信息数据</li>
<li>准实时的统计信息数据</li>
<li>其他一些访问频繁但变更较少的数据</li>
<li>二进制多媒体数据</li>
<li>流水队列数据</li>
<li>超大文本数据</li>
<li>不适合放进MySQL的数据</li>
<li>需要放进缓存的数据</li>
</ul>
</li>
</ul>
</li>
<li><p>Schema设计对系统的性能影响</p>
</li>
<li><ul>
<li>尽量减少对数据库访问的请求<ul>
<li>尽量减少无用数据的查询请求</li>
</ul>
</li>
</ul>
</li>
<li><p>硬件环境对系统性能的影响</p>
</li>
</ul>
<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><h4 id="MySQL-Query-Optimizer"><a href="#MySQL-Query-Optimizer" class="headerlink" title="MySQL Query Optimizer"></a>MySQL Query Optimizer</h4><ol>
<li>MySQL 中有专门负责优化 SELECT 语句的优化器模块，主要功能：通过计算分析系统中收集到的统计信息，为客户端请求的 Query 提供他认为最优的执行计划（他认为最优的数据检索方式，但不见得是 DBA 认为是最优的，这部分最耗费时间）</li>
<li>当客户端向 MySQL 请求一条 Query，命令解析器模块完成请求分类，区别出是 SELECT 并转发给 MySQL Query Optimize r时，MySQL Query Optimizer 首先会对整条 Query 进行优化，处理掉一些常量表达式的预算，直接换算成常量值。并对 Query 中的查询条件进行简化和转换，如去掉一些无用或显而易见的条件、结构调整等。然后分析 Query 中的 Hint 信息（如果有），看显示 Hint 信息是否可以完全确定该 Query 的执行计划。如果没有 Hint 或 Hint 信息还不足以完全确定执行计划，则会读取所涉及对象的统计信息，根据 Query 进行写相应的计算分析，然后再得出最后的执行计划。</li>
</ol>
<h4 id="MySQL常见瓶颈"><a href="#MySQL常见瓶颈" class="headerlink" title="MySQL常见瓶颈"></a>MySQL常见瓶颈</h4><ul>
<li>CPU：CPU在饱和的时候一般发生在数据装入内存或从磁盘上读取数据时候</li>
<li>IO：磁盘I/O瓶颈发生在装入数据远大于内存容量的时候</li>
<li>服务器硬件的性能瓶颈：top，free，iostat 和 vmstat来查看系统的性能状态</li>
</ul>
<h4 id="性能下降SQL慢-执行时间长-等待时间长-原因分析"><a href="#性能下降SQL慢-执行时间长-等待时间长-原因分析" class="headerlink" title="性能下降SQL慢 执行时间长 等待时间长 原因分析"></a>性能下降SQL慢 执行时间长 等待时间长 原因分析</h4><ul>
<li>查询语句写的烂</li>
<li>索引失效（单值、复合）</li>
<li>关联查询太多join（设计缺陷或不得已的需求）</li>
<li>服务器调优及各个参数设置（缓冲、线程数等）</li>
</ul>
<h4 id="MySQL常见性能分析手段"><a href="#MySQL常见性能分析手段" class="headerlink" title="MySQL常见性能分析手段"></a>MySQL常见性能分析手段</h4><p>在优化MySQL时，通常需要对数据库进行分析，常见的分析手段有<strong>慢查询日志</strong>，<strong>EXPLAIN 分析查询</strong>，<strong>profiling分析</strong>以及<strong>show命令查询系统状态及系统变量</strong>，通过定位分析性能的瓶颈，才能更好的优化数据库系统的性能。</p>
<h5 id="性能瓶颈定位"><a href="#性能瓶颈定位" class="headerlink" title="性能瓶颈定位"></a>性能瓶颈定位</h5><p>我们可以通过 show 命令查看 MySQL 状态及变量，找到系统的瓶颈：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Mysql&gt; <span class="keyword">show</span> status ——显示状态信息（扩展<span class="keyword">show</span> status <span class="keyword">like</span> ‘XXX’）</span><br><span class="line">Mysql&gt; <span class="keyword">show</span> variables ——显示系统变量（扩展<span class="keyword">show</span> variables <span class="keyword">like</span> ‘XXX’）</span><br><span class="line">Mysql&gt; <span class="keyword">show</span> innodb status ——显示InnoDB存储引擎的状态</span><br><span class="line">Mysql&gt; <span class="keyword">show</span> processlist ——查看当前<span class="keyword">SQL</span>执行，包括执行状态、是否锁表等</span><br><span class="line">Shell&gt; mysqladmin variables -u username -p <span class="keyword">password</span>——显示系统变量</span><br><span class="line">Shell&gt; mysqladmin extended-status -u username -p <span class="keyword">password</span>——显示状态信息</span><br></pre></td></tr></table></figure>

<h5 id="Explain-执行计划"><a href="#Explain-执行计划" class="headerlink" title="Explain(执行计划)"></a>Explain(执行计划)</h5><p>是什么：使用 <strong>Explain</strong> 关键字可以模拟优化器执行SQL查询语句，从而知道 MySQL 是如何处理你的 SQL 语句的。分析你的查询语句或是表结构的性能瓶颈</p>
<p>能干吗：</p>
<ul>
<li>表的读取顺序</li>
<li>数据读取操作的操作类型</li>
<li>哪些索引可以使用</li>
<li>哪些索引被实际使用</li>
<li>表之间的引用</li>
<li>每张表有多少行被优化器查询</li>
</ul>
<p>怎么玩：</p>
<ul>
<li>Explain + SQL语句</li>
<li>执行计划包含的信息（如果有分区表的话还会有<strong>partitions</strong>）</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539945-f25d6d79-1cb8-42b6-a6fa-b57a1ba9b5c9.webp" alt="image">expalin</p>
<p>各字段解释</p>
<ul>
<li><p><strong>id</strong>（select 查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序）</p>
</li>
<li><ul>
<li>id相同，执行顺序从上往下<ul>
<li>id全不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</li>
<li>id部分相同，执行顺序是先按照数字大的先执行，然后数字相同的按照从上往下的顺序执行</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>select_type</strong>（查询类型，用于区别普通查询、联合查询、子查询等复杂查询）</p>
</li>
<li><ul>
<li><strong>SIMPLE</strong> ：简单的select查询，查询中不包含子查询或UNION<ul>
<li><strong>PRIMARY</strong>：查询中若包含任何复杂的子部分，最外层查询被标记为PRIMARY</li>
<li><strong>SUBQUERY</strong>：在select或where列表中包含了子查询</li>
<li><strong>DERIVED</strong>：在from列表中包含的子查询被标记为DERIVED，MySQL会递归执行这些子查询，把结果放在临时表里</li>
<li><strong>UNION</strong>：若第二个select出现在UNION之后，则被标记为UNION，若UNION包含在from子句的子查询中，外层select将被标记为DERIVED</li>
<li><strong>UNION RESULT</strong>：从UNION表获取结果的select</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>table</strong>（显示这一行的数据是关于哪张表的）</p>
</li>
<li><p><strong>type</strong>（显示查询使用了那种类型，从最好到最差依次排列 <strong>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</strong> ）<br>  tip: 一般来说，得保证查询至少达到range级别，最好到达ref</p>
</li>
<li><ul>
<li>system：表只有一行记录（等于系统表），是 const 类型的特例，平时不会出现<ul>
<li>const：表示通过索引一次就找到了，const 用于比较 primary key 或 unique 索引，因为只要匹配一行数据，所以很快，如将主键置于 where 列表中，mysql 就能将该查询转换为一个常量</li>
<li>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常见于主键或唯一索引扫描</li>
<li>ref：非唯一性索引扫描，范围匹配某个单独值得所有行。本质上也是一种索引访问，他返回所有匹配某个单独值的行，然而，它可能也会找到多个符合条件的行，多以他应该属于查找和扫描的混合体</li>
<li>range：只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引，一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询，这种范围扫描索引比全表扫描要好，因为它只需开始于索引的某一点，而结束于另一点，不用扫描全部索引</li>
<li>index：Full Index Scan，index于ALL区别为index类型只遍历索引树。通常比ALL快，因为索引文件通常比数据文件小。（<strong>也就是说虽然all和index都是读全表，但index是从索引中读取的，而all是从硬盘中读的</strong>）</li>
<li>ALL：Full Table Scan，将遍历全表找到匹配的行</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>possible_keys</strong>（显示可能应用在这张表中的索引，一个或多个，查询涉及到的字段若存在索引，则该索引将被列出，但不一定被查询实际使用）</p>
</li>
<li><p><strong>key</strong></p>
</li>
<li><ul>
<li>实际使用的索引，如果为NULL，则没有使用索引<ul>
<li><strong>查询中若使用了覆盖索引，则该索引和查询的 select 字段重叠，仅出现在key列表中</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539958-bcf79915-a194-4c29-9bb0-f8a828626624.webp" alt="image">explain-key</p>
<ul>
<li><p><strong>key_len</strong></p>
</li>
<li><ul>
<li>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好<ul>
<li>key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>ref</strong>（显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值）</p>
</li>
<li><p><strong>rows</strong>（根据表统计信息及索引选用情况，大致估算找到所需的记录所需要读取的行数）</p>
</li>
<li><p><strong>Extra</strong>（包含不适合在其他列中显示但十分重要的额外信息）</p>
</li>
</ul>
<ol>
<li><ol>
<li>using filesort: 说明mysql会对数据使用一个外部的索引排序，不是按照表内的索引顺序进行读取。mysql中无法利用索引完成的排序操作称为“文件排序”。常见于order by和group by语句中<ol start="2">
<li>Using temporary：使用了临时表保存中间结果，mysql在对查询结果排序时使用临时表。常见于排序order by和分组查询group by。</li>
<li>using index：表示相应的select操作中使用了覆盖索引，避免访问了表的数据行，效率不错，如果同时出现using where，表明索引被用来执行索引键值的查找；否则索引被用来读取数据而非执行查找操作</li>
<li>using where：使用了where过滤</li>
<li>using join buffer：使用了连接缓存</li>
<li>impossible where：where子句的值总是false，不能用来获取任何元祖</li>
<li>select tables optimized away：在没有group by子句的情况下，基于索引优化操作或对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化</li>
<li>distinct：优化distinct操作，在找到第一匹配的元祖后即停止找同样值的动作</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><strong>case</strong>:</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539975-a8ae7858-047b-4816-a2d7-c5b3cab09fab.webp" alt="image">explain-demo</p>
<ol>
<li>第一行（执行顺序4）：id列为1，表示是union里的第一个select，select_type列的primary表示该查询为外层查询，table列被标记为，表示查询结果来自一个衍生表，其中derived3中3代表该查询衍生自第三个select查询，即id为3的select。【select d1.name……】</li>
<li>第二行（执行顺序2）：id为3，是整个查询中第三个select的一部分。因查询包含在from中，所以为derived。【select id,name from t1 where other_column=’’】</li>
<li>第三行（执行顺序3）：select列表中的子查询select_type为subquery，为整个查询中的第二个select。【select id from t3】</li>
<li>第四行（执行顺序1）：select_type为union，说明第四个select是union里的第二个select，最先执行【select name,id from t2】</li>
<li>第五行（执行顺序5）：代表从union的临时表中读取行的阶段，table列的&lt;union1,4&gt;表示用第一个和第四个select的结果进行union操作。【两个结果union操作】</li>
</ol>
<h5 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h5><p>MySQL 的慢查询日志是 MySQL 提供的一种日志记录，它用来记录在 MySQL 中响应时间超过阈值的语句，具体指运行时间超过 <code>long_query_time</code> 值的 SQL，则会被记录到慢查询日志中。</p>
<ul>
<li><code>long_query_time</code> 的默认值为10，意思是运行10秒以上的语句</li>
<li>默认情况下，MySQL数据库没有开启慢查询日志，需要手动设置参数开启</li>
</ul>
<p><strong>查看开启状态</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">&#x27;%slow_query_log%&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>开启慢查询日志</strong></p>
<ul>
<li>临时配置：</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="builtin-name">set</span> global <span class="attribute">slow_query_log</span>=<span class="string">&#x27;ON&#x27;</span>;</span><br><span class="line">mysql&gt; <span class="builtin-name">set</span> global <span class="attribute">slow_query_log_file</span>=<span class="string">&#x27;/var/lib/mysql/hostname-slow.log&#x27;</span>;</span><br><span class="line">mysql&gt; <span class="builtin-name">set</span> global <span class="attribute">long_query_time</span>=2;</span><br></pre></td></tr></table></figure>

<p>也可set文件位置，系统会默认给一个缺省文件host_name-slow.log</p>
<p>使用set操作开启慢查询日志只对当前数据库生效，如果MySQL重启则会失效。</p>
<ul>
<li>永久配置<br>  修改配置文件my.cnf或my.ini，在[mysqld]一行下面加入两个配置参数</li>
</ul>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">slow_query_log</span> = <span class="literal">ON</span></span><br><span class="line"><span class="attr">slow_query_log_file</span> = /var/lib/mysql/hostname-slow.log</span><br><span class="line"><span class="attr">long_query_time</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>注：log-slow-queries 参数为慢查询日志存放的位置，一般这个目录要有 MySQL 的运行帐号的可写权限，一般都将这个目录设置为 MySQL 的数据存放目录；long_query_time=2 中的 2 表示查询超过两秒才记录；在my.cnf或者 my.ini 中添加 log-queries-not-using-indexes 参数，表示记录下没有使用索引的查询。</p>
<p>可以用 <code>select sleep(4)</code> 验证是否成功开启。</p>
<p>在生产环境中，如果手工分析日志，查找、分析SQL，还是比较费劲的，所以MySQL提供了日志分析工具<strong>mysqldumpslow</strong>。</p>
<p>通过 mysqldumpslow –help 查看操作帮助信息</p>
<ul>
<li>得到返回记录集最多的10个SQL<br>  <code>mysqldumpslow -s r -t 10 /var/lib/mysql/hostname-slow.log</code></li>
<li>得到访问次数最多的10个SQL<br>  <code>mysqldumpslow -s c -t 10 /var/lib/mysql/hostname-slow.log</code></li>
<li>得到按照时间排序的前10条里面含有左连接的查询语句<br>  <code>mysqldumpslow -s t -t 10 -g &quot;left join&quot; /var/lib/mysql/hostname-slow.log</code></li>
<li>也可以和管道配合使用<br>  <code>mysqldumpslow -s r -t 10 /var/lib/mysql/hostname-slow.log | more</code></li>
</ul>
<p><strong>也可使用 pt-query-digest 分析 RDS MySQL 慢查询日志</strong></p>
<h5 id="Show-Profile-分析查询"><a href="#Show-Profile-分析查询" class="headerlink" title="Show Profile 分析查询"></a>Show Profile 分析查询</h5><p>通过慢日志查询可以知道哪些 SQL 语句执行效率低下，通过 explain 我们可以得知 SQL 语句的具体执行情况，索引使用等，还可以结合<code>Show Profile</code>命令查看执行状态。</p>
<ul>
<li><p>Show Profile 是 MySQL 提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于SQL的调优的测量</p>
</li>
<li><p>默认情况下，参数处于关闭状态，并保存最近15次的运行结果</p>
</li>
<li><p>分析步骤<br>  mysql&gt; show profiles; +———-+————+———————————+ | Query_ID | Duration  | Query              | +———-+————+———————————+ |     1 | 0.00385450 | show variables like “profiling” | |     2 | 0.00170050 | show variables like “profiling” | |     3 | 0.00038025 | select * from t_base_user    | +———-+————+———————————+</p>
</li>
<li><ul>
<li>converting HEAP to MyISAM 查询结果太大，内存都不够用了往磁盘上搬了。<ul>
<li>create tmp table 创建临时表，这个要注意</li>
<li>Copying to tmp table on disk  把内存临时表复制到磁盘</li>
<li>locked</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li><ol>
<li>诊断SQL，show profile cpu,block io for query  id(上一步前面的问题SQL数字号码)<ol start="2">
<li>日常开发需要注意的结论</li>
<li>是否支持，看看当前的mysql版本是否支持</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;Show  <span class="keyword">variables</span> like <span class="comment">&#x27;profiling&#x27;</span>;  --默认是关闭，使用前需要开启</span><br></pre></td></tr></table></figure>

<ol>
<li><ol>
<li>开启功能，默认是关闭，使用前需要开启</li>
</ol>
</li>
</ol>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;<span class="builtin-name">set</span> <span class="attribute">profiling</span>=1;</span><br></pre></td></tr></table></figure>

<ol>
<li><ol>
<li>运行SQL<ol start="2">
<li>查看结果</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>❝查询中哪些情况不会使用索引？</p>
</blockquote>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><h4 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h4><ol>
<li>全值匹配我最爱</li>
<li>最佳左前缀法则，比如建立了一个联合索引(a,b,c)，那么其实我们可利用的索引就有(a), (a,b), (a,b,c)</li>
<li>不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描</li>
<li>存储引擎不能使用索引中范围条件右边的列</li>
<li>尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致))，减少select</li>
<li>is null ,is not null 也无法使用索引</li>
<li>like “xxxx%” 是可以用到索引的，like “%xxxx” 则不行(like “%xxx%” 同理)。like以通配符开头(‘%abc…’)索引失效会变成全表扫描的操作，</li>
<li>字符串不加单引号索引失效</li>
<li>少用or，用它来连接时会索引失效</li>
<li>&lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN 可用到索引，&lt;&gt;，not in ，!= 则不行，会导致全表扫描</li>
</ol>
<p><strong>一般性建议</strong></p>
<ul>
<li>对于单键索引，尽量选择针对当前query过滤性更好的索引</li>
<li>在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。</li>
<li>在选择组合索引的时候，尽量选择可以能够包含当前query中的where字句中更多字段的索引</li>
<li>尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的</li>
<li>少用Hint强制索引</li>
</ul>
<h4 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h4><p><strong>永远小表驱动大表（小的数据集驱动大的数据集）</strong></p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slect * <span class="keyword">from</span> A <span class="keyword">where</span> <span class="built_in">id</span> <span class="keyword">in</span> (select <span class="built_in">id</span> <span class="keyword">from</span> B)`等价于</span><br><span class="line"><span class="comment">#等价于</span></span><br><span class="line">select <span class="built_in">id</span> <span class="keyword">from</span> B</span><br><span class="line">select * <span class="keyword">from</span> A <span class="keyword">where</span> A.<span class="built_in">id</span>=B.<span class="built_in">id</span></span><br></pre></td></tr></table></figure>

<p>当 B 表的数据集必须小于 A 表的数据集时，用 in 优于 exists</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> B <span class="keyword">where</span> B.id=A.id)</span><br><span class="line"><span class="comment">#等价于</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> B <span class="keyword">where</span> B.id = A.id<span class="string">`</span></span><br></pre></td></tr></table></figure>

<p>当 A 表的数据集小于B表的数据集时，用 exists优于用 in</p>
<p>注意：A表与B表的ID字段应建立索引。</p>
<p><strong>order by关键字优化</strong></p>
<ul>
<li><p>order by子句，尽量使用 Index 方式排序，避免使用 FileSort 方式排序</p>
</li>
<li><p>MySQL 支持两种方式的排序，FileSort 和 Index，Index效率高，它指 MySQL 扫描索引本身完成排序，FileSort 效率较低；</p>
</li>
<li><p>ORDER BY 满足两种情况，会使用Index方式排序；①ORDER BY语句使用索引最左前列 ②使用where子句与ORDER BY子句条件列组合满足索引最左前列</p>
</li>
<li><p>尽可能在索引列上完成排序操作，遵照索引建的最佳最前缀</p>
</li>
<li><p>如果不在索引列上，filesort 有两种算法，mysql就要启动双路排序和单路排序</p>
</li>
<li><ul>
<li>双路排序：MySQL 4.1之前是使用双路排序,字面意思就是两次扫描磁盘，最终得到数据<ul>
<li>单路排序：从磁盘读取查询需要的所有列，按照order by 列在 buffer对它们进行排序，然后扫描排序后的列表进行输出，效率高于双路排序</li>
</ul>
</li>
</ul>
</li>
<li><p>优化策略</p>
</li>
<li><ul>
<li>增大sort_buffer_size参数的设置<ul>
<li>增大max_lencth_for_sort_data参数的设置</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>GROUP BY关键字优化</strong></p>
<ul>
<li>group by实质是先排序后进行分组，遵照索引建的最佳左前缀</li>
<li>当无法使用索引列，增大 <code>max_length_for_sort_data</code> 参数的设置，增大<code>sort_buffer_size</code>参数的设置</li>
<li>where高于having，能写在where限定的条件就不要去having限定了</li>
</ul>
<h4 id="数据类型优化"><a href="#数据类型优化" class="headerlink" title="数据类型优化"></a>数据类型优化</h4><p>MySQL 支持的数据类型非常多，选择正确的数据类型对于获取高性能至关重要。不管存储哪种类型的数据，下面几个简单的原则都有助于做出更好的选择。</p>
<ul>
<li>更小的通常更好：一般情况下，应该尽量使用可以正确存储数据的最小数据类型。<br>  简单就好：简单的数据类型通常需要更少的CPU周期。例如，整数比字符操作代价更低，因为字符集和校对规则（排序规则）使字符比较比整型比较复杂。</li>
<li>尽量避免NULL：通常情况下最好指定列为NOT NULL</li>
</ul>
<h2 id="九、分区、分表、分库"><a href="#九、分区、分表、分库" class="headerlink" title="九、分区、分表、分库"></a>九、分区、分表、分库</h2><h3 id="MySQL分区"><a href="#MySQL分区" class="headerlink" title="MySQL分区"></a>MySQL分区</h3><p>一般情况下我们创建的表对应一组存储文件，使用<code>MyISAM</code>存储引擎时是一个<code>.MYI</code>和<code>.MYD</code>文件，使用<code>Innodb</code>存储引擎时是一个<code>.ibd</code>和<code>.frm</code>（表结构）文件。</p>
<p>当数据量较大时（一般千万条记录级别以上），MySQL的性能就会开始下降，这时我们就需要将数据分散到多组存储文件，保证其单个文件的执行效率</p>
<p><strong>能干嘛</strong></p>
<ul>
<li>逻辑数据分割</li>
<li>提高单一的写和读应用速度</li>
<li>提高分区范围读查询的速度</li>
<li>分割数据能够有多个不同的物理文件路径</li>
<li>高效的保存历史数据</li>
</ul>
<p><strong>怎么玩</strong></p>
<p>首先查看当前数据库是否支持分区</p>
<ul>
<li>MySQL5.6以及之前版本：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">&#x27;%partition%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>MySQL5.6：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> plugins;</span><br></pre></td></tr></table></figure>

<p><strong>分区类型及操作</strong></p>
<ul>
<li><strong>RANGE分区</strong>：基于属于一个给定连续区间的列值，把多行分配给分区。mysql将会根据指定的拆分策略，,把数据放在不同的表文件上。相当于在文件上,被拆成了小块.但是,对外给客户的感觉还是一张表，透明的。<br>  按照 range 来分，就是每个库一段连续的数据，这个一般是按比如<strong>时间范围</strong>来的，比如交易表啊，销售表啊等，可以根据年月来存放数据。可能会产生热点问题，大量的流量都打在最新的数据上了。<br>  range 来分，好处在于说，扩容的时候很简单。</li>
<li><strong>LIST分区</strong>：类似于按RANGE分区，每个分区必须明确定义。它们的主要区别在于，LIST分区中每个分区的定义和选择是基于某列的值从属于一个值列表集中的一个值，而RANGE分区是从属于一个连续区间值的集合。</li>
<li><strong>HASH分区</strong>：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL 中有效的、产生非负整数值的任何表达式。<br>  hash 分发，好处在于说，可以平均分配每个库的数据量和请求压力；坏处在于说扩容起来比较麻烦，会有一个数据迁移的过程，之前的数据需要重新计算 hash 值重新分配到不同的库或表</li>
<li><strong>KEY分区</strong>：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL服务器提供其自身的哈希函数。必须有一列或多列包含整数值。</li>
</ul>
<p><strong>看上去分区表很帅气，为什么大部分互联网还是更多的选择自己分库分表来水平扩展咧？</strong></p>
<ul>
<li>分区表，分区键设计不太灵活，如果不走分区键，很容易出现全表锁</li>
<li>一旦数据并发量上来，如果在分区表实施关联，就是一个灾难</li>
<li>自己分库分表，自己掌控业务场景与访问模式，可控。分区表，研发写了一个sql，都不确定mysql是怎么玩的，不太可控</li>
</ul>
<blockquote>
<p>❝</p>
<p>随着业务的发展，业务越来越复杂，应用的模块越来越多，总的数据量很大，高并发读写操作均超过单个数据库服务器的处理能力怎么办？</p>
</blockquote>
<p>这个时候就出现了<strong>数据分片</strong>，数据分片指按照某个维度将存放在单一数据库中的数据分散地存放至多个数据库或表中。数据分片的有效手段就是对关系型数据库进行分库和分表。</p>
<p>区别于分区的是，分区一般都是放在单机里的，用的比较多的是时间范围分区，方便归档。只不过分库分表需要代码实现，分区则是mysql内部实现。分库分表和分区并不冲突，可以结合使用。</p>
<blockquote>
<p>❝</p>
<p>说说分库与分表的设计</p>
</blockquote>
<h3 id="MySQL分表"><a href="#MySQL分表" class="headerlink" title="MySQL分表"></a>MySQL分表</h3><p>分表有两种分割方式，一种垂直拆分，另一种水平拆分。</p>
<ul>
<li><p><strong>垂直拆分</strong><br>  垂直分表，通常是按照业务功能的使用频次，把主要的、热门的字段放在一起做为主要表。然后把不常用的，按照各自的业务属性进行聚集，拆分到不同的次要表中；主要表和次要表的关系一般都是一对一的。</p>
</li>
<li><p><strong>水平拆分(数据分片)</strong><br>  单表的容量不超过500W，否则建议水平拆分。是把一个表复制成同样表结构的不同表，然后把数据按照一定的规则划分，分别存储到这些表中，从而保证单表的容量不会太大，提升性能；当然这些结构一样的表，可以放在一个或多个数据库中。<br>  水平分割的几种方法：</p>
</li>
<li><ul>
<li>使用MD5哈希，做法是对UID进行md5加密，然后取前几位（我们这里取前两位），然后就可以将不同的UID哈希到不同的用户表（user_xx）中了。<ul>
<li>还可根据时间放入不同的表，比如：article_201601，article_201602。</li>
<li>按热度拆分，高点击率的词条生成各自的一张表，低热度的词条都放在一张大表里，待低热度的词条达到一定的贴数后，再把低热度的表单独拆分成一张表。</li>
<li>根据ID的值放入对应的表，第一个表user_0000，第二个100万的用户数据放在第二 个表user_0001中，随用户增加，直接添加用户表就行了。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539957-9e85fd78-eebe-4644-a408-80ff3dfc87cd.webp?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<h3 id="MySQL分库"><a href="#MySQL分库" class="headerlink" title="MySQL分库"></a>MySQL分库</h3><blockquote>
<p>❝为什么要分库?</p>
</blockquote>
<p>数据库集群环境后都是多台 slave，基本满足了读取操作;  但是写入或者说大数据、频繁的写入操作对master性能影响就比较大，这个时候，单库并不能解决大规模并发写入的问题，所以就会考虑分库。</p>
<blockquote>
<p>❝分库是什么？</p>
</blockquote>
<p>一个库里表太多了，导致了海量数据，系统性能下降，把原本存储于一个库的表拆分存储到多个库上， 通常是将表按照功能模块、关系密切程度划分出来，部署到不同库上。</p>
<p>优点：</p>
<ul>
<li>减少增量数据写入时的锁对查询的影响</li>
<li>由于单表数量下降，常见的查询操作由于减少了需要扫描的记录，使得单表单次查询所需的检索行数变少，减少了磁盘IO，时延变短</li>
</ul>
<p>但是它无法解决单表数据量太大的问题</p>
<p><strong>分库分表后的难题</strong></p>
<p>分布式事务的问题，数据的完整性和一致性问题。</p>
<p>数据操作维度问题：用户、交易、订单各个不同的维度，用户查询维度、产品数据分析维度的不同对比分析角度。跨库联合查询的问题，可能需要两次查询 跨节点的count、order by、group by以及聚合函数问题，可能需要分别在各个节点上得到结果后在应用程序端进行合并 额外的数据管理负担，如：访问数据表的导航定位 额外的数据运算压力，如：需要在多个节点执行，然后再合并计算程序编码开发难度提升，没有太好的框架解决，更多依赖业务看如何分，如何合，是个难题。</p>
<blockquote>
<p>❝配主从，正经公司的话，也不会让 Javaer 去搞的，但还是要知道</p>
</blockquote>
<h2 id="十、主从复制"><a href="#十、主从复制" class="headerlink" title="十、主从复制"></a>十、主从复制</h2><h3 id="复制的基本原理"><a href="#复制的基本原理" class="headerlink" title="复制的基本原理"></a>复制的基本原理</h3><ul>
<li>slave 会从 master 读取 binlog 来进行数据同步</li>
<li>三个步骤<br>  <img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590540019-3b79bd00-05a5-47a9-a4bb-c594e451c33c.webp?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image">img</li>
</ul>
<ol>
<li><ol>
<li>master将改变记录到二进制日志（binary log）。这些记录过程叫做二进制日志事件，binary log events；<ol start="2">
<li>salve 将 master 的 binary log events 拷贝到它的中继日志（relay log）;</li>
<li>slave 重做中继日志中的事件，将改变应用到自己的数据库中。MySQL 复制是异步且是串行化的。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="复制的基本原则"><a href="#复制的基本原则" class="headerlink" title="复制的基本原则"></a>复制的基本原则</h3><ul>
<li>每个 slave只有一个 master</li>
<li>每个 salve只能有一个唯一的服务器 ID</li>
<li>每个master可以有多个salve</li>
</ul>
<h3 id="复制的最大问题"><a href="#复制的最大问题" class="headerlink" title="复制的最大问题"></a>复制的最大问题</h3><ul>
<li>延时</li>
</ul>
<h2 id="十一、其他问题"><a href="#十一、其他问题" class="headerlink" title="十一、其他问题"></a>十一、其他问题</h2><h3 id="说一说三个范式"><a href="#说一说三个范式" class="headerlink" title="说一说三个范式"></a>说一说三个范式</h3><ul>
<li>第一范式（1NF）：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。</li>
<li>第二范式（2NF）：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。</li>
<li>第三范式（3NF）：在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。所谓传递函数依赖，指的是如 果存在”A → B → C”的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系：关键字段 → 非关键字段 x → 非关键字段y</li>
</ul>
<h3 id="百万级别或以上的数据如何删除"><a href="#百万级别或以上的数据如何删除" class="headerlink" title="百万级别或以上的数据如何删除"></a>百万级别或以上的数据如何删除</h3><p>关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。</p>
<ol>
<li>所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）</li>
<li>然后删除其中无用数据（此过程需要不到两分钟）</li>
<li>删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。</li>
<li>与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。</li>
</ol>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>阶段汇总集合：<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzIyNDU2ODA4OQ==&mid=2247486073&idx=2&sn=a26a44e561a468d94be99761ab5fc1fc&chksm=e80dbc0fdf7a3519999f1fdf0ee5b98b12a519c539f3ede9152ef66e4a3fb6a7f771cc2db382&scene=21#wechat_redirect">001期~180期汇总，方便阅读（增加设计模式）</a></p>
<p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/10/java4-1602932967.png" alt="Redis 常见面试题（2020最新版）"></p>
<h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><h3 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h3><p>Redis(Remote Dictionary Server) 是一个使用 C 语言编写的，开源的（BSD许可）高性能非关系型（NoSQL）的键值对数据库。</p>
<p>Redis 可以存储键和五种不同类型的值之间的映射。键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。</p>
<p>与传统数据库不同的是 Redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存方向，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。另外，Redis 也经常用来做分布式锁。除此之外，Redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。</p>
<h3 id="Redis有哪些优缺点"><a href="#Redis有哪些优缺点" class="headerlink" title="Redis有哪些优缺点"></a>Redis有哪些优缺点</h3><ul>
<li><p>优点</p>
<ul>
<li>读写性能优异， Redis能读的速度是110000次/s，写的速度是81000次/s。</li>
<li>支持数据持久化，支持AOF和RDB两种持久化方式。</li>
<li>支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。</li>
<li>数据结构丰富，除了支持string类型的value外还支持hash、set、zset、list等数据结构。</li>
<li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</li>
<li>Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。</li>
<li>主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。</li>
<li>Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。</li>
</ul>
</li>
</ul>
<h3 id="为什么要用-Redis-为什么要用缓存"><a href="#为什么要用-Redis-为什么要用缓存" class="headerlink" title="为什么要用 Redis /为什么要用缓存"></a>为什么要用 Redis /为什么要用缓存</h3><p>主要从“高性能”和“高并发”这两点来看待这个问题。</p>
<h4 id="高性能："><a href="#高性能：" class="headerlink" title="高性能："></a>高性能：</h4><p>假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p>
<p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/10/java6-1602932967.png" alt="Redis 常见面试题（2020最新版）">img</p>
<h4 id="高并发："><a href="#高并发：" class="headerlink" title="高并发："></a>高并发：</h4><p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p>
<p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/10/java0-1602932967.png" alt="Redis 常见面试题（2020最新版）">img</p>
<h3 id="为什么要用-Redis-而不用-map-guava-做缓存"><a href="#为什么要用-Redis-而不用-map-guava-做缓存" class="headerlink" title="为什么要用 Redis 而不用 map/guava 做缓存?"></a>为什么要用 Redis 而不用 map/guava 做缓存?</h3><p>缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。</p>
<p>使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 或 memcached服务的高可用，整个程序架构上较为复杂。</p>
<h3 id="Redis为什么这么快"><a href="#Redis为什么这么快" class="headerlink" title="Redis为什么这么快"></a>Redis为什么这么快</h3><p>1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)；</p>
<p>2、数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的；</p>
<p>3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</p>
<p>4、使用多路 I/O 复用模型，非阻塞 IO；</p>
<p>5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="Redis有哪些数据类型"><a href="#Redis有哪些数据类型" class="headerlink" title="Redis有哪些数据类型"></a>Redis有哪些数据类型</h3><p>Redis主要有5种数据类型，包括String，List，Set，Zset，Hash，满足大部分的使用要求</p>
<p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/10/java3-1602932967.png" alt="Redis 常见面试题（2020最新版）"></p>
<h3 id="Redis的应用场景"><a href="#Redis的应用场景" class="headerlink" title="Redis的应用场景"></a>Redis的应用场景</h3><h3 id="总结一"><a href="#总结一" class="headerlink" title="总结一"></a>总结一</h3><ul>
<li>计数器</li>
</ul>
<p>可以对 String 进行自增自减运算，从而实现计数器功能。Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。</p>
<ul>
<li>缓存</li>
</ul>
<p>将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。</p>
<ul>
<li>会话缓存</li>
</ul>
<p>可以使用 Redis 来统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。</p>
<ul>
<li>全页缓存（FPC）</li>
</ul>
<p>除基本的会话token之外，Redis还提供很简便的FPC平台。以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</p>
<ul>
<li>查找表</li>
</ul>
<p>例如 DNS 记录就很适合使用 Redis 进行存储。查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。</p>
<ul>
<li>消息队列(发布/订阅功能)</li>
</ul>
<p>List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息。不过最好使用 Kafka、RabbitMQ 等消息中间件。</p>
<ul>
<li>分布式锁实现</li>
</ul>
<p>在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。</p>
<ul>
<li>其它</li>
</ul>
<p>Set 可以实现交集、并集等操作，从而实现共同好友等功能。ZSet 可以实现有序性操作，从而实现排行榜等功能。</p>
<h4 id="总结二"><a href="#总结二" class="headerlink" title="总结二"></a>总结二</h4><p>Redis相比其他缓存，有一个非常大的优势，就是支持多种数据类型。</p>
<p>数据类型说明string字符串，最简单的k-v存储hashhash格式，value为field和value，适合ID-Detail这样的场景。list简单的list，顺序列表，支持首位或者末尾插入数据set无序list，查找速度快，适合交集、并集、差集处理sorted set有序的set</p>
<p>其实，通过上面的数据类型的特性，基本就能想到合适的应用场景了。</p>
<p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/10/java8-1602932967.png" alt="Redis 常见面试题（2020最新版）"></p>
<p>如上所述，虽然Redis不像关系数据库那么复杂的数据结构，但是，也能适合很多场景，比一般的缓存数据结构要多。了解每种数据结构适合的业务场景，不仅有利于提升开发效率，也能有效利用Redis的性能。</p>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h3 id="什么是Redis持久化？"><a href="#什么是Redis持久化？" class="headerlink" title="什么是Redis持久化？"></a>什么是Redis持久化？</h3><p>持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。</p>
<h3 id="Redis-的持久化机制是什么？各自的优缺点？"><a href="#Redis-的持久化机制是什么？各自的优缺点？" class="headerlink" title="Redis 的持久化机制是什么？各自的优缺点？"></a>Redis 的持久化机制是什么？各自的优缺点？</h3><p>Redis 提供两种持久化机制 RDB（默认） 和 AOF 机制:</p>
<p><strong>RDB：是Redis DataBase缩写快照</strong></p>
<p>RDB是Redis默认的持久化方式。按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为dump.rdb。通过配置文件中的save参数来定义快照的周期。</p>
<p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/10/java0-1602932967-1.png" alt="Redis 常见面试题（2020最新版）">img</p>
<p>优点：</p>
<ul>
<li>1、只有一个文件 dump.rdb，方便持久化。</li>
<li>2、容灾性好，一个文件可以保存到安全的磁盘。</li>
<li>3、性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能</li>
<li>4.相对于数据集大时，比 AOF 的启动效率更高。</li>
</ul>
<p>缺点：</p>
<ul>
<li>1、数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候)</li>
<li>2、AOF（Append-only file)持久化方式：是指所有的命令行记录以 redis 命令请 求协议的格式完全持久化存储)保存为 aof 文件。</li>
</ul>
<p><strong>AOF：持久化</strong></p>
<p>AOF持久化(即Append Only File持久化)，则是将Redis执行的每次写命令记录到单独的日志文件中，当重启Redis会重新将持久化的日志中文件恢复数据。</p>
<p>当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。</p>
<p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/10/java6-1602932967-1.png" alt="Redis 常见面试题（2020最新版）">img</p>
<p>优点：</p>
<ul>
<li>1、数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次。</li>
<li>2、通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。</li>
<li>3、AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）)</li>
</ul>
<p>缺点：</p>
<ul>
<li>1、AOF 文件比 RDB 文件大，且恢复速度慢。</li>
<li>2、数据集大的时候，比 rdb 启动效率低。</li>
</ul>
<p>优缺点是什么？</p>
<ul>
<li>AOF文件比RDB更新频率高，优先使用AOF还原数据。</li>
<li>AOF比RDB更安全也更大</li>
<li>RDB性能比AOF好</li>
<li>如果两个都配了优先加载AOF</li>
</ul>
<h3 id="如何选择合适的持久化方式"><a href="#如何选择合适的持久化方式" class="headerlink" title="如何选择合适的持久化方式"></a>如何选择合适的持久化方式</h3><ul>
<li>一般来说， 如果想达到足以媲美PostgreSQL的数据安全性，你应该同时使用两种持久化功能。在这种情况下，当 Redis 重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</li>
<li>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以只使用RDB持久化。</li>
<li>有很多用户都只使用AOF持久化，但并不推荐这种方式，因为定时生成RDB快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比AOF恢复的速度要快，除此之外，使用RDB还可以避免AOF程序的bug。</li>
<li>如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式。</li>
</ul>
<h3 id="Redis持久化数据和缓存怎么做扩容？"><a href="#Redis持久化数据和缓存怎么做扩容？" class="headerlink" title="Redis持久化数据和缓存怎么做扩容？"></a>Redis持久化数据和缓存怎么做扩容？</h3><ul>
<li>如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。</li>
<li>如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。</li>
</ul>
<p>搜索公众号 Java面试题精选，回复“面试资料”，送你一份Java面试宝典.pdf</p>
<h2 id="过期键的删除策略"><a href="#过期键的删除策略" class="headerlink" title="过期键的删除策略"></a>过期键的删除策略</h2><h3 id="Redis的过期键的删除策略"><a href="#Redis的过期键的删除策略" class="headerlink" title="Redis的过期键的删除策略"></a>Redis的过期键的删除策略</h3><p>我们都知道，Redis是key-value数据库，我们可以设置Redis中缓存的key的过期时间。Redis的过期策略就是指当Redis中缓存的key过期了，Redis如何处理。</p>
<p>过期策略通常有以下三种：</p>
<ul>
<li>定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</li>
<li>惰性过期：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</li>
<li>定期过期：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。<br>  (expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。)</li>
</ul>
<p>Redis中同时使用了惰性过期和定期过期两种过期策略。</p>
<h3 id="Redis-key的过期时间和永久有效分别怎么设置？"><a href="#Redis-key的过期时间和永久有效分别怎么设置？" class="headerlink" title="Redis key的过期时间和永久有效分别怎么设置？"></a>Redis key的过期时间和永久有效分别怎么设置？</h3><p>EXPIRE和PERSIST命令。</p>
<h3 id="我们知道通过expire来设置key-的过期时间，那么对过期的数据怎么处理呢"><a href="#我们知道通过expire来设置key-的过期时间，那么对过期的数据怎么处理呢" class="headerlink" title="我们知道通过expire来设置key 的过期时间，那么对过期的数据怎么处理呢?"></a>我们知道通过expire来设置key 的过期时间，那么对过期的数据怎么处理呢?</h3><p>除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：</p>
<ol>
<li>定时去清理过期的缓存；</li>
<li>当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</li>
</ol>
<p>两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。</p>
<h2 id="内存相关"><a href="#内存相关" class="headerlink" title="内存相关"></a>内存相关</h2><h3 id="MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"><a href="#MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据" class="headerlink" title="MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"></a>MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据</h3><p>redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。</p>
<h3 id="Redis的内存淘汰策略有哪些"><a href="#Redis的内存淘汰策略有哪些" class="headerlink" title="Redis的内存淘汰策略有哪些"></a>Redis的内存淘汰策略有哪些</h3><p>Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。</p>
<p>全局的键空间选择性移除</p>
<ul>
<li>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。</li>
<li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。（这个是最常用的）</li>
<li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。</li>
</ul>
<p>设置过期时间的键空间选择性移除</p>
<ul>
<li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。</li>
<li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。</li>
<li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。</li>
</ul>
<p><strong>总结</strong></p>
<p>Redis的内存淘汰策略的选取并不会影响过期的key的处理。内存淘汰策略用于处理内存不足时的需要申请额外空间的数据；过期策略用于处理过期的缓存数据。</p>
<h3 id="Redis主要消耗什么物理资源？"><a href="#Redis主要消耗什么物理资源？" class="headerlink" title="Redis主要消耗什么物理资源？"></a>Redis主要消耗什么物理资源？</h3><p>内存。</p>
<h3 id="Redis的内存用完了会发生什么？"><a href="#Redis的内存用完了会发生什么？" class="headerlink" title="Redis的内存用完了会发生什么？"></a>Redis的内存用完了会发生什么？</h3><p>如果达到设置的上限，Redis的写命令会返回错误信息（但是读命令还可以正常返回。）或者你可以配置内存淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容。</p>
<h3 id="Redis如何做内存优化？"><a href="#Redis如何做内存优化？" class="headerlink" title="Redis如何做内存优化？"></a>Redis如何做内存优化？</h3><p>可以好好利用Hash,list,sorted set,set等集合类型数据，因为通常情况下很多小的Key-Value可以用更紧凑的方式存放到一起。尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key，而是应该把这个用户的所有信息存储到一张散列表里面</p>
<h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><h3 id="Redis线程模型"><a href="#Redis线程模型" class="headerlink" title="Redis线程模型"></a>Redis线程模型</h3><p>Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处理器（file event handler）。它的组成结构为4部分：多个套接字、IO多路复用程序、文件事件分派器、事件处理器。因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型。</p>
<ul>
<li>文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li>
<li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li>
</ul>
<p>虽然文件事件处理器以单线程方式运行， 但通过使用 I/O 多路复用程序来监听多个套接字， 文件事件处理器既实现了高性能的网络通信模型， 又可以很好地与 redis 服务器中其他同样以单线程方式运行的模块进行对接， 这保持了 Redis 内部单线程设计的简单性。</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h3><p>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
<p>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p>
<h3 id="Redis事务的概念"><a href="#Redis事务的概念" class="headerlink" title="Redis事务的概念"></a>Redis事务的概念</h3><p>Redis 事务的本质是通过MULTI、EXEC、WATCH等一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p>
<p>总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</p>
<p>搜索公众号 Java面试题精选，回复“面试资料”，送你一份Java面试宝典.pdf</p>
<h3 id="Redis事务的三个阶段"><a href="#Redis事务的三个阶段" class="headerlink" title="Redis事务的三个阶段"></a>Redis事务的三个阶段</h3><ol>
<li>事务开始 MULTI</li>
<li>命令入队</li>
<li>事务执行 EXEC</li>
</ol>
<p>事务执行过程中，如果服务端收到有EXEC、DISCARD、WATCH、MULTI之外的请求，将会把请求放入队列中排</p>
<h3 id="事务管理（ACID）概述"><a href="#事务管理（ACID）概述" class="headerlink" title="事务管理（ACID）概述"></a>事务管理（ACID）概述</h3><ul>
<li>原子性（Atomicity）</li>
</ul>
<p>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</p>
<ul>
<li>一致性（Consistency）</li>
</ul>
<p>事务前后数据的完整性必须保持一致。</p>
<ul>
<li>隔离性（Isolation）</li>
</ul>
<p>多个事务并发执行时，一个事务的执行不应影响其他事务的执行</p>
<ul>
<li>持久性（Durability）</li>
</ul>
<p>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响</p>
<p>Redis的事务总是具有ACID中的一致性和隔离性，其他特性是不支持的。当服务器运行在_AOF_持久化模式下，并且appendfsync选项的值为always时，事务也具有耐久性。</p>
<h3 id="Redis事务支持隔离性吗"><a href="#Redis事务支持隔离性吗" class="headerlink" title="Redis事务支持隔离性吗"></a>Redis事务支持隔离性吗</h3><p>Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，Redis 的事务是总是带有隔离性的。</p>
<h3 id="Redis事务保证原子性吗，支持回滚吗"><a href="#Redis事务保证原子性吗，支持回滚吗" class="headerlink" title="Redis事务保证原子性吗，支持回滚吗"></a>Redis事务保证原子性吗，支持回滚吗</h3><p>Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。</p>
<h3 id="Redis事务其他实现"><a href="#Redis事务其他实现" class="headerlink" title="Redis事务其他实现"></a>Redis事务其他实现</h3><ul>
<li>基于Lua脚本，Redis可以保证脚本内的命令一次性、按顺序地执行，<br>  其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完</li>
<li>基于中间标记变量，通过另外的标记变量来标识事务是否执行完成，读取数据时先读取该标记变量判断是否事务执行完成。但这样会需要额外写代码实现，比较繁琐</li>
</ul>
<h2 id="集群方案"><a href="#集群方案" class="headerlink" title="集群方案"></a>集群方案</h2><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/10/java7-1602932968.png" alt="Redis 常见面试题（2020最新版）"></p>
<p>哨兵的介绍</p>
<p>sentinel，中文名是哨兵。哨兵是 redis 集群机构中非常重要的一个组件，主要有以下功能：</p>
<ul>
<li>集群监控：负责监控 redis master 和 slave 进程是否正常工作。</li>
<li>消息通知：如果某个 redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</li>
<li>故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。</li>
<li>配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。</li>
</ul>
<p>哨兵用于实现 redis 集群的高可用，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。</p>
<ul>
<li>故障转移时，判断一个 master node 是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举的问题。</li>
<li>即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成部分的故障转移系统本身是单点的，那就很坑爹了。</li>
</ul>
<p>哨兵的核心知识</p>
<ul>
<li>哨兵至少需要 3 个实例，来保证自己的健壮性。</li>
<li>哨兵 + redis 主从的部署架构，是不保证数据零丢失的，只能保证 redis 集群的高可用性。</li>
<li>对于哨兵 + redis 主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。</li>
</ul>
<h3 id="官方Redis-Cluster-方案-服务端路由查询"><a href="#官方Redis-Cluster-方案-服务端路由查询" class="headerlink" title="官方Redis Cluster 方案(服务端路由查询)"></a>官方Redis Cluster 方案(服务端路由查询)</h3><p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/10/java9-1602932968.png" alt="Redis 常见面试题（2020最新版）"></p>
<p>redis 集群模式的工作原理能说一下么？在集群模式下，redis 的 key 是如何寻址的？分布式寻址都有哪些算法？了解一致性 hash 算法吗？</p>
<p><strong>简介</strong></p>
<p>Redis Cluster是一种服务端Sharding技术，3.0版本开始正式提供。Redis Cluster并没有使用一致性hash，而是采用slot(槽)的概念，一共分成16384个槽。将请求发送到任意节点，接收到请求的节点会将查询请求发送到正确的节点上执行</p>
<p><strong>方案说明</strong></p>
<ol>
<li>通过哈希的方式，将数据分片，每个节点均分存储一定哈希槽(哈希值)区间的数据，默认分配了16384 个槽位</li>
<li>每份数据分片会存储在多个互为主从的多节点上</li>
<li>数据写入先写主节点，再同步到从节点(支持配置为阻塞同步)</li>
<li>同一分片多个节点间的数据不保持一致性</li>
<li>读取数据时，当客户端操作的key没有分配在该节点上时，redis会返回转向指令，指向正确的节点</li>
<li>扩容时时需要需要把旧节点的数据迁移一部分到新节点</li>
</ol>
<p>在 redis cluster 架构下，每个 redis 要放开两个端口号，比如一个是 6379，另外一个就是 加1w 的端口号，比如 16379。</p>
<p>16379 端口号是用来进行节点间通信的，也就是 cluster bus 的东西，cluster bus 的通信，用来进行故障检测、配置更新、故障转移授权。cluster bus 用了另外一种二进制的协议，<code>gossip</code> 协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。</p>
<p>节点间的内部通信机制</p>
<p>基本通信原理</p>
<p>集群元数据的维护有两种方式：集中式、Gossip 协议。redis cluster 节点间采用 gossip 协议进行通信。</p>
<p>分布式寻址算法</p>
<ul>
<li>hash 算法（大量缓存重建）</li>
<li>一致性 hash 算法（自动缓存迁移）+ 虚拟节点（自动负载均衡）</li>
<li>redis cluster 的 hash slot 算法</li>
</ul>
<p>优点</p>
<ul>
<li>无中心架构，支持动态扩容，对业务透明</li>
<li>具备Sentinel的监控和自动Failover(故障转移)能力</li>
<li>客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可</li>
<li>高性能，客户端直连redis服务，免去了proxy代理的损耗</li>
</ul>
<p>缺点</p>
<ul>
<li>运维也很复杂，数据迁移需要人工干预</li>
<li>只能使用0号数据库</li>
<li>不支持批量操作(pipeline管道操作)</li>
<li>分布式逻辑和存储模块耦合等</li>
</ul>
<h3 id="基于客户端分配"><a href="#基于客户端分配" class="headerlink" title="基于客户端分配"></a>基于客户端分配</h3><p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/10/java0-1602932968.jpeg" alt="Redis 常见面试题（2020最新版）"></p>
<p><strong>简介</strong></p>
<p>Redis Sharding是Redis Cluster出来之前，业界普遍使用的多Redis实例集群方法。其主要思想是采用哈希算法将Redis数据的key进行散列，通过hash函数，特定的key会映射到特定的Redis节点上。Java redis客户端驱动jedis，支持Redis Sharding功能，即ShardedJedis以及结合缓存池的ShardedJedisPool</p>
<p>优点</p>
<ul>
<li>优势在于非常简单，服务端的Redis实例彼此独立，相互无关联，每个Redis实例像单服务器一样运行，非常容易线性扩展，系统的灵活性很强</li>
</ul>
<p>缺点</p>
<ul>
<li>由于sharding处理放到客户端，规模进一步扩大时给运维带来挑战。</li>
<li>客户端sharding不支持动态增删节点。服务端Redis实例群拓扑结构有变化时，每个客户端都需要更新调整。连接不能共享，当应用规模增大时，资源浪费制约优化</li>
</ul>
<h3 id="基于代理服务器分片"><a href="#基于代理服务器分片" class="headerlink" title="基于代理服务器分片"></a>基于代理服务器分片</h3><p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/10/java5-1602932968.jpeg" alt="Redis 常见面试题（2020最新版）"></p>
<p><strong>简介</strong></p>
<p>客户端发送请求到一个代理组件，代理解析客户端的数据，并将请求转发至正确的节点，最后将结果回复给客户端</p>
<p><strong>特征</strong></p>
<ul>
<li>透明接入，业务程序不用关心后端Redis实例，切换成本低</li>
<li>Proxy 的逻辑和存储的逻辑是隔离的</li>
<li>代理层多了一次转发，性能有所损耗</li>
</ul>
<p><strong>业界开源方案</strong></p>
<ul>
<li>Twtter开源的Twemproxy</li>
<li>豌豆荚开源的Codis</li>
</ul>
<h3 id="Redis-主从架构"><a href="#Redis-主从架构" class="headerlink" title="Redis 主从架构"></a>Redis 主从架构</h3><p>单机的 redis，能够承载的 QPS 大概就在上万到几万不等。对于缓存来说，一般都是用来支撑读高并发的。因此架构做成主从(master-slave)架构，一主多从，主负责写，并且将数据复制到其它的 slave 节点，从节点负责读。所有的读请求全部走从节点。这样也可以很轻松实现水平扩容，支撑读高并发。</p>
<p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/10/java1-1602932968.png" alt="Redis 常见面试题（2020最新版）">redis-master-slave</p>
<p>redis replication -&gt; 主从架构 -&gt; 读写分离 -&gt; 水平扩容支撑读高并发</p>
<p>redis replication 的核心机制</p>
<ul>
<li>redis 采用异步方式复制数据到 slave 节点，不过 redis2.8 开始，slave node 会周期性地确认自己每次复制的数据量；</li>
<li>一个 master node 是可以配置多个 slave node 的；</li>
<li>slave node 也可以连接其他的 slave node；</li>
<li>slave node 做复制的时候，不会 block master node 的正常工作；</li>
<li>slave node 在做复制的时候，也不会 block 对自己的查询操作，它会用旧的数据集来提供服务；但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了；</li>
<li>slave node 主要用来进行横向扩容，做读写分离，扩容的 slave node 可以提高读的吞吐量。</li>
</ul>
<p>注意，如果采用了主从架构，那么建议必须开启 master node 的持久化，不建议用 slave node 作为 master node 的数据热备，因为那样的话，如果你关掉 master 的持久化，可能在 master 宕机重启的时候数据是空的，然后可能一经过复制， slave node 的数据也丢了。</p>
<p>另外，master 的各种备份方案，也需要做。万一本地的所有文件丢失了，从备份中挑选一份 rdb 去恢复 master，这样才能确保启动的时候，是有数据的，即使采用了后续讲解的高可用机制，slave node 可以自动接管 master node，但也可能 sentinel 还没检测到 master failure，master node 就自动重启了，还是可能导致上面所有的 slave node 数据被清空。</p>
<p>往期面试题汇总：<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzIyNDU2ODA4OQ==&mid=2247485351&idx=2&sn=214225ab4345f4d9c562900cb42a52ba&chksm=e80db1d1df7a38c741137246bf020a5f8970f74cd03530ccc4cb2258c1ced68e66e600e9e059&scene=21#wechat_redirect">001期~150期汇总</a></p>
<h4 id="redis-主从复制的核心原理"><a href="#redis-主从复制的核心原理" class="headerlink" title="redis 主从复制的核心原理"></a>redis 主从复制的核心原理</h4><p>当启动一个 slave node 的时候，它会发送一个 <code>PSYNC</code> 命令给 master node。</p>
<p>如果这是 slave node 初次连接到 master node，那么会触发一次 <code>full resynchronization</code> 全量复制。此时 master 会启动一个后台线程，开始生成一份 <code>RDB</code> 快照文件，</p>
<p>同时还会将从客户端 client 新收到的所有写命令缓存在内存中。<code>RDB</code> 文件生成完毕后， master 会将这个 <code>RDB</code> 发送给 slave，slave 会先写入本地磁盘，然后再从本地磁盘加载到内存中，</p>
<p>接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。</p>
<p>slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。</p>
<p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/10/java6-1602932968.png" alt="Redis 常见面试题（2020最新版）">redis-master-slave-replication</p>
<h4 id="过程原理"><a href="#过程原理" class="headerlink" title="过程原理"></a>过程原理</h4><ol>
<li>当从库和主库建立MS关系后，会向主数据库发送SYNC命令</li>
<li>主库接收到SYNC命令后会开始在后台保存快照(RDB持久化过程)，并将期间接收到的写命令缓存起来</li>
<li>当快照完成后，主Redis会将快照文件和所有缓存的写命令发送给从Redis</li>
<li>从Redis接收到后，会载入快照文件并且执行收到的缓存的命令</li>
<li>之后，主Redis每当接收到写命令时就会将命令发送从Redis，从而保证数据的一致</li>
</ol>
<p>缺点</p>
<ul>
<li>所有的slave节点数据的复制和同步都由master节点来处理，会照成master节点压力太大，使用主从从结构来解决</li>
</ul>
<h3 id="Redis集群的主从复制模型是怎样的？"><a href="#Redis集群的主从复制模型是怎样的？" class="headerlink" title="Redis集群的主从复制模型是怎样的？"></a>Redis集群的主从复制模型是怎样的？</h3><p>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型，每个节点都会有N-1个复制品</p>
<h3 id="生产环境中的-redis-是怎么部署的？"><a href="#生产环境中的-redis-是怎么部署的？" class="headerlink" title="生产环境中的 redis 是怎么部署的？"></a>生产环境中的 redis 是怎么部署的？</h3><p>redis cluster，10 台机器，5 台机器部署了 redis 主实例，另外 5 台机器部署了 redis 的从实例，每个主实例挂了一个从实例，5 个节点对外提供读写服务，每个节点的读写高峰qps可能可以达到每秒 5 万，5 台机器最多是 25 万读写请求/s。</p>
<p>机器是什么配置？32G 内存+ 8 核 CPU + 1T 磁盘，但是分配给 redis 进程的是10g内存，一般线上生产环境，redis 的内存尽量不要超过 10g，超过 10g 可能会有问题。</p>
<p>5 台机器对外提供读写，一共有 50g 内存。</p>
<p>因为每个主实例都挂了一个从实例，所以是高可用的，任何一个主实例宕机，都会自动故障迁移，redis 从实例会自动变成主实例继续提供读写服务。</p>
<p>你往内存里写的是什么数据？每条数据的大小是多少？商品数据，每条数据是 10kb。100 条数据是 1mb，10 万条数据是 1g。常驻内存的是 200 万条商品数据，占用内存是 20g，仅仅不到总内存的 50%。目前高峰期每秒就是 3500 左右的请求量。</p>
<p>其实大型的公司，会有基础架构的 team 负责缓存集群的运维。</p>
<h3 id="说说Redis哈希槽的概念？"><a href="#说说Redis哈希槽的概念？" class="headerlink" title="说说Redis哈希槽的概念？"></a>说说Redis哈希槽的概念？</h3><p>Redis集群没有使用一致性hash,而是引入了哈希槽的概念，Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。</p>
<h3 id="Redis集群会有写操作丢失吗？为什么？"><a href="#Redis集群会有写操作丢失吗？为什么？" class="headerlink" title="Redis集群会有写操作丢失吗？为什么？"></a>Redis集群会有写操作丢失吗？为什么？</h3><p>Redis并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。</p>
<h3 id="Redis集群之间是如何复制的？"><a href="#Redis集群之间是如何复制的？" class="headerlink" title="Redis集群之间是如何复制的？"></a>Redis集群之间是如何复制的？</h3><p>异步复制</p>
<h3 id="Redis集群最大节点个数是多少？"><a href="#Redis集群最大节点个数是多少？" class="headerlink" title="Redis集群最大节点个数是多少？"></a>Redis集群最大节点个数是多少？</h3><p>16384个</p>
<h3 id="Redis集群如何选择数据库？"><a href="#Redis集群如何选择数据库？" class="headerlink" title="Redis集群如何选择数据库？"></a>Redis集群如何选择数据库？</h3><p>Redis集群目前无法做数据库选择，默认在0数据库。</p>
<h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><h3 id="Redis是单线程的，如何提高多核CPU的利用率？"><a href="#Redis是单线程的，如何提高多核CPU的利用率？" class="headerlink" title="Redis是单线程的，如何提高多核CPU的利用率？"></a>Redis是单线程的，如何提高多核CPU的利用率？</h3><p>可以在同一个服务器部署多个Redis的实例，并把他们当作不同的服务器来使用，在某些时候，无论如何一个服务器是不够的， 所以，如果你想使用多个CPU，你可以考虑一下分片（shard）。</p>
<h3 id="为什么要做Redis分区？"><a href="#为什么要做Redis分区？" class="headerlink" title="为什么要做Redis分区？"></a>为什么要做Redis分区？</h3><p>分区可以让Redis管理更大的内存，Redis将可以使用所有机器的内存。如果没有分区，你最多只能使用一台机器的内存。分区使Redis的计算能力通过简单地增加计算机得到成倍提升，Redis的网络带宽也会随着计算机和网卡的增加而成倍增长。</p>
<h3 id="你知道有哪些Redis分区实现方案？"><a href="#你知道有哪些Redis分区实现方案？" class="headerlink" title="你知道有哪些Redis分区实现方案？"></a>你知道有哪些Redis分区实现方案？</h3><ul>
<li>客户端分区就是在客户端就已经决定数据会被存储到哪个redis节点或者从哪个redis节点读取。大多数客户端已经实现了客户端分区。</li>
<li>代理分区 意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。代理根据分区规则决定请求哪些Redis实例，然后根据Redis的响应结果返回给客户端。redis和memcached的一种代理实现就是Twemproxy</li>
<li>查询路由(Query routing) 的意思是客户端随机地请求任意一个redis实例，然后由Redis将请求转发给正确的Redis节点。Redis Cluster实现了一种混合形式的查询路由，但并不是直接将请求从一个redis节点转发到另一个redis节点，而是在客户端的帮助下直接redirected到正确的redis节点。</li>
</ul>
<h3 id="Redis分区有什么缺点？"><a href="#Redis分区有什么缺点？" class="headerlink" title="Redis分区有什么缺点？"></a>Redis分区有什么缺点？</h3><ul>
<li>涉及多个key的操作通常不会被支持。例如你不能对两个集合求交集，因为他们可能被存储到不同的Redis实例（实际上这种情况也有办法，但是不能直接使用交集指令）。</li>
<li>同时操作多个key,则不能使用Redis事务.</li>
<li>分区使用的粒度是key，不能使用一个非常长的排序key存储一个数据集（The partitioning granularity is the key, so it is not possible to shard a dataset with a single huge key like a very big sorted set）</li>
<li>当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的Redis实例和主机同时收集RDB / AOF文件。</li>
<li>分区时动态扩容或缩容可能非常复杂。Redis集群在运行时增加或者删除Redis节点，能做到最大程度对用户透明地数据再平衡，但其他一些客户端分区或者代理分区方法则不支持这种特性。然而，有一种预分片的技术也可以较好的解决这个问题。</li>
</ul>
<h2 id="分布式问题"><a href="#分布式问题" class="headerlink" title="分布式问题"></a>分布式问题</h2><h3 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h3><p>Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系Redis中可以使用SETNX命令实现分布式锁。</p>
<p>当且仅当 key 不存在，将 key 的值设为 value。若给定的 key 已经存在，则 SETNX 不做任何动作</p>
<p>SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。</p>
<p>返回值：设置成功，返回 1 。设置失败，返回 0 。</p>
<p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/10/java10-1602932968.png" alt="Redis 常见面试题（2020最新版）">img</p>
<p>使用SETNX完成同步锁的流程及事项如下：</p>
<p>使用SETNX命令获取锁，若返回0（key已存在，锁已存在）则获取失败，反之获取成功</p>
<p>为了防止获取锁后程序出现异常，导致其他线程/进程调用SETNX命令总是返回0而进入死锁状态，需要为该key设置一个“合理”的过期时间</p>
<p>释放锁，使用DEL命令将锁数据删除</p>
<h3 id="如何解决-Redis-的并发竞争-Key-问题"><a href="#如何解决-Redis-的并发竞争-Key-问题" class="headerlink" title="如何解决 Redis 的并发竞争 Key 问题"></a>如何解决 Redis 的并发竞争 Key 问题</h3><p>所谓 Redis 的并发竞争 Key 的问题也就是多个系统同时对一个 key 进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同！</p>
<p>推荐一种方案：分布式锁（zookeeper 和 redis 都可以实现分布式锁）。（如果不存在 Redis 的并发竞争 Key 问题，不要使用分布式锁，这样会影响性能）</p>
<p>基于zookeeper临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。</p>
<p>在实践中，当然是从以可靠性为主。所以首推Zookeeper。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8bddd381de06">https://www.jianshu.com/p/8bddd381de06</a></p>
<h3 id="分布式Redis是前期做还是后期规模上来了再做好？为什么？"><a href="#分布式Redis是前期做还是后期规模上来了再做好？为什么？" class="headerlink" title="分布式Redis是前期做还是后期规模上来了再做好？为什么？"></a>分布式Redis是前期做还是后期规模上来了再做好？为什么？</h3><p>既然Redis是如此的轻量（单实例只使用1M内存），为防止以后的扩容，最好的办法就是一开始就启动较多实例。即便你只有一台服务器，你也可以一开始就让Redis以分布式的方式运行，使用分区，在同一台服务器上启动多个实例。</p>
<p>一开始就多设置几个Redis实例，例如32或者64个实例，对大多数用户来说这操作起来可能比较麻烦，但是从长久来看做这点牺牲是值得的。</p>
<p>这样的话，当你的数据不断增长，需要更多的Redis服务器时，你需要做的就是仅仅将Redis实例从一台服务迁移到另外一台服务器而已（而不用考虑重新分区的问题）。一旦你添加了另一台服务器，你需要将你一半的Redis实例从第一台机器迁移到第二台机器。</p>
<h3 id="什么是-RedLock"><a href="#什么是-RedLock" class="headerlink" title="什么是 RedLock"></a>什么是 RedLock</h3><p>Redis 官方站提出了一种权威的基于 Redis 实现分布式锁的方式名叫 <em>Redlock</em>，此种方式比原先的单节点的方法更安全。它可以保证以下特性：</p>
<ol>
<li>安全特性：互斥访问，即永远只有一个 client 能拿到锁</li>
<li>避免死锁：最终 client 都可能拿到锁，不会出现死锁的情况，即使原本锁住某资源的 client crash 了或者出现了网络分区</li>
<li>容错性：只要大部分 Redis 节点存活就可以正常提供服务</li>
</ol>
<p>往期面试题汇总：<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzIyNDU2ODA4OQ==&mid=2247485351&idx=2&sn=214225ab4345f4d9c562900cb42a52ba&chksm=e80db1d1df7a38c741137246bf020a5f8970f74cd03530ccc4cb2258c1ced68e66e600e9e059&scene=21#wechat_redirect">001期~150期汇总</a></p>
<h2 id="缓存异常"><a href="#缓存异常" class="headerlink" title="缓存异常"></a>缓存异常</h2><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩是指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p>解决方案</p>
<ol>
<li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li>
<li>一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。</li>
<li>给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存。</li>
</ol>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p>解决方案</p>
<ol>
<li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截；</li>
<li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</li>
<li>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力</li>
</ol>
<h3 id="附加"><a href="#附加" class="headerlink" title="附加"></a>附加</h3><p>对于空间的利用到达了一种极致，那就是Bitmap和布隆过滤器(Bloom Filter)。</p>
<p>Bitmap：典型的就是哈希表</p>
<p>缺点是，Bitmap对于每个元素只能记录1bit信息，如果还想完成额外的功能，恐怕只能靠牺牲更多的空间、时间来完成了。</p>
<p><strong>布隆过滤器（推荐）</strong></p>
<p>就是引入了k(k&gt;1)k(k&gt;1)个相互独立的哈希函数，保证在给定的空间、误判率下，完成元素判重的过程。</p>
<p>它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p>
<p>Bloom-Filter算法的核心思想就是利用多个不同的Hash函数来解决“冲突”。</p>
<p>Hash存在一个冲突（碰撞）的问题，用同一个Hash得到的两个URL的值有可能相同。为了减少冲突，我们可以多引入几个Hash，如果通过其中的一个Hash值我们得出某元素不在集合中，那么该元素肯定不在集合中。只有在所有的Hash函数告诉我们该元素在集合中时，才能确定该元素存在于集合中。这便是Bloom-Filter的基本思想。</p>
<p>Bloom-Filter一般用于在大数据量的集合中判定某元素是否存在。</p>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p>
<p>解决方案</p>
<ol>
<li>设置热点数据永远不过期。</li>
<li>加互斥锁，互斥锁</li>
</ol>
<h3 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h3><p>缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p>
<p>解决方案</p>
<ol>
<li>直接写个缓存刷新页面，上线时手工操作一下；</li>
<li>数据量不大，可以在项目启动的时候自动进行加载；</li>
<li>定时刷新缓存；</li>
</ol>
<h3 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h3><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p>
<p>缓存降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p>
<p>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p>
<ol>
<li>一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</li>
<li>警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</li>
<li>错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</li>
<li>严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</li>
</ol>
<p>服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。</p>
<h3 id="热点数据和冷数据"><a href="#热点数据和冷数据" class="headerlink" title="热点数据和冷数据"></a>热点数据和冷数据</h3><p>热点数据，缓存才有价值</p>
<p>对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。频繁修改的数据，看情况考虑使用缓存</p>
<p>对于热点数据，比如我们的某IM产品，生日祝福模块，当天的寿星列表，缓存以后可能读取数十万次。再举个例子，某导航产品，我们将导航信息，缓存以后可能读取数百万次。</p>
<p>数据更新前至少读取两次，缓存才有意义。这个是最基本的策略，如果缓存还没有起作用就失效了，那就没有太大价值了。</p>
<p>那存不存在，修改频率很高，但是又不得不考虑缓存的场景呢？有！比如，这个读取接口对数据库的压力很大，但是又是热点数据，这个时候就需要考虑通过缓存手段，减少数据库的压力，比如我们的某助手产品的，点赞数，收藏数，分享数等是非常典型的热点数据，但是又不断变化，此时就需要将数据同步保存到Redis缓存，减少数据库压力。</p>
<h3 id="缓存热点key"><a href="#缓存热点key" class="headerlink" title="缓存热点key"></a>缓存热点key</h3><p>缓存中的一个Key(比如一个促销商品)，在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p>
<p><strong>解决方案</strong></p>
<p>对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入DB查询</p>
<h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h2><h3 id="Redis支持的Java客户端都有哪些？官方推荐用哪个？"><a href="#Redis支持的Java客户端都有哪些？官方推荐用哪个？" class="headerlink" title="Redis支持的Java客户端都有哪些？官方推荐用哪个？"></a>Redis支持的Java客户端都有哪些？官方推荐用哪个？</h3><p>Redisson、Jedis、lettuce等等，官方推荐使用Redisson。</p>
<h3 id="Redis和Redisson有什么关系？"><a href="#Redis和Redisson有什么关系？" class="headerlink" title="Redis和Redisson有什么关系？"></a>Redis和Redisson有什么关系？</h3><p>Redisson是一个高级的分布式协调Redis客服端，能帮助用户在分布式环境中轻松实现一些Java的对象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish / Subscribe, HyperLogLog)。</p>
<h3 id="Jedis与Redisson对比有什么优缺点？"><a href="#Jedis与Redisson对比有什么优缺点？" class="headerlink" title="Jedis与Redisson对比有什么优缺点？"></a>Jedis与Redisson对比有什么优缺点？</h3><p>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p>
<h3 id="Redis与Memcached的区别"><a href="#Redis与Memcached的区别" class="headerlink" title="Redis与Memcached的区别"></a>Redis与Memcached的区别</h3><p>两者都是非关系型内存键值数据库，现在公司一般都是用 Redis 来实现缓存，而且 Redis 自身也越来越强大了！Redis 与 Memcached 主要有以下不同：</p>
<p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/10/java2-1602932968.png" alt="Redis 常见面试题（2020最新版）"></p>
<p>(1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型</p>
<p>(2) redis的速度比memcached快很多</p>
<p>(3) redis可以持久化其数据</p>
<h3 id="如何保证缓存与数据库双写时的数据一致性？"><a href="#如何保证缓存与数据库双写时的数据一致性？" class="headerlink" title="如何保证缓存与数据库双写时的数据一致性？"></a>如何保证缓存与数据库双写时的数据一致性？</h3><p>你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？</p>
<p>一般来说，就是如果你的系统不是严格要求缓存+数据库必须一致性的话，缓存可以稍微的跟数据库偶尔有不一致的情况，最好不要做这个方案，读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况</p>
<p>串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。</p>
<p>还有一种方式就是可能会暂时产生不一致的情况，但是发生的几率特别小，就是<strong>先更新数据库，然后再删除缓存。</strong></p>
<p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/10/java10-1602932968-1.png" alt="Redis 常见面试题（2020最新版）"></p>
<h3 id="Redis常见性能问题和解决方案？"><a href="#Redis常见性能问题和解决方案？" class="headerlink" title="Redis常见性能问题和解决方案？"></a>Redis常见性能问题和解决方案？</h3><ol>
<li>Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化。</li>
<li>如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。</li>
<li>为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内。</li>
<li>尽量避免在压力较大的主库上增加从库</li>
<li>Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。</li>
<li>为了Master的稳定性，主从复制不要用图状结构，用单向链表结构更稳定，即主从关系为：Master&lt;–Slave1&lt;–Slave2&lt;–Slave3…，这样的结构也方便解决单点故障问题，实现Slave对Master的替换，也即，如果Master挂了，可以立马启用Slave1做Master，其他不变。</li>
</ol>
<h3 id="Redis官方为什么不提供Windows版本？"><a href="#Redis官方为什么不提供Windows版本？" class="headerlink" title="Redis官方为什么不提供Windows版本？"></a>Redis官方为什么不提供Windows版本？</h3><p>因为目前Linux版本已经相当稳定，而且用户量很大，无需开发windows版本，反而会带来兼容性等问题。</p>
<h3 id="一个字符串类型的值能存储最大容量是多少？"><a href="#一个字符串类型的值能存储最大容量是多少？" class="headerlink" title="一个字符串类型的值能存储最大容量是多少？"></a>一个字符串类型的值能存储最大容量是多少？</h3><p>512M</p>
<h3 id="Redis如何做大量数据插入？"><a href="#Redis如何做大量数据插入？" class="headerlink" title="Redis如何做大量数据插入？"></a>Redis如何做大量数据插入？</h3><p>Redis2.6开始redis-cli支持一种新的被称之为pipe mode的新模式用于执行大量数据插入工作。</p>
<h3 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><a href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？" class="headerlink" title="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"></a>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？</h3><p>使用keys指令可以扫出指定模式的key列表。</p>
<p>对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？</p>
<p>这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p>
<h3 id="使用Redis做过异步队列吗，是如何实现的"><a href="#使用Redis做过异步队列吗，是如何实现的" class="headerlink" title="使用Redis做过异步队列吗，是如何实现的"></a>使用Redis做过异步队列吗，是如何实现的</h3><p>使用list类型保存数据信息，rpush生产消息，lpop消费消息，当lpop没有消息时，可以sleep一段时间，然后再检查有没有信息，如果不想sleep的话，可以使用blpop, 在没有信息的时候，会一直阻塞，直到信息的到来。redis可以通过pub/sub主题订阅模式实现一个生产者，多个消费者，当然也存在一定的缺点，当消费者下线时，生产的消息会丢失。</p>
<h3 id="Redis如何实现延时队列"><a href="#Redis如何实现延时队列" class="headerlink" title="Redis如何实现延时队列"></a>Redis如何实现延时队列</h3><p>使用sortedset，使用时间戳做score, 消息内容作为key,调用zadd来生产消息，消费者使用zrangbyscore获取n秒之前的数据做轮询处理。</p>
<h3 id="Redis回收进程如何工作的？"><a href="#Redis回收进程如何工作的？" class="headerlink" title="Redis回收进程如何工作的？"></a>Redis回收进程如何工作的？</h3><ol>
<li>一个客户端运行了新的命令，添加了新的数据。</li>
<li>Redis检查内存使用情况，如果大于maxmemory的限制， 则根据设定好的策略进行回收。</li>
<li>一个新的命令被执行，等等。</li>
<li>所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。</li>
</ol>
<p>如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。</p>
<h3 id="Redis回收使用的是什么算法？"><a href="#Redis回收使用的是什么算法？" class="headerlink" title="Redis回收使用的是什么算法？"></a>Redis回收使用的是什么算法？</h3><p>LRU算法</p>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="OSI七层体系结构"><a href="#OSI七层体系结构" class="headerlink" title="OSI七层体系结构"></a>OSI七层体系结构</h2><p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018114733.webp"></p>
<h2 id="中继设备"><a href="#中继设备" class="headerlink" title="中继设备"></a>中继设备</h2><p>* <strong>物理层</strong>中继系统：<strong>转发器</strong>(repeater)。</p>
<p>* <strong>数据链路层</strong>中继系统：<strong>网桥</strong>(bridge)。</p>
<p>* <strong>网络层</strong>中继系统：<strong>路由器</strong>(router)，路由器连接了多个网络，所以至少有2个以上IP地址。</p>
<p>* <strong>网络层以上</strong>的中继系统：**网关(**gateway)。</p>
<h2 id="各层数据"><a href="#各层数据" class="headerlink" title="各层数据"></a><strong>各层数据</strong></h2><p><strong>数据包(packet)：</strong>应用层；</p>
<p><strong>段(segment)：</strong>传输层;</p>
<p><strong>IP数据报(datagram)：</strong>网络层，也有人称IP数据包</p>
<p><strong>数据帧(frame)：</strong>数据链路层；</p>
<h2 id="每一层的协议"><a href="#每一层的协议" class="headerlink" title="每一层的协议"></a>每一层的协议</h2><ul>
<li>物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器，网关）</li>
<li>数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）</li>
<li>网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）</li>
<li>传输层：TCP、UDP、SPX</li>
<li>会话层：NFS、SQL、NETBIOS、RPC</li>
<li>表示层：JPEG、MPEG、ASII</li>
<li>应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS</li>
</ul>
<h2 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h2><blockquote>
<p>TCP/IP模型实际上是OSI模型的一个浓缩版本，它只有四个层次：</p>
</blockquote>
<ol>
<li>应用层，对应着OSI的应用层、表示层、会话层</li>
<li>传输层，对应着OSI的传输层</li>
<li>网络层，对应着OSI的网络层</li>
<li>网络接口层，对应着OSI的数据链路层和物理层</li>
</ol>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p><strong>1 TCP是面向连接的</strong>；</p>
<p><strong>2 每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）；</strong></p>
<p><strong>3 TCP提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达；</strong></p>
<p><strong>4 TCP提供全双工通信。</strong>TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；</p>
<p><strong>5 面向字节流。</strong>TCP中的“流”（stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。</p>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p><strong>1 UDP是无连接的；</strong></p>
<p><strong>2 UDP使用尽最大努力交付</strong>，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）；</p>
<p><strong>3 UDP是面向报文的；</strong></p>
<p><strong>4 UDP没有拥塞控制</strong>，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）；</p>
<p><strong>5 UDP支持一对一、一对多、多对一和多对多的交互通信；</strong></p>
<p><strong>6 UDP的首部开销小，</strong>只有8个字节，比TCP的20个字节的首部要短。</p>
<h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201016094553.png" alt="image"></p>
<p>握手之前主动打开连接的客户端结束CLOSED阶段，被动打开的服务器端也结束CLOSED阶段，并进入LISTEN阶段。随后开始“三次握手”：</p>
<p>（1）首先客户端向服务器端发送一段TCP报文，其中：</p>
<ul>
<li>标记位为SYN，表示“请求建立新连接”;</li>
<li>序号为Seq=X（X一般为1）；</li>
<li>客户端进入SYN-SENT阶段。</li>
</ul>
<p>（2）服务器端接收到来自客户端的TCP报文之后，结束LISTEN阶段。并返回一段TCP报文，其中：</p>
<ul>
<li>标志位为SYN和ACK；</li>
<li>序号为Seq=y；确认号为Ack=x+1；</li>
<li>服务器端进入SYN-RCVD阶段。</li>
</ul>
<p>（3）客户端接收到来自服务器端的确认收到数据的TCP报文之后，明确了从客户端到服务器的数据传输是正常的，结束SYN-SENT阶段。并返回最后一段TCP报文。其中：</p>
<ul>
<li>标志位为ACK；</li>
<li>序号为Seq=x+1，表示收到服务器端的确认号Ack，并将其值作为自己的序号值；</li>
<li>确认号为Ack=y+1，表示收到服务器端序号Seq，并将其值加1作为自己的确认号Ack的值；</li>
<li>随后客户端进入ESTABLISHED阶段。</li>
</ul>
<blockquote>
<p>注意：若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包</p>
</blockquote>
<h3 id="为什么要三次握手？"><a href="#为什么要三次握手？" class="headerlink" title="为什么要三次握手？"></a>为什么要三次握手？</h3><ol>
<li>保持信息对等。</li>
<li>防止请求超时导致脏连接。</li>
</ol>
<h3 id="两次握手会怎样？"><a href="#两次握手会怎样？" class="headerlink" title="两次握手会怎样？"></a>两次握手会怎样？</h3><p>如果两次握手就创建连接，客户端传输完数据并释放连接后，第一个超时的连接请求才到达服务器，服务器会认为是客户端创建新连接的请求，然后创建连接。此时客户端的状态不是SYN_SENT，所以会直接丢弃服务器传来的确认数据，导致最后只是服务器单方面建立了连接。</p>
<h3 id="三次握手时可以携带数据吗？"><a href="#三次握手时可以携带数据吗？" class="headerlink" title="三次握手时可以携带数据吗？"></a>三次握手时可以携带数据吗？</h3><ul>
<li>第三次握手是可以携带数据的，前两次握手是不可以携带数据的</li>
</ul>
<h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201016094655.png" alt="image"></p>
<ul>
<li>第一次挥手：客户端发送一个FIN，seq = u 用来关闭客户端到服务端的数据传送；</li>
<li>第二次挥手：服务端发送一个FIN，确认序号ACK = u+1给对方；</li>
<li>第三次挥手：服务端发送一个FIN，seq = w，确认序号ACK = u+1 用来关闭服务端到客户端的数据传送；</li>
<li>第四次挥手：客户端发送一个ACK = w+1 给服务端。</li>
</ul>
<h4 id="为什么不直接关闭而是进入TIME-WAIT（2MSL）呢？"><a href="#为什么不直接关闭而是进入TIME-WAIT（2MSL）呢？" class="headerlink" title="为什么不直接关闭而是进入TIME_WAIT（2MSL）呢？"></a>为什么不直接关闭而是进入TIME_WAIT（2MSL）呢？</h4><ol>
<li>客户端要确认服务器能收到ACK信号。(如果不确认这一点，服务器会认为客户端没有收到自己的FIN+ACK报文，所以会重发)</li>
<li>防止失效请求。(为了防止已失效的连接的请求数据包和正常的混淆)</li>
</ol>
<h2 id="TCP协议如何保证可靠传输"><a href="#TCP协议如何保证可靠传输" class="headerlink" title="TCP协议如何保证可靠传输"></a>TCP协议如何保证可靠传输</h2><p>1 应用数据被分割成TCP认为最适合发送的数据块。</p>
<p><strong>2 超时重传</strong>： 当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</p>
<p>3 TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</p>
<p><strong>4 校验和：</strong> TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。</p>
<p>5 TCP的接收端会丢弃重复的数据。</p>
<p><strong>6 流量控制：</strong> TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的我数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。 （TCP利用滑动窗口实现流量控制）</p>
<p><strong>7 拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</p>
<p><strong>8 停止等待ARQ协议（stop and wait）</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</p>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><blockquote>
<p>ACK 确认，确认方收到包后的确认报文</p>
<p>拥塞窗口值 cwnd，</p>
<p>ssthresh （slow start threshold）慢启动阈值</p>
<p>MSS (Maximum segment size) 最大分段大小</p>
<p>RTT (round-trip time) 往返时间，来回通信延迟</p>
<p>RTO (retransmission timeout) 重传超时</p>
</blockquote>
<h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h3><ul>
<li>TCP 刚建立连接，逐渐提速试探网络承受能力<br>  1 慢启动初始启动时设置拥塞窗口值（cwnd）为1、2、4或10个MSS<br>  2 cwnd 大小每当收到一个ACK增加，每个 RTT 内成倍增加, 呈指数上升<br>  3 当达到慢启动阈值 ssthresh 时 cwnd &gt;= ssthresh，进入拥塞避免算法-线性增长阶段</li>
</ul>
<h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><ul>
<li>拥塞窗口值 cwnd &gt;= ssthresh 慢启动阈值时，cwnd 进入线性增长阶段</li>
<li>cwnd 大小每当收到一个ACK增加，每个 RTT 只增加 1, 呈线性上升</li>
</ul>
<h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><blockquote>
<p>Tahoe：如果收到三次重复确认——即第四次收到相同确认号的分段确认，并且分段对应包无负载分段和无改变接收窗口——的话，Tahoe算法则进入快速重传，将慢启动阈值改为当前拥塞窗口的一半，将拥塞窗口降为1个MSS，并重新进入慢启动阶段。</p>
</blockquote>
<ul>
<li>设置 ssthresh 为当前 cwnd 的一半</li>
<li>cwnd 变为 1MSS，</li>
<li>重新进入慢启动 - 指数上升再线性上升</li>
<li>对于RTO，将拥塞窗口降为1个MSS，然后进入慢启动阶段</li>
</ul>
<h3 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h3><blockquote>
<p>Reno：如果收到三次重复确认，Reno算法则进入快速重传，只将拥塞窗口减半来跳过慢启动阶段，将慢启动阈值设为当前新的拥塞窗口值，进入一个称为“快速恢复”的新设计阶段。</p>
</blockquote>
<ul>
<li>设置 ssthresh 为当前 cwnd 的一半</li>
<li>cwnd 也设置为 ssthresh 大小</li>
<li>进入拥塞避免阶段 - 线性上升</li>
<li>对于RTO，将拥塞窗口降为1个MSS，然后进入慢启动阶段</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018161850.jpeg" alt="img"></p>
<h3 id="常用端口以及对应服务"><a href="#常用端口以及对应服务" class="headerlink" title="常用端口以及对应服务"></a>常用端口以及对应服务</h3><table>
<thead>
<tr>
<th align="center">常见服务</th>
<th align="center">端口</th>
</tr>
</thead>
<tbody><tr>
<td align="center">HTTP</td>
<td align="center">80</td>
</tr>
<tr>
<td align="center">FTP</td>
<td align="center">21</td>
</tr>
<tr>
<td align="center">DNS</td>
<td align="center">53</td>
</tr>
<tr>
<td align="center">POP3</td>
<td align="center">110</td>
</tr>
<tr>
<td align="center">SMTP</td>
<td align="center">25</td>
</tr>
<tr>
<td align="center">SSH</td>
<td align="center">22</td>
</tr>
<tr>
<td align="center">nginx</td>
<td align="center">80</td>
</tr>
<tr>
<td align="center">MEMCACHED</td>
<td align="center">11211</td>
</tr>
<tr>
<td align="center">MYSQL</td>
<td align="center">3306</td>
</tr>
<tr>
<td align="center">TOMCAT</td>
<td align="center">8080</td>
</tr>
<tr>
<td align="center">NFS</td>
<td align="center">2049</td>
</tr>
<tr>
<td align="center">TLENET</td>
<td align="center">23</td>
</tr>
<tr>
<td align="center">HTTPS</td>
<td align="center">443</td>
</tr>
<tr>
<td align="center">SAMBA</td>
<td align="center">UDP139 TCP139</td>
</tr>
<tr>
<td align="center">POSTFIX</td>
<td align="center">25</td>
</tr>
<tr>
<td align="center">IMAP</td>
<td align="center">143</td>
</tr>
<tr>
<td align="center">ZABBIX</td>
<td align="center">10051</td>
</tr>
<tr>
<td align="center">DHCP</td>
<td align="center">56</td>
</tr>
</tbody></table>
<h3 id="在浏览器中输入网址之后执行会发生什么？"><a href="#在浏览器中输入网址之后执行会发生什么？" class="headerlink" title="在浏览器中输入网址之后执行会发生什么？"></a>在浏览器中输入网址之后执行会发生什么？</h3><ol>
<li><strong>浏览器查找域名的IP地址</strong></li>
</ol>
<blockquote>
<p>1.查找浏览器缓存</p>
<p>2.查找系统缓存</p>
<p>3.查找路由器缓存</p>
<p>4.递归查询：如果以上步骤还找不到，则ISP的DNS服务器就会进行递归查询，所谓递归查询就是如果主机所询问的本地域名服务器不知道被查询域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其他根域名服务器继续发出查询请求报文，而不是让该主机自己进行下一步查询。（本地域名服务器地址是通过DHPC协议获取地址，DHPC是负责分配IP地址的）</p>
<p>5.迭代查询：本地域名服务器采用迭代查询，它先向一个根域名服务器查询。本地域名服务器向根域名服务器的查询一般都是采用迭代查询。所谓迭代查询就是当根域名服务器收到本地域名服务器发出的查询请求报文后，要么告诉本地域名服务器下一步应该查询哪一个域名服务器，然后本地域名服务器自己进行后续的查询。（而不是替代本地域名服务器进行后续查询）。</p>
<p>本例子中：根域名服务器告诉本地域名服务器，下一次应查询的顶级域名服务器dns.net的IP地址。本地域名服务器向顶级域名服务器dns.net进行查询。顶级域名服务器dns.net告诉本地域名服务器，下一次应查询的权限域名服务器dns.csdn.net的IP地址。本地域名服务器向权限域名服务器dns.csdn.net进行查询。权限域名服务器dns.csdn.net告诉本地域名服务器，所查询的主机<a target="_blank" rel="noopener" href="http://www.csdn.net的ip地址.本地域名服务器最后把结果告诉主机./">www.csdn.net的IP地址。本地域名服务器最后把结果告诉主机。</a></p>
</blockquote>
<ol start="2">
<li><strong>浏览器与目标服务器建立TCP连接</strong></li>
</ol>
<ul>
<li>浏览器所在的客户机向服务器发出连接请求报文（SYN标志为1）；服务器接收报文后，同意建立连接，向客户机发出确认报文（SYN，ACK标志位均为1）；客户机接收到确认报文后，再次向服务器发出报文，确认已接收到确认报文；此处客户机与服务器之间的TCP连接建立完成，开始通信。</li>
</ul>
<ol start="3">
<li><p><strong>浏览器通过http协议发送请求</strong></p>
</li>
<li><p><strong>服务器处理请求并返回数据</strong></p>
</li>
<li><p><strong>浏览器接收到数据并渲染页面</strong></p>
</li>
</ol>
<h2 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h2><ul>
<li><p>A类地址：以0开头，第一个字节范围：0~127（1.0.0.0 - 126.255.255.255)；</p>
</li>
<li><p>B类地址：以10开头，第一个字节范围：128~191（128.0.0.0 - 191.255.255.255);</p>
</li>
<li><p>C类地址：以110开头，第一个字节范围：192~223（192.0.0.0 - 223.255.255.255);</p>
</li>
<li><p>内部地址：10.0.0.0—10.255.255.255， 172.16.0.0—172.31.255.255， 192.168.0.0—192.168.255.255。</p>
</li>
</ul>
<h2 id="IP地址与物理地址的区别"><a href="#IP地址与物理地址的区别" class="headerlink" title="IP地址与物理地址的区别"></a>IP地址与物理地址的区别</h2><p>物理地址：数据链路层和物理层使用的地址</p>
<p>IP地址：网络层和以上各层使用的地址，逻辑地址</p>
<p>ARP协议：用于IP地址和MAC地址的对应</p>
<h2 id="GET和POST的区别？"><a href="#GET和POST的区别？" class="headerlink" title="GET和POST的区别？"></a>GET和POST的区别？</h2><h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><ul>
<li>get重点是从服务器上获取资源</li>
<li>get传输数据是通过URL请求，以field（字段） = value的形式，置于URL后，并用“？”连接，多个请求数据间用“&amp;”连接</li>
<li>get传输数据量小，因为受URL长度限制，但是效率高</li>
<li>get是不安全的，因为URL是可见的，可能会泄漏私密信息</li>
<li>get方式只能支持ASCII字符，向服务器传的中文字符可能会乱码</li>
</ul>
<h4 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h4><ul>
<li>post重点是向服务器发送数据。</li>
<li>post传输数据是通过HTTP的post机制。将字段和对应值封存在请求实体中发送给服务器。这个过程用户是不可见的</li>
<li>post可以传输大量数据，所以上传文件时只能用post</li>
<li>post支持标准字符集，可以正确传递中文字符</li>
<li>post 较get安全性高</li>
</ul>
<h2 id="HTTP常见的状态码有哪些？"><a href="#HTTP常见的状态码有哪些？" class="headerlink" title="HTTP常见的状态码有哪些？"></a>HTTP常见的状态码有哪些？</h2><ul>
<li>1xx：指示信息–表示请求已接收，继续处理</li>
<li>2xx：成功–表示请求已被成功接收、理解、接受</li>
<li>3xx：重定向–要完成请求必须进行更进一步的操作</li>
<li>4xx：客户端错误–请求有语法错误或请求无法实现</li>
<li>5xx：服务器端错误–服务器未能实现合法的请求</li>
</ul>
<h4 id="常见的状态码："><a href="#常见的状态码：" class="headerlink" title="常见的状态码："></a>常见的状态码：</h4><ul>
<li>200：请求被正常处理</li>
<li>204：请求被受理但没有资源可以返回</li>
<li>206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。</li>
<li>301：永久性重定向</li>
<li>302：临时重定向</li>
<li>303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上</li>
<li>304：发送附带条件的请求时，条件不满足时返回，与重定向无关</li>
<li>307：临时重定向，与302类似，只是强制要求使用POST方法</li>
<li>400：请求报文语法有误，服务器无法识别</li>
<li>401：请求需要认证</li>
<li>403：请求的对应资源禁止被访问</li>
<li>404：服务器无法找到对应资源</li>
<li>500：服务器内部错误</li>
<li>503：服务器正忙</li>
</ul>
<h2 id="HTTP中重定向和请求转发的区别？"><a href="#HTTP中重定向和请求转发的区别？" class="headerlink" title="HTTP中重定向和请求转发的区别？"></a>HTTP中重定向和请求转发的区别？</h2><p>本质区别：</p>
<ul>
<li>转发是服务器行为</li>
<li>重定向是客户端行为</li>
</ul>
<p>重定向特点：两次请求，浏览器地址发生变化，可以访问自己 web 之外的资源，传输的数据会丢失。</p>
<p>请求转发特点：一次请求，浏览器地址不变，访问的是自己本身的 web 资源，传输的数据不会丢失。</p>
<h2 id="HTTP和HTTPS的区别？"><a href="#HTTP和HTTPS的区别？" class="headerlink" title="HTTP和HTTPS的区别？"></a>HTTP和HTTPS的区别？</h2><p>HTTPS = HTTP + SSL，SSL协议工作在应用层与传输层之间</p>
<ul>
<li>https有ca证书，http一般没有</li>
<li>http是超文本传输协议，信息是明文传输。https则是具有安全性的ssl加密传输协议</li>
<li>http默认80端口，https默认443端口</li>
</ul>
<h2 id="HTTP-2-与-HTTP-1-x-的主要区别？"><a href="#HTTP-2-与-HTTP-1-x-的主要区别？" class="headerlink" title="HTTP/2 与 HTTP/1.x 的主要区别？"></a>HTTP/2 与 HTTP/1.x 的主要区别？</h2><ul>
<li>二进制协议代替文本协议，更加简洁高效</li>
<li>针对每个域只使用一个多路复用的连接</li>
<li>压缩头部信息减小开销</li>
<li>允许服务器主动推送应答到客户端的缓存中</li>
</ul>
<h2 id="HTTP请求报文与响应报文格式？"><a href="#HTTP请求报文与响应报文格式？" class="headerlink" title="HTTP请求报文与响应报文格式？"></a>HTTP请求报文与响应报文格式？</h2><p>请求报文：</p>
<p>a、请求行：包含请求方法、URI、HTTP版本信息<br>b、请求首部字段<br>c、请求内容实体</p>
<p>响应报文：</p>
<p>a、状态行：包含HTTP版本、状态码、状态码的原因短语<br>b、响应首部字段<br>c、响应内容实体</p>
<h2 id="什么是HTTP协议无状态协议？"><a href="#什么是HTTP协议无状态协议？" class="headerlink" title="什么是HTTP协议无状态协议？"></a>什么是HTTP协议无状态协议？</h2><p>无状态协议对于事物处理没有记忆能力。缺少状态意味着后续的处理需要前面的信息。</p>
<h2 id="cookie和session的区别和联系"><a href="#cookie和session的区别和联系" class="headerlink" title="cookie和session的区别和联系"></a>cookie和session的区别和联系</h2><h3 id="Cookie的工作原理"><a href="#Cookie的工作原理" class="headerlink" title="Cookie的工作原理"></a><strong>Cookie的工作原理</strong></h3><ul>
<li>浏览器端第一次发送请求到服务器端</li>
<li>服务器端创建Cookie，该Cookie中包含用户的信息，然后将该Cookie发送到浏览器端</li>
<li>浏览器端再次访问服务器端时会携带服务器端创建的Cookie</li>
<li>服务器端通过Cookie中携带的数据区分不同的用户</li>
</ul>
<h3 id="Session的工作原理"><a href="#Session的工作原理" class="headerlink" title="Session的工作原理"></a><strong>Session的工作原理</strong></h3><ul>
<li>浏览器端第一次发送请求到服务器端，服务器端创建一个Session，同时会创建一个特殊的Cookie（name为JSESSIONID的固定值，value为session对象的ID），然后将该Cookie发送至浏览器端</li>
<li>浏览器端发送第N（N&gt;1）次请求到服务器端,浏览器端访问服务器端时就会携带该name为JSESSIONID的Cookie对象</li>
<li>服务器端根据name为JSESSIONID的Cookie的value(sessionId),去查询Session对象，从而区分不同用户。</li>
</ul>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><h4 id="1、存储位置不同"><a href="#1、存储位置不同" class="headerlink" title="1、存储位置不同"></a>1、存储位置不同</h4><blockquote>
<p>cookie的数据信息存放在客户端浏览器上。</p>
</blockquote>
<blockquote>
<p>session的数据信息存放在服务器上。</p>
</blockquote>
<h4 id="2、存储容量不同"><a href="#2、存储容量不同" class="headerlink" title="2、存储容量不同"></a>2、存储容量不同</h4><blockquote>
<p>单个cookie保存的数据&lt;=4KB，一个站点最多保存20个Cookie。</p>
</blockquote>
<blockquote>
<p>对于session来说并没有上限，但出于对服务器端的性能考虑，session内不要存放过多的东西，并且设置session删除机制。</p>
</blockquote>
<h4 id="3、存储方式不同"><a href="#3、存储方式不同" class="headerlink" title="3、存储方式不同"></a>3、存储方式不同</h4><blockquote>
<p>cookie中只能保管ASCII字符串，并需要通过编码方式存储为Unicode字符或者二进制数据。</p>
</blockquote>
<blockquote>
<p>session中能够存储任何类型的数据，包括且不限于string，integer，list，map等。</p>
</blockquote>
<h4 id="4、隐私策略不同"><a href="#4、隐私策略不同" class="headerlink" title="4、隐私策略不同"></a>4、隐私策略不同</h4><blockquote>
<p>cookie对客户端是可见的，所以它是不安全的。</p>
</blockquote>
<blockquote>
<p>session存储在服务器上，对客户端是透明的，不存在敏感信息泄漏的风险。</p>
</blockquote>
<h4 id="5、有效期上不同"><a href="#5、有效期上不同" class="headerlink" title="5、有效期上不同"></a>5、有效期上不同</h4><blockquote>
<p>可以通过设置cookie的属性，达到使cookie长期有效的效果。</p>
</blockquote>
<blockquote>
<p>session依赖于名为JSESSIONID的cookie，而cookie JSESSIONID的过期时间默认为-1，只需关闭窗口该session就会失效，因而session不能达到长期有效的效果。</p>
</blockquote>
<h4 id="6、服务器压力不同"><a href="#6、服务器压力不同" class="headerlink" title="6、服务器压力不同"></a>6、服务器压力不同</h4><blockquote>
<p>cookie保管在客户端，不占用服务器资源。对于并发用户十分多的网站，cookie是很好的选择。</p>
</blockquote>
<blockquote>
<p>session是保管在服务器端的，每个用户都会产生一个session。假如并发访问的用户十分多，会产生十分多的session，耗费大量的内存。</p>
</blockquote>
<h2 id="HTTPS方式与web服务器通信的步骤？"><a href="#HTTPS方式与web服务器通信的步骤？" class="headerlink" title="HTTPS方式与web服务器通信的步骤？"></a>HTTPS方式与web服务器通信的步骤？</h2><p>1、客户使用HTTPS的URL访问web服务器，要求与web服务器建立SSL连接<br>2、web服务器收到客户端请求后，将网站的证书信息（证书中包含公钥）传送一份给客户端<br>3、客户端的浏览器与web服务器开始协商SSL连接的安全等级，也就是信息的加密等级<br>4、客户端的浏览器根据双方同意的安全等级，建立会话秘钥，然后利用网站的公钥将会话秘钥加密，并传送给网站<br>5、web服务器利用自己的私钥解密出会话秘钥<br>6、web服务器利用会话秘钥加密与客户端之间的通信</p>
<h2 id="说说常见的常见HTTP首部字段？"><a href="#说说常见的常见HTTP首部字段？" class="headerlink" title="说说常见的常见HTTP首部字段？"></a>说说常见的常见HTTP首部字段？</h2><p>通用首部字段（请求报文与响应报文都会使用的首部字段）</p>
<p>Date：创建报文时间Connection：连接的管理Cache-Control：缓存的控制Transfer-Encoding：报文主体的传输编码方式</p>
<p>请求首部字段（请求报文会使用的首部字段）</p>
<p>Host：请求资源所在服务器Accept：可处理的媒体类型Accept-Charset：可接收的字符集Accept-Encoding：可接受的内容编码Accept-Language：可接受的自然语言</p>
<p>响应首部字段（响应报文会使用的首部字段）</p>
<p>Accept-Ranges：可接受的字节范围Location：令客户端重新定向到的URIServer：HTTP服务器的安装信息</p>
<p>实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）</p>
<p>Allow：资源可支持的HTTP方法Content-Type：实体主类的类型Content-Encoding：实体主体适用的编码方式Content-Language：实体主体的自然语言Content-Length：实体主体的的字节数Content-Range：实体主体的位置范围，一般用于发出部分请求时使用</p>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p><strong>概念：</strong>父进程创建一个子进程，子进程退出后，父进程没有调用 <strong>wait</strong> 或 <strong>waitpid</strong> 获取子进程的<strong>状态信息</strong>，那么子进程的<strong>状态描述符</strong>仍然保存在系统中</p>
<p><strong>危害：</strong>不调用 wait 或者 waitpid，保留的信息不会被释放，进程号会被一直占用，但是系统的进程号是有限的，如果有大量的僵尸进程，系统会因为没有进程号而无法创建新的进程</p>
<h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p><strong>概念：</strong>父进程退出，而它的子进程仍然在执行，那么子进程就会成为孤儿进程</p>
<p><strong>无危害：</strong>孤儿进程被 init 进程（进程号为1）所收养，并由 init 进程对它们完成状态收集工作</p>
<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><h3 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h3><ol>
<li>并发</li>
</ol>
<ul>
<li>并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。</li>
<li>并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。</li>
<li>操作系统通过引入进程和线程，使得程序能够并发运行。</li>
</ul>
<ol>
<li>共享</li>
</ol>
<ul>
<li>共享是指系统中的资源可以被多个并发进程共同使用。</li>
<li>有两种共享方式：互斥共享和同时共享。</li>
<li>互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。</li>
</ul>
<ol>
<li>虚拟</li>
</ol>
<ul>
<li><p>虚拟技术把一个物理实体转换为多个逻辑实体。</p>
</li>
<li><p>主要有两种虚拟技术：时分复用技术和空分复用技术。</p>
<ul>
<li><p>多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</p>
</li>
<li><p><strong>虚拟内存使用了空分复用技术，它**</strong>将物理内存抽象为地址空间**<strong>，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存**</strong>中。**</p>
</li>
</ul>
</li>
</ul>
<ol>
<li>异步</li>
</ol>
<ul>
<li>异步指进程不是一次性执行完毕</li>
</ul>
<h2 id="二、进程管理"><a href="#二、进程管理" class="headerlink" title="二、进程管理"></a>二、进程管理</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul>
<li><strong>进程是资源分配的基本单位</strong></li>
<li>进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。</li>
</ul>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul>
<li>线程是基本的CPU执行单元，也是程序执行流的最小单元，系统独立调度和分派的基本单位</li>
<li>线程由线程ID、程序计数器、寄存器集合和堆栈组成</li>
<li>进程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但是可与同属于一个进程的其他线程共享所拥有的全部资源</li>
<li>一个进程中可以有多个线程，它们共享进程资源</li>
<li>引入线程后，进程的内涵发生了改变，进程只作为除CPU外的系统资源的分配单元，而线程则作为处理器的分配单元</li>
<li>引入进程的目的是为了更好的使多程序并发执行，提高资源利用率和系统吞吐量；引入线程的目的是为了减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能</li>
</ul>
<h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><ul>
<li><p><strong>拥有资源</strong></p>
<ul>
<li>进程是资源分配的基本单位，但是线程不拥有资源（除了一点必不可少的资源），线程可以访问隶属进程的系统资源</li>
<li>如果线程也拥有资源，则切换线程就需要较大的时空开销，线程的概念就没有意义了</li>
</ul>
</li>
<li><p>调度</p>
<ul>
<li>传统操作系统中拥有资源和独立调度的基本单位都是进程</li>
<li>引入线程后，线程是独立调度的基本单位，进程是拥有资源的基本单位</li>
<li>在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</li>
</ul>
</li>
<li><p><strong>系统开销</strong></p>
<ul>
<li>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。</li>
<li>类似地，在进行<strong>进程切换时</strong>，涉及当前<strong>执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置（即，Context）</strong>，而<strong>线程切换时</strong>只需<strong>保存和设置少量寄存器内容</strong>，开销很小</li>
<li>同一个进程内的多个线程共享进程的地址空间，因此这些线程间同步与通信非常容易，甚至无须操作系统的干预</li>
</ul>
</li>
<li><p>并发性：</p>
<ul>
<li>引入线程后，不仅进程间可以并发执行，而且多个线程之间也可以并发执行，提高了并发性和吞吐量</li>
</ul>
</li>
<li><p><strong>通信方面</strong></p>
<ul>
<li>进程间通信需要进程同步和互斥手段的辅助，以保证数据的一致性，而线程间通信可以直接读/写进程数据段（如全局变量）来进行通信</li>
</ul>
</li>
</ul>
<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><ul>
<li>协程，是一种基于线程之上，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，自主开辟的异步任务，具有对内核来说不可见的特性</li>
<li>正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程</li>
</ul>
<h3 id="协程和线程的区别"><a href="#协程和线程的区别" class="headerlink" title="协程和线程的区别"></a>协程和线程的区别</h3><table>
<thead>
<tr>
<th>比较项</th>
<th>线程</th>
<th>协程</th>
</tr>
</thead>
<tbody><tr>
<td>占用资源</td>
<td>初始单位为1MB,固定不可变</td>
<td>初始一般为 2KB，可随需要而增大</td>
</tr>
<tr>
<td>调度所属</td>
<td>由 OS 的内核完成</td>
<td>由用户完成</td>
</tr>
<tr>
<td>切换开销</td>
<td>涉及模式切换(从用户态切换到内核态)、16个寄存器、PC、SP…等寄存器的刷新等</td>
<td>只有三个寄存器的值修改 - PC / SP / DX.</td>
</tr>
<tr>
<td>性能问题</td>
<td>资源占用太高，频繁创建销毁会带来严重的性能问题</td>
<td>资源占用小,不会带来严重的性能问题</td>
</tr>
<tr>
<td>数据同步</td>
<td>需要用锁等机制确保数据的一直性和可见性</td>
<td>不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</td>
</tr>
</tbody></table>
<h3 id="进程状态的切换"><a href="#进程状态的切换" class="headerlink" title="进程状态的切换"></a>进程状态的切换</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1599655539465-7c6412b9-cf1c-41eb-98c2-631439893c16.png" alt="image.png"></p>
<ul>
<li>就绪状态（ready）：进程获取了除处理器以外的一切所需资源，等待被调度，多个处于就绪状态的进程拍成就绪队列</li>
<li>运行状态（running）：进程正在处理器上运行</li>
<li>阻塞状态（waiting）：等待某资源为可用</li>
<li>创建态（created）：进程正在被创建，尚未转到就绪态</li>
<li>结束态（terminated）：进程正从系统消失，可能是进程正常结束或其他原因中断退出运行</li>
</ul>
<p>应该注意以下内容：</p>
<ul>
<li>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li>
<li>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</li>
</ul>
<h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><h4 id="1-批处理系统"><a href="#1-批处理系统" class="headerlink" title="1. 批处理系统"></a>1. 批处理系统</h4><ul>
<li>批处理系统在很老的计算机时使用，没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）</li>
</ul>
<p><strong>1.1 先来先服务 first-come first-serverd（FCFS）</strong></p>
<ul>
<li>非抢占式的调度算法，按照请求的顺序进行调度</li>
<li><strong>有利于长作业，但不利于短作业</strong>，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长</li>
</ul>
<p><strong>1.2 短作业优先 shortest job first（SJF）</strong></p>
<ul>
<li>非抢占式的调度算法，按估计运行时间最短的顺序进行调度</li>
<li><strong>长作业有可能会饿死</strong>，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度</li>
</ul>
<p><strong>1.3 高响应比优先</strong> </p>
<ul>
<li>高响应比优先调度算法是FCFS和SJF的综合平衡，每次进行作业调度时，先计算后备作业队列中每个作业的响应比，从中选出响应比最高的作业投入运行</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1599725265351-ac1b4730-41f4-45af-ab73-a8e3bf6ae880.png" alt="image.png"></li>
<li>要求服务时间短，响应比高，有利于短作业</li>
<li>等待时间长，响应比高，不会出现长作业饿死的情况</li>
</ul>
<h4 id="2-交互式系统"><a href="#2-交互式系统" class="headerlink" title="2. 交互式系统"></a>2. 交互式系统</h4><p><strong>2.1 时间片轮转</strong></p>
<p><strong>2.2 优先级调度</strong></p>
<p><strong>2.3 多级反馈队列</strong></p>
<ul>
<li>多级队列是为这种需要连续执行多个时间片的进程考虑，<strong>设置了多个队列，每个队列时间片大小都不同</strong>，例如 1,2,4,8,..。<strong>进程在第一个队列没执行完，就会被移到下一个队列</strong>。这种方式下，之前的进程只需要交换 7 次</li>
<li><strong>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列中的进程</strong></li>
<li>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合</li>
</ul>
<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><ul>
<li><p><strong>进程间通信(IPC，InterProcess Communication)的目的</strong></p>
</li>
<li><ul>
<li><strong>数据传输：</strong>一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几兆字节之间<ul>
<li><strong>共享数据：</strong>多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到</li>
<li><strong>通知事件：</strong>一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）</li>
<li><strong>资源共享：</strong>多个进程之间共享同样的资源。为了作到这一点，需要内核提供锁和同步机制</li>
<li><strong>进程控制：</strong>有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变</li>
</ul>
</li>
</ul>
</li>
<li><p>IPC方式包括：管道、系统IPC（信号量、消息队列、共享内存）和套接字（socket）</p>
</li>
</ul>
<h4 id="管道-pipe"><a href="#管道-pipe" class="headerlink" title="管道(pipe)"></a>管道(pipe)</h4><ul>
<li><p><strong>管道的特点：</strong></p>
</li>
<li><ul>
<li><strong>管道是半双工</strong>，数据只能向一个方向流动；双方需要互相通信时，需要建立起两个管道<ul>
<li>只能用于具有亲缘关系的进程（<strong>父子进程或者兄弟进程</strong>）之间</li>
<li>管道对于两端通信的进程来说就只是一种<strong>文件</strong>，一种<strong>不属于文件系统仅存在内存中的“伪文件”</strong></li>
<li>管道的通信方式为：写端每次都将数据写入管道缓冲区的 <strong>末尾</strong> ，而读端每次都从管道缓冲区的 <strong>头部</strong> 读出数据</li>
<li>当一个管道建立时，它会创建两个文件描述符：fd[0]为读而打开，fd[1]为写而打开，要关闭管道只需将这两个文件描述符关闭即可。如下图：</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1598175402011-cbc30792-6045-4701-b33c-2222787f89e6.png" alt="image.png"></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>管道的实质</strong></p>
</li>
<li><ul>
<li>管道的实质是一个<strong>内核缓冲区</strong>，进程以先进先出的方式从缓冲区存取数据：管道一端的进程顺序地将进程数据写入缓冲区，另一端的进程则顺序地读取数据<ul>
<li>该缓冲区可以看做一个循环队列，读和写的位置都是自动增加的，一个数据只能被读一次，读出以后再缓冲区都不复存在了</li>
<li>当缓冲区读空或者写满时，有一定的规则控制相应的读进程或写进程是否进入等待队列，当空的缓冲区有新数据写入或慢的缓冲区有数据读出时，就唤醒等待队列中的进程继续读写</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="信号-signals"><a href="#信号-signals" class="headerlink" title="信号(signals)"></a>信号(signals)</h4><ul>
<li><p><strong>信号的特点：</strong></p>
</li>
<li><ul>
<li>Unix系统中使用的最古老的进程间通信的方法之一，操作系统通过信号来通知进程系统中发生了某种预先规定好的事件（一组事件中的一个），它也是用户进程之间通信和同步的一种原始机制<ul>
<li>一个键盘中断或者一个错误条件（比如进程试图访问它的虚拟内存中不存在的位置等）都有可能产生一个信号</li>
<li>信号可以在任何时候发给某一进程，而无需知道该进程的状态、</li>
<li>对信号的任何处理，包括终止进程，都必须由接收到信号的进程真正执行时才能处理，所以信号处理可能需要延迟一段时间</li>
<li>如果该进程当前并未处于执行状态，则内核保存该信号，直到该进程回复执行并传递给它为止</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>信号的来源：</strong></p>
</li>
<li><ul>
<li><strong>信号是软件层次上对中断机制的一种模拟，是一种异步通信方式（所以信号不是中断，**</strong>信号处理程序在用户态下运行的, 中断程序在核心态下运行的**<strong>）</strong><ul>
<li><strong>信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发生了哪些系统事件</strong></li>
<li>信号事件主要有两个来源：</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>硬件来源：用户按键输入 <code>Ctrl+C</code> 退出、硬件异常如无效的存储访问等<ul>
<li>软件终止：终止进程信号、其他进程调用 <code>kill</code> 函数、软件异常产生信号</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>信号生命周期和处理流程</strong></p>
</li>
</ul>
<ol>
<li><ol>
<li><strong>信号被某个进程产生</strong>，并设置此信号传递的对象（一般为<strong>对应进程的pid</strong>），然后<strong>传递给操作系统</strong><ol start="2">
<li>操作系统根据接收进程的设置（是否阻塞）而选择性的发送给接收者，如果接收者阻塞该信号（且该信号是可以阻塞的），操作系统将暂时保留该信号，而不传递，直到该进程解除了对此信号的阻塞（如果对应进程已经退出，则丢弃此信号），<strong>如果对应进程没有阻塞，操作系统将传递此信号</strong></li>
<li><strong>目的进程接收到此信号后</strong>，将根据当前进程对此信号设置的预处理方式，<strong>暂时终止当前代码的执行，**</strong>保护上下文<strong>（主要包括临时寄存器数据，当前程序位置以及当前CPU的状态）、</strong>转而执行中断服务程序**<strong>，执行完成后在回复到中断的位置</strong>。当然，对于抢占式内核，在中断返回时还将引发新的调度</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="消息队列-message"><a href="#消息队列-message" class="headerlink" title="消息队列(message)"></a>消息队列(message)</h4><ul>
<li><p>消息队列的特点：</p>
</li>
<li><ul>
<li>消息队列是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识<ul>
<li>消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区受限等特点</li>
<li>消息队列允许一个或多个进程向它写入与读取消息</li>
<li>管道和消息队列的通信数据都是先进先出的原则</li>
<li>与管道相比，管道发送的数据没有类型；消息队列有类型，读端可以根据数据类型读取特定的数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="共享内存-share-memory"><a href="#共享内存-share-memory" class="headerlink" title="共享内存(share memory)"></a>共享内存(share memory)</h4><ul>
<li>使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的</li>
<li>为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率</li>
<li>信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问</li>
</ul>
<h4 id="信号量-semaphore"><a href="#信号量-semaphore" class="headerlink" title="信号量(semaphore)"></a>信号量(semaphore)</h4><ul>
<li><p><strong>信号量</strong></p>
</li>
<li><ul>
<li>信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于<strong>进程间同步</strong></li>
</ul>
</li>
<li><p><strong>信号量与普通整型变量的区别：</strong></p>
</li>
<li><ul>
<li>信号量是非负整型变量，除了初始化之外，它只能通过两个标准原子操作：wait(semap) , signal(semap) ; 来进行访问<ul>
<li>操作也被成为PV原语，而普通整型变量则可以在任何语句块中被访问</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="套接字-socket"><a href="#套接字-socket" class="headerlink" title="套接字(socket)"></a>套接字(socket)</h4><ul>
<li>适合<strong>同一主机的不同进程间</strong>和<strong>不同主机的进程间</strong>进行全双工网络通信</li>
</ul>
<h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><h4 id="1-临界区"><a href="#1-临界区" class="headerlink" title="1. 临界区"></a>1. 临界区</h4><ul>
<li>对临界资源进行访问的那段代码称为临界区。</li>
<li>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</li>
<li>// entry section</li>
<li>// critical section;</li>
<li>// exit section</li>
</ul>
<h4 id="2-同步与互斥"><a href="#2-同步与互斥" class="headerlink" title="2. 同步与互斥"></a>2. 同步与互斥</h4><ul>
<li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li>
<li>互斥：多个进程在同一时刻只有一个进程能进入临界区。</li>
</ul>
<h4 id="3-信号量"><a href="#3-信号量" class="headerlink" title="3. 信号量"></a>3. 信号量</h4><ul>
<li><p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p>
</li>
<li><ul>
<li><strong>down</strong> : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；<ul>
<li><strong>up</strong> ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断</strong>。</p>
</li>
<li><p>如果信号量的取值只能为 0 或者 1，那么就成为了 <strong>互斥量（Mutex）</strong> ，0 表示临界区已经加锁，1 表示临界区解锁。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>使用信号量实现生产者-消费者问题</strong></p>
<p>问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。</p>
<p>因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。</p>
<p>为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。</p>
<p>注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。</p>
<figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#define N 100</span><br><span class="line">typedef int semaphore;</span><br><span class="line">semaphore mutex = 1;</span><br><span class="line">semaphore empty = N;</span><br><span class="line">semaphore full = 0;</span><br><span class="line">void producer() &#123;</span><br><span class="line">    <span class="meta">while</span>(TRUE) &#123;</span><br><span class="line">        int item = produce_item();</span><br><span class="line">        <span class="meta">do</span><span class="meta">wn(</span><span class="variable">&amp;empty</span>);</span><br><span class="line">        <span class="meta">do</span><span class="meta">wn(</span><span class="variable">&amp;mutex</span>);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        up(<span class="variable">&amp;mutex</span>);</span><br><span class="line">        up(<span class="variable">&amp;full</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void consumer() &#123;</span><br><span class="line">    <span class="meta">while</span>(TRUE) &#123;</span><br><span class="line">        <span class="meta">do</span><span class="meta">wn(</span><span class="variable">&amp;full</span>);</span><br><span class="line">        <span class="meta">do</span><span class="meta">wn(</span><span class="variable">&amp;mutex</span>);</span><br><span class="line">        int item = remove_item();</span><br><span class="line">        consume_item(item);</span><br><span class="line">        up(<span class="variable">&amp;mutex</span>);</span><br><span class="line">        up(<span class="variable">&amp;empty</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-管程"><a href="#4-管程" class="headerlink" title="4. 管程"></a>4. 管程</h4><ul>
<li>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</li>
<li>c 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。</li>
</ul>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">monitor ProducerConsumer</span><br><span class="line">    integer i;</span><br><span class="line">    condition c;</span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">()</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">remove</span><span class="params">()</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span> monitor;</span><br></pre></td></tr></table></figure>

<ul>
<li>管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。</li>
<li>管程引入了 <strong>条件变量</strong> 以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</li>
<li><strong>使用管程实现生产者-消费者问题</strong></li>
</ul>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 管程</span></span><br><span class="line">monitor ProducerConsumer</span><br><span class="line">    condition full, <span class="keyword">empty</span>;</span><br><span class="line">    integer count := <span class="number">0</span>;</span><br><span class="line">    condition c;</span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">(item: integer)</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> count = N <span class="keyword">then</span> wait(full);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        count := count + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">1</span> <span class="keyword">then</span> signal(<span class="keyword">empty</span>);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">remove</span>:</span> integer;</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">0</span> <span class="keyword">then</span> wait(<span class="keyword">empty</span>);</span><br><span class="line">        <span class="keyword">remove</span> = remove_item;</span><br><span class="line">        count := count - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = N -<span class="number">1</span> <span class="keyword">then</span> signal(full);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span> monitor;</span><br><span class="line"><span class="comment">// 生产者客户端</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">producer</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="title">true</span> <span class="title">do</span></span></span><br><span class="line"><span class="function">    <span class="title">begin</span></span></span><br><span class="line"><span class="function">        <span class="title">item</span> = <span class="title">produce_item</span>;</span></span><br><span class="line">        ProducerConsumer.insert(item);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">// 消费者客户端</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">consumer</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="title">true</span> <span class="title">do</span></span></span><br><span class="line"><span class="function">    <span class="title">begin</span></span></span><br><span class="line"><span class="function">        <span class="title">item</span> = <span class="title">ProducerConsumer</span>.<span class="title">remove</span>;</span></span><br><span class="line">        consume_item(item);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>

<h2 id="三、死锁"><a href="#三、死锁" class="headerlink" title="三、死锁"></a>三、死锁</h2><h3 id="1、死锁、饥饿、死循环的区别"><a href="#1、死锁、饥饿、死循环的区别" class="headerlink" title="1、死锁、饥饿、死循环的区别"></a>1、死锁、饥饿、死循环的区别</h3><ul>
<li><p>死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。至少有两个进程或以上同时发生死锁。</p>
</li>
<li><p>饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。</p>
</li>
<li><p>死循环：某进程执行过程中一直跳不出某个循环的现象。</p>
</li>
</ul>
<h3 id="2、死锁产生的必要条件"><a href="#2、死锁产生的必要条件" class="headerlink" title="2、死锁产生的必要条件"></a>2、死锁产生的必要条件</h3><p>产生死锁必须同时满足以下四个条件，只要其中一个不成立，死锁就不会发生。</p>
<ul>
<li>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁（如哲学家的筷子、打印机设备）。</li>
<li>不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</li>
<li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。（有了一个，还想要另一个，但是自己原来那个不放手。）</li>
<li>循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</li>
</ul>
<h3 id="3、什么时候会发生死锁"><a href="#3、什么时候会发生死锁" class="headerlink" title="3、什么时候会发生死锁"></a>3、什么时候会发生死锁</h3><p>1、对系统资源的竞争。各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁。</p>
<p>2、进程推进顺序非法。请求和释放资源的顺序不当，同样也会导致死锁。例如，并发执行进程P1、P2分别申请并占有了资源R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又申请R1，两者会因为申请的资源被对方占有而阻塞，从而发生死锁。</p>
<p>3、信号量的使用不当也会造成死锁。如生产者-消费者问题中，如果实现互斥的P操作在实现同步的P操作之前，就有可能导致死锁。（可以把互斥信号量、同步信号量也看做是一种抽象的系统资源）</p>
<h3 id="4、死锁的处理——预防死锁"><a href="#4、死锁的处理——预防死锁" class="headerlink" title="4、死锁的处理——预防死锁"></a>4、死锁的处理——预防死锁</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/png/218528/1575718340782-6dca5998-47bd-490f-bab3-2417f36e8825.png?x-oss-process=image/resize,w_1500" alt="image.png"></p>
<h4 id="4-1-破坏互斥条件"><a href="#4-1-破坏互斥条件" class="headerlink" title="4.1 破坏互斥条件"></a>4.1 破坏互斥条件</h4><h4 id="4-2-破坏不剥夺条件"><a href="#4-2-破坏不剥夺条件" class="headerlink" title="4.2 破坏不剥夺条件"></a>4.2 破坏不剥夺条件</h4><h4 id="4-3-破坏请求和保持条件"><a href="#4-3-破坏请求和保持条件" class="headerlink" title="4.3 破坏请求和保持条件"></a>4.3 破坏请求和保持条件</h4><h4 id="4-4-破坏循环等待条件"><a href="#4-4-破坏循环等待条件" class="headerlink" title="4.4 破坏循环等待条件"></a>4.4 破坏循环等待条件</h4><h3 id="5、死锁的处理——避免死锁"><a href="#5、死锁的处理——避免死锁" class="headerlink" title="5、死锁的处理——避免死锁"></a>5、死锁的处理——避免死锁</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/png/218528/1575722844700-df890c05-54b7-4217-898b-4cce009af1db.png?x-oss-process=image/resize,w_1500" alt="image.png"></p>
<h4 id="5-2-银行家算法"><a href="#5-2-银行家算法" class="headerlink" title="5.2 银行家算法"></a>5.2 银行家算法</h4><p><img src="https://cdn.nlark.com/yuque/0/2019/png/218528/1575723680965-560e06d5-2688-40b9-bede-4f3822bf6237.png?x-oss-process=image/resize,w_1500" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/218528/1575725368390-6e09854f-9422-4228-b3d3-36cb7473d161.png?x-oss-process=image/resize,w_1500" alt="image.png"></p>
<p>银行家算法总结：</p>
<p>用Available向量表示系统当前的可用资源数。</p>
<p>试分配：</p>
<p>在某一时刻，进程提出资源申请，系统首先检查申请的资源数是否超过进程的最大需求量。</p>
<p>不超过，则检查是否超过当前可用的资源数。</p>
<p>如果都不超过，则试着分配给该进程。</p>
<p>然后用安全性算法检查此次分配是否会导致系统进入不安全状态。</p>
<p>安全性算法简单理解：系统当前剩余的资源数超过了某个进程的Need向量，就把该进程加入安全序列，并将Allocation添加到Available，不断循环此过程，看最终能否让所有进程都加入安全序列，如果可以，此次分配时安全的，系统开始分配。</p>
<p>注意：处于安全状态一定不会死锁，死锁一定处于不安全状态，处于不安全状态不一定会死锁。</p>
<h3 id="6、死锁的处理——检测和解除"><a href="#6、死锁的处理——检测和解除" class="headerlink" title="6、死锁的处理——检测和解除"></a>6、死锁的处理——检测和解除</h3><h4 id="6-1-数据结构"><a href="#6-1-数据结构" class="headerlink" title="6.1 数据结构"></a>6.1 数据结构</h4><p>1、用种数据结构来保存资源的请求和分配信息。数据结构定义如下：</p>
<ul>
<li><p>两种结点：</p>
</li>
<li><ul>
<li>进程结点：对应一个进程<pre><code>- 资源结点：对应一类资源，一类资源可能有多个</code></pre>
</li>
</ul>
</li>
<li><p>两种边：</p>
</li>
<li><ul>
<li>进程结点-&gt;资源结点：表示进程想申请几个资源（每条边代表一个）<pre><code>- 资源结点-&gt;进程结点：表示进程想申请几个资源（每条边代表一个）</code></pre>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/218528/1575734720016-bc4c28fa-fae9-478a-aed9-816b1286e6f3.png" alt="image.png"></p>
<p>（矩形中的小圆代表资源的数量）</p>
<p>2、提供一种算法，利用上述信息来检测系统是否已进入死锁状态。算法描述如下：</p>
<p>如果系统中剩余的可用资源满足进程的需求，则进程将顺利自行下去，然后将资源归还系统，然后激活正在等待资源的进程，并顺利执行下去，一直这样下去，如果最终能消除所有边，就称这个图是可完全简化的，此时一定没有发生死锁（相当于找一个安全序列）。如果最终不能消除所有边，那么此时就是发生了死锁。最终连着边的那些进程就是处于死锁状态的进程。</p>
<p>算法简单理解：把没有处于阻塞态的进程的边都去掉，循环此过程。</p>
<h4 id="6-2-死锁的解除"><a href="#6-2-死锁的解除" class="headerlink" title="6.2 死锁的解除"></a>6.2 死锁的解除</h4><p>1、一旦检测出死锁的发生，就应该立即解除死锁。</p>
<p>2、并不是系统中所有进程都是死锁状态，用死锁检测算法简化资源分配图后，还连着边的那些进程就是死锁进程。</p>
<p>3、解除死锁的主要方法有：</p>
<ul>
<li>资源剥夺法：挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</li>
<li>撤销进程法（终止进程法）：强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的有点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束，一旦被终止可谓功亏一篑，以后还得从头再来。</li>
<li>进程回退法：让一个或多个死锁进程回退到足以避免死锁的地步。这就是要求系统要记录进程的历史信息，设置还原点。</li>
</ul>
<p>问题：决定对谁动手？</p>
<ul>
<li>进程优先级</li>
<li>已执行了多长时间</li>
<li>还要多久完成</li>
<li>进程已经使用了多少资源（资源分配多的优先）</li>
<li>进程是交互式的还是批处理式的（批处理优先）</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/218528/1575734667024-d54814af-cee6-49d8-8a26-4798efd42280.png?x-oss-process=image/resize,w_746"></p>
<h2 id="四、内存管理"><a href="#四、内存管理" class="headerlink" title="四、内存管理"></a>四、内存管理</h2><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><ul>
<li><strong>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存</strong>。</li>
<li>为了更好的管理内存，<strong>操作系统将内存抽象成地址空间。</strong> <strong>每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中</strong>。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</li>
<li>从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个<strong>程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能</strong>。<strong>例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序</strong>。</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1597062741056-0b5eeebc-b334-4929-9319-359a8cf9e7cc.png" alt="image.png"></li>
</ul>
<h3 id="分页与分段"><a href="#分页与分段" class="headerlink" title="分页与分段"></a>分页与分段</h3><ul>
<li><strong>分页</strong>管理方式是从计算机的角度考虑设计的，以<strong>提高内存的利用率</strong>，提升计算机的性能, 且分页通过硬件机制实现，对用户完全透明</li>
<li><strong>分段</strong>管理方式的提出则是考虑了用户和程序员，以<strong>满足方便编程、信息保护和共享、动态增长及动态链接</strong>等多方面的需要</li>
</ul>
<h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><ul>
<li><p><strong>内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表</strong>。</p>
</li>
<li><p>一个虚拟地址分成两个部分，一部分存储页号，一部分存储偏移量。</p>
</li>
<li><p>页表：</p>
</li>
<li><ul>
<li>为了便于在内存中找到进程的每个页面所对应的物理块，<strong>系统为每个进程建立一张页表</strong>，记录页面在内存中对应的物理块号，页表一般存放在内存中。在配置了页表后，进程执行时，通过查找该表，即可找到每页在内存中的物理块号。可见，页表的作用是实现从页号到物理块号的地址映射<ul>
<li>下图的页表存放着 16 个页，这 16 个页需要用 4 个bit来进行索引定位。</li>
</ul>
</li>
</ul>
</li>
<li><p>例如对于虚拟地址（0010 000000000100），前 4 位是当在虚拟地址对应的存储页号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。那么映射后，这个页（地址空间）对应的页框（物理内存地址）的地址为 （110 000000000100）。</p>
</li>
<li><p><strong>相当于前缀做一个Mapping，前缀决定虚拟地址属于哪个块，后缀决定这个虚拟地址在块中的相对位置</strong></p>
</li>
<li><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1266758/1597064732122-fa391785-bc91-450c-a6db-3284d9ee19ea.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
</li>
</ul>
<h4 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h4><ul>
<li><p>分段式管理方式按照用户进程中的自然段划分逻辑空间</p>
</li>
<li><ul>
<li>例如，用户进程由主程序、两个子程序、栈和一段数据组成，于是可以把这个用户进程划分为5个段，每段从0 开始编址，并分配一段连续的地址空间<ul>
<li>段内要求连续，段间不要求连续，因此整个作业的地址空间是二维的，其<strong>逻辑地址</strong>由<strong>段号S</strong>与<strong>段内偏移量W</strong>两部分组成</li>
</ul>
</li>
</ul>
</li>
<li><p>页式系统中，逻辑地址的页号和页内偏移量对用户是透明的，段式系统中，段号和段内偏移量必须由用户显示提供，，在髙级程序设计语言中，这个工作由编译程序完成</p>
</li>
<li><p>段表</p>
</li>
<li><ul>
<li>每个进程都有一张逻辑空间与内存空间映射的段表，其中每一个段表项对应进程的一个段，段表项记录该段在内存中的起始地址和段的长度<ul>
<li>在配置了段表后，执行中的进程可通过查找段表，找到每个段所对应的内存区</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1598085231446-c4b4cce0-09de-4296-85a2-7a2021e9f923.png" alt="image.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>段的共享和保护</p>
</li>
<li><ul>
<li>共享：通过两个作业的段表中相应表项指向被共享的段的同一个物理副本来实现的<ul>
<li>保护：存取控制保护、地址越界保护</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h4><ul>
<li>分页能有效地提高内存利用率，分段能反映程序的逻辑结构并有利于段的共享，将这两种存储管理方法结合起来，就形成了段页式存储管理方式</li>
<li>程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1598086260778-9d62781d-6da7-4186-af92-ecf9e30b8b47.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image.png"></li>
</ul>
<h3 id="分页与分段的比较"><a href="#分页与分段的比较" class="headerlink" title="分页与分段的比较"></a>分页与分段的比较</h3><ul>
<li>对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段</li>
<li>地址空间的维度：分页是一维地址空间，分段是二维的</li>
<li>大小是否可以改变：页的大小不可变，段的大小可以动态改变</li>
<li>出现的原因：<strong>分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护</strong></li>
</ul>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p><strong>页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）</strong></p>
<ol>
<li><strong>最佳（OPT, Optimal replacement algorithm）</strong></li>
</ol>
<ul>
<li>所<strong>选择的被换出的页面在未来最长时间内不再被访问</strong>，通常可以保证获得最低的缺页率。</li>
<li>是一种<strong>理论上的算法</strong>，因为无法知道一个页面多长时间不再被访问。</li>
</ul>
<ol start="2">
<li><p><strong>最近最久未使用（LRU, Least Recently Used）</strong></p>
</li>
<li><p><strong>最近未使用（NRU, Not Recently Used）</strong></p>
</li>
</ol>
<ul>
<li><p>每个页面都有两个状态位：R 与 M，<strong>当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1</strong>。其中 R 位会定时被清零。可以将页面分成以下四类：</p>
</li>
<li><ul>
<li><p>R=0，M=0 </p>
<ul>
<li>R=0，M=1</li>
<li>R=1，M=0</li>
<li>R=1，M=1</li>
</ul>
</li>
</ul>
</li>
<li><p>当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。</p>
</li>
<li><p><strong>NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）</strong>。</p>
</li>
</ul>
<ol start="4">
<li><strong>先进先出（FIFO, First In First Out）</strong></li>
</ol>
<ul>
<li><ul>
<li>选择换出的页面是最先进入的页面。<ul>
<li><strong>该算法会将那些经常被访问的页面换出，导致缺页率升高</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="5">
<li><strong>第二次机会算法</strong></li>
</ol>
<ul>
<li><ul>
<li><strong>FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：</strong><ul>
<li><strong>当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。</strong></li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1597061941454-03800959-859a-4877-abfd-27c39e401945.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="6">
<li><strong>时钟（Clock）</strong></li>
</ol>
<ul>
<li><ul>
<li>第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。<ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1597062565754-826091ad-7dc4-4c83-943d-343b7bd7bdac.png" alt="image.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="五、设备管理"><a href="#五、设备管理" class="headerlink" title="五、设备管理"></a>五、设备管理</h2><h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><ul>
<li><p>读写一个磁盘块的时间的影响因素有：</p>
</li>
<li><ul>
<li>旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）<ul>
<li>寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）</li>
<li>实际的数据传输时间</li>
</ul>
</li>
</ul>
</li>
<li><p>其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p>
<ul>
<li><p>先来先服务（FCFS, First Come First Served） </p>
</li>
<li><p>最短寻道时间优先（SSTF, Shortest Seek Time First）</p>
</li>
<li><p>电梯算法（SCAN） </p>
<ul>
<li>电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</li>
<li>电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。</li>
<li>因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="什么是-Spring-框架"><a href="#什么是-Spring-框架" class="headerlink" title="什么是 Spring 框架"></a>什么是 Spring 框架</h2><p>Spring 是一种轻量级开发框架，旨在提高开发人员的开发效率以及系统的可维护性。</p>
<p>一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助开发。这些模块是：核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。比如：Core Container 中的 Core 组件是Spring 所有组件的核心，Beans 组件和 Context 组件是实现IOC和依赖注入的基础，AOP组件用来实现面向切面编程。</p>
<p>Spring 官网列出的 Spring 的 6 个特征:</p>
<ul>
<li><strong>核心技术</strong> ：依赖注入(DI)，AOP，事件(events)，资源，i18n，验证，数据绑定，类型转换，SpEL。</li>
<li><strong>测试</strong> ：模拟对象，TestContext框架，Spring MVC 测试，WebTestClient。</li>
<li><strong>数据访问</strong> ：事务，DAO支持，JDBC，ORM，编组XML。</li>
<li><strong>Web支持</strong> : Spring MVC和Spring WebFlux Web框架。</li>
<li><strong>集成</strong> ：远程处理，JMS，JCA，JMX，电子邮件，任务，调度，缓存。</li>
<li><strong>语言</strong> ：Kotlin，Groovy，动态语言。</li>
</ul>
<h2 id="Spring模块"><a href="#Spring模块" class="headerlink" title="Spring模块"></a>Spring模块</h2><p>下图对应的是 Spring4.x 版本。目前最新的5.x版本中 Web 模块的 Portlet 组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/spring.jpg"></p>
<ul>
<li><strong>Spring Core：</strong> 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IoC 依赖注入功能。</li>
<li><strong>Spring Aspects</strong> ： 该模块为与AspectJ的集成提供支持。</li>
<li><strong>Spring AOP</strong> ：提供了面向切面的编程实现。</li>
<li><strong>Spring JDBC</strong> : Java数据库连接。</li>
<li><strong>Spring JMS</strong> ：Java消息服务。</li>
<li><strong>Spring ORM</strong> : 用于支持Hibernate等ORM工具。</li>
<li><strong>Spring Web</strong> : 为创建Web应用程序提供支持。</li>
<li><strong>Spring Test</strong> : 提供了对 JUnit 和 TestNG 测试的支持。</li>
</ul>
<h2 id="Spring框架的优点是什么"><a href="#Spring框架的优点是什么" class="headerlink" title="Spring框架的优点是什么"></a>Spring框架的优点是什么</h2><ul>
<li>轻量：Spring 是轻量的，基本的版本大约2MB。</li>
<li>控制反转：Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。</li>
<li>面向切面的编程(AOP)：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。</li>
<li>容器：Spring 包含并管理应用中对象的生命周期和配置。</li>
<li>MVC框架：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。</li>
<li>事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。</li>
<li>异常处理：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常。</li>
</ul>
<h2 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h2><p>IoC（Inverse of Control:控制反转）是一种<strong>设计思想</strong>，就是 <strong>将原本在程序中手动创建对象的控制权，交由Spring框架来管理。</strong> IoC 在其他语言中也有应用，并非 Spring 特有。 <strong>IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。</strong></p>
<p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 <strong>IoC 容器就像是一个工厂一样，当需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</strong> 在实际项目中一个 Service 类可能有几百甚至上千个类作为它的底层，假如需要实例化这个 Service，可能要每次都要搞清这个 Service 所有底层类的构造函数。如果利用 IoC 的话，只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。</p>
<p><strong>Spring IoC的初始化过程：</strong></p>
<p><strong><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201015160750.png" alt="image.png"></strong></p>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</p>
<p><strong>Spring AOP就是基于动态代理的</strong>，如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用<strong>Cglib</strong> ，这时候Spring AOP会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理。</p>
<p>当然也可以使用 AspectJ ,Spring AOP 已经集成了AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p>
<p>使用 AOP 之后可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。</p>
<h2 id="Spring-中的-bean-的作用域有哪些"><a href="#Spring-中的-bean-的作用域有哪些" class="headerlink" title="Spring 中的 bean 的作用域有哪些?"></a>Spring 中的 bean 的作用域有哪些?</h2><ul>
<li>singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li>
<li>prototype : 每次请求都会创建一个新的 bean 实例。</li>
<li>request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。</li>
<li>session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。</li>
<li>global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话</li>
</ul>
<h2 id="Spring-中的单例-bean-的线程安全问题了解吗？"><a href="#Spring-中的单例-bean-的线程安全问题了解吗？" class="headerlink" title="Spring 中的单例 bean 的线程安全问题了解吗？"></a>Spring 中的单例 bean 的线程安全问题了解吗？</h2><p>单例 bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候，对这个对象的非静态成员变量的写操作会存在线程安全问题。</p>
<p>常见的有两种解决办法：</p>
<ol>
<li>在Bean对象中尽量避免定义可变的成员变量（不太现实）。</li>
<li>在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。</li>
</ol>
<h2 id="Component-和-Bean-的区别是什么？"><a href="#Component-和-Bean-的区别是什么？" class="headerlink" title="@Component 和 @Bean 的区别是什么？"></a>@Component 和 @Bean 的区别是什么？</h2><ol>
<li>作用对象不同: <code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</li>
<li><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中（可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。<code>@Bean</code> 注解通常是在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了Spring这是某个类的示例，当需要用它的时候Spring进行装配加载。</li>
<li><code>@Bean</code> 注解比 <code>Component</code> 注解的自定义性更强，而且很多地方只能通过 <code>@Bean</code> 注解来注册bean。比如当引用第三方库中的类需要装配到 <code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</li>
</ol>
<h2 id="将一个类声明为Spring的-bean-的注解有哪些"><a href="#将一个类声明为Spring的-bean-的注解有哪些" class="headerlink" title="将一个类声明为Spring的 bean 的注解有哪些?"></a>将一个类声明为Spring的 bean 的注解有哪些?</h2><p>一般使用 <code>@Autowired</code> 注解自动装配 bean，要想把类标识成可用于 <code>@Autowired</code> 注解自动装配的 bean 的类,采用以下注解可实现：</p>
<ul>
<li><code>@Component</code> ：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个Bean不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li>
<li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li>
<li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao层。</li>
<li><code>@Controller</code> : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</li>
</ul>
<h2 id="SpringMVC-工作原理"><a href="#SpringMVC-工作原理" class="headerlink" title="SpringMVC 工作原理"></a>SpringMVC 工作原理</h2><ol>
<li><p>客户端（浏览器）发送请求，直接请求到 <code>DispatcherServlet</code>。</p>
</li>
<li><p><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code>，解析请求对应的 <code>Handler</code>。</p>
</li>
<li><p>解析到对应的 <code>Handler</code>（也就是平常说的 <code>Controller</code> 控制器）后，开始由 <code>HandlerAdapter</code> 适配器处理。</p>
</li>
<li><p><code>HandlerAdapter</code> 会根据 <code>Handler</code>来调用真正的处理器开处理请求，并处理相应的业务逻辑。</p>
</li>
<li><p>处理器处理完业务后，会返回一个 <code>ModelAndView</code> 对象，<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</p>
</li>
<li><p><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</p>
</li>
<li><p><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</p>
</li>
<li><p>把 <code>View</code> 返回给请求者（浏览器）</p>
<h5 id="SpringMVC-的流程"><a href="#SpringMVC-的流程" class="headerlink" title="SpringMVC 的流程"></a>SpringMVC 的流程</h5></li>
</ol>
<pre><code>![image](https://cdn.jsdelivr.net/gh/xray1025/image01/20201015152955.png)





![image](https://cdn.jsdelivr.net/gh/xray1025/image01/20201015153017.png)</code></pre>
<h2 id="Spring-框架中用到了哪些设计模式？"><a href="#Spring-框架中用到了哪些设计模式？" class="headerlink" title="Spring 框架中用到了哪些设计模式？"></a>Spring 框架中用到了哪些设计模式？</h2><ul>
<li><strong>工厂设计模式</strong> : Spring使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li>
<li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li>
<li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li>
<li><strong>包装器设计模式</strong> : 项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让可以根据客户的需求能够动态切换不同的数据源。</li>
<li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li>
<li><strong>适配器模式</strong> :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li>
</ul>
<h2 id="Spring-管理事务的方式有几种？"><a href="#Spring-管理事务的方式有几种？" class="headerlink" title="Spring 管理事务的方式有几种？"></a>Spring 管理事务的方式有几种？</h2><ul>
<li>编程式事务，在代码中硬编码。(不推荐使用)</li>
<li>声明式事务，在配置文件中配置（推荐使用） <ul>
<li>基于XML的声明式事务</li>
<li>基于注解的声明式事务 </li>
</ul>
</li>
</ul>
<h2 id="Spring-事务中的隔离级别有哪几种"><a href="#Spring-事务中的隔离级别有哪几种" class="headerlink" title="Spring 事务中的隔离级别有哪几种?"></a>Spring 事务中的隔离级别有哪几种?</h2><p><strong>TransactionDefinition 接口中定义了五个表示隔离级别的常量：</strong></p>
<ul>
<li><strong>TransactionDefinition.ISOLATION_DEFAULT:</strong> 使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.</li>
<li><strong>TransactionDefinition.ISOLATION_READ_UNCOMMITTED:</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></li>
<li><strong>TransactionDefinition.ISOLATION_READ_COMMITTED:</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li>
<li><strong>TransactionDefinition.ISOLATION_REPEATABLE_READ:</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li>
<li><strong>TransactionDefinition.ISOLATION_SERIALIZABLE:</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ul>
<h2 id="Spring-事务中哪几种事务传播行为"><a href="#Spring-事务中哪几种事务传播行为" class="headerlink" title="Spring 事务中哪几种事务传播行为?"></a>Spring 事务中哪几种事务传播行为?</h2><p><strong>支持当前事务的情况：</strong></p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_REQUIRED：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li>
<li><strong>TransactionDefinition.PROPAGATION_SUPPORTS：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li><strong>TransactionDefinition.PROPAGATION_MANDATORY：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</li>
</ul>
<p><strong>不支持当前事务的情况：</strong></p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_REQUIRES_NEW：</strong> 创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li>
<li><strong>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：</strong> 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li><strong>TransactionDefinition.PROPAGATION_NEVER：</strong> 以非事务方式运行，如果当前存在事务，则抛出异常。</li>
</ul>
<p><strong>其他情况：</strong></p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_NESTED：</strong> 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</li>
</ul>
<h2 id="Spring如何解决循环依赖"><a href="#Spring如何解决循环依赖" class="headerlink" title="Spring如何解决循环依赖"></a>Spring如何解决循环依赖</h2><h4 id="1、-循环依赖"><a href="#1、-循环依赖" class="headerlink" title="1、 循环依赖"></a>1、 循环依赖</h4><ul>
<li>循环引用：即2个或以上bean 互相持有对方，最终形成闭环。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201015150352.png" alt="img"></p>
<h4 id="2、循环依赖的场景？"><a href="#2、循环依赖的场景？" class="headerlink" title="2、循环依赖的场景？"></a>2、循环依赖的场景？</h4><p>①构造器依赖（这个解决不了，具体原因往下看）。</p>
<p>②通过setter循环依赖。（这个可以解决）。</p>
<h4 id="3-如何发现？"><a href="#3-如何发现？" class="headerlink" title="3 如何发现？"></a>3 如何发现？</h4><ul>
<li><p>spring在创建对象之前（对象还未出现）的时候，会将放在一个Set容器里，beanName为key，表示该对象正在被创建中。</p>
</li>
<li><p>如果是构造器依赖，ABC构造器循环依赖，在创建A的时候singletonsCurrentlyInCreation中有A的beanName，然后发现需要B对象，先获取B，发现B不存在，那么继续创建B，先在singletonsCurrentlyInCreation中存放B的beanName，然后发现创建B对象的时候，需要先创建C，继续查询C，发现C不存在，那么现在singletonsCurrentlyInCreation中存放C的beanName，但是创建C的时候发现需要先创建A，获取A的时候spring发现singletonsCurrentlyInCreation存在A的beanName，那么表示A当前正在被创建中，spring抛出异常。</p>
</li>
</ul>
<h4 id="4-如何解决？"><a href="#4-如何解决？" class="headerlink" title="4.如何解决？"></a>4.如何解决？</h4><p>spring的创建分为3步。</p>
<p><img src="https://www.pianshen.com/images/544/0d52e6561321baa378f949ae43fab9e0.png" alt="img"></p>
<p>①createBeanInstance：初始化对象，类似于clazz.newInstance()</p>
<p>②populateBean：填充属性，bean的对象依赖属性就是在这一步进行填充</p>
<p>③initializeBean：调用spring配置中的init-method方法</p>
<p>经过上述三步，一个spring的bean才被完全创建。setter形式的循环依赖出现在第一步跟第二步之间，所以spring在存放bean的时候做了一点文章。</p>
<p>spring将单例bean的存放利用三个hashmap作为三个级别的缓存解决循环引用问题。</p>
<h4 id="5-三级缓存"><a href="#5-三级缓存" class="headerlink" title="5 三级缓存"></a>5 三级缓存</h4><p>三级缓存源码主要是指：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Cache of singleton objects: bean name --&gt; bean instance */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;(<span class="number">256</span>);</span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name --&gt; ObjectFactory */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;String, ObjectFactory&lt;?&gt;&gt;(<span class="number">16</span>);</span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name --&gt; bean instance */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;String, Object&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<p>这三级缓存分别指：</p>
<ul>
<li>一级缓存：singletonObjects，存放完全实例化属性赋值完成的Bean，直接可以使用。</li>
<li>二级缓存：earlySingletonObjects，存放早期Bean的引用，尚未属性装配的Bean</li>
<li>三级缓存：singletonFactories，存放实例化完成的Bean工厂。</li>
</ul>
<h4 id="6-解决"><a href="#6-解决" class="headerlink" title="6 解决"></a>6 解决</h4><ul>
<li><p>bean对象填充属性的时候，先判断该bean对象是否为单例，并且是否允许提前暴露（一般都为true），如果条件都符合，则调用addSingletonFactory方法，将创建改bean对象的工厂类存存放到第三级缓存registeredSingletons中，然后如果创建过程中，该bean对象完整创建，那么该对象会被registeredSingletons移除 然后加入到一级缓存singletonObjects中。</p>
</li>
<li><p>但是如果这个时候对象创建出现了循环引用，用之前的ABC对象举例。A对象装配之前，先讲自己的对象引用存放三级缓存中registeredSingletons然后，然后发现需要对象B，调用getSingleton(B)方法，获取B的过程，先去一级缓存中查询，如果没找到，再去二级缓存，三级缓存，这个时候因为B还没有创建，所以需要创建B对象，这个时候重复之前创建A的过程，B对象先将自己的对象引用存放到registeredSingletons中 然后，装配B对象，发现这个时候需要对象C，同理，先创建C。</p>
</li>
<li><p>注意！这个时候循环引用出现了，C的创建时需要装配A的，所以利索当然的调用getSingleton(A)方法，但是之前A虽然没有创建完全，不存在一级缓存singletonObjects,但是A的对象引用存在三级缓存registeredSingletons中，C获取到A之后，讲A从三级缓存registeredSingletons中删除，移到二级缓存earlySingletonObjects中，然后C创建完成，放置一级缓存singletonObjects中，B也创建完成，放置一级缓存singletonObjects中，随后A也创建完成，放置一级缓存singletonObjects中。</p>
</li>
</ul>
<p>循环引用的问题就此解决。</p>
<h2 id="Spring容器中Bean的生命周期非常简单"><a href="#Spring容器中Bean的生命周期非常简单" class="headerlink" title="Spring容器中Bean的生命周期非常简单"></a>Spring容器中Bean的生命周期非常简单</h2><p>1.容器寻找Bean的定义信息并且将其实例化。</p>
<p>2.使用依赖注入，Spring按照Bean定义信息配置Bean的所有属性。</p>
<p>3.如果Bean实现了BeanNameAware接口，工厂调用Bean的setBeanName()方法传递Bean的ID。</p>
<p>4.如果Bean实现了BeanFactoryAware接口，工厂调用setBeanFactory()方法传入工厂自身。</p>
<p>5.如果BeanPostProcessor和Bean关联，那么它们的postProcessBeforeInitialzation()方法将被调用。</p>
<p>6.如果Bean指定了init-method方法，它将被调用。</p>
<p>7.最后，如果有BeanPsotProcessor和Bean关联，那么它们的postProcessAfterInitialization()方法将被调用。</p>
<p>到这个时候，Bean已经可以被应用系统使用了，并且将被保留在Bean Factory中知道它不再需要。有两种方法可以把它从Bean Factory中删除掉。</p>
<p>1.如果Bean实现了DisposableBean接口，destory()方法被调用。</p>
<p>2.如果指定了订制的销毁方法，就调用这个方法。</p>
<p>Bean在Spring应用上下文的生命周期与在Bean工厂中的生命周期只有一点不同，唯一不同的是，如果Bean实现了ApplicationContextAwre接口，setApplicationContext()方法被调用。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">X_ray</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://xray1025.github.io/2020/10/18/00000000.Java%E5%90%8E%E7%AB%AF%E6%B1%87%E6%80%BB/">https://xray1025.github.io/2020/10/18/00000000.Java%E5%90%8E%E7%AB%AF%E6%B1%87%E6%80%BB/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://xray1025.github.io" target="_blank">X_ray's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/10/22/Mybatis%E7%9A%84%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E5%92%8C%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Mybatis的一级缓存和二级缓存</div></div></a></div><div class="next-post pull-right"><a href="/2020/10/18/JAVA%E9%9B%86%E5%90%88/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java集合</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/11/12/0000.数据库调优/" title="数据库调优"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-12</div><div class="title">数据库调优</div></div></a></div><div><a href="/2020/10/30/000001.SpringBoot面试题/" title="SpringBoot面试题"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-30</div><div class="title">SpringBoot面试题</div></div></a></div><div><a href="/2020/10/26/EXPLAIN执行计划中要重点关注哪些要素/" title="EXPLAIN执行计划中要重点关注哪些要素"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-26</div><div class="title">EXPLAIN执行计划中要重点关注哪些要素</div></div></a></div><div><a href="/2020/10/18/JAVA集合/" title="Java集合"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-18</div><div class="title">Java集合</div></div></a></div><div><a href="/2020/10/22/Mybatis的一级缓存和二级缓存/" title="Mybatis的一级缓存和二级缓存"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-22</div><div class="title">Mybatis的一级缓存和二级缓存</div></div></a></div><div><a href="/2020/11/04/Spring、SpringMvc、MyBatis用到的设计模式/" title="Spring、SpringMVC、MyBatis用到的设计模式"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-04</div><div class="title">Spring、SpringMVC、MyBatis用到的设计模式</div></div></a></div></div></div></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/null" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">X_ray</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">105</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E8%AF%AD%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">Java语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.</span> <span class="toc-text">Java特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK%EF%BC%8C-JRE%E5%92%8CJVM%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.</span> <span class="toc-text">JDK， JRE和JVM的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">Java基本数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">1.4.</span> <span class="toc-text">包装类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.1.</span> <span class="toc-text">基本类型和包装类的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%9C-%E2%80%9D-%E5%92%8C-equals-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.</span> <span class="toc-text">“&#x3D;&#x3D;” 和 equals() 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#equals-%E4%B8%8E-hashcode-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.6.</span> <span class="toc-text">equals() 与 hashcode() 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E3%80%81StringBuilder%E3%80%81StringBuffer%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.7.</span> <span class="toc-text">String、StringBuilder、StringBuffer的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-s-%E2%80%9Chello%E2%80%9D%E5%92%8CString-s-new-String-%E2%80%9Chello%E2%80%9D-%E5%8C%BA%E5%88%AB"><span class="toc-number">1.8.</span> <span class="toc-text">String s &#x3D; “hello”和String s &#x3D; new String(“hello”);区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static%E5%92%8Cfinal%E5%8C%BA%E5%88%AB"><span class="toc-number">1.9.</span> <span class="toc-text">static和final区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%8D%A0%E7%94%A8%E5%87%A0%E4%B8%AA%E5%AD%97%E8%8A%82%EF%BC%9F"><span class="toc-number">1.10.</span> <span class="toc-text">引用类型是占用几个字节？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E4%B8%AD%E7%9A%84-switch-e-%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E6%8D%AE-JDK1-8"><span class="toc-number">1.10.1.</span> <span class="toc-text">java中的 switch(e) 选择结构可以使用数据类型的数据(JDK1.8)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6%E7%9A%84%E6%9E%84%E6%88%90%E8%A7%84%E5%88%99"><span class="toc-number">1.11.</span> <span class="toc-text">标识符的构成规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#amp-%E5%92%8C-amp-amp-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.12.</span> <span class="toc-text">&amp;和&amp;&amp;的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.13.</span> <span class="toc-text">重载和重写的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final%E3%80%81finally%E3%80%81finalize%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.14.</span> <span class="toc-text">final、finally、finalize的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">1.15.</span> <span class="toc-text">Java修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.16.</span> <span class="toc-text">抽象类和接口的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E3%80%81%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.17.</span> <span class="toc-text">泛型、反射和注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">1.18.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Error%E5%92%8CException%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.18.1.</span> <span class="toc-text">Error和Exception的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%97%E6%A3%80%E5%BC%82%E5%B8%B8%E4%B8%8E%E9%9D%9E%E5%8F%97%E6%A3%80%E5%BC%82%E5%B8%B8"><span class="toc-number">1.18.2.</span> <span class="toc-text">受检异常与非受检异常</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO"><span class="toc-number">1.19.</span> <span class="toc-text">IO</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E9%9B%86%E5%90%88"><span class="toc-number">2.</span> <span class="toc-text">Java集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList%E5%92%8CVector%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.1.</span> <span class="toc-text">ArrayList和Vector的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">ArrayList的扩容机制？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E5%92%8CHashTable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.3.</span> <span class="toc-text">HashMap和HashTable的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.4.</span> <span class="toc-text">HashMap的底层实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF2%E7%9A%84%E5%B9%82%E6%AC%A1%E6%96%B9%EF%BC%9F"><span class="toc-number">2.5.</span> <span class="toc-text">HashMap的长度为什么是2的幂次方？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentHashMap%E5%92%8CHashTable%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.6.</span> <span class="toc-text">ConcurrentHashMap和HashTable的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Comparable%E5%92%8CComparator%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.7.</span> <span class="toc-text">Comparable和Comparator接口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM"><span class="toc-number">3.</span> <span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F"><span class="toc-number">3.1.</span> <span class="toc-text">运行时数据区域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">3.1.1.</span> <span class="toc-text">程序计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-number">3.1.2.</span> <span class="toc-text">Java虚拟机栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-number">3.1.3.</span> <span class="toc-text">本地方法栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E5%A0%86"><span class="toc-number">3.1.4.</span> <span class="toc-text">Java 堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">3.1.5.</span> <span class="toc-text">方法区</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">3.1.5.1.</span> <span class="toc-text">运行时常量池</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-number">3.1.6.</span> <span class="toc-text">直接内存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Minor-GC%E5%92%8CFull-GC"><span class="toc-number">3.2.</span> <span class="toc-text">Minor GC和Full GC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Minor-GC%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="toc-number">3.2.1.</span> <span class="toc-text">Minor GC触发机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Full-GC%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="toc-number">3.2.2.</span> <span class="toc-text">Full GC触发机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8"><span class="toc-number">3.3.</span> <span class="toc-text">Java中的四种引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8"><span class="toc-number">3.3.1.</span> <span class="toc-text">强引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8"><span class="toc-number">3.3.2.</span> <span class="toc-text">软引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="toc-number">3.3.3.</span> <span class="toc-text">弱引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8"><span class="toc-number">3.3.4.</span> <span class="toc-text">虚引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E6%A0%B7%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%AD%98%E6%B4%BB"><span class="toc-number">3.4.</span> <span class="toc-text">怎样判断对象是否存活</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E4%B8%BAGC-roots%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.5.</span> <span class="toc-text">作为GC roots的几种对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-number">3.6.</span> <span class="toc-text">垃圾收集算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-number">3.6.1.</span> <span class="toc-text">标记-清除算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-number">3.6.2.</span> <span class="toc-text">复制算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="toc-number">3.6.3.</span> <span class="toc-text">标记-整理算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-number">3.6.4.</span> <span class="toc-text">分代收集算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.7.</span> <span class="toc-text">垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Serial%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.7.1.</span> <span class="toc-text">Serial收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ParNew%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.7.2.</span> <span class="toc-text">ParNew收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parallel-Scavenge%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.7.3.</span> <span class="toc-text">Parallel Scavenge收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Serial-Old%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.7.4.</span> <span class="toc-text">Serial Old收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parallel-Old%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.7.5.</span> <span class="toc-text">Parallel Old收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMS%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.7.6.</span> <span class="toc-text">CMS收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.7.7.</span> <span class="toc-text">G1收集器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5"><span class="toc-number">3.8.</span> <span class="toc-text">内存分配与回收策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%85%88%E5%9C%A8Eden%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">3.8.1.</span> <span class="toc-text">对象优先在Eden区分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E5%AF%B9%E8%B1%A1%E7%9B%B4%E6%8E%A5%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="toc-number">3.8.2.</span> <span class="toc-text">大对象直接进入老年代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%BF%E6%9C%9F%E5%AD%98%E6%B4%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="toc-number">3.8.3.</span> <span class="toc-text">长期存活的对象进入老年代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%AF%B9%E8%B1%A1%E5%B9%B4%E9%BE%84%E5%88%A4%E6%96%AD"><span class="toc-number">3.8.4.</span> <span class="toc-text">动态对象年龄判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D"><span class="toc-number">3.8.5.</span> <span class="toc-text">空间分配担保</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">3.8.6.</span> <span class="toc-text">回收方法区</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E4%B8%AD%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E7%9A%84"><span class="toc-number">3.9.</span> <span class="toc-text">Java中对象访问是如何进行的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="toc-number">3.10.</span> <span class="toc-text">JVM参数设置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">3.11.</span> <span class="toc-text">类加载机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">3.11.1.</span> <span class="toc-text">类的加载过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8A%A0%E8%BD%BD"><span class="toc-number">3.11.1.1.</span> <span class="toc-text">1.加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%AA%8C%E8%AF%81"><span class="toc-number">3.11.1.2.</span> <span class="toc-text">2.验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%87%86%E5%A4%87"><span class="toc-number">3.11.1.3.</span> <span class="toc-text">3.准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%A7%A3%E6%9E%90"><span class="toc-number">3.11.1.4.</span> <span class="toc-text">4.解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.11.1.5.</span> <span class="toc-text">5.初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E4%BD%BF%E7%94%A8"><span class="toc-number">3.11.1.6.</span> <span class="toc-text">6.使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E5%8D%B8%E8%BD%BD"><span class="toc-number">3.11.1.7.</span> <span class="toc-text">7.卸载</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">3.11.2.</span> <span class="toc-text">类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">3.11.2.1.</span> <span class="toc-text">启动类加载器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">3.11.2.2.</span> <span class="toc-text">扩展类加载器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">3.11.2.3.</span> <span class="toc-text">应用程序类加载器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">3.11.2.4.</span> <span class="toc-text">自定义加载器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.11.3.</span> <span class="toc-text">双亲委派模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">3.11.3.1.</span> <span class="toc-text">优点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#happens-before%E5%8E%9F%E5%88%99"><span class="toc-number">3.12.</span> <span class="toc-text">happens-before原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">3.12.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%88%99%E5%AE%9A%E4%B9%89"><span class="toc-number">3.12.2.</span> <span class="toc-text">原则定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%84%E5%88%99%E5%A6%82%E4%B8%8B"><span class="toc-number">3.12.3.</span> <span class="toc-text">规则如下</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%AC%A1%E5%BA%8F%E8%A7%84%E5%88%99"><span class="toc-number">3.12.3.1.</span> <span class="toc-text">程序次序规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E5%AE%9A%E8%A7%84%E5%88%99"><span class="toc-number">3.12.3.2.</span> <span class="toc-text">锁定规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile%E5%8F%98%E9%87%8F%E8%A7%84%E5%88%99"><span class="toc-number">3.12.3.3.</span> <span class="toc-text">volatile变量规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E8%A7%84%E5%88%99"><span class="toc-number">3.12.3.4.</span> <span class="toc-text">传递规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%AF%E5%8A%A8%E8%A7%84%E5%88%99"><span class="toc-number">3.12.3.5.</span> <span class="toc-text">线程启动规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E4%B8%AD%E6%96%AD%E8%A7%84%E5%88%99"><span class="toc-number">3.12.3.6.</span> <span class="toc-text">程中断规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%BB%88%E7%BB%93%E8%A7%84%E5%88%99"><span class="toc-number">3.12.3.7.</span> <span class="toc-text">线程终结规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%BB%88%E7%BB%93%E8%A7%84%E5%88%99"><span class="toc-number">3.12.3.8.</span> <span class="toc-text">对象终结规则</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-number">4.1.</span> <span class="toc-text">什么是线程死锁?如何避免死锁?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%8A%B6%E6%80%81-%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%81%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">线程的生命周期和状态?（重要！）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">4.3.</span> <span class="toc-text">多线程的特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sleep-%E6%96%B9%E6%B3%95%E5%92%8C-wait-%E6%96%B9%E6%B3%95%E5%8C%BA%E5%88%AB%E5%92%8C%E5%85%B1%E5%90%8C%E7%82%B9-%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%81%EF%BC%89"><span class="toc-number">4.4.</span> <span class="toc-text">sleep() 方法和 wait() 方法区别和共同点?（重要！）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#notify-%E5%92%8C-notifyAll%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">4.5.</span> <span class="toc-text">notify 和 notifyAll有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#yield-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">4.6.</span> <span class="toc-text">yield()方法有什么用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#join-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">4.7.</span> <span class="toc-text">join()方法有什么用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="toc-number">4.8.</span> <span class="toc-text">使用线程池的好处？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">4.9.</span> <span class="toc-text">创建线程的几种方式？（重要）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%8A%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">4.10.</span> <span class="toc-text">常见的线程池及适用场景？（重要）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-runnable-%E5%92%8C-callable-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">4.11.</span> <span class="toc-text">说一下 runnable 和 callable 有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#start-%E6%96%B9%E6%B3%95%E5%92%8Crun-%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B%E5%92%8C%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">4.12.</span> <span class="toc-text">start() 方法和run() 方法简介和区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%83%BD%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%EF%BC%9F%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">4.13.</span> <span class="toc-text">线程池都有哪几种工作队列？（重要）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0%EF%BC%9F"><span class="toc-number">4.14.</span> <span class="toc-text">线程池参数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-number">4.15.</span> <span class="toc-text">线程池ThreadPoolExecutor的工作流程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD-execute-%E5%92%8C-submit-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">4.16.</span> <span class="toc-text">线程池中 execute() 和 submit() 方法有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">4.17.</span> <span class="toc-text">synchronized 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized%E7%9A%84%E9%94%81%E5%8D%87%E7%BA%A7%E6%B5%81%E7%A8%8B%E4%B9%8B%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-number">4.17.0.1.</span> <span class="toc-text">synchronized的锁升级流程之偏向锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized%E7%9A%84%E9%94%81%E5%8D%87%E7%BA%A7%E6%B5%81%E7%A8%8B%E4%B9%8B%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">4.17.0.2.</span> <span class="toc-text">synchronized的锁升级流程之轻量级锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized%E7%9A%84%E9%94%81%E5%8D%87%E7%BA%A7%E6%B5%81%E7%A8%8B%E4%B9%8B%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">4.17.0.3.</span> <span class="toc-text">synchronized的锁升级流程之重量级锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81-%E8%BD%BB%E9%87%8F%E9%94%81%EF%BC%8C%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%AF%B9%E6%AF%94"><span class="toc-number">4.17.0.4.</span> <span class="toc-text">偏向锁,轻量锁，重量级锁的优缺点对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82synchronized-%E4%BB%8E%E5%81%8F%E5%90%91%E9%94%81%E5%88%B0%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">4.17.0.5.</span> <span class="toc-text">彻底搞懂synchronized(从偏向锁到重量级锁)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%EF%BC%9F"><span class="toc-number">4.18.</span> <span class="toc-text">什么是乐观锁和悲观锁？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">4.18.1.</span> <span class="toc-text">悲观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">4.18.2.</span> <span class="toc-text">乐观锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">4.19.</span> <span class="toc-text">自旋锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%82%E5%BA%94%E6%80%A7%E8%87%AA%E6%97%8B%EF%BC%88CAS%EF%BC%89"><span class="toc-number">4.20.</span> <span class="toc-text">适应性自旋（CAS）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized%E5%92%8C-Lock-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">4.21.</span> <span class="toc-text">synchronized和 Lock 的区别？（重要）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized%E5%92%8CReentrantLock%EF%BC%88%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%89-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">4.22.</span> <span class="toc-text">synchronized和ReentrantLock（重入锁） 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">4.23.</span> <span class="toc-text">volatile关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized-%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C-volatile-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.24.</span> <span class="toc-text">synchronized 关键字和 volatile 关键字的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFCAS"><span class="toc-number">4.25.</span> <span class="toc-text">什么是CAS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS%E7%BC%BA%E7%82%B9"><span class="toc-number">4.25.1.</span> <span class="toc-text">CAS缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFThreadLocal%E5%8F%98%E9%87%8F%EF%BC%9F"><span class="toc-number">4.26.</span> <span class="toc-text">什么是ThreadLocal变量？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Semaphore%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">4.27.</span> <span class="toc-text">Semaphore有什么作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-atomic-%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">4.28.</span> <span class="toc-text">说一下 atomic 的原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CyclicBarrier%E5%92%8CCountDownLatch%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">4.29.</span> <span class="toc-text">CyclicBarrier和CountDownLatch的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4%E5%AF%B9ReentrantReadWriteLock%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">4.30.</span> <span class="toc-text">说一说对ReentrantReadWriteLock的理解？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4Condition%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">4.31.</span> <span class="toc-text">说一说Condition的理解？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%BD%A0%E5%AF%B9exchanger%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">4.32.</span> <span class="toc-text">说一说你对exchanger的理解？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.33.</span> <span class="toc-text">生产者和消费者模型的作用是什么？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL"><span class="toc-number">5.</span> <span class="toc-text">MySQL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81MySQL%E6%9E%B6%E6%9E%84"><span class="toc-number">5.1.</span> <span class="toc-text">一、MySQL架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81MySQL-%E4%BA%8B%E5%8A%A1"><span class="toc-number">5.2.</span> <span class="toc-text">二、MySQL 事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ACID-%E2%80%94-%E4%BA%8B%E5%8A%A1%E5%9F%BA%E6%9C%AC%E8%A6%81%E7%B4%A0"><span class="toc-number">5.2.1.</span> <span class="toc-text">ACID — 事务基本要素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">5.2.2.</span> <span class="toc-text">并发事务处理带来的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%BB%E8%AF%BB%E5%92%8C%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">5.2.2.1.</span> <span class="toc-text">幻读和不可重复读的区别：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%EF%BC%9A"><span class="toc-number">5.2.2.2.</span> <span class="toc-text">并发事务处理带来的问题的解决办法：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">5.2.3.</span> <span class="toc-text">事务隔离级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%AF%94%E8%BE%83"><span class="toc-number">5.2.4.</span> <span class="toc-text">隔离级别比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81MySQL%E9%94%81%E6%9C%BA%E5%88%B6"><span class="toc-number">5.3.</span> <span class="toc-text">三、MySQL锁机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">5.3.1.</span> <span class="toc-text">锁的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyISAM-%E8%A1%A8%E9%94%81"><span class="toc-number">5.3.2.</span> <span class="toc-text">MyISAM 表锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB-%E8%A1%8C%E9%94%81"><span class="toc-number">5.3.3.</span> <span class="toc-text">InnoDB 行锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E9%94%81%E6%9C%BA%E5%88%B6"><span class="toc-number">5.3.3.1.</span> <span class="toc-text">加锁机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.3.3.2.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">5.3.4.</span> <span class="toc-text">死锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">5.4.</span> <span class="toc-text">四、存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%AF%B9%E6%AF%94"><span class="toc-number">5.4.1.</span> <span class="toc-text">存储引擎对比</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%AF%B9%E6%AF%94"><span class="toc-number">5.4.1.1.</span> <span class="toc-text">文件存储结构对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MyISAM%E5%92%8CInnoDB%E5%8C%BA%E5%88%AB"><span class="toc-number">5.4.1.2.</span> <span class="toc-text">MyISAM和InnoDB区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.5.</span> <span class="toc-text">五、数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.5.1.</span> <span class="toc-text">MySQL的数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8C%83%E5%BC%8F%E4%B8%8E%E5%8F%8D%E8%8C%83%E5%BC%8F"><span class="toc-number">5.5.2.</span> <span class="toc-text">范式与反范式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E8%8C%83%E5%BC%8F%E5%8C%96%E5%92%8C%E5%8F%8D%E8%8C%83%E5%BC%8F%E5%8C%96"><span class="toc-number">5.5.2.1.</span> <span class="toc-text">混合范式化和反范式化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E8%A1%A8%E5%92%8C%E6%B1%87%E6%80%BB%E8%A1%A8"><span class="toc-number">5.5.2.2.</span> <span class="toc-text">缓存表和汇总表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E7%B4%A2%E5%BC%95"><span class="toc-number">5.6.</span> <span class="toc-text">六、索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">5.6.1.</span> <span class="toc-text">索引的优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8A%A3%E5%8A%BF"><span class="toc-number">5.6.2.</span> <span class="toc-text">索引的劣势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB"><span class="toc-number">5.6.3.</span> <span class="toc-text">MySQL索引分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%A7%92%E5%BA%A6"><span class="toc-number">5.6.3.1.</span> <span class="toc-text">数据结构角度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E7%89%A9%E7%90%86%E5%AD%98%E5%82%A8%E8%A7%92%E5%BA%A6"><span class="toc-number">5.6.3.2.</span> <span class="toc-text">从物理存储角度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E9%80%BB%E8%BE%91%E8%A7%92%E5%BA%A6"><span class="toc-number">5.6.3.3.</span> <span class="toc-text">从逻辑角度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84"><span class="toc-number">5.6.4.</span> <span class="toc-text">MySQL索引结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#B-Tree%E7%B4%A2%E5%BC%95"><span class="toc-number">5.6.4.1.</span> <span class="toc-text">B+Tree索引</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#B-Tree"><span class="toc-number">5.6.4.1.1.</span> <span class="toc-text">B-Tree</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-Tree-1"><span class="toc-number">5.6.4.1.2.</span> <span class="toc-text">B+Tree</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#MyISAM%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E4%B8%8E%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">5.6.4.1.3.</span> <span class="toc-text">MyISAM主键索引与二级索引的结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#InnoDB%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E4%B8%8E%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">5.6.4.1.4.</span> <span class="toc-text">InnoDB主键索引与二级索引的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%EF%BC%9A"><span class="toc-number">5.6.4.1.4.1.</span> <span class="toc-text">主键索引：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%EF%BC%88%E9%9D%9E%E4%B8%BB%E9%94%AE%EF%BC%89%E7%B4%A2%E5%BC%95%EF%BC%9A"><span class="toc-number">5.6.4.1.4.2.</span> <span class="toc-text">二级（非主键）索引：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#InnoDB-%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9"><span class="toc-number">5.6.4.1.5.</span> <span class="toc-text">InnoDB 索引结构需要注意的点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hash%E7%B4%A2%E5%BC%95"><span class="toc-number">5.6.4.2.</span> <span class="toc-text">Hash索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#full-text%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95"><span class="toc-number">5.6.4.3.</span> <span class="toc-text">full-text全文索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#R-Tree%E7%A9%BA%E9%97%B4%E7%B4%A2%E5%BC%95"><span class="toc-number">5.6.4.4.</span> <span class="toc-text">R-Tree空间索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E9%9C%80%E8%A6%81%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">5.6.5.</span> <span class="toc-text">哪些情况需要创建索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8D%E8%A6%81%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">5.6.6.</span> <span class="toc-text">哪些情况不要创建索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E6%80%A7%E8%83%BD%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">5.6.7.</span> <span class="toc-text">高性能创建索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95"><span class="toc-number">5.6.7.1.</span> <span class="toc-text">列前缀索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E4%B8%AD%E7%B4%A2%E5%BC%95%E9%A1%BA%E5%BA%8F"><span class="toc-number">5.6.7.2.</span> <span class="toc-text">联合索引中索引顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">5.6.7.3.</span> <span class="toc-text">覆盖索引</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81MySQL%E6%9F%A5%E8%AF%A2"><span class="toc-number">5.7.</span> <span class="toc-text">七、MySQL查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%85%A2%E6%9F%A5%E8%AF%A2"><span class="toc-number">5.7.1.</span> <span class="toc-text">优化慢查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%95%88%E6%9E%9C%E4%B8%8E%E4%BC%98%E5%8C%96"><span class="toc-number">5.7.2.</span> <span class="toc-text">索引效果与优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E6%9E%84%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">5.7.3.</span> <span class="toc-text">重构查询的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E5%88%86%E6%9F%A5%E8%AF%A2"><span class="toc-number">5.7.3.1.</span> <span class="toc-text">切分查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E8%A7%A3%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2"><span class="toc-number">5.7.3.2.</span> <span class="toc-text">分解关联查询</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C%E7%9A%84%E5%9F%BA%E7%A1%80"><span class="toc-number">5.7.4.</span> <span class="toc-text">查询执行的基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="toc-number">5.7.4.1.</span> <span class="toc-text">查询缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%A4%84%E7%90%86"><span class="toc-number">5.7.4.2.</span> <span class="toc-text">查询优化处理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E8%A7%A3%E6%9E%90%E5%99%A8%E5%92%8C%E9%A2%84%E5%A4%84%E7%90%86"><span class="toc-number">5.7.4.2.1.</span> <span class="toc-text">语法解析器和预处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8"><span class="toc-number">5.7.4.2.2.</span> <span class="toc-text">查询优化器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%92%8C%E7%B4%A2%E5%BC%95%E7%9A%84%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF"><span class="toc-number">5.7.4.2.3.</span> <span class="toc-text">数据和索引的统计信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2"><span class="toc-number">5.7.4.2.4.</span> <span class="toc-text">如何执行关联查询</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8"><span class="toc-number">5.7.4.2.5.</span> <span class="toc-text">关联查询优化器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96"><span class="toc-number">5.7.4.2.6.</span> <span class="toc-text">排序优化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92"><span class="toc-number">5.7.4.3.</span> <span class="toc-text">查询执行计划</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E7%BB%99%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">5.7.4.4.</span> <span class="toc-text">返回结果给客户端</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%A0%E4%B8%AA%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.7.5.</span> <span class="toc-text">几个查询语句的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#count-%E5%92%8Ccount-%E5%88%97%E5%90%8D-%E6%9F%A5%E8%AF%A2"><span class="toc-number">5.7.5.0.1.</span> <span class="toc-text">count(*)和count(列名)查询</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#in%E5%92%8C-exists-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">5.7.5.0.2.</span> <span class="toc-text">in和 exists 的区别？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#UNION%E5%92%8CUNION-ALL%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.7.5.0.3.</span> <span class="toc-text">UNION和UNION ALL的区别?</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">5.7.6.</span> <span class="toc-text">SQL执行顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Join%E5%9B%BE"><span class="toc-number">5.7.7.</span> <span class="toc-text">Join图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81MySQL%E8%B0%83%E4%BC%98"><span class="toc-number">5.8.</span> <span class="toc-text">八、MySQL调优</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%B1%E5%93%8Dmysql%E7%9A%84%E6%80%A7%E8%83%BD%E5%9B%A0%E7%B4%A0"><span class="toc-number">5.8.1.</span> <span class="toc-text">影响mysql的性能因素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">5.8.2.</span> <span class="toc-text">性能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL-Query-Optimizer"><span class="toc-number">5.8.2.1.</span> <span class="toc-text">MySQL Query Optimizer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL%E5%B8%B8%E8%A7%81%E7%93%B6%E9%A2%88"><span class="toc-number">5.8.2.2.</span> <span class="toc-text">MySQL常见瓶颈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%B8%8B%E9%99%8DSQL%E6%85%A2-%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E9%95%BF-%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4%E9%95%BF-%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90"><span class="toc-number">5.8.2.3.</span> <span class="toc-text">性能下降SQL慢 执行时间长 等待时间长 原因分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL%E5%B8%B8%E8%A7%81%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%89%8B%E6%AE%B5"><span class="toc-number">5.8.2.4.</span> <span class="toc-text">MySQL常见性能分析手段</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88%E5%AE%9A%E4%BD%8D"><span class="toc-number">5.8.2.4.1.</span> <span class="toc-text">性能瓶颈定位</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Explain-%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92"><span class="toc-number">5.8.2.4.2.</span> <span class="toc-text">Explain(执行计划)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-number">5.8.2.4.3.</span> <span class="toc-text">慢查询日志</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Show-Profile-%E5%88%86%E6%9E%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">5.8.2.4.4.</span> <span class="toc-text">Show Profile 分析查询</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">5.8.3.</span> <span class="toc-text">性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96"><span class="toc-number">5.8.3.1.</span> <span class="toc-text">索引优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">5.8.3.2.</span> <span class="toc-text">查询优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BC%98%E5%8C%96"><span class="toc-number">5.8.3.3.</span> <span class="toc-text">数据类型优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E5%88%86%E5%8C%BA%E3%80%81%E5%88%86%E8%A1%A8%E3%80%81%E5%88%86%E5%BA%93"><span class="toc-number">5.9.</span> <span class="toc-text">九、分区、分表、分库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E5%88%86%E5%8C%BA"><span class="toc-number">5.9.1.</span> <span class="toc-text">MySQL分区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E5%88%86%E8%A1%A8"><span class="toc-number">5.9.2.</span> <span class="toc-text">MySQL分表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E5%88%86%E5%BA%93"><span class="toc-number">5.9.3.</span> <span class="toc-text">MySQL分库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">5.10.</span> <span class="toc-text">十、主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">5.10.1.</span> <span class="toc-text">复制的基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99"><span class="toc-number">5.10.2.</span> <span class="toc-text">复制的基本原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%9A%84%E6%9C%80%E5%A4%A7%E9%97%AE%E9%A2%98"><span class="toc-number">5.10.3.</span> <span class="toc-text">复制的最大问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98"><span class="toc-number">5.11.</span> <span class="toc-text">十一、其他问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%B8%89%E4%B8%AA%E8%8C%83%E5%BC%8F"><span class="toc-number">5.11.1.</span> <span class="toc-text">说一说三个范式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BE%E4%B8%87%E7%BA%A7%E5%88%AB%E6%88%96%E4%BB%A5%E4%B8%8A%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4"><span class="toc-number">5.11.2.</span> <span class="toc-text">百万级别或以上的数据如何删除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis"><span class="toc-number">6.</span> <span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">6.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFRedis"><span class="toc-number">6.1.1.</span> <span class="toc-text">什么是Redis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">6.1.2.</span> <span class="toc-text">Redis有哪些优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-Redis-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%BC%93%E5%AD%98"><span class="toc-number">6.1.3.</span> <span class="toc-text">为什么要用 Redis &#x2F;为什么要用缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E6%80%A7%E8%83%BD%EF%BC%9A"><span class="toc-number">6.1.3.1.</span> <span class="toc-text">高性能：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E5%B9%B6%E5%8F%91%EF%BC%9A"><span class="toc-number">6.1.3.2.</span> <span class="toc-text">高并发：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-Redis-%E8%80%8C%E4%B8%8D%E7%94%A8-map-guava-%E5%81%9A%E7%BC%93%E5%AD%98"><span class="toc-number">6.1.4.</span> <span class="toc-text">为什么要用 Redis 而不用 map&#x2F;guava 做缓存?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB"><span class="toc-number">6.1.5.</span> <span class="toc-text">Redis为什么这么快</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.2.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.2.1.</span> <span class="toc-text">Redis有哪些数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">6.2.2.</span> <span class="toc-text">Redis的应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B8%80"><span class="toc-number">6.2.3.</span> <span class="toc-text">总结一</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%BA%8C"><span class="toc-number">6.2.3.1.</span> <span class="toc-text">总结二</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">6.3.</span> <span class="toc-text">持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFRedis%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%9F"><span class="toc-number">6.3.1.</span> <span class="toc-text">什么是Redis持久化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%90%84%E8%87%AA%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">6.3.2.</span> <span class="toc-text">Redis 的持久化机制是什么？各自的优缺点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="toc-number">6.3.3.</span> <span class="toc-text">如何选择合适的持久化方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%E5%92%8C%E7%BC%93%E5%AD%98%E6%80%8E%E4%B9%88%E5%81%9A%E6%89%A9%E5%AE%B9%EF%BC%9F"><span class="toc-number">6.3.4.</span> <span class="toc-text">Redis持久化数据和缓存怎么做扩容？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E6%9C%9F%E9%94%AE%E7%9A%84%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="toc-number">6.4.</span> <span class="toc-text">过期键的删除策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E7%9A%84%E8%BF%87%E6%9C%9F%E9%94%AE%E7%9A%84%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="toc-number">6.4.1.</span> <span class="toc-text">Redis的过期键的删除策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-key%E7%9A%84%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E5%92%8C%E6%B0%B8%E4%B9%85%E6%9C%89%E6%95%88%E5%88%86%E5%88%AB%E6%80%8E%E4%B9%88%E8%AE%BE%E7%BD%AE%EF%BC%9F"><span class="toc-number">6.4.2.</span> <span class="toc-text">Redis key的过期时间和永久有效分别怎么设置？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%91%E4%BB%AC%E7%9F%A5%E9%81%93%E9%80%9A%E8%BF%87expire%E6%9D%A5%E8%AE%BE%E7%BD%AEkey-%E7%9A%84%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%EF%BC%8C%E9%82%A3%E4%B9%88%E5%AF%B9%E8%BF%87%E6%9C%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E5%91%A2"><span class="toc-number">6.4.3.</span> <span class="toc-text">我们知道通过expire来设置key 的过期时间，那么对过期的数据怎么处理呢?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3"><span class="toc-number">6.5.</span> <span class="toc-text">内存相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E9%87%8C%E6%9C%892000w%E6%95%B0%E6%8D%AE%EF%BC%8Credis%E4%B8%AD%E5%8F%AA%E5%AD%9820w%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81redis%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E9%83%BD%E6%98%AF%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE"><span class="toc-number">6.5.1.</span> <span class="toc-text">MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E7%9A%84%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">6.5.2.</span> <span class="toc-text">Redis的内存淘汰策略有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E4%B8%BB%E8%A6%81%E6%B6%88%E8%80%97%E4%BB%80%E4%B9%88%E7%89%A9%E7%90%86%E8%B5%84%E6%BA%90%EF%BC%9F"><span class="toc-number">6.5.3.</span> <span class="toc-text">Redis主要消耗什么物理资源？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E7%9A%84%E5%86%85%E5%AD%98%E7%94%A8%E5%AE%8C%E4%BA%86%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">6.5.4.</span> <span class="toc-text">Redis的内存用完了会发生什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%A6%82%E4%BD%95%E5%81%9A%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">6.5.5.</span> <span class="toc-text">Redis如何做内存优化？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.6.</span> <span class="toc-text">线程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.6.1.</span> <span class="toc-text">Redis线程模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">6.7.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1%EF%BC%9F"><span class="toc-number">6.7.1.</span> <span class="toc-text">什么是事务？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">6.7.2.</span> <span class="toc-text">Redis事务的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5"><span class="toc-number">6.7.3.</span> <span class="toc-text">Redis事务的三个阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%EF%BC%88ACID%EF%BC%89%E6%A6%82%E8%BF%B0"><span class="toc-number">6.7.4.</span> <span class="toc-text">事务管理（ACID）概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E4%BA%8B%E5%8A%A1%E6%94%AF%E6%8C%81%E9%9A%94%E7%A6%BB%E6%80%A7%E5%90%97"><span class="toc-number">6.7.5.</span> <span class="toc-text">Redis事务支持隔离性吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E4%BA%8B%E5%8A%A1%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%E5%90%97%EF%BC%8C%E6%94%AF%E6%8C%81%E5%9B%9E%E6%BB%9A%E5%90%97"><span class="toc-number">6.7.6.</span> <span class="toc-text">Redis事务保证原子性吗，支持回滚吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E4%BA%8B%E5%8A%A1%E5%85%B6%E4%BB%96%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.7.7.</span> <span class="toc-text">Redis事务其他实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88"><span class="toc-number">6.8.</span> <span class="toc-text">集群方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.8.1.</span> <span class="toc-text">哨兵模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%98%E6%96%B9Redis-Cluster-%E6%96%B9%E6%A1%88-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%B7%AF%E7%94%B1%E6%9F%A5%E8%AF%A2"><span class="toc-number">6.8.2.</span> <span class="toc-text">官方Redis Cluster 方案(服务端路由查询)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%86%E9%85%8D"><span class="toc-number">6.8.3.</span> <span class="toc-text">基于客户端分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%86%E7%89%87"><span class="toc-number">6.8.4.</span> <span class="toc-text">基于代理服务器分片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84"><span class="toc-number">6.8.5.</span> <span class="toc-text">Redis 主从架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="toc-number">6.8.5.1.</span> <span class="toc-text">redis 主从复制的核心原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B%E5%8E%9F%E7%90%86"><span class="toc-number">6.8.5.2.</span> <span class="toc-text">过程原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E9%9B%86%E7%BE%A4%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%9E%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">6.8.6.</span> <span class="toc-text">Redis集群的主从复制模型是怎样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84-redis-%E6%98%AF%E6%80%8E%E4%B9%88%E9%83%A8%E7%BD%B2%E7%9A%84%EF%BC%9F"><span class="toc-number">6.8.7.</span> <span class="toc-text">生产环境中的 redis 是怎么部署的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4Redis%E5%93%88%E5%B8%8C%E6%A7%BD%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%9F"><span class="toc-number">6.8.8.</span> <span class="toc-text">说说Redis哈希槽的概念？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E9%9B%86%E7%BE%A4%E4%BC%9A%E6%9C%89%E5%86%99%E6%93%8D%E4%BD%9C%E4%B8%A2%E5%A4%B1%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">6.8.9.</span> <span class="toc-text">Redis集群会有写操作丢失吗？为什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E9%9B%86%E7%BE%A4%E4%B9%8B%E9%97%B4%E6%98%AF%E5%A6%82%E4%BD%95%E5%A4%8D%E5%88%B6%E7%9A%84%EF%BC%9F"><span class="toc-number">6.8.10.</span> <span class="toc-text">Redis集群之间是如何复制的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E9%9B%86%E7%BE%A4%E6%9C%80%E5%A4%A7%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">6.8.11.</span> <span class="toc-text">Redis集群最大节点个数是多少？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E9%9B%86%E7%BE%A4%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9F"><span class="toc-number">6.8.12.</span> <span class="toc-text">Redis集群如何选择数据库？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%8C%BA"><span class="toc-number">6.9.</span> <span class="toc-text">分区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%EF%BC%8C%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E5%A4%9A%E6%A0%B8CPU%E7%9A%84%E5%88%A9%E7%94%A8%E7%8E%87%EF%BC%9F"><span class="toc-number">6.9.1.</span> <span class="toc-text">Redis是单线程的，如何提高多核CPU的利用率？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%81%9ARedis%E5%88%86%E5%8C%BA%EF%BC%9F"><span class="toc-number">6.9.2.</span> <span class="toc-text">为什么要做Redis分区？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93%E6%9C%89%E5%93%AA%E4%BA%9BRedis%E5%88%86%E5%8C%BA%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="toc-number">6.9.3.</span> <span class="toc-text">你知道有哪些Redis分区实现方案？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%88%86%E5%8C%BA%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">6.9.4.</span> <span class="toc-text">Redis分区有什么缺点？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%97%AE%E9%A2%98"><span class="toc-number">6.10.</span> <span class="toc-text">分布式问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">6.10.1.</span> <span class="toc-text">Redis实现分布式锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-Redis-%E7%9A%84%E5%B9%B6%E5%8F%91%E7%AB%9E%E4%BA%89-Key-%E9%97%AE%E9%A2%98"><span class="toc-number">6.10.2.</span> <span class="toc-text">如何解决 Redis 的并发竞争 Key 问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8FRedis%E6%98%AF%E5%89%8D%E6%9C%9F%E5%81%9A%E8%BF%98%E6%98%AF%E5%90%8E%E6%9C%9F%E8%A7%84%E6%A8%A1%E4%B8%8A%E6%9D%A5%E4%BA%86%E5%86%8D%E5%81%9A%E5%A5%BD%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">6.10.3.</span> <span class="toc-text">分布式Redis是前期做还是后期规模上来了再做好？为什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-RedLock"><span class="toc-number">6.10.4.</span> <span class="toc-text">什么是 RedLock</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%BC%82%E5%B8%B8"><span class="toc-number">6.11.</span> <span class="toc-text">缓存异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">6.11.1.</span> <span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">6.11.2.</span> <span class="toc-text">缓存穿透</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%84%E5%8A%A0"><span class="toc-number">6.11.3.</span> <span class="toc-text">附加</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">6.11.4.</span> <span class="toc-text">缓存击穿</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD"><span class="toc-number">6.11.5.</span> <span class="toc-text">缓存预热</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%99%8D%E7%BA%A7"><span class="toc-number">6.11.6.</span> <span class="toc-text">缓存降级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE%E5%92%8C%E5%86%B7%E6%95%B0%E6%8D%AE"><span class="toc-number">6.11.7.</span> <span class="toc-text">热点数据和冷数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%83%AD%E7%82%B9key"><span class="toc-number">6.11.8.</span> <span class="toc-text">缓存热点key</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="toc-number">6.12.</span> <span class="toc-text">常用工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E6%94%AF%E6%8C%81%E7%9A%84Java%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%AE%98%E6%96%B9%E6%8E%A8%E8%8D%90%E7%94%A8%E5%93%AA%E4%B8%AA%EF%BC%9F"><span class="toc-number">6.12.1.</span> <span class="toc-text">Redis支持的Java客户端都有哪些？官方推荐用哪个？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%92%8CRedisson%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">6.12.2.</span> <span class="toc-text">Redis和Redisson有什么关系？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Jedis%E4%B8%8ERedisson%E5%AF%B9%E6%AF%94%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">6.12.3.</span> <span class="toc-text">Jedis与Redisson对比有什么优缺点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E4%B8%8EMemcached%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.12.4.</span> <span class="toc-text">Redis与Memcached的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E6%97%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F"><span class="toc-number">6.12.5.</span> <span class="toc-text">如何保证缓存与数据库双写时的数据一致性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%B8%B8%E8%A7%81%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="toc-number">6.12.6.</span> <span class="toc-text">Redis常见性能问题和解决方案？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%AE%98%E6%96%B9%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8F%90%E4%BE%9BWindows%E7%89%88%E6%9C%AC%EF%BC%9F"><span class="toc-number">6.12.7.</span> <span class="toc-text">Redis官方为什么不提供Windows版本？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E8%83%BD%E5%AD%98%E5%82%A8%E6%9C%80%E5%A4%A7%E5%AE%B9%E9%87%8F%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">6.12.8.</span> <span class="toc-text">一个字符串类型的值能存储最大容量是多少？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%A6%82%E4%BD%95%E5%81%9A%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E6%8F%92%E5%85%A5%EF%BC%9F"><span class="toc-number">6.12.9.</span> <span class="toc-text">Redis如何做大量数据插入？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%87%E5%A6%82Redis%E9%87%8C%E9%9D%A2%E6%9C%891%E4%BA%BF%E4%B8%AAkey%EF%BC%8C%E5%85%B6%E4%B8%AD%E6%9C%8910w%E4%B8%AAkey%E6%98%AF%E4%BB%A5%E6%9F%90%E4%B8%AA%E5%9B%BA%E5%AE%9A%E7%9A%84%E5%B7%B2%E7%9F%A5%E7%9A%84%E5%89%8D%E7%BC%80%E5%BC%80%E5%A4%B4%E7%9A%84%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%B0%86%E5%AE%83%E4%BB%AC%E5%85%A8%E9%83%A8%E6%89%BE%E5%87%BA%E6%9D%A5%EF%BC%9F"><span class="toc-number">6.12.10.</span> <span class="toc-text">假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Redis%E5%81%9A%E8%BF%87%E5%BC%82%E6%AD%A5%E9%98%9F%E5%88%97%E5%90%97%EF%BC%8C%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">6.12.11.</span> <span class="toc-text">使用Redis做过异步队列吗，是如何实现的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97"><span class="toc-number">6.12.12.</span> <span class="toc-text">Redis如何实现延时队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%9B%9E%E6%94%B6%E8%BF%9B%E7%A8%8B%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F"><span class="toc-number">6.12.13.</span> <span class="toc-text">Redis回收进程如何工作的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%9B%9E%E6%94%B6%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-number">6.12.14.</span> <span class="toc-text">Redis回收使用的是什么算法？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-number">7.</span> <span class="toc-text">算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-number">8.</span> <span class="toc-text">计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#OSI%E4%B8%83%E5%B1%82%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">8.1.</span> <span class="toc-text">OSI七层体系结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E7%BB%A7%E8%AE%BE%E5%A4%87"><span class="toc-number">8.2.</span> <span class="toc-text">中继设备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%84%E5%B1%82%E6%95%B0%E6%8D%AE"><span class="toc-number">8.3.</span> <span class="toc-text">各层数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%8F%E4%B8%80%E5%B1%82%E7%9A%84%E5%8D%8F%E8%AE%AE"><span class="toc-number">8.4.</span> <span class="toc-text">每一层的协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-IP%E6%A8%A1%E5%9E%8B"><span class="toc-number">8.5.</span> <span class="toc-text">TCP&#x2F;IP模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP"><span class="toc-number">8.6.</span> <span class="toc-text">TCP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP"><span class="toc-number">8.7.</span> <span class="toc-text">UDP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">8.8.</span> <span class="toc-text">TCP三次握手</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F"><span class="toc-number">8.8.1.</span> <span class="toc-text">为什么要三次握手？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%BC%9A%E6%80%8E%E6%A0%B7%EF%BC%9F"><span class="toc-number">8.8.2.</span> <span class="toc-text">两次握手会怎样？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%97%B6%E5%8F%AF%E4%BB%A5%E6%90%BA%E5%B8%A6%E6%95%B0%E6%8D%AE%E5%90%97%EF%BC%9F"><span class="toc-number">8.8.3.</span> <span class="toc-text">三次握手时可以携带数据吗？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">8.9.</span> <span class="toc-text">TCP四次挥手</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%9B%B4%E6%8E%A5%E5%85%B3%E9%97%AD%E8%80%8C%E6%98%AF%E8%BF%9B%E5%85%A5TIME-WAIT%EF%BC%882MSL%EF%BC%89%E5%91%A2%EF%BC%9F"><span class="toc-number">8.9.0.1.</span> <span class="toc-text">为什么不直接关闭而是进入TIME_WAIT（2MSL）呢？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E5%8D%8F%E8%AE%AE%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="toc-number">8.10.</span> <span class="toc-text">TCP协议如何保证可靠传输</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">8.11.</span> <span class="toc-text">拥塞控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%85%A2%E5%90%AF%E5%8A%A8"><span class="toc-number">8.11.1.</span> <span class="toc-text">慢启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D"><span class="toc-number">8.11.2.</span> <span class="toc-text">拥塞避免</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0"><span class="toc-number">8.11.3.</span> <span class="toc-text">快速重传</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D"><span class="toc-number">8.11.4.</span> <span class="toc-text">快速恢复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%AB%AF%E5%8F%A3%E4%BB%A5%E5%8F%8A%E5%AF%B9%E5%BA%94%E6%9C%8D%E5%8A%A1"><span class="toc-number">8.11.5.</span> <span class="toc-text">常用端口以及对应服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E4%B9%8B%E5%90%8E%E6%89%A7%E8%A1%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">8.11.6.</span> <span class="toc-text">在浏览器中输入网址之后执行会发生什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IP%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">8.12.</span> <span class="toc-text">IP地址的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IP%E5%9C%B0%E5%9D%80%E4%B8%8E%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.13.</span> <span class="toc-text">IP地址与物理地址的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">8.14.</span> <span class="toc-text">GET和POST的区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GET"><span class="toc-number">8.14.0.1.</span> <span class="toc-text">GET</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#POST"><span class="toc-number">8.14.0.2.</span> <span class="toc-text">POST</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">8.15.</span> <span class="toc-text">HTTP常见的状态码有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81%EF%BC%9A"><span class="toc-number">8.15.0.1.</span> <span class="toc-text">常见的状态码：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E4%B8%AD%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">8.16.</span> <span class="toc-text">HTTP中重定向和请求转发的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E5%92%8CHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">8.17.</span> <span class="toc-text">HTTP和HTTPS的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-2-%E4%B8%8E-HTTP-1-x-%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">8.18.</span> <span class="toc-text">HTTP&#x2F;2 与 HTTP&#x2F;1.x 的主要区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E4%B8%8E%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F%EF%BC%9F"><span class="toc-number">8.19.</span> <span class="toc-text">HTTP请求报文与响应报文格式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFHTTP%E5%8D%8F%E8%AE%AE%E6%97%A0%E7%8A%B6%E6%80%81%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-number">8.20.</span> <span class="toc-text">什么是HTTP协议无状态协议？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cookie%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="toc-number">8.21.</span> <span class="toc-text">cookie和session的区别和联系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">8.21.1.</span> <span class="toc-text">Cookie的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Session%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">8.21.2.</span> <span class="toc-text">Session的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">8.21.3.</span> <span class="toc-text">区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE%E4%B8%8D%E5%90%8C"><span class="toc-number">8.21.3.1.</span> <span class="toc-text">1、存储位置不同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%AD%98%E5%82%A8%E5%AE%B9%E9%87%8F%E4%B8%8D%E5%90%8C"><span class="toc-number">8.21.3.2.</span> <span class="toc-text">2、存储容量不同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E4%B8%8D%E5%90%8C"><span class="toc-number">8.21.3.3.</span> <span class="toc-text">3、存储方式不同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E9%9A%90%E7%A7%81%E7%AD%96%E7%95%A5%E4%B8%8D%E5%90%8C"><span class="toc-number">8.21.3.4.</span> <span class="toc-text">4、隐私策略不同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E6%9C%89%E6%95%88%E6%9C%9F%E4%B8%8A%E4%B8%8D%E5%90%8C"><span class="toc-number">8.21.3.5.</span> <span class="toc-text">5、有效期上不同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8E%8B%E5%8A%9B%E4%B8%8D%E5%90%8C"><span class="toc-number">8.21.3.6.</span> <span class="toc-text">6、服务器压力不同</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTPS%E6%96%B9%E5%BC%8F%E4%B8%8Eweb%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%9A%E4%BF%A1%E7%9A%84%E6%AD%A5%E9%AA%A4%EF%BC%9F"><span class="toc-number">8.22.</span> <span class="toc-text">HTTPS方式与web服务器通信的步骤？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B8%B8%E8%A7%81HTTP%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5%EF%BC%9F"><span class="toc-number">8.23.</span> <span class="toc-text">说说常见的常见HTTP首部字段？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">9.</span> <span class="toc-text">操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="toc-number">9.0.1.</span> <span class="toc-text">僵尸进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="toc-number">9.0.2.</span> <span class="toc-text">孤儿进程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-number">9.1.</span> <span class="toc-text">一、概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="toc-number">9.1.1.</span> <span class="toc-text">基本特征</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">9.2.</span> <span class="toc-text">二、进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">9.2.1.</span> <span class="toc-text">进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">9.2.2.</span> <span class="toc-text">线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.2.3.</span> <span class="toc-text">进程和线程的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B"><span class="toc-number">9.2.4.</span> <span class="toc-text">协程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.2.5.</span> <span class="toc-text">协程和线程的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E5%88%87%E6%8D%A2"><span class="toc-number">9.2.6.</span> <span class="toc-text">进程状态的切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">9.2.7.</span> <span class="toc-text">进程调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="toc-number">9.2.7.1.</span> <span class="toc-text">1. 批处理系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%B3%BB%E7%BB%9F"><span class="toc-number">9.2.7.2.</span> <span class="toc-text">2. 交互式系统</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">9.2.8.</span> <span class="toc-text">进程间通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93-pipe"><span class="toc-number">9.2.8.1.</span> <span class="toc-text">管道(pipe)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7-signals"><span class="toc-number">9.2.8.2.</span> <span class="toc-text">信号(signals)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-message"><span class="toc-number">9.2.8.3.</span> <span class="toc-text">消息队列(message)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98-share-memory"><span class="toc-number">9.2.8.4.</span> <span class="toc-text">共享内存(share memory)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F-semaphore"><span class="toc-number">9.2.8.5.</span> <span class="toc-text">信号量(semaphore)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97-socket"><span class="toc-number">9.2.8.6.</span> <span class="toc-text">套接字(socket)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">9.2.9.</span> <span class="toc-text">进程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="toc-number">9.2.9.1.</span> <span class="toc-text">1. 临界区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5"><span class="toc-number">9.2.9.2.</span> <span class="toc-text">2. 同步与互斥</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">9.2.9.3.</span> <span class="toc-text">3. 信号量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%AE%A1%E7%A8%8B"><span class="toc-number">9.2.9.4.</span> <span class="toc-text">4. 管程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%AD%BB%E9%94%81"><span class="toc-number">9.3.</span> <span class="toc-text">三、死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%AD%BB%E9%94%81%E3%80%81%E9%A5%A5%E9%A5%BF%E3%80%81%E6%AD%BB%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.3.1.</span> <span class="toc-text">1、死锁、饥饿、死循环的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">9.3.2.</span> <span class="toc-text">2、死锁产生的必要条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%8F%91%E7%94%9F%E6%AD%BB%E9%94%81"><span class="toc-number">9.3.3.</span> <span class="toc-text">3、什么时候会发生死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E2%80%94%E2%80%94%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81"><span class="toc-number">9.3.4.</span> <span class="toc-text">4、死锁的处理——预防死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E7%A0%B4%E5%9D%8F%E4%BA%92%E6%96%A5%E6%9D%A1%E4%BB%B6"><span class="toc-number">9.3.4.1.</span> <span class="toc-text">4.1 破坏互斥条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E7%A0%B4%E5%9D%8F%E4%B8%8D%E5%89%A5%E5%A4%BA%E6%9D%A1%E4%BB%B6"><span class="toc-number">9.3.4.2.</span> <span class="toc-text">4.2 破坏不剥夺条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E7%A0%B4%E5%9D%8F%E8%AF%B7%E6%B1%82%E5%92%8C%E4%BF%9D%E6%8C%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">9.3.4.3.</span> <span class="toc-text">4.3 破坏请求和保持条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-%E7%A0%B4%E5%9D%8F%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6"><span class="toc-number">9.3.4.4.</span> <span class="toc-text">4.4 破坏循环等待条件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E2%80%94%E2%80%94%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-number">9.3.5.</span> <span class="toc-text">5、死锁的处理——避免死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="toc-number">9.3.5.1.</span> <span class="toc-text">5.2 银行家算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E2%80%94%E2%80%94%E6%A3%80%E6%B5%8B%E5%92%8C%E8%A7%A3%E9%99%A4"><span class="toc-number">9.3.6.</span> <span class="toc-text">6、死锁的处理——检测和解除</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">9.3.6.1.</span> <span class="toc-text">6.1 数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-%E6%AD%BB%E9%94%81%E7%9A%84%E8%A7%A3%E9%99%A4"><span class="toc-number">9.3.6.2.</span> <span class="toc-text">6.2 死锁的解除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">9.4.</span> <span class="toc-text">四、内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number">9.4.1.</span> <span class="toc-text">虚拟内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E4%B8%8E%E5%88%86%E6%AE%B5"><span class="toc-number">9.4.2.</span> <span class="toc-text">分页与分段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%A1%B5"><span class="toc-number">9.4.2.1.</span> <span class="toc-text">分页</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%AE%B5"><span class="toc-number">9.4.2.2.</span> <span class="toc-text">分段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F"><span class="toc-number">9.4.2.3.</span> <span class="toc-text">段页式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E4%B8%8E%E5%88%86%E6%AE%B5%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">9.4.3.</span> <span class="toc-text">分页与分段的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">9.4.4.</span> <span class="toc-text">页面置换算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86"><span class="toc-number">9.5.</span> <span class="toc-text">五、设备管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">9.5.1.</span> <span class="toc-text">磁盘调度算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring"><span class="toc-number">10.</span> <span class="toc-text">Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Spring-%E6%A1%86%E6%9E%B6"><span class="toc-number">10.1.</span> <span class="toc-text">什么是 Spring 框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E6%A8%A1%E5%9D%97"><span class="toc-number">10.2.</span> <span class="toc-text">Spring模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BC%98%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">10.3.</span> <span class="toc-text">Spring框架的优点是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IoC"><span class="toc-number">10.4.</span> <span class="toc-text">IoC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOP"><span class="toc-number">10.5.</span> <span class="toc-text">AOP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-%E4%B8%AD%E7%9A%84-bean-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">10.6.</span> <span class="toc-text">Spring 中的 bean 的作用域有哪些?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B-bean-%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">10.7.</span> <span class="toc-text">Spring 中的单例 bean 的线程安全问题了解吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Component-%E5%92%8C-Bean-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">10.8.</span> <span class="toc-text">@Component 和 @Bean 的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%A3%B0%E6%98%8E%E4%B8%BASpring%E7%9A%84-bean-%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">10.9.</span> <span class="toc-text">将一个类声明为Spring的 bean 的注解有哪些?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringMVC-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">10.10.</span> <span class="toc-text">SpringMVC 工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#SpringMVC-%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">10.10.0.0.1.</span> <span class="toc-text">SpringMVC 的流程</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%94%A8%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">10.11.</span> <span class="toc-text">Spring 框架中用到了哪些设计模式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-%E7%AE%A1%E7%90%86%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-number">10.12.</span> <span class="toc-text">Spring 管理事务的方式有几种？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-%E4%BA%8B%E5%8A%A1%E4%B8%AD%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D"><span class="toc-number">10.13.</span> <span class="toc-text">Spring 事务中的隔离级别有哪几种?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-%E4%BA%8B%E5%8A%A1%E4%B8%AD%E5%93%AA%E5%87%A0%E7%A7%8D%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA"><span class="toc-number">10.14.</span> <span class="toc-text">Spring 事务中哪几种事务传播行为?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="toc-number">10.15.</span> <span class="toc-text">Spring如何解决循环依赖</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="toc-number">10.15.0.1.</span> <span class="toc-text">1、 循环依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">10.15.0.2.</span> <span class="toc-text">2、循环依赖的场景？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A6%82%E4%BD%95%E5%8F%91%E7%8E%B0%EF%BC%9F"><span class="toc-number">10.15.0.3.</span> <span class="toc-text">3 如何发现？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">10.15.0.4.</span> <span class="toc-text">4.如何解决？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">10.15.0.5.</span> <span class="toc-text">5 三级缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E8%A7%A3%E5%86%B3"><span class="toc-number">10.15.0.6.</span> <span class="toc-text">6 解决</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E5%AE%B9%E5%99%A8%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%9D%9E%E5%B8%B8%E7%AE%80%E5%8D%95"><span class="toc-number">10.16.</span> <span class="toc-text">Spring容器中Bean的生命周期非常简单</span></a></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/01/03/0086.%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/" title="0086.分隔链表"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="0086.分隔链表"/></a><div class="content"><a class="title" href="/2021/01/03/0086.%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/" title="0086.分隔链表">0086.分隔链表</a><time datetime="2021-01-03T13:29:27.637Z" title="发表于 2021-01-03 21:29:27">2021-01-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/23/0000.Java%E6%BA%90%E7%A0%81/" title="JDK源码"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JDK源码"/></a><div class="content"><a class="title" href="/2020/12/23/0000.Java%E6%BA%90%E7%A0%81/" title="JDK源码">JDK源码</a><time datetime="2020-12-23T07:32:47.662Z" title="发表于 2020-12-23 15:32:47">2020-12-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/11/23/%E5%BF%AB%E9%80%9F%E7%90%86%E8%A7%A3%20volatile%20%E5%85%B3%E9%94%AE%E5%AD%97/" title="快速理解 volatile 关键字"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="快速理解 volatile 关键字"/></a><div class="content"><a class="title" href="/2020/11/23/%E5%BF%AB%E9%80%9F%E7%90%86%E8%A7%A3%20volatile%20%E5%85%B3%E9%94%AE%E5%AD%97/" title="快速理解 volatile 关键字">快速理解 volatile 关键字</a><time datetime="2020-11-23T11:11:08.654Z" title="发表于 2020-11-23 19:11:08">2020-11-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/11/12/0000.SpringBoot%E9%9D%A2%E8%AF%95%E9%A2%98/" title="SpringBoot面试题"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringBoot面试题"/></a><div class="content"><a class="title" href="/2020/11/12/0000.SpringBoot%E9%9D%A2%E8%AF%95%E9%A2%98/" title="SpringBoot面试题">SpringBoot面试题</a><time datetime="2020-11-12T02:46:43.400Z" title="发表于 2020-11-12 10:46:43">2020-11-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/11/12/0000.%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B0%83%E4%BC%98/" title="数据库调优"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库调优"/></a><div class="content"><a class="title" href="/2020/11/12/0000.%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B0%83%E4%BC%98/" title="数据库调优">数据库调优</a><time datetime="2020-11-12T01:51:41.182Z" title="发表于 2020-11-12 09:51:41">2020-11-12</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By X_ray</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>