<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="X_ray">


    <meta name="subtitle" content="yesterday you said tomorrow">




<title>X_ray&#39;s blog</title>



    <link rel="icon" href="/image/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.1.1"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Xray&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Xray&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title"></h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">X_ray</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">十一月 5, 2020&nbsp;&nbsp;19:05:04</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="Java语法"><a href="#Java语法" class="headerlink" title="Java语法"></a>Java语法</h1><h2 id="Java特点"><a href="#Java特点" class="headerlink" title="Java特点"></a>Java特点</h2><ul>
<li><strong>面向对象：</strong><ul>
<li>类：类是现实世界在计算机中的反映，它将数据和对这些数据的操作封装在一起。</li>
<li>对象：类的实例。</li>
<li>抽象：在定义一个类的时候，实际上就是把一类事物的公有的属性和行为提取出来，形成一个物理模型，这种研究问题的方法称为抽象。</li>
<li>封装：把对象的属性和行为（数据）结合为一个独立的整体，并尽可能隐藏对象的内部实现细节。<ul>
<li>1、通过隐藏对象的属性来保护对象的内部状态</li>
<li>2、提高代码的可用性和可维护性</li>
<li>3、禁止对象之间的不良交互来提高模块化</li>
</ul>
</li>
<li>继承：继承是从已有的类中派生出新的类称为子类，子类继承父类的数据属性和行为，并能根据自己的需求扩展出新的行为，提高了代码的复用性。</li>
<li>多态：指允许不同的对象对同一消息做出相应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式（发送消息就是函数调用）。<ul>
<li>多态存在的三个必要条件<ul>
<li>继承</li>
<li>重写</li>
<li>父类引用指向子类对象</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>健壮性：</strong>吸收C/C++语言的优点，去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等），提供了一个相对安全的内存管理和访问机制。</li>
<li><strong>跨平台性：</strong>通过Java语言编写的应用程序在不同的系统平台上都可以运行【JVM】</li>
</ul>
<h2 id="JDK，-JRE和JVM的区别"><a href="#JDK，-JRE和JVM的区别" class="headerlink" title="JDK， JRE和JVM的区别"></a>JDK， JRE和JVM的区别</h2><ul>
<li>JDK（Java Development Kid，Java 开发开源工具包），是针对 Java 开发人员的产品，是整个 Java 的核心，包括了 Java 运行环境 JRE、Java 工具和 Java 基础类库。</li>
<li>JRE（Java Runtime Environment，Java 运行环境）是运行 JAVA 程序所必须的环境的集合，包含 JVM 标准实现及 Java 核心类库。</li>
<li>JVM（Java Virtual Machine，Java 虚拟机）是整个 Java 实现跨平台的最核心的部分，能够运行以 Java 语言写作的软件程序。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018090519.png"></p>
<h2 id="Java基本数据类型"><a href="#Java基本数据类型" class="headerlink" title="Java基本数据类型"></a>Java基本数据类型</h2><p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018095519.png" alt="image-20201018095515731"></p>
<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><ul>
<li><p>让基本类型也具有对象的特征</p>
</li>
<li><p><strong>装箱</strong>：由基本数据类型构造出一个包装类的对象。</p>
</li>
<li><p><strong>拆箱</strong>：由一个包装类对象转换到相应的基本数据类型。</p>
</li>
</ul>
<h3 id="基本类型和包装类的区别"><a href="#基本类型和包装类的区别" class="headerlink" title="基本类型和包装类的区别"></a>基本类型和包装类的区别</h3><ol>
<li>声明方式不同：基本类型不使用new关键字，而包装类型需要使用new关键字来在<strong>堆中分配存储空间</strong>；</li>
<li>存储方式及位置不同：基本类型是直接将变量值存储在栈中，而包装类型是将对象放在堆中，然后通过引用来使用；</li>
<li>初始值不同：基本类型的初始值如int为0，boolean为false，而包装类型的初始值为null；</li>
<li>使用方式不同：基本类型直接赋值直接使用就好，而包装类型在集合如Collection、Map时会使用到。</li>
</ol>
<h2 id="“-”-和-equals-的区别"><a href="#“-”-和-equals-的区别" class="headerlink" title="“==” 和 equals() 的区别"></a>“==” 和 equals() 的区别</h2><ul>
<li>对于基本数据类型的变量，只能使用 == 判断值是否相等，不能使用equals();</li>
<li>对于引用数据类型，<ul>
<li>如果没有对 equals() 进行重写，== 和equals() 比较的都是引用类型的变量所指向的对象的地址；</li>
<li>诸如String、Date等类对equals方法进行了重写的话，equals() 比较的是所指向的对象的内容。</li>
</ul>
</li>
</ul>
<h2 id="equals-与-hashcode-的区别"><a href="#equals-与-hashcode-的区别" class="headerlink" title="equals() 与 hashcode() 的区别"></a>equals() 与 hashcode() 的区别</h2><ul>
<li>equals()相等的两个对象他们的hashCode()肯定相等。</li>
<li>hashCode()相等的两个对象他们的equals()不一定相等。</li>
</ul>
<h2 id="String、StringBuilder、StringBuffer的区别"><a href="#String、StringBuilder、StringBuffer的区别" class="headerlink" title="String、StringBuilder、StringBuffer的区别"></a>String、StringBuilder、StringBuffer的区别</h2><table>
<thead>
<tr>
<th>String</th>
<th>StringBuffer</th>
<th>StringBuilder</th>
</tr>
</thead>
<tbody><tr>
<td>String的值是不可变的，这就导致每次对String的操作都会生成新的String对象，不仅效率低下，而且浪费大量优先的内存空间</td>
<td>StringBuffer是可变类，和线程安全的字符串操作类，任何对它指向的字符串的操作都不会产生新的对象。每个StringBuffer对象都有一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会自动增加容量</td>
<td>可变类，速度更快</td>
</tr>
<tr>
<td>不可变</td>
<td>可变</td>
<td>可变</td>
</tr>
<tr>
<td></td>
<td>线程安全</td>
<td>线程不安全</td>
</tr>
</tbody></table>
<h2 id="String-s-“hello”和String-s-new-String-“hello”-区别"><a href="#String-s-“hello”和String-s-new-String-“hello”-区别" class="headerlink" title="String s = “hello”和String s = new String(“hello”);区别"></a>String s = “hello”和String s = new String(“hello”);区别</h2><ul>
<li><p><code>String s = &quot;hello&quot;</code>，JVM会直接检查字符串常量池是否已有”hello”字符串对象，如没有，就分配一个内存存放”hello”，如果有，则直接将字符串常量池中的地址返回给栈。(没有new，没有堆的操作)</p>
</li>
<li><p><code>String s = new String(&quot;hello&quot;);</code>可能创建两个对象也可能创建一个对象。如果常量池中有<code>hello</code>字符串常量的话，则仅仅在堆中创建一个对象。如果常量池中没有<code>hello</code>对象，则堆上和常量池都需要创建。</p>
</li>
</ul>
<h2 id="static和final区别"><a href="#static和final区别" class="headerlink" title="static和final区别"></a>static和final区别</h2><table>
<thead>
<tr>
<th align="left">关键词</th>
<th align="left">修饰物</th>
<th align="left">影响</th>
</tr>
</thead>
<tbody><tr>
<td align="left">final</td>
<td align="left">变量</td>
<td align="left">分配到常量池中，程序不可改变其值（引用变量不能变，引用对象可以变）</td>
</tr>
<tr>
<td align="left">final</td>
<td align="left">方法</td>
<td align="left">子类中将不能被重写</td>
</tr>
<tr>
<td align="left">final</td>
<td align="left">类</td>
<td align="left">不能被继承</td>
</tr>
<tr>
<td align="left">static</td>
<td align="left">变量</td>
<td align="left">分配在内存堆上，引用都会指向这一个地址而不会重新分配内存</td>
</tr>
<tr>
<td align="left">static</td>
<td align="left">方法块</td>
<td align="left">虚拟机优先加载</td>
</tr>
<tr>
<td align="left">static</td>
<td align="left">类</td>
<td align="left">可以直接通过类来调用而不需要new</td>
</tr>
</tbody></table>
<h2 id="引用类型是占用几个字节？"><a href="#引用类型是占用几个字节？" class="headerlink" title="引用类型是占用几个字节？"></a>引用类型是占用几个字节？</h2><p>hotspot在64位平台上，占8个字节，在32位平台上占4个字节。</p>
<h3 id="java中的-switch-e-选择结构可以使用数据类型的数据-JDK1-8"><a href="#java中的-switch-e-选择结构可以使用数据类型的数据-JDK1-8" class="headerlink" title="java中的 switch(e) 选择结构可以使用数据类型的数据(JDK1.8)"></a>java中的 switch(e) 选择结构可以使用数据类型的数据(JDK1.8)</h3><ul>
<li><p>在switch（e）中，e只能是一个整数表达式或者枚举常量（更大字体），整数表达式可以是int基本类型或Integer包装类型，由于byte,short,char都可以隐含转换为int，所以，这些类型以及这些类型的包装类型也是可以的。显然，boolean、double和long类型都不符合switch的语法规定，并且不能被隐式转换成int类型，所以，它们不能作用于swtich语句中。</p>
</li>
<li><p>1.7后支持String。</p>
</li>
<li><p>基本类型中，没有<code>boolean</code>和<code>浮点类型</code>+<code>长类型long</code>及其相应的包装类型。外加<code>String</code>和<code>enum</code>。</p>
</li>
</ul>
<h2 id="标识符的构成规则"><a href="#标识符的构成规则" class="headerlink" title="标识符的构成规则"></a>标识符的构成规则</h2><ul>
<li>标识符由数字（0<del>9）和字母（A</del>Z 和 a~z）、美元符号（$）和下划线（_）组合构成。</li>
<li>标识符不能使用数字作为第一个字符。</li>
<li>标识符不能是java的关键字和保留字，但可以包含关键字和保留字，不能包含空格</li>
<li>标识符不允许单独使用下划线作为分隔符。</li>
</ul>
<h2 id="amp-和-amp-amp-的区别"><a href="#amp-和-amp-amp-的区别" class="headerlink" title="&amp;和&amp;&amp;的区别"></a>&amp;和&amp;&amp;的区别</h2><ul>
<li>逻辑与，用&amp;连接的两个条件的最后结果计算第一个表达式为false也会计算第二个表达式</li>
<li>短路与，如果第一个表达式为false整个表达式直接为false跳过第二个判断表达式</li>
</ul>
<h2 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h2><ul>
<li><p>重载 Overload：表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）。</p>
</li>
<li><p>重写 Override：表示子类中的方法覆盖父类中的方法</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018092249.png"></p>
<h2 id="final、finally、finalize的区别"><a href="#final、finally、finalize的区别" class="headerlink" title="final、finally、finalize的区别"></a>final、finally、finalize的区别</h2><ul>
<li>final用于声明属性、方法和类，分别表示属性不可变、方法不可覆盖、类不可被继承（不能再派生出新的子类）</li>
<li>finally作为异常处理的一部分，它只能用在try/catch语句中，并且附带着一个语句块，表示这段语句最终一定被执行，经常被用在需要释放资源的情况下。</li>
<li>finalize是Object类中的一个方法，一旦垃圾回收器准备好释放对象占用的空间，将首先调用其 finalize() 方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。</li>
</ul>
<h2 id="Java修饰符"><a href="#Java修饰符" class="headerlink" title="Java修饰符"></a>Java修饰符</h2><table>
<thead>
<tr>
<th><strong>访问级别</strong></th>
<th><strong>访问控制修饰符</strong></th>
<th><strong>同类</strong></th>
<th><strong>同包</strong></th>
<th><strong>子类(不同包)</strong></th>
<th><strong>不同包(其他类)</strong></th>
</tr>
</thead>
<tbody><tr>
<td>公共</td>
<td>public</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>受保护</td>
<td>protected</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
<td>✖</td>
</tr>
<tr>
<td>默认</td>
<td>default</td>
<td>✔</td>
<td>✔</td>
<td>✖</td>
<td>✖</td>
</tr>
<tr>
<td>私有</td>
<td>private</td>
<td>✔</td>
<td>✖</td>
<td>✖</td>
<td>✖</td>
</tr>
</tbody></table>
<h2 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h2><ul>
<li><p>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</p>
</li>
<li><p>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。</p>
</li>
<li><p>抽象类是可以有静态代码块和静态方法，接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)。</p>
</li>
<li><p>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p>
</li>
</ul>
<h2 id="泛型、反射和注解"><a href="#泛型、反射和注解" class="headerlink" title="泛型、反射和注解"></a>泛型、反射和注解</h2><ul>
<li>泛型类型是通过类型参数化的泛型类或接口。数据类型是数据的参数化，而泛型就是数据类型的参数化，来解决程序的通用性设计和实现的若干问题。</li>
<li>反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</li>
<li>注解的本质就是一个继承了 Annotation 接口的接口，注解是代码里的特殊标记，这些标记可以在编译，类加载，运行时被读取，并执行相应的处理。<ul>
<li>元注解：注解的注解，分别有@Retention、 @Target、 @Document、 @Inherited和@Repeatable（JDK1.8加入）五种。</li>
<li>JDK注解：<ul>
<li>@Override 它是用来描述当前方法是一个重写的方法，在编译阶段对方法进行检查 jdk1.5中它只能描述继承中的重写，jdk1.6中它可以描述接口实现的重写,也能描述类的继承的重写  </li>
<li>@Deprecated 它是用于描述当前方法是一个过时的方法 </li>
<li>@SuppressWarnings 对程序中的警告去除。 </li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018101623.png"></p>
<h3 id="Error和Exception的区别"><a href="#Error和Exception的区别" class="headerlink" title="Error和Exception的区别"></a>Error和Exception的区别</h3><ul>
<li><p>Error，指程序中无法处理的错误，表示运行应用程序中出现了严重的错误。</p>
</li>
<li><p>Exception，程序本身可以捕获并且可以处理的异常。</p>
<ul>
<li><p>运行时异常</p>
<ul>
<li><p><strong>定义</strong>：RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。</p>
</li>
<li><p><strong>特点</strong>：Java 编译器不会检查它。也就是说，当程序中可能出现这类异常时，倘若既”没有通过throws声明抛出它”，也”没有用try-catch语句捕获它”，还是会编译通过。</p>
</li>
</ul>
</li>
<li><p>编译时异常</p>
<ul>
<li><p><strong>定义</strong>: Exception 中除 RuntimeException 及其子类之外的异常。</p>
</li>
<li><p><strong>特点</strong>: Java 编译器会检查它。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="受检异常与非受检异常"><a href="#受检异常与非受检异常" class="headerlink" title="受检异常与非受检异常"></a>受检异常与非受检异常</h3><ul>
<li><p>受检异常</p>
<ul>
<li>编译器要求必须处理的异常。正确的程序在运行过程中，经常容易出现的、符合预期的异常情况。一旦发生此类异常，就必须采用某种方式进行处理。</li>
<li><strong>除 RuntimeException 及其子类外，其他的 Exception 异常都属于受检异常</strong>。</li>
</ul>
</li>
<li><p>非受检异常</p>
<ul>
<li>编译器不会进行检查并且不要求必须处理的异常。</li>
<li><strong>该类异常包括运行时异常（RuntimeException极其子类）和错误（Error）。</strong></li>
</ul>
</li>
</ul>
<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018103150.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018103200.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018103228.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018103300.png"></p>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><ul>
<li><p><strong>拥有资源</strong></p>
<ul>
<li>进程是资源分配的基本单位，但是线程不拥有资源（除了一点必不可少的资源），线程可以访问隶属进程的系统资源</li>
<li>如果线程也拥有资源，则切换线程就需要较大的时空开销，线程的概念就没有意义了</li>
</ul>
</li>
<li><p>调度</p>
<ul>
<li>传统操作系统中拥有资源和独立调度的基本单位都是进程</li>
<li>引入线程后，线程是独立调度的基本单位，进程是拥有资源的基本单位</li>
<li>在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</li>
</ul>
</li>
<li><p><strong>系统开销</strong></p>
<ul>
<li>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。</li>
<li>类似地，在进行<strong>进程切换时</strong>，涉及当前<strong>执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置（即，Context）</strong>，而<strong>线程切换时</strong>只需<strong>保存和设置少量寄存器内容</strong>，开销很小</li>
<li>同一个进程内的多个线程共享进程的地址空间，因此这些线程间同步与通信非常容易，甚至无须操作系统的干预</li>
</ul>
</li>
<li><p>并发性：</p>
<ul>
<li>引入线程后，不仅进程间可以并发执行，而且多个线程之间也可以并发执行，提高了并发性和吞吐量</li>
</ul>
</li>
</ul>
<h2 id="进程状态的切换"><a href="#进程状态的切换" class="headerlink" title="进程状态的切换"></a>进程状态的切换</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1599655539465-7c6412b9-cf1c-41eb-98c2-631439893c16.png" alt="image.png"></p>
<ul>
<li>就绪状态（ready）：进程获取了除处理器以外的一切所需资源，等待被调度，多个处于就绪状态的进程拍成就绪队列</li>
<li>运行状态（running）：进程正在处理器上运行</li>
<li>阻塞状态（waiting）：等待某资源为可用</li>
<li>创建态（created）：进程正在被创建，尚未转到就绪态</li>
<li>结束态（terminated）：进程正从系统消失，可能是进程正常结束或其他原因中断退出运行</li>
</ul>
<p>应该注意以下内容：</p>
<ul>
<li>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li>
<li>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</li>
</ul>
<h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><h3 id="1-批处理系统"><a href="#1-批处理系统" class="headerlink" title="1. 批处理系统"></a>1. 批处理系统</h3><ul>
<li>批处理系统在很老的计算机时使用，没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）</li>
</ul>
<p><strong>1.1 先来先服务 first-come first-serverd（FCFS）</strong></p>
<ul>
<li>非抢占式的调度算法，按照请求的顺序进行调度</li>
<li><strong>有利于长作业，但不利于短作业</strong>，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长</li>
</ul>
<p><strong>1.2 短作业优先 shortest job first（SJF）</strong></p>
<ul>
<li>非抢占式的调度算法，按估计运行时间最短的顺序进行调度</li>
<li><strong>长作业有可能会饿死</strong>，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度</li>
</ul>
<p><strong>1.3 高响应比优先</strong> </p>
<ul>
<li>高响应比优先调度算法是FCFS和SJF的综合平衡，每次进行作业调度时，先计算后备作业队列中每个作业的响应比，从中选出响应比最高的作业投入运行</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1599725265351-ac1b4730-41f4-45af-ab73-a8e3bf6ae880.png" alt="image.png"></li>
<li>要求服务时间短，响应比高，有利于短作业</li>
<li>等待时间长，响应比高，不会出现长作业饿死的情况</li>
</ul>
<h3 id="2-交互式系统"><a href="#2-交互式系统" class="headerlink" title="2. 交互式系统"></a>2. 交互式系统</h3><p><strong>2.1 时间片轮转</strong></p>
<p><strong>2.2 优先级调度</strong></p>
<p><strong>2.3 多级反馈队列</strong></p>
<ul>
<li>多级队列是为这种需要连续执行多个时间片的进程考虑，<strong>设置了多个队列，每个队列时间片大小都不同</strong>，例如 1,2,4,8,..。<strong>进程在第一个队列没执行完，就会被移到下一个队列</strong>。这种方式下，之前的进程只需要交换 7 次</li>
<li><strong>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列中的进程</strong></li>
<li>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合</li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁、饥饿、死循环的区别"><a href="#死锁、饥饿、死循环的区别" class="headerlink" title="死锁、饥饿、死循环的区别"></a>死锁、饥饿、死循环的区别</h3><ul>
<li><p>死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。至少有两个进程或以上同时发生死锁。</p>
</li>
<li><p>饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。</p>
</li>
<li><p>死循环：某进程执行过程中一直跳不出某个循环的现象。</p>
</li>
</ul>
<h3 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h3><ul>
<li>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁（如哲学家的筷子、打印机设备）。</li>
<li>不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</li>
<li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。（有了一个，还想要另一个，但是自己原来那个不放手。）</li>
<li>循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</li>
</ul>
<h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><p>用Available向量表示系统当前的可用资源数。</p>
<p>试分配：</p>
<p>在某一时刻，进程提出资源申请，系统首先检查申请的资源数是否超过进程的最大需求量。</p>
<p>不超过，则检查是否超过当前可用的资源数。</p>
<p>如果都不超过，则试着分配给该进程。</p>
<p>然后用安全性算法检查此次分配是否会导致系统进入不安全状态。</p>
<p>安全性算法简单理解：系统当前剩余的资源数超过了某个进程的Need向量，就把该进程加入安全序列，并将Allocation添加到Available，不断循环此过程，看最终能否让所有进程都加入安全序列，如果可以，此次分配时安全的，系统开始分配。</p>
<p>注意：处于安全状态一定不会死锁，死锁一定处于不安全状态，处于不安全状态不一定会死锁。</p>
<h2 id="分页与分段的比较"><a href="#分页与分段的比较" class="headerlink" title="分页与分段的比较"></a>分页与分段的比较</h2><ul>
<li>对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段</li>
<li>地址空间的维度：分页是一维地址空间，分段是二维的</li>
<li>大小是否可以改变：页的大小不可变，段的大小可以动态改变</li>
<li>出现的原因：<strong>分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护</strong></li>
</ul>
<h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><p><strong>页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）</strong></p>
<ol>
<li><strong>最佳（OPT, Optimal replacement algorithm）</strong></li>
</ol>
<ul>
<li>所<strong>选择的被换出的页面在未来最长时间内不再被访问</strong>，通常可以保证获得最低的缺页率。</li>
<li>是一种<strong>理论上的算法</strong>，因为无法知道一个页面多长时间不再被访问。</li>
</ul>
<ol start="2">
<li><p><strong>最近最久未使用（LRU, Least Recently Used）</strong></p>
</li>
<li><p><strong>最近未使用（NRU, Not Recently Used）</strong></p>
</li>
</ol>
<ul>
<li><p>每个页面都有两个状态位：R 与 M，<strong>当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1</strong>。其中 R 位会定时被清零。可以将页面分成以下四类：</p>
</li>
<li><ul>
<li><p>R=0，M=0 </p>
<pre><code>- R=0，M=1
- R=1，M=0
- R=1，M=1</code></pre>
</li>
</ul>
</li>
<li><p>当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。</p>
</li>
<li><p><strong>NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）</strong>。</p>
</li>
</ul>
<ol start="4">
<li><strong>先进先出（FIFO, First In First Out）</strong></li>
</ol>
<ul>
<li>选择换出的页面是最先进入的页面。<ul>
<li><strong>该算法会将那些经常被访问的页面换出，导致缺页率升高</strong>。</li>
</ul>
</li>
</ul>
<ol start="5">
<li><strong>第二次机会算法</strong></li>
</ol>
<ul>
<li><strong>FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：</strong><ul>
<li><strong>当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。</strong></li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1597061941454-03800959-859a-4877-abfd-27c39e401945.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image.png"></li>
</ul>
</li>
</ul>
<ol start="6">
<li><strong>时钟（Clock）</strong></li>
</ol>
<ul>
<li>第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。<ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1597062565754-826091ad-7dc4-4c83-943d-343b7bd7bdac.png" alt="image.png"></li>
</ul>
</li>
</ul>
<h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><ul>
<li><p>读写一个磁盘块的时间的影响因素有：</p>
</li>
<li><ul>
<li>旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）<pre><code>- 寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）
- 实际的数据传输时间</code></pre>
</li>
</ul>
</li>
<li><p>其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p>
<ul>
<li><p>先来先服务（FCFS, First Come First Served） </p>
</li>
<li><p>最短寻道时间优先（SSTF, Shortest Seek Time First）</p>
</li>
<li><p>电梯算法（SCAN） </p>
<ul>
<li>电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</li>
<li>电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。</li>
<li>因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。</li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>

        
            <section class="post-copyright">
                
                
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>年与时驰，意与日去，遂成枯落，多不接世，悲守穷庐，将复何及</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2020/11/10/%E5%89%91%E6%8C%87Offer52.%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/">剑指Offer52.两个链表的第一个公共节点.md</a>
            
            
            <a class="next" rel="next" href="/2020/11/04/Spring%E3%80%81SpringMvc%E3%80%81MyBatis%E7%94%A8%E5%88%B0%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">Spring、SpringMVC、MyBatis用到的设计模式</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© X_ray | Powered by <a href="https://xray1025.top" target="_blank">Xray</a></span>
    </div>
</footer>

    </div>
</body>
</html>
