<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="X_ray">


    <meta name="subtitle" content="yesterday you said tomorrow">




<title>JVM | X_ray&#39;s blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.1.1"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Xray&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/categories">Categories</a>
                
                    <a class="menu-item" href="/tags">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Xray&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/categories">Categories</a>
                
                    <a class="menu-item" href="/tags">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">JVM</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">X_ray</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">九月 2, 2020&nbsp;&nbsp;16:33:01</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Java/">Java</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><ul>
<li>JVM是可运行Java代码的假想计算机，组成部分包括：堆、方法区、栈、本地方法栈和程序计数器。其中，堆和方法区是共享区，栈、本地方法栈和程序计数器是线程私有的。</li>
</ul>
<a id="more"></a>

<ul>
<li>Java运行过程：<ul>
<li>源文件通过编译器编译为.class字节码文件，字节码文件通过JVM中的解释器解释成特定机器上的字节码文件</li>
</ul>
</li>
</ul>
<h2 id="1-线程"><a href="#1-线程" class="headerlink" title="1 线程"></a>1 线程</h2><p><strong>JVM的系统线程主要有：</strong></p>
<ul>
<li>虚拟机栈</li>
<li>周期性任务线程：负责定时器事件（中断），用来调度周期性操作的执行</li>
<li>GC线程：负责JVM中的垃圾回收</li>
<li>编译器线程：在运行时将字节码动态的编译成本地平台相关的机器码</li>
<li>信号分发线程：负责接收发送到JVM的信号并调用适当的JVM方法处理</li>
</ul>
<h2 id="2-JVM内存区域"><a href="#2-JVM内存区域" class="headerlink" title="2 JVM内存区域"></a>2 JVM内存区域</h2><h3 id="2-1-程序计数器"><a href="#2-1-程序计数器" class="headerlink" title="2.1 程序计数器"></a>2.1 程序计数器</h3><ul>
<li>当前线程所执行的字节码的行号指示器，占用内存空间较小，没有规定OutOfMemoryError</li>
</ul>
<h3 id="2-2-栈"><a href="#2-2-栈" class="headerlink" title="2.2 栈"></a>2.2 栈</h3><ul>
<li>描述java方法的内存模型，每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用到执行完成的过程，都对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</li>
<li>栈帧是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接、方法返回值和异常分派。</li>
</ul>
<h3 id="2-3-本地方法栈"><a href="#2-3-本地方法栈" class="headerlink" title="2.3 本地方法栈"></a>2.3 本地方法栈</h3><p>为Native方法服务</p>
<h3 id="2-4-堆"><a href="#2-4-堆" class="headerlink" title="2.4 堆"></a>2.4 堆</h3><ul>
<li>线程共享，</li>
<li>创建的对象和数组都保存在Java堆内存中，也是垃圾收集器进行垃圾收集的最重要的内存区域</li>
<li>根据分代收集算法，可以细分为：新生代（Eden、SurvivorFrom、ServivorTo）和老年代</li>
</ul>
<h3 id="2-5-方法区"><a href="#2-5-方法区" class="headerlink" title="2.5 方法区"></a>2.5 方法区</h3><p>即永久代（Permanent Generation），用于储存被Java加载的类信息、常量、静态常量、即时编译器编译后的代码等数据。</p>
<p>运行时常量池（Runtime Constant Pool）是方法区的一部分，负责存放Class文件中的常量池</p>
<h2 id="3-Java运行时内存"><a href="#3-Java运行时内存" class="headerlink" title="3 Java运行时内存"></a>3 Java运行时内存</h2><h3 id="3-1-新生代"><a href="#3-1-新生代" class="headerlink" title="3.1 新生代"></a>3.1 新生代</h3><ul>
<li>用来存放新生的对象，占堆1/3的空间</li>
<li>新生代分为<ul>
<li>Eden区</li>
<li>ServivorFrom</li>
<li>ServivorTo</li>
</ul>
</li>
<li>MinorGC：<ul>
<li>Eden内存不够时触发</li>
<li>频繁执行</li>
<li>采用复制算法</li>
<li>过程：<ul>
<li>将Eden、ServivorFrom复制到Servivor，并将年龄+1（如果年龄达到老年区的标准，则赋值到老年区）</li>
<li>清空Eden、ServivorFrom</li>
<li>将ServivorTo和ServivorFrom互换</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-2-老年代"><a href="#3-2-老年代" class="headerlink" title="3.2 老年代"></a>3.2 老年代</h3><ul>
<li>主要存放应用程序中生命周期长的内存对象</li>
<li>MajorGC：<ul>
<li>老年代空间不够时触发</li>
<li>不会频繁执行</li>
<li>采用标记清除算法：<ul>
<li>扫描一次所有老年代，标记出存活的的对象，然后回收没有标记的对象</li>
<li>耗时比较长</li>
<li>会产生内存碎片</li>
<li>老年代满时，跑出OOM（out of memory）异常</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-3-永久代"><a href="#3-3-永久代" class="headerlink" title="3.3 永久代"></a>3.3 永久代</h3><ul>
<li><p>内存的永久保存区域，主要存放Class和Meta的信息</p>
</li>
<li><p>GC不会在主程序运行期对永久代进行清理</p>
</li>
<li><p>Java 8 中，永久代已经被移除，被一个元数据区（元空间）取代</p>
<ul>
<li>元空间并不在虚拟机中，而是使用本地内存</li>
</ul>
</li>
</ul>
<h2 id="4-垃圾回收算法"><a href="#4-垃圾回收算法" class="headerlink" title="4 垃圾回收算法"></a>4 垃圾回收算法</h2><h3 id="4-1-如何确定垃圾"><a href="#4-1-如何确定垃圾" class="headerlink" title="4.1 如何确定垃圾"></a>4.1 如何确定垃圾</h3><h4 id="4-1-1-引用计数法"><a href="#4-1-1-引用计数法" class="headerlink" title="4.1.1 引用计数法"></a>4.1.1 引用计数法</h4><ul>
<li>一个对象如果没有任何与之关联的引用，即它们的引用计数都不为0，则说明对象不太可能再被用到，那么这个对象就是可回收对象</li>
</ul>
<h4 id="4-1-2-可达性分析"><a href="#4-1-2-可达性分析" class="headerlink" title="4.1.2 可达性分析"></a>4.1.2 可达性分析</h4><ul>
<li>为了解决引用计数法的循环引用问题，通过一系列的GC root作为搜索起点，如果在GC root和一个对象之间没有可达路径，则称该对象是不可达的</li>
<li>不可达对象经过两次标记后仍不可达，则为可回收对象</li>
</ul>
<h3 id="4-2-标记清除算法（Mark-Sweep）"><a href="#4-2-标记清除算法（Mark-Sweep）" class="headerlink" title="4.2 标记清除算法（Mark-Sweep）"></a>4.2 标记清除算法（Mark-Sweep）</h3><ul>
<li><strong>标记：</strong>标记处所有需要回收的对象</li>
<li><strong>清除：</strong>回收所有被标记的对象所占用的空间</li>
<li>弊端：内存碎片化严重</li>
</ul>
<h3 id="4-3-复制算法（copying）"><a href="#4-3-复制算法（copying）" class="headerlink" title="4.3 复制算法（copying）"></a>4.3 复制算法（copying）</h3><ul>
<li>按内存容量将内存划分为等大小的两块，每次只使用其中一块，当前内存满后将其尚存活的对象复制到另一块上，把已使用的内存回收</li>
<li>实现简单，内存效率高</li>
<li>可用内存被压缩到一半</li>
<li>存活对象增多时，算法效率大大降低</li>
</ul>
<h3 id="4-4-标记整理算法（Mark-Compact）"><a href="#4-4-标记整理算法（Mark-Compact）" class="headerlink" title="4.4 标记整理算法（Mark-Compact）"></a>4.4 标记整理算法（Mark-Compact）</h3><ul>
<li>标记</li>
<li>将存活对象移向内存的一端，然后清除边界外的对象</li>
</ul>
<h3 id="4-5-分代收集算法"><a href="#4-5-分代收集算法" class="headerlink" title="4.5 分代收集算法"></a>4.5 分代收集算法</h3><ul>
<li>主流收集算法</li>
<li>新生代：每次垃圾回收时都有大量垃圾需要被回收<ul>
<li>复制算法</li>
</ul>
</li>
<li>老年代：每次垃圾回收时只有少量对象需要被回收<ul>
<li>标记整理算法</li>
</ul>
</li>
</ul>
<h2 id="5-Java四种引用类型"><a href="#5-Java四种引用类型" class="headerlink" title="5 Java四种引用类型"></a>5 Java四种引用类型</h2><ul>
<li>强引用<ul>
<li>把一个对象赋值给一个引用变量即是强引用</li>
<li>处于可达状态，不可被回收</li>
<li>容易造成内存泄漏</li>
</ul>
</li>
<li>软引用<ul>
<li>SoftReference类</li>
<li>系统内存不足时即被回收</li>
</ul>
</li>
<li>弱引用<ul>
<li>WeakReference类</li>
<li>只要垃圾回收机制一运行即被回收</li>
</ul>
</li>
<li>虚引用<ul>
<li>PhantomReference类</li>
<li>必须和引用队列联合使用</li>
<li>主要用来跟踪对象呗垃圾回收的状态</li>
</ul>
</li>
</ul>
<h2 id="6-分区收集算法"><a href="#6-分区收集算法" class="headerlink" title="6 分区收集算法"></a>6 分区收集算法</h2><ul>
<li>将整个堆空间划分为连续的不同小区间，每个小区间独立使用，独立回收。</li>
<li>可以控制一次回收多少个小区间，减少一次GC所产生的停顿</li>
</ul>
<h2 id="7-垃圾收集器"><a href="#7-垃圾收集器" class="headerlink" title="7 垃圾收集器"></a>7 垃圾收集器</h2><p>分类：</p>
<ul>
<li><p>新生代：</p>
<ul>
<li>Serial</li>
<li>ParNew</li>
<li>Parallel Scavenge</li>
<li>G1</li>
</ul>
</li>
<li><p>老年代：</p>
<ul>
<li><p>CMS</p>
</li>
<li><p>Serial Old（MSC）</p>
</li>
<li><p>Parallel Old</p>
</li>
<li><p>G1</p>
</li>
</ul>
</li>
</ul>
<h3 id="7-1-Serial"><a href="#7-1-Serial" class="headerlink" title="7.1 Serial"></a>7.1 Serial</h3><ul>
<li>最基本的垃圾收集器</li>
<li>单线程</li>
<li>使用复制算法</li>
<li>收集垃圾过程中需要暂停所有其他的工作线程</li>
<li>简单高效</li>
<li>是java 虚拟机运行在Client 模式下默认的新生代垃圾收集器</li>
</ul>
<h3 id="7-2-ParNew"><a href="#7-2-ParNew" class="headerlink" title="7.2 ParNew"></a>7.2 ParNew</h3><ul>
<li>Serial收集器的多线程版本</li>
<li>使用复制算法</li>
<li>收集垃圾过程中需要暂停所有其他的工作线程</li>
<li>默认开启和CPU 数目相同的线程数</li>
<li>是很多java虚拟机运行在Server 模式下新生代的默认垃圾收集器。</li>
</ul>
<h3 id="7-3-Parallel-Scavenge"><a href="#7-3-Parallel-Scavenge" class="headerlink" title="7.3 Parallel Scavenge"></a>7.3 Parallel Scavenge</h3><ul>
<li>多线程</li>
<li>使用复制算法</li>
<li>重点关注程序到达一个可控制的吞吐量（运行用户代码时间/(运行用户代码时间+垃圾收集时间）</li>
<li>自适应调节策略</li>
</ul>
<h3 id="7-4-Serial-Old"><a href="#7-4-Serial-Old" class="headerlink" title="7.4 Serial Old"></a>7.4 Serial Old</h3><ul>
<li>单线程</li>
<li>标记整理算法</li>
<li>是运行在Client 默认的java 虚拟机默认的年老代垃圾收集器</li>
</ul>
<h3 id="7-5-Parallel-Old"><a href="#7-5-Parallel-Old" class="headerlink" title="7.5 Parallel Old"></a>7.5 Parallel Old</h3><ul>
<li>多线程</li>
<li>标记整理算法</li>
</ul>
<h3 id="7-6-CMS"><a href="#7-6-CMS" class="headerlink" title="7.6 CMS"></a>7.6 CMS</h3><ul>
<li><p>多线程标记清除算法：Concurrent Mark Sweep</p>
</li>
<li><p>主要目标：获取最短垃圾回收停顿时间</p>
</li>
<li><p>多线程</p>
</li>
<li><p>标记清除算法</p>
</li>
</ul>
<h4 id="7-6-1-初始标记"><a href="#7-6-1-初始标记" class="headerlink" title="7.6.1 初始标记"></a>7.6.1 初始标记</h4><ul>
<li>标记GC roots能直接关联的对象</li>
<li>速度快</li>
<li>需要暂停所有的工作进程</li>
</ul>
<h4 id="7-6-2-并发标记"><a href="#7-6-2-并发标记" class="headerlink" title="7.6.2 并发标记"></a>7.6.2 并发标记</h4><ul>
<li>和用户线程一起工作，进行GC roots跟踪</li>
</ul>
<h4 id="7-6-3-重新标记"><a href="#7-6-3-重新标记" class="headerlink" title="7.6.3 重新标记"></a>7.6.3 重新标记</h4><ul>
<li>修正在并发标记期间，因用户程序继续运行而导致标记产生的那一部分对象的标记记录</li>
<li>需要暂停所有的工作线程</li>
</ul>
<h4 id="7-6-4-并发清除"><a href="#7-6-4-并发清除" class="headerlink" title="7.6.4 并发清除"></a>7.6.4 并发清除</h4><ul>
<li>和用户线程一起工作，清除回收对象</li>
<li>不需要暂停工作进程</li>
</ul>
<h3 id="7-7-G1"><a href="#7-7-G1" class="headerlink" title="7.7 G1"></a>7.7 G1</h3><ul>
<li>最先进</li>
<li>Garbage First</li>
<li>标记整理算法，不产生内存碎片</li>
<li>可以非常精确控制停顿时间，在不牺牲吞吐量的前提下，实现低停顿垃圾回收</li>
<li>把堆内存划分为大小固定的几个独立区域，优先回收垃圾最多的区域</li>
<li>回收效率高</li>
</ul>
<h2 id="8-IO-NIO"><a href="#8-IO-NIO" class="headerlink" title="8 IO/NIO"></a>8 IO/NIO</h2><h3 id="8-1-IO分类"><a href="#8-1-IO分类" class="headerlink" title="8.1 IO分类"></a>8.1 IO分类</h3><h4 id="8-1-1-IO"><a href="#8-1-1-IO" class="headerlink" title="8.1.1 IO"></a>8.1.1 IO</h4><ul>
<li>当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会交出CPU处于阻塞状态。当数据就绪之后，内核就会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态。</li>
</ul>
<h4 id="8-1-2-NIO"><a href="#8-1-2-NIO" class="headerlink" title="8.1.2 NIO"></a>8.1.2 NIO</h4><ul>
<li>当用户线程发起一个请求后，并不需要等待，而是马上就得到一个结果。如果结果是error时，它就知道数据还没有准备好，于是它可以再次发送请求。一旦内核中的数据准备就绪，并且又再次收到用户线程的请求，那么它马上就将结果返回给用户线程，然后返回。</li>
<li>在非阻塞IO 模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO不会交出CPU，而会一直占用CPU。</li>
</ul>
<h4 id="8-1-3-多路复用IO"><a href="#8-1-3-多路复用IO" class="headerlink" title="8.1.3 多路复用IO"></a>8.1.3 多路复用IO</h4><ul>
<li><p>在多路复用IO模型中，会有一个线程不断去轮询多个socket 的状态，只有当socket 真正有读写事件时，才真正调用实际的IO 读写操作。</p>
</li>
<li><p>因为在多路复用IO 模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket 读写事件进行时，才会使用IO资源，所以它大大减少了资源占用。</p>
</li>
<li><p>多路复用IO 为何比非阻塞IO 模型的效率高是因为在非阻塞IO中，不断地询socket 状态时通过用户线程去进行的，而在多路复用IO中，轮询每个socket 状态是内核在进行的，这个效率要比用户线程要高的多。</p>
</li>
<li><p>多路复用IO 模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用IO 模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询。</p>
</li>
</ul>
<h4 id="8-1-4-信号驱动IO"><a href="#8-1-4-信号驱动IO" class="headerlink" title="8.1.4 信号驱动IO"></a>8.1.4 信号驱动IO</h4><ul>
<li>在信号驱动IO 模型中，当用户线程发起一个IO 请求操作，会给对应的socket 注一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO 请求操作。</li>
</ul>
<h4 id="8-1-5-异步IO"><a href="#8-1-5-异步IO" class="headerlink" title="8.1.5 异步IO"></a>8.1.5 异步IO</h4><ul>
<li>当用户线程发起操作请求后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个请求后，它会立刻返回，说明请求已经成功发起，因此不会对用户线程产生任何block。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成后，内核会给用户线程发送一个信号，告诉它操作完成了。</li>
</ul>
<h3 id="8-2-NIO"><a href="#8-2-NIO" class="headerlink" title="8.2 NIO"></a>8.2 NIO</h3><h4 id="8-2-1-IO包"><a href="#8-2-1-IO包" class="headerlink" title="8.2.1 IO包"></a>8.2.1 IO包</h4><p>分类：</p>
<ul>
<li>字节流：<ul>
<li>InputStream</li>
<li>OutputStream</li>
</ul>
</li>
<li>字符流：<ul>
<li>Reader</li>
<li>Writer</li>
</ul>
</li>
</ul>
<h4 id="8-2-2-NIO"><a href="#8-2-2-NIO" class="headerlink" title="8.2.2 NIO"></a>8.2.2 NIO</h4><p>核心部分：</p>
<ul>
<li>通道（Channel）：<ul>
<li>提供从文件、网络读取数据的渠道</li>
<li>Channel 是双向的，既可以用来进行读操作，又可以用来进行写操作</li>
<li>Stream 是单向的</li>
<li>分类：<ul>
<li>IO：FileChannel</li>
<li>UDP：DatagramChannel</li>
<li>TCP：SocketChannel（client）/ ServerSocketChannel(server)</li>
</ul>
</li>
</ul>
</li>
<li>缓冲区（Buffer）:<ul>
<li>读取或写入的数据都必须经由Buffer</li>
<li>常用子类：ByteBuffer、IntBuffer、 CharBuffer、 LongBuffer、DoubleBuffer、FloatBuffer、ShortBuffer</li>
</ul>
</li>
<li>选择区（Selector）：<ul>
<li>检测多个注册的通道上是否有事件发生，如果有事件发生，便获取事件然后针对每个事件进行相应的响应处理</li>
<li>用一个单线程就可以管理多个通道</li>
<li>使得只有在连接真正有读写事件发生时，才会调用函数来进行读写，就大大地减少了系统开销</li>
<li>不必为每个连接都创建一个线程，不用去维护多个线程，并且避免了多线程之间的上下文切换导致的开销</li>
</ul>
</li>
</ul>
<p>对比：</p>
<ul>
<li>传统IO基于字节流和字符流进行操作</li>
<li>NIO 基于Channel 和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中</li>
</ul>
<h4 id="8-2-3-缓冲区"><a href="#8-2-3-缓冲区" class="headerlink" title="8.2.3 缓冲区"></a>8.2.3 缓冲区</h4><ul>
<li>Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。</li>
<li>NIO 的缓冲导向方法不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。</li>
<li>NIO需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</li>
</ul>
<h4 id="8-2-4-非阻塞"><a href="#8-2-4-非阻塞" class="headerlink" title="8.2.4 非阻塞"></a>8.2.4 非阻塞</h4><ul>
<li>IO 的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情。</li>
<li>NIO 的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 </li>
<li>非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。</li>
<li>线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</li>
</ul>
<h2 id="9-类加载"><a href="#9-类加载" class="headerlink" title="9 类加载"></a>9 类加载</h2><h3 id="9-1-步骤"><a href="#9-1-步骤" class="headerlink" title="9.1 步骤"></a>9.1 步骤</h3><h4 id="9-1-1-加载"><a href="#9-1-1-加载" class="headerlink" title="9.1.1 加载"></a>9.1.1 加载</h4><ul>
<li>会在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的入口。</li>
</ul>
<h4 id="9-1-2-验证"><a href="#9-1-2-验证" class="headerlink" title="9.1.2 验证"></a>9.1.2 验证</h4><ul>
<li>为了确保Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</li>
</ul>
<h4 id="9-1-3-准备"><a href="#9-1-3-准备" class="headerlink" title="9.1.3 准备"></a>9.1.3 准备</h4><ul>
<li>正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。</li>
</ul>
<h4 id="9-1-4-解析"><a href="#9-1-4-解析" class="headerlink" title="9.1.4 解析"></a>9.1.4 解析</h4><ul>
<li><p>虚拟机将常量池中的符号引用替换为直接引用的过程。</p>
</li>
<li><p>符号引用：引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同</p>
</li>
<li><p>直接引用：直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。</p>
</li>
</ul>
<h4 id="9-1-5-初始化"><a href="#9-1-5-初始化" class="headerlink" title="9.1.5 初始化"></a>9.1.5 初始化</h4><ul>
<li>执行类中定义的Java 程序代码。</li>
</ul>
<h3 id="9-2-双亲委派模型"><a href="#9-2-双亲委派模型" class="headerlink" title="9.2 双亲委派模型"></a>9.2 双亲委派模型</h3><ul>
<li><p>当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。</p>
</li>
<li><p>使用不同的类加载器最终得到的都是同样一个Object 对象</p>
</li>
</ul>
<p><img src="C:\Users\x\AppData\Roaming\Typora\typora-user-images\image-20200825114823414.png" alt="image-20200825114823414"></p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>X_ray</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://xray1025.github.io/2020/09/02/JVM/">https://xray1025.github.io/2020/09/02/JVM/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>yesterday you said tomorrow</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/JVM/"># JVM</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2020/09/03/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/">反转链表</a>
            
            
            <a class="next" rel="next" href="/2020/09/02/redis/">Redis</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© X_ray | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
