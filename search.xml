<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>0001.两数之和</title>
    <url>/2020/09/11/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p><strong>一遍哈希表</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">      Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">          <span class="keyword">int</span> temp = target - nums[i];</span><br><span class="line">          <span class="keyword">if</span>(map.containsKey(temp))&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;map.get(temp), i&#125;; </span><br><span class="line">          &#125;</span><br><span class="line">          map.put(nums[i], i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(n)，<br>只遍历了包含有 n 个元素的列表一次。在表中进行的每次查找只花费 O(1) 的时间。</p>
</li>
<li><p>空间复杂度：O(n)，<br>所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 n 个元素。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>0002.两数相加</title>
    <url>/2020/09/11/0002.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    	ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    	ListNode p = l1, q = l2, curr = dummyHead;</span><br><span class="line">    	<span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">while</span> (p != <span class="keyword">null</span> || q != <span class="keyword">null</span>) &#123;</span><br><span class="line">        	<span class="keyword">int</span> x = (p != <span class="keyword">null</span>) ? p.val : <span class="number">0</span>;</span><br><span class="line">        	<span class="keyword">int</span> y = (q != <span class="keyword">null</span>) ? q.val : <span class="number">0</span>;</span><br><span class="line">        	<span class="keyword">int</span> sum = carry + x + y;</span><br><span class="line">        	carry = sum / <span class="number">10</span>;</span><br><span class="line">        	curr.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">        	curr = curr.next;</span><br><span class="line">        	<span class="keyword">if</span> (p != <span class="keyword">null</span>) p = p.next;</span><br><span class="line">        	<span class="keyword">if</span> (q != <span class="keyword">null</span>) q = q.next;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        	curr.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> dummyHead.next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(max⁡(m,n))，假设 m 和 n 分别表示 l1 和 l2 的长度，上面的算法最多重复 max⁡(m,n) 次。</li>
<li>空间复杂度：O(max⁡(m,n))， 新列表的长度最多为 max(m,n)+1。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>ListNode</tag>
      </tags>
  </entry>
  <entry>
    <title>0015.三数之和</title>
    <url>/2020/10/05/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> target = - nums[i];</span><br><span class="line">            <span class="keyword">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[left] + nums[right] == target)&#123;</span><br><span class="line">                    res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(nums[i], nums[left], nums[right])));</span><br><span class="line"></span><br><span class="line">                    ++left;</span><br><span class="line">                    --right;</span><br><span class="line">                    <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left - <span class="number">1</span>])&#123;</span><br><span class="line">                        ++left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right + <span class="number">1</span>])&#123;</span><br><span class="line">                        --right;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[left] + nums[right] &lt; target)&#123;</span><br><span class="line">                    ++left;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    --right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(N^2)，其中 NN 是数组 nums 的长度。</p>
</li>
<li><p>空间复杂度：O(logN)。我们忽略存储答案的空间，额外的排序的空间复杂度为 O(logN)。然而我们修改了输入的数组 nums，在实际情况下不一定允许，因此也可以看成使用了一个额外的数组存储了 nums 的副本并进行排序，空间复杂度为 O(N)。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>0032.最长有效括号</title>
    <url>/2020/09/14/0032.%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">                maxLength = Math.max(maxLength, l * <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l &lt; r)&#123;</span><br><span class="line">                l = <span class="number">0</span>;</span><br><span class="line">                r = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        l = <span class="number">0</span>;</span><br><span class="line">        r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">                maxLength = Math.max(maxLength, l * <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l &gt; r)&#123;</span><br><span class="line">                l = <span class="number">0</span>;</span><br><span class="line">                r = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：o(n)</li>
<li>空间复杂度：o(1)</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>0033.搜索旋转排序数组</title>
    <url>/2020/09/14/0033.%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p><strong>二分查找：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[l] &lt;= nums[mid])&#123;</span><br><span class="line">                <span class="keyword">if</span>(target &gt;= nums[l] &amp;&amp; target &lt; nums[mid])&#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(target &gt; nums[mid] &amp;&amp; target &lt;= nums[r])&#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：o(logn)</li>
<li>空间复杂度：o(1)</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>0034.在排序数组中查找元素的第一个和最后一个位置</title>
    <url>/2020/09/14/0034.%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<p><strong>二分查找：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l_index = <span class="number">0</span>,r_index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= target)&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        l_index = nums[left] != target ? -<span class="number">1</span>:left;</span><br><span class="line"></span><br><span class="line">        left = <span class="number">0</span>;</span><br><span class="line">        right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;= target)&#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        r_index = nums[right] != target ? -<span class="number">1</span>:right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;l_index,r_index&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：o(logn)</li>
<li>空间复杂度：o(1)</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>0039.组合总和</title>
    <url>/2020/09/14/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</url>
    <content><![CDATA[<p><strong>回溯法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; combine = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        dfs(candidates, target, ans, combine, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; combine, <span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(idx == candidates.length)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(combine));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(candidates, target, ans, combine, idx + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(target - candidates[idx] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            combine.add(candidates[idx]);</span><br><span class="line">            dfs(candidates, target - candidates[idx], ans, combine, idx);</span><br><span class="line">            combine.remove(combine.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(S)，其中 S 为所有可行解的长度之和。从分析给出的搜索树我们可以看出时间复杂度取决于搜索树所有叶子节点的深度之和，即所有可行解的长度之和。在这题中，我们很难给出一个比较紧的上界，我们知道 O(n×2^n)是一个比较松的上界，即在这份代码中，n 个位置每次考虑选或者不选，如果符合条件，就加入答案的时间代价。但是实际运行的时候，因为不可能所有的解都满足条件，递归的时候我们还会用 target - candidates[idx] &gt;= 0 进行剪枝，所以实际运行情况是远远小于这个上界的。</li>
<li>空间复杂度：O(target)。除答案数组外，空间复杂度取决于递归的栈深度，在最差情况下需要递归 O(target)层。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title>0046.全排列</title>
    <url>/2020/09/18/0046.%E5%85%A8%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<p><strong>回溯法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        backtrack(nums, res, tmp, visited);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; tmp, <span class="keyword">int</span>[] visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp.size() == nums.length)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(tmp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            visited[i] = <span class="number">1</span>;</span><br><span class="line">            tmp.add(nums[i]);</span><br><span class="line">            backtrack(nums, res, tmp, visited);</span><br><span class="line">            visited[i] = <span class="number">0</span>;</span><br><span class="line">            tmp.remove(tmp.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>0047.全排列2</title>
    <url>/2020/09/18/0047.%E5%85%A8%E6%8E%92%E5%88%972/</url>
    <content><![CDATA[<p><strong>回溯法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] vis;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; perm = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backtrack(nums, ans, <span class="number">0</span>, perm);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, List&lt;List&lt;Integer&gt;&gt; ans, <span class="keyword">int</span> idx, List&lt;Integer&gt; perm)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == nums.length) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(perm));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[i] || (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !vis[i - <span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            perm.add(nums[i]);</span><br><span class="line">            vis[i] = <span class="keyword">true</span>;</span><br><span class="line">            backtrack(nums, ans, idx + <span class="number">1</span>, perm);</span><br><span class="line">            vis[i] = <span class="keyword">false</span>;</span><br><span class="line">            perm.remove(idx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n×n!)，其中 n 为序列的长度。</li>
<li>空间复杂度：O(n)。我们需要 O(n) 的标记数组，同时在递归的时候栈深度会达到 O(n)，因此总空间复杂度为 O(n+n)=O(2n)=O(n)。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>0094.二叉树的中序遍历</title>
    <url>/2020/09/14/0094.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p><strong>递归：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        inorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root.left, res);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        inorder(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</li>
<li>空间复杂度：O(n)。空间复杂度取决于递归的栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。</li>
</ul>
<p><strong>利用栈迭代：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stk = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span> || !stk.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stk.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.pop();</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</li>
<li>空间复杂度：O(n)。空间复杂度取决于栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n)。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer27.二叉树的镜像</title>
    <url>/2020/09/18/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<p><strong>递归</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = maxDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> r = maxDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(l, r) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(n)，</p>
</li>
<li><p>空间复杂度：O(height)。</p>
</li>
</ul>
<p><strong>非递归</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中 n 为二叉树的节点个数。与方法一同样的分析，每个节点只会被访问一次。</li>
<li>空间复杂度：此方法空间的消耗取决于队列存储的元素数量，其在最坏情况下会达到 O(n)。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>0106. 从中序与后序遍历序列构造二叉树</title>
    <url>/2020/09/25/0106.%20%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p><strong>递归</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> build(inorder, postorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>, <span class="number">0</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">build</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder, <span class="keyword">int</span> il, <span class="keyword">int</span> ir, <span class="keyword">int</span> pl, <span class="keyword">int</span> pr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(il &gt; ir)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(il == ir)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(inorder[il]);</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(postorder[pr]);</span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = il; i &lt;= ir; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == root.val)&#123;</span><br><span class="line">                index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = build(inorder, postorder, il, index - <span class="number">1</span>, pl, pl + index - il - <span class="number">1</span>);</span><br><span class="line">        root.right = build(inorder, postorder, index + <span class="number">1</span>, ir, pl + index - il, pr - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>0116. 填充每个节点的下一个右侧节点指针</title>
    <url>/2020/09/28/0116.%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        Node leftmost = root;</span><br><span class="line">        <span class="keyword">while</span> (leftmost.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node head = leftmost;</span><br><span class="line">            <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">                head.left.next = head.right;</span><br><span class="line">                <span class="keyword">if</span> (head.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    head.right.next = head.next.left;</span><br><span class="line">                &#125;</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            leftmost = leftmost.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</li>
<li>空间复杂度：O(1)。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>0117. 填充每个节点的下一个右侧节点指针2</title>
    <url>/2020/09/28/0117.%20%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%882/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Node last, nextStart;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        Node start = root;</span><br><span class="line">        <span class="keyword">while</span>(start != <span class="keyword">null</span>)&#123;</span><br><span class="line">            last = <span class="keyword">null</span>;</span><br><span class="line">            nextStart = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span>(Node p = start; p != <span class="keyword">null</span>; p = p.next)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    handle(p.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(p.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    handle(p.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            start = nextStart;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Node p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(last != <span class="keyword">null</span>)&#123;</span><br><span class="line">            last.next = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nextStart == <span class="keyword">null</span>)&#123;</span><br><span class="line">            nextStart = p;</span><br><span class="line">        &#125;</span><br><span class="line">        last = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</li>
<li>空间复杂度：O(1)。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>0154.二叉树的后序遍历</title>
    <url>/2020/09/29/0145.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p><strong>递归：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        postorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode node, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        postorder(node.left, res);</span><br><span class="line">        postorder(node.right, res);</span><br><span class="line">        res.add(node.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</li>
<li>空间复杂度：O(n)。空间复杂度取决于递归的栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。</li>
</ul>
<p><strong>利用栈迭代：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (root.right == <span class="keyword">null</span> || root.right == prev) &#123;</span><br><span class="line">                res.add(root.val);</span><br><span class="line">                prev = root;</span><br><span class="line">                root = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</li>
<li>空间复杂度：O(n)。空间复杂度取决于栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n)。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>0189.旋转数组</title>
    <url>/2020/09/16/0189.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p><strong>三次反转</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k = k % nums.length;</span><br><span class="line">        reverse(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, k, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[start];</span><br><span class="line">            nums[start] = nums[end];</span><br><span class="line">            nums[end] = temp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(n)，</p>
</li>
<li><p>空间复杂度：O(1)。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>0198.打家劫舍</title>
    <url>/2020/09/22/0198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</url>
    <content><![CDATA[<p><strong>动态规划 + 滚动数组：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> first = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> second = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = second;</span><br><span class="line">            second = Math.max(first + nums[i], tmp);</span><br><span class="line">            first = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中 n 是数组长度。只需要对数组遍历一次。</li>
<li>空间复杂度：O(1)。使用滚动数组，可以只存储前两间房屋的最高总金额，而不需要存储整个数组的结果，因此空间复杂度是 O(1)。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>0200.岛屿数量</title>
    <url>/2020/09/18/0200.%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</url>
    <content><![CDATA[<p><strong>dfs</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nr = grid.length;</span><br><span class="line">        <span class="keyword">int</span> nc = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r &gt;= nr || c &gt;= nc || grid[r][c] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        grid[r][c] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">        dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">        dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">        dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> nr = grid.length;</span><br><span class="line">        <span class="keyword">int</span> nc = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> num_islands = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; nr; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; nc; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    ++num_islands;</span><br><span class="line">                    dfs(grid, r, c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num_islands;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(MN)，其中 M 和 N 分别为行数和列数。</p>
</li>
<li><p>空间复杂度：O(MN)，在最坏情况下，整个网格均为陆地，深度优先搜索的深度达到 MN。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>0206.反转链表</title>
    <url>/2020/09/24/0206.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p><strong>非递归</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode tmp = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度： O(n) 。总共有 n 个节点，我们每个遍历一次。</li>
<li>空间复杂度： O(1) 。</li>
</ul>
<p><strong>递归</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode tmp = head.next;</span><br><span class="line">        head.next = pre;</span><br><span class="line">        pre = head;</span><br><span class="line">        reverseList(tmp);</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度： O(n) 。总共有 n 个节点，我们每个遍历一次。</li>
<li>空间复杂度： O(n) 。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>0213.打家劫舍2</title>
    <url>/2020/09/22/0213.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D2/</url>
    <content><![CDATA[<p><strong>动态规划 + 滚动数组：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(myRob(nums, <span class="number">0</span>, len - <span class="number">2</span>), myRob(nums, <span class="number">1</span>, len - <span class="number">1</span>)); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myRob</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> second = nums[start];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = second;</span><br><span class="line">            second = Math.max(first + nums[i], tmp);</span><br><span class="line">            first = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中 n 是数组长度。只需要对数组遍历一次。</li>
<li>空间复杂度：O(1)。使用滚动数组，可以只存储前两间房屋的最高总金额，而不需要存储整个数组的结果，因此空间复杂度是 O(1)。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>0328.奇偶链表</title>
    <url>/2020/09/18/0328.%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p><strong>奇偶链表</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode dummyNode1 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode dummyNode2 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">        ListNode p = head, p1 = dummyNode1, p2 = dummyNode2;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                p1.next = p;</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p2.next = p;</span><br><span class="line">                p2 = p2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">            index ++;</span><br><span class="line">        &#125;</span><br><span class="line">        p2.next = <span class="keyword">null</span>; </span><br><span class="line">        p1.next = dummyNode2.next;</span><br><span class="line">        <span class="keyword">return</span> dummyNode1.next;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度： O(n) 。总共有 n 个节点，我们每个遍历一次。</p>
<p>空间复杂度： O(1) 。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>0300.最长子序列</title>
    <url>/2020/09/23/0300.%E6%9C%80%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p><strong>动态规划：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &lt; nums[i])&#123;</span><br><span class="line">                    tmp = Math.max(tmp, dp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i] = tmp + <span class="number">1</span>;</span><br><span class="line">                maxLength = Math.max(maxLength, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n^2)，其中 n 为数组 nums 的长度。动态规划的状态数为 nn，计算状态 dp[i] 时，需要 O(n) 的时间遍历 dp[0…i−1] 的所有状态，所以总时间复杂度为 O(n^2)。</li>
<li>空间复杂度：O(n)，需要额外使用长度为 n 的 dp 数组。</li>
</ul>
<p><strong>贪心 + 二分查找：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> j = res;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (i + j) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(result[mid] &lt; num)&#123;</span><br><span class="line">                    i = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    j = mid; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result[i] = num;</span><br><span class="line">            <span class="keyword">if</span>(res == j)&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度 O(NlogN) ： 遍历 nums 列表需 O(N)，在每个 nums[i] 二分法需 O(logN)。</li>
<li>空间复杂度 O(N) ： result 列表占用线性大小额外空间。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>0337.打家劫舍3</title>
    <url>/2020/09/22/0337.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D3/</url>
    <content><![CDATA[<p><strong>动态规划</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = dfs(root);</span><br><span class="line">        <span class="keyword">return</span> Math.max(res[<span class="number">0</span>], res[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] dfs(TreeNode node)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] l = dfs(node.left);</span><br><span class="line">        <span class="keyword">int</span>[] r = dfs(node.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> selected = node.val + l[<span class="number">1</span>] + r[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> notSelected = Math.max(l[<span class="number">0</span>], l[<span class="number">1</span>]) + Math.max(r[<span class="number">0</span>], r[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;selected, notSelected&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)。</li>
<li>空间复杂度：O(n)。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Tree</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>0404.左叶子之和</title>
    <url>/2020/09/19/0404.%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span> &amp;&amp; root.left.left == <span class="keyword">null</span> &amp;&amp; root.left.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            sum += root.left.val;</span><br><span class="line">        &#125;</span><br><span class="line">        sumOfLeftLeaves(root.left); </span><br><span class="line">        sumOfLeftLeaves(root.right);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度： O(n) 。总共有 n 个节点，我们每个遍历一次。</li>
<li>空间复杂度： O(1) 。空间复杂度与深度优先搜索使用的栈的最大深度相关。在最坏的情况下，树呈现链式结构，深度为 O(n)，对应的空间复杂度也为 O(n)。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>0538. 把二叉搜索树转换为累加树</title>
    <url>/2020/09/21/0538.%20%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/</url>
    <content><![CDATA[<p><strong>反中序遍历：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        convertBST(root.right);</span><br><span class="line">        sum += root.val;</span><br><span class="line">        root.val = sum;</span><br><span class="line">        convertBST(root.left);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(n)，其中 nn 是二叉搜索树的节点数。每一个节点恰好被遍历一次。</p>
</li>
<li><p>空间复杂度：O(n)，为递归过程中栈的开销，平均情况下为 O(logn)，最坏情况下树呈现链状，为 O(n)。</p>
</li>
</ul>
<p><strong>Morris遍历：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        </span><br><span class="line">        whille(rode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                sum += node.val;</span><br><span class="line">                node.val = sum;</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                TreeNode suc = getSuccessor(node);</span><br><span class="line">                <span class="keyword">if</span>(suc.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    suc.left = node;</span><br><span class="line">                    node = node.right;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    suc.left = <span class="keyword">null</span>;</span><br><span class="line">                    sum += node.val;</span><br><span class="line">                    node.val = sum;</span><br><span class="line">                    node = node.left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">getSuccessor</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        TreeNode suc = node.right;</span><br><span class="line">        <span class="keyword">while</span>(suc.left != <span class="keyword">null</span> &amp;&amp; suc.left != node)&#123;</span><br><span class="line">            suc = suc.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> suc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)，其中 n 是二叉搜索树的节点数。没有左子树的节点只被访问一次，有左子树的节点被访问两次。</p>
<p>空间复杂度：O(1)。只操作已经存在的指针（树的空闲指针），因此只需要常数的额外空间。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>0617.合并二叉树</title>
    <url>/2020/09/23/0617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p><strong>递归</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        TreeNode t = <span class="keyword">new</span> TreeNode(); </span><br><span class="line">        <span class="keyword">if</span>(t1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> t = t2;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> t =t1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            t.val = t1.val + t2.val;</span><br><span class="line">        &#125;</span><br><span class="line">        t.left = mergeTrees(t1.left, t2.left);</span><br><span class="line">        t.right = mergeTrees(t1.right, t2.right);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(min(m,n))，其中 m 和 n 分别是两个二叉树的节点个数。对两个二叉树同时进行深度优先搜索，只有当两个二叉树中的对应节点都不为空时才会对该节点进行显性合并操作，因此被访问到的节点数不会超过较小的二叉树的节点数。</li>
<li>空间复杂度：O(min(m,n))，其中 m 和 n 分别是两个二叉树的节点个数。空间复杂度取决于递归调用的层数，递归调用的层数不会超过较小的二叉树的最大高度，最坏情况下，二叉树的高度等于节点数。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>0701.二叉搜索树中的插入操作</title>
    <url>/2020/09/30/0701.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p><strong>递归：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; val) &#123;</span><br><span class="line">            root.right = insertIntoBST(root.right, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root.left = insertIntoBST(root.left, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>迭代：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode pos = root;</span><br><span class="line">        <span class="keyword">while</span>(pos != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(val &lt; pos.val)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pos.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    pos = pos.left;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    pos.left = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(pos.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    pos = pos.right;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    pos.right = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(N)，其中 N 为树中节点的数目。最坏情况下，我们需要将值插入到树的最深的叶子结点上，而叶子节点最深为 O(N)。</li>
<li>空间复杂度：O(1)。我们只使用了常数大小的空间。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>0068.监控二叉树</title>
    <url>/2020/09/22/0968.%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCameraCover</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lrd(root) == <span class="number">0</span>)&#123;</span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 0代表结点待覆盖</span></span><br><span class="line"><span class="comment">    	1代表结点已覆盖</span></span><br><span class="line"><span class="comment">    	2代表结点已安装监控</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lrd</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = lrd(node.left);</span><br><span class="line">        <span class="keyword">int</span> r = lrd(node.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l == <span class="number">0</span> || r == <span class="number">0</span>)&#123;</span><br><span class="line">            sum++;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l == <span class="number">1</span> &amp;&amp; r == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l + r &gt;= <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>1295. 统计位数为偶数的数字</title>
    <url>/2020/10/03/1295.%E7%BB%9F%E8%AE%A1%E4%BD%8D%E6%95%B0%E4%B8%BA%E5%81%B6%E6%95%B0%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p><strong>最佳：对数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>((<span class="keyword">int</span>)(Math.log10(num) + <span class="number">1</span>) % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>把数字转成字符串</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (String.valueOf(nums[i]).length() % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>循环除以10</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(nums[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                nums[i] /= <span class="number">10</span>;</span><br><span class="line">                tmp++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>直接比较</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> findNumbers(<span class="built_in">int</span>[] nums) &#123;</span><br><span class="line">    <span class="built_in">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>((nums[i]&gt;=<span class="number">10</span>&amp;&amp;nums[i]&lt;<span class="number">100</span>)||(nums[i]&gt;=<span class="number">1000</span>&amp;&amp;nums[i]&lt;<span class="number">10000</span>))</span><br><span class="line">            count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM</title>
    <url>/2020/09/02/JVM/</url>
    <content><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><ul>
<li>JVM是可运行Java代码的假想计算机，组成部分包括：堆、方法区、栈、本地方法栈和程序计数器。其中，堆和方法区是共享区，栈、本地方法栈和程序计数器是线程私有的。</li>
</ul>
<a id="more"></a>

<ul>
<li>Java运行过程：<ul>
<li>源文件通过编译器编译为.class字节码文件，字节码文件通过JVM中的解释器解释成特定机器上的字节码文件</li>
</ul>
</li>
</ul>
<h2 id="1-线程"><a href="#1-线程" class="headerlink" title="1 线程"></a>1 线程</h2><p><strong>JVM的系统线程主要有：</strong></p>
<ul>
<li>虚拟机栈</li>
<li>周期性任务线程：负责定时器事件（中断），用来调度周期性操作的执行</li>
<li>GC线程：负责JVM中的垃圾回收</li>
<li>编译器线程：在运行时将字节码动态的编译成本地平台相关的机器码</li>
<li>信号分发线程：负责接收发送到JVM的信号并调用适当的JVM方法处理</li>
</ul>
<h2 id="2-JVM内存区域"><a href="#2-JVM内存区域" class="headerlink" title="2 JVM内存区域"></a>2 JVM内存区域</h2><h3 id="2-1-程序计数器"><a href="#2-1-程序计数器" class="headerlink" title="2.1 程序计数器"></a>2.1 程序计数器</h3><ul>
<li>当前线程所执行的字节码的行号指示器，占用内存空间较小，没有规定OutOfMemoryError</li>
</ul>
<h3 id="2-2-栈"><a href="#2-2-栈" class="headerlink" title="2.2 栈"></a>2.2 栈</h3><ul>
<li>描述java方法的内存模型，每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用到执行完成的过程，都对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</li>
<li>栈帧是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接、方法返回值和异常分派。</li>
</ul>
<h3 id="2-3-本地方法栈"><a href="#2-3-本地方法栈" class="headerlink" title="2.3 本地方法栈"></a>2.3 本地方法栈</h3><p>为Native方法服务</p>
<h3 id="2-4-堆"><a href="#2-4-堆" class="headerlink" title="2.4 堆"></a>2.4 堆</h3><ul>
<li>线程共享，</li>
<li>创建的对象和数组都保存在Java堆内存中，也是垃圾收集器进行垃圾收集的最重要的内存区域</li>
<li>根据分代收集算法，可以细分为：新生代（Eden、SurvivorFrom、ServivorTo）和老年代</li>
</ul>
<h3 id="2-5-方法区"><a href="#2-5-方法区" class="headerlink" title="2.5 方法区"></a>2.5 方法区</h3><p>即永久代（Permanent Generation），用于储存被Java加载的类信息、常量、静态常量、即时编译器编译后的代码等数据。</p>
<p>运行时常量池（Runtime Constant Pool）是方法区的一部分，负责存放Class文件中的常量池</p>
<h2 id="3-Java运行时内存"><a href="#3-Java运行时内存" class="headerlink" title="3 Java运行时内存"></a>3 Java运行时内存</h2><h3 id="3-1-新生代"><a href="#3-1-新生代" class="headerlink" title="3.1 新生代"></a>3.1 新生代</h3><ul>
<li>用来存放新生的对象，占堆1/3的空间</li>
<li>新生代分为<ul>
<li>Eden区</li>
<li>ServivorFrom</li>
<li>ServivorTo</li>
</ul>
</li>
<li>MinorGC：<ul>
<li>Eden内存不够时触发</li>
<li>频繁执行</li>
<li>采用复制算法</li>
<li>过程：<ul>
<li>将Eden、ServivorFrom复制到Servivor，并将年龄+1（如果年龄达到老年区的标准，则赋值到老年区）</li>
<li>清空Eden、ServivorFrom</li>
<li>将ServivorTo和ServivorFrom互换</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-2-老年代"><a href="#3-2-老年代" class="headerlink" title="3.2 老年代"></a>3.2 老年代</h3><ul>
<li>主要存放应用程序中生命周期长的内存对象</li>
<li>MajorGC：<ul>
<li>老年代空间不够时触发</li>
<li>不会频繁执行</li>
<li>采用标记清除算法：<ul>
<li>扫描一次所有老年代，标记出存活的的对象，然后回收没有标记的对象</li>
<li>耗时比较长</li>
<li>会产生内存碎片</li>
<li>老年代满时，跑出OOM（out of memory）异常</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-3-永久代"><a href="#3-3-永久代" class="headerlink" title="3.3 永久代"></a>3.3 永久代</h3><ul>
<li><p>内存的永久保存区域，主要存放Class和Meta的信息</p>
</li>
<li><p>GC不会在主程序运行期对永久代进行清理</p>
</li>
<li><p>Java 8 中，永久代已经被移除，被一个元数据区（元空间）取代</p>
<ul>
<li>元空间并不在虚拟机中，而是使用本地内存</li>
</ul>
</li>
</ul>
<h2 id="4-垃圾回收算法"><a href="#4-垃圾回收算法" class="headerlink" title="4 垃圾回收算法"></a>4 垃圾回收算法</h2><h3 id="4-1-如何确定垃圾"><a href="#4-1-如何确定垃圾" class="headerlink" title="4.1 如何确定垃圾"></a>4.1 如何确定垃圾</h3><h4 id="4-1-1-引用计数法"><a href="#4-1-1-引用计数法" class="headerlink" title="4.1.1 引用计数法"></a>4.1.1 引用计数法</h4><ul>
<li>一个对象如果没有任何与之关联的引用，即它们的引用计数都不为0，则说明对象不太可能再被用到，那么这个对象就是可回收对象</li>
</ul>
<h4 id="4-1-2-可达性分析"><a href="#4-1-2-可达性分析" class="headerlink" title="4.1.2 可达性分析"></a>4.1.2 可达性分析</h4><ul>
<li>为了解决引用计数法的循环引用问题，通过一系列的GC root作为搜索起点，如果在GC root和一个对象之间没有可达路径，则称该对象是不可达的</li>
<li>不可达对象经过两次标记后仍不可达，则为可回收对象</li>
</ul>
<h3 id="4-2-标记清除算法（Mark-Sweep）"><a href="#4-2-标记清除算法（Mark-Sweep）" class="headerlink" title="4.2 标记清除算法（Mark-Sweep）"></a>4.2 标记清除算法（Mark-Sweep）</h3><ul>
<li><strong>标记：</strong>标记处所有需要回收的对象</li>
<li><strong>清除：</strong>回收所有被标记的对象所占用的空间</li>
<li>弊端：内存碎片化严重</li>
</ul>
<h3 id="4-3-复制算法（copying）"><a href="#4-3-复制算法（copying）" class="headerlink" title="4.3 复制算法（copying）"></a>4.3 复制算法（copying）</h3><ul>
<li>按内存容量将内存划分为等大小的两块，每次只使用其中一块，当前内存满后将其尚存活的对象复制到另一块上，把已使用的内存回收</li>
<li>实现简单，内存效率高</li>
<li>可用内存被压缩到一半</li>
<li>存活对象增多时，算法效率大大降低</li>
</ul>
<h3 id="4-4-标记整理算法（Mark-Compact）"><a href="#4-4-标记整理算法（Mark-Compact）" class="headerlink" title="4.4 标记整理算法（Mark-Compact）"></a>4.4 标记整理算法（Mark-Compact）</h3><ul>
<li>标记</li>
<li>将存活对象移向内存的一端，然后清除边界外的对象</li>
</ul>
<h3 id="4-5-分代收集算法"><a href="#4-5-分代收集算法" class="headerlink" title="4.5 分代收集算法"></a>4.5 分代收集算法</h3><ul>
<li>主流收集算法</li>
<li>新生代：每次垃圾回收时都有大量垃圾需要被回收<ul>
<li>复制算法</li>
</ul>
</li>
<li>老年代：每次垃圾回收时只有少量对象需要被回收<ul>
<li>标记整理算法</li>
</ul>
</li>
</ul>
<h2 id="5-Java四种引用类型"><a href="#5-Java四种引用类型" class="headerlink" title="5 Java四种引用类型"></a>5 Java四种引用类型</h2><ul>
<li>强引用<ul>
<li>把一个对象赋值给一个引用变量即是强引用</li>
<li>处于可达状态，不可被回收</li>
<li>容易造成内存泄漏</li>
</ul>
</li>
<li>软引用<ul>
<li>SoftReference类</li>
<li>系统内存不足时即被回收</li>
</ul>
</li>
<li>弱引用<ul>
<li>WeakReference类</li>
<li>只要垃圾回收机制一运行即被回收</li>
</ul>
</li>
<li>虚引用<ul>
<li>PhantomReference类</li>
<li>必须和引用队列联合使用</li>
<li>主要用来跟踪对象呗垃圾回收的状态</li>
</ul>
</li>
</ul>
<h2 id="6-分区收集算法"><a href="#6-分区收集算法" class="headerlink" title="6 分区收集算法"></a>6 分区收集算法</h2><ul>
<li>将整个堆空间划分为连续的不同小区间，每个小区间独立使用，独立回收。</li>
<li>可以控制一次回收多少个小区间，减少一次GC所产生的停顿</li>
</ul>
<h2 id="7-垃圾收集器"><a href="#7-垃圾收集器" class="headerlink" title="7 垃圾收集器"></a>7 垃圾收集器</h2><p>分类：</p>
<ul>
<li><p>新生代：</p>
<ul>
<li>Serial</li>
<li>ParNew</li>
<li>Parallel Scavenge</li>
<li>G1</li>
</ul>
</li>
<li><p>老年代：</p>
<ul>
<li><p>CMS</p>
</li>
<li><p>Serial Old（MSC）</p>
</li>
<li><p>Parallel Old</p>
</li>
<li><p>G1</p>
</li>
</ul>
</li>
</ul>
<h3 id="7-1-Serial"><a href="#7-1-Serial" class="headerlink" title="7.1 Serial"></a>7.1 Serial</h3><ul>
<li>最基本的垃圾收集器</li>
<li>单线程</li>
<li>使用复制算法</li>
<li>收集垃圾过程中需要暂停所有其他的工作线程</li>
<li>简单高效</li>
<li>是java 虚拟机运行在Client 模式下默认的新生代垃圾收集器</li>
</ul>
<h3 id="7-2-ParNew"><a href="#7-2-ParNew" class="headerlink" title="7.2 ParNew"></a>7.2 ParNew</h3><ul>
<li>Serial收集器的多线程版本</li>
<li>使用复制算法</li>
<li>收集垃圾过程中需要暂停所有其他的工作线程</li>
<li>默认开启和CPU 数目相同的线程数</li>
<li>是很多java虚拟机运行在Server 模式下新生代的默认垃圾收集器。</li>
</ul>
<h3 id="7-3-Parallel-Scavenge"><a href="#7-3-Parallel-Scavenge" class="headerlink" title="7.3 Parallel Scavenge"></a>7.3 Parallel Scavenge</h3><ul>
<li>多线程</li>
<li>使用复制算法</li>
<li>重点关注程序到达一个可控制的吞吐量（运行用户代码时间/(运行用户代码时间+垃圾收集时间）</li>
<li>自适应调节策略</li>
</ul>
<h3 id="7-4-Serial-Old"><a href="#7-4-Serial-Old" class="headerlink" title="7.4 Serial Old"></a>7.4 Serial Old</h3><ul>
<li>单线程</li>
<li>标记整理算法</li>
<li>是运行在Client 默认的java 虚拟机默认的年老代垃圾收集器</li>
</ul>
<h3 id="7-5-Parallel-Old"><a href="#7-5-Parallel-Old" class="headerlink" title="7.5 Parallel Old"></a>7.5 Parallel Old</h3><ul>
<li>多线程</li>
<li>标记整理算法</li>
</ul>
<h3 id="7-6-CMS"><a href="#7-6-CMS" class="headerlink" title="7.6 CMS"></a>7.6 CMS</h3><ul>
<li><p>多线程标记清除算法：Concurrent Mark Sweep</p>
</li>
<li><p>主要目标：获取最短垃圾回收停顿时间</p>
</li>
<li><p>多线程</p>
</li>
<li><p>标记清除算法</p>
</li>
</ul>
<h4 id="7-6-1-初始标记"><a href="#7-6-1-初始标记" class="headerlink" title="7.6.1 初始标记"></a>7.6.1 初始标记</h4><ul>
<li>标记GC roots能直接关联的对象</li>
<li>速度快</li>
<li>需要暂停所有的工作进程</li>
</ul>
<h4 id="7-6-2-并发标记"><a href="#7-6-2-并发标记" class="headerlink" title="7.6.2 并发标记"></a>7.6.2 并发标记</h4><ul>
<li>和用户线程一起工作，进行GC roots跟踪</li>
</ul>
<h4 id="7-6-3-重新标记"><a href="#7-6-3-重新标记" class="headerlink" title="7.6.3 重新标记"></a>7.6.3 重新标记</h4><ul>
<li>修正在并发标记期间，因用户程序继续运行而导致标记产生的那一部分对象的标记记录</li>
<li>需要暂停所有的工作线程</li>
</ul>
<h4 id="7-6-4-并发清除"><a href="#7-6-4-并发清除" class="headerlink" title="7.6.4 并发清除"></a>7.6.4 并发清除</h4><ul>
<li>和用户线程一起工作，清除回收对象</li>
<li>不需要暂停工作进程</li>
</ul>
<h3 id="7-7-G1"><a href="#7-7-G1" class="headerlink" title="7.7 G1"></a>7.7 G1</h3><ul>
<li>最先进</li>
<li>Garbage First</li>
<li>标记整理算法，不产生内存碎片</li>
<li>可以非常精确控制停顿时间，在不牺牲吞吐量的前提下，实现低停顿垃圾回收</li>
<li>把堆内存划分为大小固定的几个独立区域，优先回收垃圾最多的区域</li>
<li>回收效率高</li>
</ul>
<h2 id="8-IO-NIO"><a href="#8-IO-NIO" class="headerlink" title="8 IO/NIO"></a>8 IO/NIO</h2><h3 id="8-1-IO分类"><a href="#8-1-IO分类" class="headerlink" title="8.1 IO分类"></a>8.1 IO分类</h3><h4 id="8-1-1-IO"><a href="#8-1-1-IO" class="headerlink" title="8.1.1 IO"></a>8.1.1 IO</h4><ul>
<li>当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会交出CPU处于阻塞状态。当数据就绪之后，内核就会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态。</li>
</ul>
<h4 id="8-1-2-NIO"><a href="#8-1-2-NIO" class="headerlink" title="8.1.2 NIO"></a>8.1.2 NIO</h4><ul>
<li>当用户线程发起一个请求后，并不需要等待，而是马上就得到一个结果。如果结果是error时，它就知道数据还没有准备好，于是它可以再次发送请求。一旦内核中的数据准备就绪，并且又再次收到用户线程的请求，那么它马上就将结果返回给用户线程，然后返回。</li>
<li>在非阻塞IO 模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO不会交出CPU，而会一直占用CPU。</li>
</ul>
<h4 id="8-1-3-多路复用IO"><a href="#8-1-3-多路复用IO" class="headerlink" title="8.1.3 多路复用IO"></a>8.1.3 多路复用IO</h4><ul>
<li><p>在多路复用IO模型中，会有一个线程不断去轮询多个socket 的状态，只有当socket 真正有读写事件时，才真正调用实际的IO 读写操作。</p>
</li>
<li><p>因为在多路复用IO 模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket 读写事件进行时，才会使用IO资源，所以它大大减少了资源占用。</p>
</li>
<li><p>多路复用IO 为何比非阻塞IO 模型的效率高是因为在非阻塞IO中，不断地询socket 状态时通过用户线程去进行的，而在多路复用IO中，轮询每个socket 状态是内核在进行的，这个效率要比用户线程要高的多。</p>
</li>
<li><p>多路复用IO 模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用IO 模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询。</p>
</li>
</ul>
<h4 id="8-1-4-信号驱动IO"><a href="#8-1-4-信号驱动IO" class="headerlink" title="8.1.4 信号驱动IO"></a>8.1.4 信号驱动IO</h4><ul>
<li>在信号驱动IO 模型中，当用户线程发起一个IO 请求操作，会给对应的socket 注一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO 请求操作。</li>
</ul>
<h4 id="8-1-5-异步IO"><a href="#8-1-5-异步IO" class="headerlink" title="8.1.5 异步IO"></a>8.1.5 异步IO</h4><ul>
<li>当用户线程发起操作请求后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个请求后，它会立刻返回，说明请求已经成功发起，因此不会对用户线程产生任何block。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成后，内核会给用户线程发送一个信号，告诉它操作完成了。</li>
</ul>
<h3 id="8-2-NIO"><a href="#8-2-NIO" class="headerlink" title="8.2 NIO"></a>8.2 NIO</h3><h4 id="8-2-1-IO包"><a href="#8-2-1-IO包" class="headerlink" title="8.2.1 IO包"></a>8.2.1 IO包</h4><p>分类：</p>
<ul>
<li>字节流：<ul>
<li>InputStream</li>
<li>OutputStream</li>
</ul>
</li>
<li>字符流：<ul>
<li>Reader</li>
<li>Writer</li>
</ul>
</li>
</ul>
<h4 id="8-2-2-NIO"><a href="#8-2-2-NIO" class="headerlink" title="8.2.2 NIO"></a>8.2.2 NIO</h4><p>核心部分：</p>
<ul>
<li>通道（Channel）：<ul>
<li>提供从文件、网络读取数据的渠道</li>
<li>Channel 是双向的，既可以用来进行读操作，又可以用来进行写操作</li>
<li>Stream 是单向的</li>
<li>分类：<ul>
<li>IO：FileChannel</li>
<li>UDP：DatagramChannel</li>
<li>TCP：SocketChannel（client）/ ServerSocketChannel(server)</li>
</ul>
</li>
</ul>
</li>
<li>缓冲区（Buffer）:<ul>
<li>读取或写入的数据都必须经由Buffer</li>
<li>常用子类：ByteBuffer、IntBuffer、 CharBuffer、 LongBuffer、DoubleBuffer、FloatBuffer、ShortBuffer</li>
</ul>
</li>
<li>选择区（Selector）：<ul>
<li>检测多个注册的通道上是否有事件发生，如果有事件发生，便获取事件然后针对每个事件进行相应的响应处理</li>
<li>用一个单线程就可以管理多个通道</li>
<li>使得只有在连接真正有读写事件发生时，才会调用函数来进行读写，就大大地减少了系统开销</li>
<li>不必为每个连接都创建一个线程，不用去维护多个线程，并且避免了多线程之间的上下文切换导致的开销</li>
</ul>
</li>
</ul>
<p>对比：</p>
<ul>
<li>传统IO基于字节流和字符流进行操作</li>
<li>NIO 基于Channel 和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中</li>
</ul>
<h4 id="8-2-3-缓冲区"><a href="#8-2-3-缓冲区" class="headerlink" title="8.2.3 缓冲区"></a>8.2.3 缓冲区</h4><ul>
<li>Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。</li>
<li>NIO 的缓冲导向方法不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。</li>
<li>NIO需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</li>
</ul>
<h4 id="8-2-4-非阻塞"><a href="#8-2-4-非阻塞" class="headerlink" title="8.2.4 非阻塞"></a>8.2.4 非阻塞</h4><ul>
<li>IO 的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情。</li>
<li>NIO 的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 </li>
<li>非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。</li>
<li>线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</li>
</ul>
<h2 id="9-类加载"><a href="#9-类加载" class="headerlink" title="9 类加载"></a>9 类加载</h2><h3 id="9-1-步骤"><a href="#9-1-步骤" class="headerlink" title="9.1 步骤"></a>9.1 步骤</h3><h4 id="9-1-1-加载"><a href="#9-1-1-加载" class="headerlink" title="9.1.1 加载"></a>9.1.1 加载</h4><ul>
<li>会在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的入口。</li>
</ul>
<h4 id="9-1-2-验证"><a href="#9-1-2-验证" class="headerlink" title="9.1.2 验证"></a>9.1.2 验证</h4><ul>
<li>为了确保Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</li>
</ul>
<h4 id="9-1-3-准备"><a href="#9-1-3-准备" class="headerlink" title="9.1.3 准备"></a>9.1.3 准备</h4><ul>
<li>正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。</li>
</ul>
<h4 id="9-1-4-解析"><a href="#9-1-4-解析" class="headerlink" title="9.1.4 解析"></a>9.1.4 解析</h4><ul>
<li><p>虚拟机将常量池中的符号引用替换为直接引用的过程。</p>
</li>
<li><p>符号引用：引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同</p>
</li>
<li><p>直接引用：直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。</p>
</li>
</ul>
<h4 id="9-1-5-初始化"><a href="#9-1-5-初始化" class="headerlink" title="9.1.5 初始化"></a>9.1.5 初始化</h4><ul>
<li>执行类中定义的Java 程序代码。</li>
</ul>
<h3 id="9-2-双亲委派模型"><a href="#9-2-双亲委派模型" class="headerlink" title="9.2 双亲委派模型"></a>9.2 双亲委派模型</h3><ul>
<li><p>当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。</p>
</li>
<li><p>使用不同的类加载器最终得到的都是同样一个Object 对象</p>
</li>
</ul>
<p><img src="C:\Users\x\AppData\Roaming\Typora\typora-user-images\image-20200825114823414.png" alt="image-20200825114823414"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/08/24/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/2020/09/02/redis/</url>
    <content><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><blockquote>
<p>NoSQL = Not Only SQL</p>
</blockquote>
<p>关系型数据库：表格</p>
<p>非关系型数据库：格式不固定，易于横向扩展</p>
<a id="more"></a>

<blockquote>
<p>传统数据库</p>
<ul>
<li>结构化组织</li>
<li>SQL</li>
<li>数据和关系存在单独的表中</li>
<li>数据定义语言</li>
<li>严格的一致性</li>
<li>基础的事务</li>
<li>。。。</li>
</ul>
</blockquote>
<blockquote>
<p>NoSQL</p>
<ul>
<li>不仅仅是数据</li>
<li>没有固定的查询语言</li>
<li>键值对存储、列存储、文档存储、图形数据库</li>
<li>最终一致性</li>
<li>CAP/BASE</li>
<li>高性能、高可用、高拓展</li>
<li>。。。</li>
</ul>
</blockquote>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote>
<p>Redis（remote dictionary server）远程字典服务</p>
</blockquote>
<blockquote>
<ul>
<li>C</li>
<li>支持网络</li>
<li>内存持久化</li>
<li>kv键值对</li>
<li>主从同步</li>
</ul>
</blockquote>
<ul>
<li>数据库</li>
<li>缓存</li>
<li>中间件</li>
</ul>
<h1 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h1><p>redis-benchmark</p>
<ul>
<li>-c指定并发连接数</li>
<li>-n指定请求数</li>
</ul>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><ul>
<li><p>默认16个数据库</p>
</li>
<li><p>默认使用第0个 </p>
<ul>
<li><p>select 0</p>
</li>
<li><p>dbsize</p>
</li>
<li><p>keys *</p>
</li>
<li><p>清空当前数据库：flushdb</p>
</li>
<li><p>清空所有：flushall</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>redis是单线程的</p>
<ul>
<li>redis是基于内存操作的</li>
<li>对内存来说，没有多线程的上下文切换效率更高</li>
<li>redis的性能瓶颈不是cpu，而是机器内存和网络宽带</li>
<li>6.0 后是多线程的</li>
</ul>
</blockquote>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h2><ul>
<li><p>setex()：设置过期时间（set with exprie）</p>
</li>
<li><p>setnx()：不存在则设置（set if not exist）</p>
</li>
<li><p>set user{name:alice, age:11}</p>
</li>
<li><p>mget/mset</p>
</li>
<li><p>getset</p>
</li>
</ul>
<h2 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h2><ul>
<li>所有命令L开头：LPUSH/LRANGE</li>
<li>RPUSH/RPOP</li>
</ul>
<h2 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h2><ul>
<li>不能重复</li>
<li>所有命令S开头</li>
</ul>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><ul>
<li>h开头</li>
</ul>
<h2 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h2><ul>
<li>在set的基础上增加了一个值</li>
<li>zset k1 score1 v1</li>
<li>以score排序</li>
</ul>
<h2 id="geospatial"><a href="#geospatial" class="headerlink" title="geospatial"></a>geospatial</h2><ul>
<li>geoadd/geodist/geohash/geopos/georadious/georadiousbymember</li>
</ul>
<h2 id="hyperloglog"><a href="#hyperloglog" class="headerlink" title="hyperloglog"></a>hyperloglog</h2><ul>
<li><p>基数：不重复的元素，可以接受误差</p>
</li>
<li><p>网页UV：一个人访问网页多次仍算一次访问</p>
</li>
</ul>
<h2 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h2><ul>
<li>位运算</li>
<li>统计用户信息 0、1</li>
</ul>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><ul>
<li><p>一组命令的集合</p>
</li>
<li><p>单条命令保证原子性</p>
</li>
<li><p>事务不保证原子性</p>
</li>
<li><p>没有隔离级别的概念</p>
</li>
<li><p>步骤：</p>
<ul>
<li>开启事务（）：multi</li>
<li>命令入队（）：</li>
<li>执行事务（）：exec</li>
</ul>
</li>
<li><p>编译时异常，所有命令都不执行</p>
</li>
<li><p>运行时异常，其他命令继续执行</p>
</li>
</ul>
<h1 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h1><ul>
<li><p>悲观锁：所有行为都加锁</p>
</li>
<li><p>乐观锁：所有行为都不加锁，更新数据的时候获取版本判断数据是否被tar修改</p>
</li>
<li><p>redis实现：</p>
<ul>
<li>使用watch监视</li>
<li>如果执行失败，unwatch解锁</li>
<li>重新监视</li>
</ul>
</li>
</ul>
<h1 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h1><ul>
<li>redis官方推荐的java连接工具</li>
</ul>
<h1 id="SpringBoot整合"><a href="#SpringBoot整合" class="headerlink" title="SpringBoot整合"></a>SpringBoot整合</h1><ul>
<li><p>在springboot2.x之后，jedis被替换为了lettuce</p>
</li>
<li><p>jedis：直连，多线程不安全，需要使用jedis pool连接池 BIO</p>
</li>
<li><p>lettuce：netty，多线程共享，可以减少线程数量 NIO</p>
</li>
<li><p>自定义redisTemplate</p>
</li>
</ul>
<h1 id="conf详解"><a href="#conf详解" class="headerlink" title="conf详解"></a>conf详解</h1><ul>
<li><p>unit单位大小写不敏感</p>
</li>
<li><p>包含其他配置文件</p>
</li>
<li><p>网络：</p>
<ul>
<li>bind 127.0.0.1</li>
<li>protected-mode yes</li>
<li>port 6379</li>
</ul>
</li>
<li><p>daemoize yes # 以守护进程的方式运行，默认为no</p>
</li>
<li><p>pidfile /var/run/redis_6379.pid # 制定一个pid文件后台运行</p>
</li>
<li><p>loglevel notice # 日志</p>
</li>
<li><p>datebase 16</p>
</li>
<li><p>snapshot</p>
<ul>
<li>执行多少次操作则持久化到文件.rdb.aof</li>
<li>save 900 1 900s内，至少1个key修改则持久化</li>
<li>save 300 10 300s内，至少10个key修改则持久化</li>
<li>save 60 100 60s内，至少100个key修改则持久化</li>
</ul>
</li>
<li><p>stop-writes-on-bgsave-error 持久化出错是否继续工作</p>
</li>
<li><p>rdbcompression 是否压缩rdb文件</p>
</li>
<li><p>rdbchecksum 保存rdb文件是否进行校验</p>
</li>
<li><p>dir./ rdb文件保存目录</p>
</li>
<li><p>REPLICATION 复制</p>
</li>
<li><p>SECURITY 安全 密码默认为空</p>
</li>
<li><p>maxclients</p>
</li>
<li><p>maxmemory</p>
</li>
<li><p>maxmemory-policy noeviction内存满时的处理策略</p>
</li>
<li><p>append only # aof配置</p>
<ul>
<li>appendonly no 默认关闭，使用rdb持久化</li>
<li>appendfilename</li>
<li>appendfsync always/everysec/no</li>
</ul>
</li>
</ul>
<h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><ul>
<li>内存型数据库</li>
</ul>
<h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>redis database</p>
<ul>
<li>在指定的时间间隔内将内存中的数据集快照写入硬盘</li>
<li>单独创建一个子进程，先将数据写入临时文件，等待持久化过程结束，再用这个临时文件替换上次持久化好的文件</li>
<li>主进程不进行任何IO操作</li>
<li>适合大规模的数据恢复</li>
<li>最后一次持久化的数据肯丢失</li>
<li>默认RDB</li>
<li>dump.rdb</li>
</ul>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>append only file</p>
<ul>
<li><p>将所有命令都记录下来（读操作不记录）</p>
</li>
<li><p>恢复时把文件重新构建</p>
</li>
<li><p>不适合大规模数据恢复</p>
</li>
<li><p>redis-check-aof –fix 修复AOF</p>
</li>
<li><p>aof文件大于64M则新建AOF</p>
</li>
</ul>
<h1 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h1><ul>
<li>发送消息：PUBLISH XXX</li>
<li>接收信息：SUBSCRIBE XXX</li>
</ul>
<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><ul>
<li>数据的复制是单向的</li>
<li>读写分离</li>
<li>作用<ul>
<li>数据冗余</li>
<li>故障恢复</li>
<li>负载均衡</li>
<li>高可用</li>
</ul>
</li>
<li>info replication：查看复制信息</li>
<li>修改port、pid、log、dump.rdb</li>
</ul>
<h1 id="哨兵（sentinel）"><a href="#哨兵（sentinel）" class="headerlink" title="哨兵（sentinel）"></a>哨兵（sentinel）</h1><ul>
<li><p>主机故障时，从机根据投票自动变为主机</p>
</li>
<li><p>主观下线：一个哨兵发现主机不可用</p>
</li>
<li><p>客观下线：多个哨兵发现主机不可用，哨兵对从机进行投票切换主机</p>
</li>
<li><p>步骤：</p>
<ul>
<li>配置哨兵：sentinel monitor myredis 127.0.0.1 6379 1</li>
<li>启动哨兵：redis-sentinel </li>
</ul>
</li>
<li><p>主机重新上线后变为从机</p>
</li>
<li><p>优点</p>
<ul>
<li>基于主从复制</li>
<li>主从可以切换，可用性高</li>
<li>手动到自动，健壮性好</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>难以在线扩容</li>
<li>实现哨兵的配置麻烦</li>
</ul>
</li>
</ul>
<h1 id="缓存穿透和雪崩、击穿"><a href="#缓存穿透和雪崩、击穿" class="headerlink" title="缓存穿透和雪崩、击穿"></a>缓存穿透和雪崩、击穿</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><ul>
<li>大量用户查询的数据在redis内存数据库中没有，继而大量访问持久层数据库<ul>
<li>布隆过滤器：对多有可能查询的参数以hash形式存储，在控制层进行校验，不符合则丢弃，从而减小了对底层存储系统的压力</li>
<li>缓存空对象：</li>
</ul>
</li>
</ul>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><ul>
<li>大量请求并发地对一个热点数据进行访问，当这个数据失效的书剑，持续的大并发就穿透缓存，直接访问数据库<ul>
<li>设置热点永不过期</li>
<li>加互斥锁</li>
</ul>
</li>
</ul>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><ul>
<li>在一个时间段，缓存集中过期失效，redis宕机<ul>
<li>redis高可用</li>
<li>限量降级</li>
<li>数据预热</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2020/09/14/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="1-遍历二叉树"><a href="#1-遍历二叉树" class="headerlink" title="1 遍历二叉树"></a>1 遍历二叉树</h2><h3 id="1-1-先序遍历"><a href="#1-1-先序遍历" class="headerlink" title="1.1 先序遍历"></a>1.1 先序遍历</h3><h4 id="1-1-1-递归实现"><a href="#1-1-1-递归实现" class="headerlink" title="1.1.1 递归实现"></a>1.1.1 递归实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderRecur</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     System.put.print(treeNode.Data); </span><br><span class="line">     preOrderRecur(treeNode.left);</span><br><span class="line">     preOrderRecur(treeNode.right);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-2-非递归方式实现"><a href="#1-1-2-非递归方式实现" class="headerlink" title="1.1.2 非递归方式实现"></a>1.1.2 非递归方式实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty)&#123;</span><br><span class="line">        TreeNode res = stack.Pop();</span><br><span class="line">        <span class="keyword">if</span> (res.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(res.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(res.right);</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(res.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="1-2-中序遍历"><a href="#1-2-中序遍历" class="headerlink" title="1.2 中序遍历"></a>1.2 中序遍历</h3><h4 id="1-2-1-递归实现"><a href="#1-2-1-递归实现" class="headerlink" title="1.2.1 递归实现"></a>1.2.1 递归实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">MidTraversal</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;  </span><br><span class="line">		MidTraversa(node.left);</span><br><span class="line">     	System.out.print(node.val+<span class="string">&quot; &quot;</span>);</span><br><span class="line">     	MidTraversa(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-2-非递归实现"><a href="#1-2-2-非递归实现" class="headerlink" title="1.2.2 非递归实现"></a>1.2.2 非递归实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode curr = root;</span><br><span class="line">    <span class="keyword">while</span>(curr != <span class="keyword">null</span> || !(stack.isEmpty()))&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr!= <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(curr);</span><br><span class="line">            curr = curr.left;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            curr = stack.pop();</span><br><span class="line">            list.add(curr.val);</span><br><span class="line">            curr = curr.right;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-后序遍历"><a href="#1-3-后序遍历" class="headerlink" title="1.3 后序遍历"></a>1.3 后序遍历</h3><h4 id="1-3-1-递归实现"><a href="#1-3-1-递归实现" class="headerlink" title="1.3.1 递归实现"></a>1.3.1 递归实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postTraversal</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123; </span><br><span class="line">        postTraversal(node.left);</span><br><span class="line">        postTraversal(node.right);</span><br><span class="line">        System.out.print(node.val+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-2-非递归实现"><a href="#1-3-2-非递归实现" class="headerlink" title="1.3.2 非递归实现"></a>1.3.2 非递归实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode curr = root;</span><br><span class="line">    TreeNode last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(curr);</span><br><span class="line">            curr = curr.left;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = stack.peek();</span><br><span class="line">        <span class="keyword">if</span> (curr.right == <span class="keyword">null</span> || curr.right == last) &#123;</span><br><span class="line">            res.add(curr.val);</span><br><span class="line">            stack.pop();</span><br><span class="line">            last = curr;</span><br><span class="line">            curr = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curr = curr.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-层次遍历"><a href="#1-4-层次遍历" class="headerlink" title="1.4 层次遍历"></a>1.4 层次遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;()；</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        List&lt;Integer&gt; level = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= queue.size(); ++i) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            level.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(node.left)；</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(level);</span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-常见算法"><a href="#2-常见算法" class="headerlink" title="2 常见算法"></a>2 常见算法</h2><h3 id="2-1-二叉树的最大深度"><a href="#2-1-二叉树的最大深度" class="headerlink" title="2.1 二叉树的最大深度"></a>2.1 二叉树的最大深度</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = maxDepth(root.left);</span><br><span class="line">    <span class="keyword">int</span> right = maxDepth(root.right);</span><br><span class="line">    <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-二叉树的镜像"><a href="#2-2-二叉树的镜像" class="headerlink" title="2.2 二叉树的镜像"></a>2.2 二叉树的镜像</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode l = mirrorTree(root.right);</span><br><span class="line">    TreeNode r = mirrorTree(root.left);</span><br><span class="line">    root.left = l;</span><br><span class="line">    root.right = r;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-判断二叉树是否对称"><a href="#2-3-判断二叉树是否对称" class="headerlink" title="2.3 判断二叉树是否对称"></a>2.3 判断二叉树是否对称</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> real(pRoot.left,pRoot.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">real</span><span class="params">(TreeNode root1,TreeNode root2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root1 == <span class="keyword">null</span> &amp;&amp; root2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root1 ==<span class="keyword">null</span> || root2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root1.val != root2.val)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> real(root1.left,root2.right)&amp;&amp;real(root1.right,root2.left);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="2-4-路径总和"><a href="#2-4-路径总和" class="headerlink" title="2.4 路径总和"></a>2.4 路径总和</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listAll = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> listAll;</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        target -= root.val;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span> &amp;&amp; root.left==<span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            listAll.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(list));</span><br><span class="line">        &#125;</span><br><span class="line">        FindPath(root.left,target);</span><br><span class="line">        FindPath(root.right,target);</span><br><span class="line">        list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> listAll;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-重建二叉树"><a href="#2-5-重建二叉树" class="headerlink" title="2.5 重建二叉树"></a>2.5 重建二叉树</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> reConstructBinaryTree(pre,<span class="number">0</span>,pre.length-<span class="number">1</span>,in,<span class="number">0</span>,in.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> startpre,<span class="keyword">int</span> endpre,<span class="keyword">int</span> [] in,<span class="keyword">int</span> startin,<span class="keyword">int</span> endin)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(startpre &gt; endpre || startin &gt; endin)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(pre[startpre]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =startin;i&lt;=endin;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i] == pre[startpre])&#123;</span><br><span class="line">            root.left = reConstructBinaryTree(pre,startpre+<span class="number">1</span>,startpre+i-startin,in,startin,i-<span class="number">1</span>);</span><br><span class="line">            root.right = reConstructBinaryTree(pre,startpre+i-startin+<span class="number">1</span>,endpre,in,i+<span class="number">1</span>,endin);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-6-最近公共祖先"><a href="#2-6-最近公共祖先" class="headerlink" title="2.6 最近公共祖先"></a>2.6 最近公共祖先</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span> || root == p || root == q)&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    <span class="keyword">if</span>(left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left != <span class="keyword">null</span> ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-7-反序列化"><a href="#2-7-反序列化" class="headerlink" title="2.7 反序列化"></a>2.7 反序列化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="keyword">null</span> || data.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] dataArr = data.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    <span class="comment">// 层次遍历逆向还原二叉树</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    TreeNode root = toNode(dataArr[index]);</span><br><span class="line">    LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (index &lt; dataArr.length - <span class="number">2</span> &amp;&amp; !queue.isEmpty()) &#123;</span><br><span class="line">        TreeNode cur = queue.remove();</span><br><span class="line">        <span class="comment">// 添加左子节点</span></span><br><span class="line">        TreeNode leftNode = toNode(dataArr[++index]);</span><br><span class="line">        cur.left = leftNode;</span><br><span class="line">        <span class="comment">// 队列中的节点用于为其赋值孩子节点，若该节点本身为 null，</span></span><br><span class="line">        <span class="comment">// 没有孩子节点，便不再添加到队列中，下同理</span></span><br><span class="line">        <span class="keyword">if</span> (leftNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(leftNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加右子节点</span></span><br><span class="line">        TreeNode rightNode = toNode(dataArr[++index]);</span><br><span class="line">        cur.right = rightNode;</span><br><span class="line">        <span class="keyword">if</span> (rightNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(rightNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">toNode</span><span class="params">(String val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="string">&quot;null&quot;</span>.equals(val)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(Integer.parseInt(val));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer27.二叉树的镜像</title>
    <url>/2020/09/16/%E5%89%91%E6%8C%87Offer27.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode l = mirrorTree(root.right);</span><br><span class="line">        TreeNode r = mirrorTree(root.left);</span><br><span class="line">        root.left = l;</span><br><span class="line">        root.right = r;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(n)，</p>
</li>
<li><p>空间复杂度：O(n)。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer46. 把数字翻译成字符串</title>
    <url>/2020/09/28/%E5%89%91%E6%8C%87Offer46.%20%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p><strong>dp</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        String s = String.valueOf(num);</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= s.length(); i++)&#123;</span><br><span class="line">            String tmp = s.substring(i - <span class="number">2</span>, i);</span><br><span class="line">            <span class="keyword">int</span> c = tmp.compareTo(<span class="string">&quot;10&quot;</span>) &gt;= <span class="number">0</span> &amp;&amp; tmp.compareTo(<span class="string">&quot;25&quot;</span>) &lt;= <span class="number">0</span> ? a + b : b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度 O(N) ： N 为字符串 s 的长度（即数字 num 的位数 log(num) ），其决定了循环次数。</li>
<li>空间复杂度 O(N) ： 字符串 s 使用 O(N) 大小的额外空间。</li>
</ul>
<p><strong>求余</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num &lt; <span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num % <span class="number">100</span> &gt;= <span class="number">10</span> &amp;&amp; num % <span class="number">100</span> &lt;= <span class="number">25</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> translateNum(num / <span class="number">10</span>) + translateNum(num / <span class="number">100</span>); </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> translateNum(num / <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, x, y = num % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span>(num != <span class="number">0</span>) &#123;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">            x = num % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">10</span> * x + y;</span><br><span class="line">            <span class="keyword">int</span> c = (tmp &gt;= <span class="number">10</span> &amp;&amp; tmp &lt;= <span class="number">25</span>) ? a + b : a;</span><br><span class="line">            b = a;</span><br><span class="line">            a = c;</span><br><span class="line">            y = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>时间复杂度 O(N) ： N 为字符串 s 的长度（即数字 num 的位数 log(num) ），其决定了循环次数。</p>
</li>
<li><p>空间复杂度 O(1) ： 几个变量使用常数大小的额外空间。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>反转链表</title>
    <url>/2020/09/03/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，反转链表后，输出新链表的表头。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment">	ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">    this.val = val;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode p = <span class="keyword">null</span>;</span><br><span class="line">        ListNode q = head;</span><br><span class="line">        ListNode temp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(q!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            temp = q.next;</span><br><span class="line">            q.next = p;</span><br><span class="line">            p = q;</span><br><span class="line">            q = temp;          </span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>ListNode</tag>
      </tags>
  </entry>
  <entry>
    <title>小红书笔试题2.笔记草稿</title>
    <url>/2020/09/22/%E5%B0%8F%E7%BA%A2%E4%B9%A6%E7%AC%94%E8%AF%95%E9%A2%982.%E7%AC%94%E8%AE%B0%E8%8D%89%E7%A8%BF/</url>
    <content><![CDATA[<p>1.输入字符包括，”(“  ,  “)”  和  “&lt;”和其他字符。 </p>
<p>2.其他字符表示笔记内容。 </p>
<p>3.()之间表示注释内容，任何字符都无效。  括号保证成对出现。 </p>
<p> 4.”&lt;”表示退格,  删去前面一个笔记内容字符。括号不受”&lt;”影响  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xiaohongshuCode2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        stringBuffer = <span class="keyword">new</span> StringBuffer(sc.nextLine());</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stringBuffer.length();)&#123;</span><br><span class="line">            <span class="keyword">if</span>(stringBuffer.charAt(i) == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                list.add(i);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(stringBuffer.charAt(i) == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> end = list.size() - <span class="number">1</span>;</span><br><span class="line">                stringBuffer.delete(list.get(end), i + <span class="number">1</span>);</span><br><span class="line">                i = list.get(end);</span><br><span class="line">                list.remove(end);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(stringBuffer.charAt(i) == <span class="string">&#x27;&lt;&#x27;</span>)&#123;</span><br><span class="line">                stringBuffer.delete(i - <span class="number">1</span>, i + <span class="number">1</span>);</span><br><span class="line">                i--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(stringBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>StringBuffer：</strong></p>
<ul>
<li>delete（int begin,int end）有两个参数，使用时删除索引从begin开始（包含begin）到end（不包含end）的所有字符；</li>
<li>deleteCharAt（int index）只有一个参数，使用时删除索引为index的字符；</li>
</ul>
<p><a href="https://www.nowcoder.com/questionTerminal/0823ca800ee04706a7e2dafc837dc236">https://www.nowcoder.com/questionTerminal/0823ca800ee04706a7e2dafc837dc236</a></p>
]]></content>
      <categories>
        <category>笔试</category>
      </categories>
      <tags>
        <tag>笔试</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>小红书笔试题3.笔记精选</title>
    <url>/2020/09/22/%E5%B0%8F%E7%BA%A2%E4%B9%A6%E7%AC%94%E8%AF%95%E9%A2%983.%E7%AC%94%E8%AE%B0%E7%B2%BE%E9%80%89/</url>
    <content><![CDATA[<p>1.不能出现连续编号的笔记。 </p>
<p>2.总点赞总数最多 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xiaohongshuCode3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            nums[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(nums[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pre = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> cur = nums[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = cur;</span><br><span class="line">            <span class="keyword">if</span> (pre + nums[i] &gt; tmp)&#123;</span><br><span class="line">                cur = pre + nums[i];</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(cur + <span class="string">&quot; &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔试</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>度小满笔试1.涂色</title>
    <url>/2020/09/21/%E5%BA%A6%E5%B0%8F%E6%BB%A1%E7%AC%94%E8%AF%951.%E6%B6%82%E8%89%B2/</url>
    <content><![CDATA[<ul>
<li><p>给定两个字符串，判断相同字符的个数</p>
<ul>
<li><p>输入：</p>
<p>ABC</p>
<p>ACC</p>
</li>
<li><p>输出：</p>
<p>2</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DuXiaoManCode1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str1 = sc.next();</span><br><span class="line">        String str2 = sc.next();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str1.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hashMap.containsKey(str1.charAt(i)))&#123;</span><br><span class="line">                hashMap.put(str1.charAt(i), hashMap.get(str1.charAt(i)) + <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                hashMap.put(str1.charAt(i), <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str2.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hashMap.containsKey(str2.charAt(i)))&#123;</span><br><span class="line">                <span class="keyword">if</span>(hashMap.get(str2.charAt(i)) == <span class="number">1</span>)&#123;</span><br><span class="line">                    hashMap.remove(str2.charAt(i));</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    hashMap.put(str2.charAt(i), hashMap.get(str2.charAt(i)) - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔试</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>度小满笔试2.昆虫走迷宫</title>
    <url>/2020/09/21/%E5%BA%A6%E5%B0%8F%E6%BB%A1%E7%AC%94%E8%AF%952.%E6%98%86%E8%99%AB%E8%B5%B0%E8%BF%B7%E5%AE%AB/</url>
    <content><![CDATA[<ul>
<li><p>@代表昆虫位置，.代表可以通行，#代表不可越过的墙壁，*代表可以越过的墙壁，求昆虫走出迷宫最小破壁次数</p>
<ul>
<li><p>输入：</p>
<p>3</p>
<p>3 3</p>
<p>###</p>
<p>*@#</p>
<p>.##</p>
<p>3 3</p>
<p>@##</p>
<p>…</p>
<p>#**</p>
<p>3 3</p>
<p>#.#</p>
<p>*@#</p>
<p>###</p>
</li>
<li><p>输出：</p>
<p>1</p>
<p>0</p>
<p>1</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> nums = sc.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> m = sc.nextInt();</span><br><span class="line">            <span class="keyword">int</span> n = sc.nextInt();</span><br><span class="line">            <span class="keyword">char</span>[][] input = <span class="keyword">char</span>[m][n];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">                String s = sc.next();</span><br><span class="line">                <span class="keyword">char</span>[] sctmp = s.toCharArray();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; sctmp.length; k++)&#123;</span><br><span class="line">                    input[j][k] = sctmp[k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b.length; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; a[<span class="number">0</span>].length; k++)&#123;</span><br><span class="line">                    res[i][j] = Integer.MAX_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span>[][] visited = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; input.length; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k =<span class="number">0</span>; k &lt; input[<span class="number">0</span>].length; k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[j][k] == <span class="string">&#x27;@&#x27;</span>)&#123;</span><br><span class="line">                        <span class="keyword">new</span> Main().dfs(input, res, visited, m, n, j, k, <span class="number">0</span>);</span><br><span class="line">                        System.out.println(b[j][k] == Integer.MAX_VALUE ? -<span class="number">1</span> : b[j][k]);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] input, <span class="keyword">int</span>[][] res, <span class="keyword">int</span>[][] visited, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> countNew = count;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt; m || j &gt; m)&#123;</span><br><span class="line">            retrun <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res[i][j] != Integer.MAX_VALUE &amp;&amp; res[i][j] &lt;= countNew)&#123;</span><br><span class="line">            <span class="keyword">return</span> res[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(visited[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(input[i][j] == <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(input[i][j] == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> countNew++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        visited[i][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> a = dfs(input, res, visited, m, n, i + <span class="number">1</span>, j, countNew);</span><br><span class="line">        <span class="keyword">int</span> b = dfs(input, res, visited, m, n, i - <span class="number">1</span>, j, countNew);</span><br><span class="line">        <span class="keyword">int</span> c = dfs(input, res, visited, m, n, i, j + <span class="number">1</span>, countNew);</span><br><span class="line">        <span class="keyword">int</span> d = dfs(input, res, visited, m, n, i, j - <span class="number">1</span>, countNew);</span><br><span class="line">        visited[i][j] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> min = Math,min(res[i][j], Math.min(Math.min(a, b), Math.min(c, d)));</span><br><span class="line">        <span class="keyword">if</span>(input[i][j] == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">            min++;</span><br><span class="line">        &#125;</span><br><span class="line">        res[i][j] = Math.min(min, res[i][j]);</span><br><span class="line">        <span class="keyword">return</span> res[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔试</category>
      </categories>
      <tags>
        <tag>笔试</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>排序</title>
    <url>/2020/09/17/%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><table>
<thead>
<tr>
<th align="center">排序算法</th>
<th align="center">平均时间复杂度</th>
<th align="center">最好情况</th>
<th align="center">最坏情况</th>
<th align="center">空间复杂度</th>
<th align="center">排序方式</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">冒泡排序</td>
<td align="center">O(n^2)</td>
<td align="center">O(n)</td>
<td align="center">O(n^2)</td>
<td align="center">O(1)</td>
<td align="center">In-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">选择排序</td>
<td align="center">O(n^2)</td>
<td align="center">O(n^2)</td>
<td align="center">O(n^2)</td>
<td align="center">O(1)</td>
<td align="center">In-place</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">插入排序</td>
<td align="center">O(n^2)</td>
<td align="center">O(n)</td>
<td align="center">O(n^2)</td>
<td align="center">O(1)</td>
<td align="center">In-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">希尔排序</td>
<td align="center">O(nlogn)</td>
<td align="center">O(nlog^2 n)</td>
<td align="center">O(n^1.5)</td>
<td align="center">O(1)</td>
<td align="center">In-place</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">归并排序</td>
<td align="center">O(nlogn)</td>
<td align="center">O(nlogn)</td>
<td align="center">O(nlogn)</td>
<td align="center">O(n)</td>
<td align="center">Out-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">快速排序</td>
<td align="center">O(nlogn)</td>
<td align="center">O(nlogn)</td>
<td align="center">O(n^2)</td>
<td align="center">O(nlogn)</td>
<td align="center">In-place</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">堆排序</td>
<td align="center">O(nlogn)</td>
<td align="center">O(nlogn)</td>
<td align="center">O(nlogn)</td>
<td align="center">O(1)</td>
<td align="center">In-place</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">计数排序</td>
<td align="center">O(n+k)</td>
<td align="center">O(n+k)</td>
<td align="center">O(n+k)</td>
<td align="center">O(k)</td>
<td align="center">Out-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">桶排序</td>
<td align="center">O(n+k)</td>
<td align="center">O(n+k)</td>
<td align="center">O(n^2)</td>
<td align="center">O(n+k)</td>
<td align="center">Out-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">基数排序</td>
<td align="center">O(n*k)</td>
<td align="center">O(n*k)</td>
<td align="center">O(n*k)</td>
<td align="center">O(n+k)</td>
<td align="center">Out-place</td>
<td align="center">稳定</td>
</tr>
</tbody></table>
<a id="more"></a>

<ul>
<li>平均情况下，快些归队的时间复杂度好O(nlogn)</li>
<li>最坏情况下，除快速排序外，都与平均情况相同</li>
<li>快些选队不稳定</li>
<li>插入排序和冒泡排序适合基本有序的序列</li>
<li>经过一趟排序就可以保证一个关键字到达最终位置的是：冒泡、快速、堆</li>
<li>选择排序和折半插入与原始序列无关</li>
</ul>
<h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1 冒泡排序"></a>1 冒泡排序</h2><ul>
<li>比较相邻的元素，如果前一个大于后一个，就交换位置；</li>
<li>每循环一次，最大的元素会位于数列的最后一个位置</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bubbleSort(<span class="keyword">int</span>[] array)&#123;</span><br><span class="line">    <span class="keyword">if</span>(array.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - <span class="number">1</span> - i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[j] &gt; array[j + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = array[j];</span><br><span class="line">                array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">                array[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2 选择排序"></a>2 选择排序</h2><ul>
<li>遍历数列，选择最小值放到第一个位置</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] selectSort(<span class="keyword">int</span>[] array)&#123;</span><br><span class="line">    <span class="keyword">if</span>(array.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; array.length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[j] &lt; array[minIndex])&#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = array[minIndex];</span><br><span class="line">        array[minIndex] = array[j];</span><br><span class="line">        array[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3 插入排序"></a>3 插入排序</h2><ul>
<li>从第二个元素开始，将其插入到合适的位置</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] insertSort(<span class="keyword">int</span>[] array)&#123;</span><br><span class="line">    <span class="keyword">if</span>(array.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> current;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i ++)&#123;</span><br><span class="line">        current = array[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> preIndex = i;</span><br><span class="line">        <span class="keyword">while</span>(preIndex &gt; <span class="number">0</span> &amp;&amp; current &lt; array[preIndex])&#123;</span><br><span class="line">            array[preIndex + <span class="number">1</span>] = array[preIndex];</span><br><span class="line">            preIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        array[preIndex + <span class="number">1</span>] = currentl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4 希尔排序"></a>4 希尔排序</h2><ul>
<li>将整个数列分组进行插入排序</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] shellSort(<span class="keyword">int</span>[] array)&#123;</span><br><span class="line">    <span class="keyword">if</span>(array.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">int</span> gap = array.length / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(gap &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = gap; i &lt; array.length; i++)&#123;</span><br><span class="line">            temp = array[i];</span><br><span class="line">            <span class="keyword">int</span> pre = i - gap;</span><br><span class="line">            <span class="keyword">while</span>(pre &gt; <span class="number">0</span> &amp;&amp; temp &lt; array[pre])&#123;</span><br><span class="line">                array[pre + <span class="number">1</span>] = array[pre];</span><br><span class="line">                pre -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            array[pre + gap] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        gap /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5 归并排序"></a>5 归并排序</h2><ul>
<li>将数列等分为两个数列递归进行归并排序</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mergeSort(<span class="keyword">int</span>[] array)&#123;</span><br><span class="line">    <span class="keyword">if</span>(array.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = array.length / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span>[] left = Arrays.vopyOfRange(array, <span class="number">0</span>, mid);</span><br><span class="line">    <span class="keyword">int</span>[] right = Arrays.copyOfRange(array, mid, array.length);</span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] merge(<span class="keyword">int</span>[] l, <span class="keyword">int</span>[] r)&#123;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[l.length + r.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>; k &lt; res.length; k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; l.length)&#123;</span><br><span class="line">            res[k] = r[j++];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j &gt; r.length)&#123;</span><br><span class="line">            res[k] = l[i++];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(l[i] &gt; r[j])&#123;</span><br><span class="line">            res[k] = r[j++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res[k] = l[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6 快速排序"></a>6 快速排序</h2><ul>
<li>遍历数列，把基准排到合适位置后，递归</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] quickSort(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)&#123;</span><br><span class="line">    <span class="keyword">if</span>(array.length &lt; <span class="number">1</span> || start &lt; <span class="number">0</span> || end &gt; array.length || start &gt; end)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> parIndex = partition(array, start, end);</span><br><span class="line">    quickSort(array, start, parIndex - <span class="number">1</span>);</span><br><span class="line">    quickSort(array, parIndex + <span class="number">1</span>, end);</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] partition(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = start;</span><br><span class="line">    <span class="keyword">int</span> index = pivot + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt;= end; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i] &lt; array[pivot])&#123;</span><br><span class="line">            swap(array, i, index);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(array, pivot, index - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> index - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pulic <span class="keyword">void</span> <span class="title">swap</span><span class="params">()</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = array[i];</span><br><span class="line">    array[i] = array[j];</span><br><span class="line">    array[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7 堆排序"></a>7 堆排序</h2><ul>
<li>取大顶堆的堆顶元素作为数列的最后一个值，递归</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] HeapSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">    len = array.length;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">1</span>) <span class="keyword">return</span> array;</span><br><span class="line">    buildMaxHeap(array);</span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        swap(array, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">        len--;</span><br><span class="line">        adjustHeap(array, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (len/<span class="number">2</span> - <span class="number">1</span>); i &gt;= <span class="number">0</span>; i--) &#123; </span><br><span class="line">        adjustHeap(array, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxIndex = i;</span><br><span class="line">    <span class="comment">//如果有左子树，且左子树大于父节点，则将最大指针指向左子树</span></span><br><span class="line">    <span class="keyword">if</span> (i * <span class="number">2</span> &lt; len &amp;&amp; array[i * <span class="number">2</span>] &gt; array[maxIndex])</span><br><span class="line">        maxIndex = i * <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//如果有右子树，且右子树大于父节点，则将最大指针指向右子树</span></span><br><span class="line">    <span class="keyword">if</span> (i * <span class="number">2</span> + <span class="number">1</span> &lt; len &amp;&amp; array[i * <span class="number">2</span> + <span class="number">1</span>] &gt; array[maxIndex])</span><br><span class="line">        maxIndex = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。</span></span><br><span class="line">    <span class="keyword">if</span> (maxIndex != i) &#123;</span><br><span class="line">        swap(array, maxIndex, i);</span><br><span class="line">        adjustHeap(array, maxIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pulic <span class="keyword">void</span> <span class="title">swap</span><span class="params">()</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = array[i];</span><br><span class="line">    array[i] = array[j];</span><br><span class="line">    array[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-计数排序"><a href="#8-计数排序" class="headerlink" title="8 计数排序"></a>8 计数排序</h2><ul>
<li>统计每个值出现的次数，反向填充数组</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] CountingSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array.length == <span class="number">0</span>) <span class="keyword">return</span> array;</span><br><span class="line">    <span class="keyword">int</span> bias, min = array[<span class="number">0</span>], max = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i] &gt; max)</span><br><span class="line">            max = array[i];</span><br><span class="line">        <span class="keyword">if</span> (array[i] &lt; min)</span><br><span class="line">            min = array[i];</span><br><span class="line">    &#125;</span><br><span class="line">    bias = <span class="number">0</span> - min;</span><br><span class="line">    <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(bucket, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        bucket[array[i] + bias]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; array.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bucket[i] != <span class="number">0</span>) &#123;</span><br><span class="line">        	array[index] = i - bias;</span><br><span class="line">            bucket[i]--;</span><br><span class="line">            index++;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-桶排序"><a href="#9-桶排序" class="headerlink" title="9 桶排序"></a>9 桶排序</h2><ul>
<li>遍历数列，将其放到不同的桶中排序后拼接</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">BucketSort</span><span class="params">(ArrayList&lt;Integer&gt; array, <span class="keyword">int</span> bucketSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.size() &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    <span class="keyword">int</span> max = array.get(<span class="number">0</span>), min = array.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array.get(i) &gt; max)</span><br><span class="line">            max = array.get(i);</span><br><span class="line">        <span class="keyword">if</span> (array.get(i) &lt; min)</span><br><span class="line">            min = array.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> bucketCount = (max - min) / bucketSize + <span class="number">1</span>;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = <span class="keyword">new</span> ArrayList&lt;&gt;(bucketCount);</span><br><span class="line">    ArrayList&lt;Integer&gt; resultArr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketCount; i++) &#123;</span><br><span class="line">        bucketArr.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.size(); i++) &#123;</span><br><span class="line">        bucketArr.get((array.get(i) - min) / bucketSize).add(array.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketCount; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bucketSize == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucketArr.get(i).size(); j++)</span><br><span class="line">                resultArr.add(bucketArr.get(i).get(j));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucketCount == <span class="number">1</span>)</span><br><span class="line">                bucketSize--;</span><br><span class="line">            ArrayList&lt;Integer&gt; temp = BucketSort(bucketArr.get(i), bucketSize);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; temp.size(); j++)</span><br><span class="line">                resultArr.add(temp.get(j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-基数排序"><a href="#10-基数排序" class="headerlink" title="10 基数排序"></a>10 基数排序</h2><ul>
<li>先根据数据的位数分桶，再进行计数排序</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] RadixSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        max = Math.max(max, array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxDigit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (max != <span class="number">0</span>) &#123;</span><br><span class="line">        max /= <span class="number">10</span>;</span><br><span class="line">        maxDigit++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">10</span>, div = <span class="number">1</span>;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        bucketList.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxDigit; i++, mod *= <span class="number">10</span>, div *= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = (array[j] % mod) / div;</span><br><span class="line">            bucketList.get(num).add(array[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucketList.size(); j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; bucketList.get(j).size(); k++)</span><br><span class="line">                array[index++] = bucketList.get(j).get(k);</span><br><span class="line">            bucketList.get(j).clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>































]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>携程笔试题1.订单记录</title>
    <url>/2020/09/23/%E6%90%BA%E7%A8%8B%E7%AC%94%E8%AF%95%E9%A2%981.%E8%AE%A2%E5%8D%95%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>输入一个时间值A，需要在这批记录中找到符合入离店时间范围（A大于等于入店时间，并且A小于等于离店时间）内的所有记录。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xiechengCode1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span> a = sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = sc.nextInt();</span><br><span class="line">            <span class="keyword">int</span> low = sc.nextInt();</span><br><span class="line">            <span class="keyword">int</span> high = sc.nextInt();</span><br><span class="line">            <span class="keyword">if</span>(a &gt;= low &amp;&amp; a &lt;= high)&#123;</span><br><span class="line">                res[i] = index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(res);</span><br><span class="line">        <span class="keyword">if</span>(res[n - <span class="number">1</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(res[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(res[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔试</category>
      </categories>
      <tags>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>携程笔试题2.LRU Cache</title>
    <url>/2020/09/28/%E6%90%BA%E7%A8%8B%E7%AC%94%E8%AF%95%E9%A2%982.LRU%20Cache/</url>
    <content><![CDATA[<p>设计一个数据结构，实现LRU Cache的功能(Least Recently Used – 最近最少使用缓存)。它支持如下2个操作： get 和 put。</p>
<ul>
<li>int get(int key) <ul>
<li>如果key已存在，则返回key对应的值value（始终大于0）；</li>
<li>如果key不存在，则返回-1。</li>
</ul>
</li>
<li>void put(int key, int value) <ul>
<li>如果key不存在，将value插入；</li>
<li>如果key已存在，则使用value替换原先已经存在的值。如果容量达到了限制，LRU Cache需要在插入新元素之前，将最近最少使用的元素删除。</li>
</ul>
</li>
</ul>
<p>请特别注意“使用”的定义：新插入或获取key视为被使用一次；而将已经存在的值替换更新，不算被使用。</p>
<p>限制：请在O(1)的时间复杂度内完成上述2个操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xiechengCode2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LRUCache</span><span class="params">(Scanner sc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = Integer.parseInt(sc.nextLine());</span><br><span class="line">        LinkedHashMap&lt;Integer,Integer&gt; mmap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        String[] temp;</span><br><span class="line">        <span class="keyword">int</span> key,value;</span><br><span class="line">        <span class="keyword">while</span> (sc.hasNext())&#123;</span><br><span class="line">            temp = sc.nextLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            key = Integer.parseInt(temp[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;p&quot;</span>.equals(temp[<span class="number">0</span>]))&#123;</span><br><span class="line">                value = Integer.parseInt(temp[<span class="number">2</span>]);</span><br><span class="line">                <span class="keyword">if</span> (mmap.containsKey(key))&#123;<span class="comment">//覆盖已有，其它什么都不做</span></span><br><span class="line">                    mmap.put(key,value);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (curr==n)&#123;<span class="comment">//如果队满了，插入新值并删除队首元素。</span></span><br><span class="line">                    mmap.put(key,value);</span><br><span class="line">                    key = mmap.entrySet().iterator().next().getKey();<span class="comment">//队首元素key</span></span><br><span class="line">                    mmap.remove(key);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    mmap.put(key,value);</span><br><span class="line">                    curr++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (mmap.containsKey(key))&#123;<span class="comment">//查询已有值，然后删除再插入在队尾</span></span><br><span class="line">                    value = mmap.get(key);</span><br><span class="line">                    System.out.println(value);</span><br><span class="line">                    mmap.remove(key);</span><br><span class="line">                    mmap.put(key,value);</span><br><span class="line">                &#125;<span class="keyword">else</span> System.out.println(-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        LRUCache(sc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔试</category>
      </categories>
      <tags>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>携程笔试题3.bit count</title>
    <url>/2020/09/28/%E6%90%BA%E7%A8%8B%E7%AC%94%E8%AF%95%E9%A2%983.bit%20count/</url>
    <content><![CDATA[<p>输入一个long类型的数值, 求该数值的二进制表示中的1的个数 .</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> xiecheng;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xiechengCode3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">long</span> n = sc.nextLong();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            n &amp;= n - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        sc.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔试</category>
      </categories>
      <tags>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2020/08/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="0-设计模式"><a href="#0-设计模式" class="headerlink" title="0 设计模式"></a>0 设计模式</h2><pre><code>一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案

本质是面向对象设计原则的实际应用</code></pre>
<a id="more"></a>

<h3 id="0-1-分类"><a href="#0-1-分类" class="headerlink" title="0.1 分类"></a>0.1 分类</h3><p><strong>创建型模式：</strong></p>
<ul>
<li>单例模式<ul>
<li>工厂模式</li>
<li>抽象工厂模式 </li>
<li>建造者模式 </li>
<li>原型模式</li>
</ul>
</li>
</ul>
<p><strong>结构型模式：</strong></p>
<ul>
<li>适配器模式</li>
<li>桥接模式</li>
<li>装饰模式</li>
<li>组合模式</li>
<li>外观模式</li>
<li>享元模式</li>
<li>代理模式</li>
</ul>
<p><strong>行为型模式：</strong></p>
<ul>
<li>模板方法模式</li>
<li>命令模式</li>
<li>迭代器模式</li>
<li>观察者模式</li>
<li>中介者模式</li>
<li>备忘录模式</li>
<li>解释器模式</li>
<li>状态模式</li>
<li>策略模式</li>
<li>职责链模式</li>
<li>访问者模式</li>
</ul>
<h3 id="0-2-OOP七大原则"><a href="#0-2-OOP七大原则" class="headerlink" title="0.2 OOP七大原则"></a>0.2 OOP七大原则</h3><p><strong>开闭原则：</strong> 对扩展开放，对修改关闭；<br><strong>里氏替换原则：</strong> 继承必须确保超类拥有的性质在子类中仍然成立；<br><strong>依赖倒置原则：</strong> 面向接口编程，而不是面向实现编程；<br><strong>单一职责原则：</strong> 控制类的粒度大小，将对象解耦，提高内聚性；<br><strong>接口隔离原则：</strong> 为类建立需要的专用接口；<br><strong>迪米特法则：</strong> 只与直接朋友交谈；<br><strong>合成复用原则：</strong> 优先使用组合、聚合等关联关系，其次才考虑使用继承实现。</p>
<h3 id="0-3-UML类图"><a href="#0-3-UML类图" class="headerlink" title="0.3 UML类图"></a>0.3 UML类图</h3><pre><code>UML（unified modeling language） 统一建模语言</code></pre>
<ul>
<li>note 注释</li>
<li>class 类</li>
<li>interface 接口</li>
<li>dependency 依赖：一种使用的关系，即一个类的实现需要另一个类的协助</li>
<li>association 关联：一个类知道另一个类的属性和方法</li>
<li>generalization 泛化（继承）：指定子类如何特化父类所以的特征和行为</li>
<li>realization 实现：表示类是接口所有特征和行为的表现</li>
<li>aggregation 聚合：整体与部分的关系，并且部分可以离开整体而单独存在</li>
<li>composite 组合：整体与部分的关系，并且部分不可以离开整体而单独存在</li>
</ul>
<figure class="highlight fix"><table><tr><td class="code"><pre><span class="line"><span class="attr">泛化 </span>=<span class="string"> 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖</span></span><br></pre></td></tr></table></figure>



<h2 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1 单例模式"></a>1 单例模式</h2><pre><code>某个类只能存在一个对象实例，并且该类只提供一个区的其对象实例的静态方法</code></pre>
<h3 id="1-1-饿汉式（静态常量）"><a href="#1-1-饿汉式（静态常量）" class="headerlink" title="1.1 饿汉式（静态常量）"></a>1.1 饿汉式（静态常量）</h3><ul>
<li>写法简单，在类装载的时候就完成了实例化，避免了线程同步问题；</li>
<li>没有达到lazy loading的效果，如果实例未使用，就会造成内存浪费；</li>
</ul>
<h3 id="1-2-饿汉式（静态代码块）"><a href="#1-2-饿汉式（静态代码块）" class="headerlink" title="1.2 饿汉式（静态代码块）"></a>1.2 饿汉式（静态代码块）</h3><h3 id="1-3-懒汉式（线程不安全）"><a href="#1-3-懒汉式（线程不安全）" class="headerlink" title="1.3 懒汉式（线程不安全）"></a>1.3 懒汉式（线程不安全）</h3><pre><code>提供一个静态的共有方法，当使用到该方法时，才去创建单例对象</code></pre>
<ul>
<li>起到lazy loading的效果；</li>
<li>只能在单线程下使用；</li>
<li>实际开发不可用。</li>
</ul>
<h3 id="1-4-懒汉式（线程安全）"><a href="#1-4-懒汉式（线程安全）" class="headerlink" title="1.4 懒汉式（线程安全）"></a>1.4 懒汉式（线程安全）</h3><pre><code>提供一个静态的共有方法，加入synchronized 同步代码</code></pre>
<ul>
<li>解决了线程不安全问题；</li>
<li>效率低；</li>
<li>实际开发不推荐使用。</li>
</ul>
<h3 id="1-5-懒汉式（同步代码块）"><a href="#1-5-懒汉式（同步代码块）" class="headerlink" title="1.5 懒汉式（同步代码块）"></a>1.5 懒汉式（同步代码块）</h3><ul>
<li>不能线程同步；</li>
<li>实际开发不可用。</li>
</ul>
<h3 id="1-6-懒汉式（双重检查）"><a href="#1-6-懒汉式（双重检查）" class="headerlink" title="1.6 懒汉式（双重检查）"></a>1.6 懒汉式（双重检查）</h3><pre><code>先使用volatile保证修改对所有线程可见，再加入synchronized同步代码块</code></pre>
<ul>
<li>保证线程安全；</li>
<li>延迟加载；</li>
<li>效率高</li>
<li>实际开发推荐使用。</li>
</ul>
<h3 id="1-7-单例（静态内部类）"><a href="#1-7-单例（静态内部类）" class="headerlink" title="1.7 单例（静态内部类）"></a>1.7 单例（静态内部类）</h3><ul>
<li>保证初始化实例只有一个线程；</li>
<li>静态内部类在装载时并不会立即实例化，而是在需要时完成实例化；</li>
<li>类的静态属性只在第一次加载类的时候初始化；</li>
<li>线程安全；</li>
<li>实现了懒加载；</li>
<li>效率高；</li>
<li>推荐使用。</li>
</ul>
<h3 id="1-8-单例（枚举）"><a href="#1-8-单例（枚举）" class="headerlink" title="1.8 单例（枚举）"></a>1.8 单例（枚举）</h3><ul>
<li>避免多线程同步问题，防止反序列化重新创建新的对象</li>
<li>推荐使用</li>
</ul>
<h2 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2 工厂模式"></a>2 工厂模式</h2><h3 id="2-1-传统模式"><a href="#2-1-传统模式" class="headerlink" title="2.1 传统模式"></a>2.1 传统模式</h3><ul>
<li>易于理解和操作；</li>
<li>违反了oop原则：对扩展开放，对修改关闭；</li>
</ul>
<h3 id="2-2-简单工厂模式"><a href="#2-2-简单工厂模式" class="headerlink" title="2.2 简单工厂模式"></a>2.2 简单工厂模式</h3><p>由一个工厂对象决定创建出哪一个实例</p>
<h3 id="2-3-工厂方法模式"><a href="#2-3-工厂方法模式" class="headerlink" title="2.3 工厂方法模式"></a>2.3 工厂方法模式</h3><p>将实例化功能抽象成抽象方法</p>
<h3 id="2-4-抽象工厂模式"><a href="#2-4-抽象工厂模式" class="headerlink" title="2.4 抽象工厂模式"></a>2.4 抽象工厂模式</h3><pre><code>定义一个借口用于创建相关或有依赖关系的对象簇，而无需指明具体的类；将工厂抽象成两层：抽象工厂和具体实现的工厂子类。</code></pre>
<h2 id="3-原型模式"><a href="#3-原型模式" class="headerlink" title="3 原型模式"></a>3 原型模式</h2><pre><code>重复创建对象</code></pre>
<h3 id="3-1-传统模式"><a href="#3-1-传统模式" class="headerlink" title="3.1 传统模式"></a>3.1 传统模式</h3><ul>
<li>易于理解和操作</li>
<li>效率低</li>
<li>总是需要重新初始化</li>
</ul>
<h3 id="3-2-原型模式"><a href="#3-2-原型模式" class="headerlink" title="3.2 原型模式"></a>3.2 原型模式</h3><pre><code>用原型实例指定创建对象的种类，通过拷贝原型创建新的对象</code></pre>
<p><strong>浅拷贝：</strong></p>
<ul>
<li>对于数据类型是基本数据类型的成员变量，浅拷贝直接进行值传递；</li>
<li>对于数据类型是引用数据类型的成员变量，浅拷贝进行引用传递；</li>
<li>浅拷贝默认使用clone()方法。</li>
</ul>
<p><strong>深拷贝：</strong></p>
<ul>
<li>复制对象的所有基本数据类型的成员变量值；</li>
<li>为所有引用数据类型的成员变量申请存储空间，并复制其引用的对象，直到该对象可达的所有对象；</li>
<li>重写clone()实现深拷贝；</li>
<li>通过对象序列化实现深拷贝（推荐）：以对象流的方式输出再输入即完成拷贝。</li>
</ul>
<p><strong>原型模式：</strong></p>
<ul>
<li>简化对象的创建过程，提高效率；</li>
<li>不用重新初始化对象，而是动态的获得对象运行是的状态；</li>
<li>克隆对象随原始对象发生变化；</li>
<li>深克隆代码比较复杂；</li>
<li>对已有的类配备克隆方法时，需要修改源代码，违背了开闭原则OCP。</li>
</ul>
<h2 id="4-建造者模式"><a href="#4-建造者模式" class="headerlink" title="4 建造者模式"></a>4 建造者模式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">建造者模式&#x2F;生成器模式：允许用户只通过指定复杂对象的类型和内容就可以构建他们，用户不需要知道具体的内部构造细节。</span><br></pre></td></tr></table></figure>

<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>Product（产品角色）</span><br><span class="line"><span class="bullet">- </span>Builder（抽象建造者）</span><br><span class="line"><span class="bullet">- </span>ConcreteBuilder（具体建造者）</span><br><span class="line"><span class="bullet">- </span>Director（指挥者）</span><br></pre></td></tr></table></figure>

<ul>
<li>客户端不必指定产品内部的细节。将产品本身与创建过程解耦，使得相同的创建过程可以创建不同的产品对象；</li>
<li>每一个具体建造者都相对独立，方便替换和添加；</li>
<li>可以精细地控制产品的创建过程；</li>
<li>增加新的具体建造者无需修改原有类库的代码，符合开闭原则；</li>
<li>产品应该具有较多的共同点；</li>
<li>如果产品的呢诶不复杂，肯导致系统变得复杂。</li>
</ul>
<p><strong>抽象工程模式vs建造者模式</strong></p>
<ul>
<li>抽象工厂模式实现对产品家族（具有不同分类维度的产品组合）的创建，不需要关心构建过程，只关心什么产品由什么工厂生产。</li>
<li>建造者模式则是要求按照指定的蓝图构建产品，主要目的是通过组装零配件而产生一个新产品。</li>
</ul>
<h2 id="5-适配器模式"><a href="#5-适配器模式" class="headerlink" title="5 适配器模式"></a>5 适配器模式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将某个类的接口转换成客户端期望的另一个接口来表示，以提高兼容性。</span><br></pre></td></tr></table></figure>

<h3 id="5-1-类适配器模式"><a href="#5-1-类适配器模式" class="headerlink" title="5.1 类适配器模式"></a>5.1 类适配器模式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Adapter类，通过继承src类，实现dst类接口，完成从src到dst的适配</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">adapter</span> <span class="keyword">extends</span> <span class="title">src</span> <span class="keyword">implements</span> <span class="title">dst</span></span></span><br></pre></td></tr></table></figure>

<h3 id="5-2-对象适配器模式"><a href="#5-2-对象适配器模式" class="headerlink" title="5.2 对象适配器模式"></a>5.2 对象适配器模式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Adapter类，通过持有src类，实现dst类接口，完成从src到dst的适配，尽量使用关联关系替代继承关系。</span><br><span class="line"></span><br><span class="line">最常用</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">adapter</span> <span class="keyword">implements</span> <span class="title">dst</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Src src; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-接口适配器模式"><a href="#5-3-接口适配器模式" class="headerlink" title="5.3 接口适配器模式"></a>5.3 接口适配器模式</h3><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">Adapter类，把<span class="attribute">src</span>作为一个接口，实现dst类接口，完成从<span class="attribute">src</span>到dst的适配。</span><br><span class="line"></span><br><span class="line">也称缺省适配器模式，当不需要全部实现接提供的方法时，可先设计一个抽象类实现接口，并为接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可以有选择地覆盖父类的某些方法。</span><br></pre></td></tr></table></figure>

<p>在springMVC中的handlerDispatcher有应用</p>
<h2 id="6-桥接模式"><a href="#6-桥接模式" class="headerlink" title="6 桥接模式"></a>6 桥接模式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将实现类与抽象类放在两个不同的类层次中，使两个层次可以独立改变</span><br><span class="line"></span><br><span class="line">基于类的最小设计原则</span><br></pre></td></tr></table></figure>

<p>在Jdbc的Driver接口有应用</p>
<h2 id="7-装饰者模式"><a href="#7-装饰者模式" class="headerlink" title="7 装饰者模式"></a>7 装饰者模式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">动态地将新功能附加到对象上，比继承更有弹性</span><br></pre></td></tr></table></figure>

<ul>
<li>Component 被装饰者</li>
<li>Decorator 装饰者</li>
<li>ConcretComponent 具体的主体</li>
<li>ConcreteDecorator 具体的装饰者</li>
</ul>
<h2 id="8-组合模式"><a href="#8-组合模式" class="headerlink" title="8 组合模式"></a>8 组合模式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">又称部分整体模式，创建了对象组的树形结构，将对象组合成树状结构以表示整体-部分的关系，组合能让客户以一致的方式处理个别对象以及组合对象。</span><br></pre></td></tr></table></figure>

<ul>
<li>Component 组合中对象声明接口，用于访问Component子部件</li>
<li>Leaf 叶子节点</li>
<li>Composite 非叶子节点，用于存储子部件</li>
</ul>
<p>在HashMap中有应用</p>
<ul>
<li>简化客户端的操作；</li>
<li>具有较强的扩展性；</li>
<li>方便创建复杂的层次结构；</li>
<li>要求较高的抽象性</li>
</ul>
<h2 id="9-外观模式"><a href="#9-外观模式" class="headerlink" title="9 外观模式"></a>9 外观模式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">又称过程模式，为子系统中的一组接口提供一个一致的界面，用以屏蔽内部子系统的细节。</span><br></pre></td></tr></table></figure>

<ul>
<li>Facade：外观类</li>
<li>Client：调用者</li>
<li>子系统</li>
</ul>
<p>在MyBatis有应用</p>
<ul>
<li>降低了客户端对子系统使用的复杂性；</li>
<li>使子系统内部更易维护和扩展；</li>
</ul>
<h2 id="10-享元模式"><a href="#10-享元模式" class="headerlink" title="10 享元模式"></a>10 享元模式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">又称蝇量模式，参考常量池、数据库连接池。缓冲池</span><br></pre></td></tr></table></figure>

<ul>
<li>FlyWeight：享元角色，是产品的抽象类，定义对象的外部状态和内部状态的接口或实现<ul>
<li>内部状态：对象共享出的信息，存储中享元对象内部并且不随环境改变</li>
<li>外部状态：对象得以依赖的一个标记，随环境改变，不可共享</li>
</ul>
</li>
<li>ConcreteFlyWeight：具体的享元角色</li>
<li>UnShareConcreteFlyWeight：不可共享的角色</li>
<li>FlyWeightFactory：享元工厂</li>
</ul>
<h2 id="11-代理模式"><a href="#11-代理模式" class="headerlink" title="11 代理模式"></a>11 代理模式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">为一个对象提供一个替身，以控制对这个对象的访问</span><br></pre></td></tr></table></figure>

<h3 id="11-1-静态代理"><a href="#11-1-静态代理" class="headerlink" title="11.1 静态代理"></a>11.1 静态代理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在使用时，需要定义接口或者父类，被代理对象和代理对象一起实现相同的接口或者继承相同父类</span><br></pre></td></tr></table></figure>

<p>Spring AOP</p>
<h3 id="11-2-动态代理"><a href="#11-2-动态代理" class="headerlink" title="11.2 动态代理"></a>11.2 动态代理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">也称JDK代理、接口代理；</span><br><span class="line"></span><br><span class="line">代理对象不需要实现接口，被代理对象需要实现接口；</span><br><span class="line"></span><br><span class="line">利用JDK中的API动态地在内存中构建代理对象。（java.lang.reflect.Proxy()）</span><br></pre></td></tr></table></figure>

<h3 id="11-3-Cglib代理"><a href="#11-3-Cglib代理" class="headerlink" title="11.3 Cglib代理"></a>11.3 Cglib代理</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">也称子类代理；</span></span><br><span class="line"></span><br><span class="line"><span class="attr">使用目标对象子类实现代理；</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Spring</span> <span class="string">AOP ，实现方法拦截。</span></span><br></pre></td></tr></table></figure>

<h2 id="12-模板模式"><a href="#12-模板模式" class="headerlink" title="12 模板模式"></a>12 模板模式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在一个抽象类中公开定义了执行它的方法的模板，它的子类可以按需要重写方法实现，但调用讲义抽象类中定义的方式进行。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>AbstractClass：抽象类，类中定义了模板方法；</p>
</li>
<li><p>ConcreteClass：实现类</p>
</li>
</ul>
<p>Spring IOC</p>
<h2 id="13-命令模式"><a href="#13-命令模式" class="headerlink" title="13 命令模式"></a>13 命令模式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个</span><br></pre></td></tr></table></figure>

<ul>
<li>Invoker：调用者</li>
<li>Receiver：被调用者</li>
<li>Command：命令，接口或虚拟类</li>
<li>ConcreteCommand：将一个接收者与一个动作绑定</li>
</ul>
<p>JDBC Tml</p>
<h2 id="14-访问者模式"><a href="#14-访问者模式" class="headerlink" title="14 访问者模式"></a>14 访问者模式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">封装一些作用于某种数据结构的各元素的操作，可以在不改变数据结构的前提下定义作用于这些元素的新操作。</span><br><span class="line"></span><br><span class="line">将数据结果和数据操作解耦</span><br></pre></td></tr></table></figure>

<ul>
<li>Visitor：抽象访问者，为该对象结果中的ConcreteElement的每一个类声明一个visit操作</li>
<li>ConcreteVisitor：具体的访问者</li>
<li>ObjectStructure：枚举它的元素，提供一个高层的接口，以允许访问者访问元素</li>
<li>ConcreteElement：具体的元素</li>
</ul>
<h2 id="15-迭代器模式"><a href="#15-迭代器模式" class="headerlink" title="15 迭代器模式"></a>15 迭代器模式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">提供一种遍历集合元素的统一接口，用一致的方法遍历集合元素，不需要知道集合对象的底层表示。</span><br></pre></td></tr></table></figure>

<ul>
<li>Iterator：迭代器，系统提供，包含：hasNext、next、remove</li>
<li>ConcreteIterator：具体的迭代器</li>
<li>Aggregate：一个统一的聚合集合接口，将客户端和具体聚合解耦</li>
<li>ConcreteAggregate：具体的聚合集合</li>
</ul>
<h2 id="16-观察者模式"><a href="#16-观察者模式" class="headerlink" title="16 观察者模式"></a>16 观察者模式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对象之间多对一依赖的一种设计方案，被依赖对象为Subject，依赖对象为Observer，Subject通知Observer变化。</span><br></pre></td></tr></table></figure>

<h2 id="17-中介者模式"><a href="#17-中介者模式" class="headerlink" title="17 中介者模式"></a>17 中介者模式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用一个中介对象来封装一系列的对象交互，是各个对象不需要显式地相互引用，从而使其耦合松散，可以登录的改变它们之间的交互。</span><br></pre></td></tr></table></figure>

<p>MVC中，C就是M和V的中介者</p>
<ul>
<li>Mediator：抽象中介者</li>
<li>Colleague：抽象同事类</li>
<li>ConcreteMediator：具体中介者</li>
<li>ConcreteColleague：具体同事类</li>
</ul>
<h2 id="18-备忘录模式"><a href="#18-备忘录模式" class="headerlink" title="18  备忘录模式"></a>18  备忘录模式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在不破坏封装性的前提下，捕获一个对象的内部状态，在该对象之外保存这个状态，这样以后可以将该对象恢复到原先保存的状态</span><br></pre></td></tr></table></figure>

<ul>
<li>Memento</li>
<li>Originator</li>
<li>Caretaker</li>
</ul>
<h2 id="19-解释器模式"><a href="#19-解释器模式" class="headerlink" title="19 解释器模式"></a>19 解释器模式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个语言（表达式），定义它的文法的一种表示，并定义一个解释器，使用该解释器解释语言中的句子</span><br></pre></td></tr></table></figure>

<ul>
<li>Context：环境角色，含有解释器之外的全局信息</li>
<li>AbstractExpression：抽象表达式</li>
<li>TerminalExpression：终结符表达式</li>
<li>NonTerminalExpression：非终结符表达式</li>
</ul>
<h2 id="20-状态模式"><a href="#20-状态模式" class="headerlink" title="20 状态模式"></a>20 状态模式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用来解决对象在多种状态转换时，需要对外输出不同的行为的问题</span><br><span class="line"></span><br><span class="line">状态发生变化时，行为也发生变化，对象看起来像是变成了其他类</span><br></pre></td></tr></table></figure>

<ul>
<li>Context：环境角色</li>
<li>State：抽象状态角色</li>
<li>Concrete：具体的状态角色</li>
</ul>
<h2 id="21-策略模式"><a href="#21-策略模式" class="headerlink" title="21 策略模式"></a>21 策略模式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">定义算法的族，分别封装，让他们之间可以互相替换。</span><br></pre></td></tr></table></figure>

<h2 id="22-职责链模式"><a href="#22-职责链模式" class="headerlink" title="22 职责链模式"></a>22 职责链模式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">又称责任链模式，为请求创建一个接收者对象的链。</span><br><span class="line"></span><br><span class="line">对请求的发送者和接收者进行解耦</span><br></pre></td></tr></table></figure>

<ul>
<li>Handler：抽象的处理者</li>
<li>ConcreteHandler：具体的处理者，若可以处理，则处理，否则交给下个处理者</li>
<li>Request：请求</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题 08.11. 硬币</title>
    <url>/2020/09/21/%E9%9D%A2%E8%AF%95%E9%A2%98%2008.11.%20%E7%A1%AC%E5%B8%81/</url>
    <content><![CDATA[<p><strong>动态规划：无限背包</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">waysToChange</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] coins = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">25</span>&#125;;</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> coin : coins)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = coin; i &lt;= n; i++)&#123;</span><br><span class="line">                dp[i] = (dp[i] + dp[i - coin]) % <span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/2020/09/02/MySQL/</url>
    <content><![CDATA[<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><pre><code>1.持久化数据到本地
2.可以实现结构化查询，方便管理</code></pre>
<a id="more"></a>

<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><pre><code>1、DB：数据库，保存一组有组织的数据的容器
2、DBMS：数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据
3、SQL:结构化查询语言，用于和DBMS通信的语言</code></pre>
<h2 id="存储数据的特点"><a href="#存储数据的特点" class="headerlink" title="存储数据的特点"></a>存储数据的特点</h2><pre><code>1、将数据放到表中，表再放到库中
2、一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性。
3、表具有一些特性，这些特性定义了数据在表中如何存储，类似java中 “类”的设计。
4、表由列组成，我们也称为字段。所有表都是由一个或多个列组成的，每一列类似java 中的”属性”
5、表中的数据是按行存储的，每一行类似于java中的“对象”。</code></pre>
<h2 id="MySQL产品的介绍和安装"><a href="#MySQL产品的介绍和安装" class="headerlink" title="MySQL产品的介绍和安装"></a>MySQL产品的介绍和安装</h2><h3 id="MySQL服务的启动和停止"><a href="#MySQL服务的启动和停止" class="headerlink" title="MySQL服务的启动和停止"></a>MySQL服务的启动和停止</h3><pre><code>方式一：计算机——右击管理——服务
方式二：通过管理员身份运行
net start 服务名（启动服务）
net stop 服务名（停止服务）</code></pre>
<h3 id="MySQL服务的登录和退出"><a href="#MySQL服务的登录和退出" class="headerlink" title="MySQL服务的登录和退出"></a>MySQL服务的登录和退出</h3><pre><code>方式一：通过mysql自带的客户端
只限于root用户

方式二：通过windows自带的客户端
登录：
mysql 【-h主机名 -P端口号 】-u用户名 -p密码

退出：
exit或ctrl+C    </code></pre>
<h2 id="MySQL的常见命令"><a href="#MySQL的常见命令" class="headerlink" title="MySQL的常见命令"></a>MySQL的常见命令</h2><pre><code>1.查看当前所有的数据库
show databases;
2.打开指定的库
use 库名
3.查看当前库的所有表
show tables;
4.查看其它库的所有表
show tables from 库名;
5.创建表
create table 表名(

    列名 列类型,
    列名 列类型，
    。。。
);
6.查看表结构
desc 表名;


7.查看服务器的版本
方式一：登录到mysql服务端
select version();
方式二：没有登录到mysql服务端
mysql --version
或
mysql --V</code></pre>
<h3 id="MySQL的语法规范"><a href="#MySQL的语法规范" class="headerlink" title="MySQL的语法规范"></a>MySQL的语法规范</h3><pre><code>1.不区分大小写,但建议关键字大写，表名、列名小写
2.每条命令最好用分号结尾
3.每条命令根据需要，可以进行缩进 或换行
4.注释
    单行注释：#注释文字
    单行注释：-- 注释文字
    多行注释：/* 注释文字  */</code></pre>
<p>​<br>​    </p>
<h3 id="SQL的语言分类"><a href="#SQL的语言分类" class="headerlink" title="SQL的语言分类"></a>SQL的语言分类</h3><pre><code>DQL（Data Query Language）：数据查询语言
    select 
DML(Data Manipulate Language):数据操作语言
    insert 、update、delete
DDL（Data Define Languge）：数据定义语言
    create、drop、alter
TCL（Transaction Control Language）：事务控制语言
    commit、rollback</code></pre>
<h3 id="SQL的常见命令"><a href="#SQL的常见命令" class="headerlink" title="SQL的常见命令"></a>SQL的常见命令</h3><pre><code>show databases； 查看所有的数据库
use 库名； 打开指定 的库
show tables ; 显示库中的所有表
show tables from 库名;显示指定库中的所有表
create table 表名(
    字段名 字段类型,    
    字段名 字段类型
); 创建表

desc 表名; 查看指定表的结构
select * from 表名;显示表中的所有数据</code></pre>
<h2 id="DQL语言的学习"><a href="#DQL语言的学习" class="headerlink" title="DQL语言的学习"></a>DQL语言的学习</h2><h3 id="进阶1：基础查询"><a href="#进阶1：基础查询" class="headerlink" title="进阶1：基础查询"></a>进阶1：基础查询</h3><pre><code>语法：
SELECT 要查询的东西
【FROM 表名】;

类似于Java中 :System.out.println(要打印的东西);
特点：
①通过select查询完的结果 ，是一个虚拟的表格，不是真实存在
② 要查询的东西 可以是常量值、可以是表达式、可以是字段、可以是函数</code></pre>
<h3 id="进阶2：条件查询"><a href="#进阶2：条件查询" class="headerlink" title="进阶2：条件查询"></a>进阶2：条件查询</h3><pre><code>条件查询：根据条件过滤原始表的数据，查询到想要的数据
语法：
select 
    要查询的字段|表达式|常量值|函数
from 
    表
where 
    条件 ;

分类：
一、条件表达式
    示例：salary&gt;10000
    条件运算符：
    &gt; &lt; &gt;= &lt;= = != &lt;&gt;

二、逻辑表达式
示例：salary&gt;10000 &amp;&amp; salary&lt;20000

逻辑运算符：

    and（&amp;&amp;）:两个条件如果同时成立，结果为true，否则为false
    or(||)：两个条件只要有一个成立，结果为true，否则为false
    not(!)：如果条件成立，则not后为false，否则为true

三、模糊查询
示例：last_name like &#39;a%&#39;</code></pre>
<h3 id="进阶3：排序查询"><a href="#进阶3：排序查询" class="headerlink" title="进阶3：排序查询"></a>进阶3：排序查询</h3><pre><code>语法：
select
    要查询的东西
from
    表
where 
    条件

order by 排序的字段|表达式|函数|别名 【asc|desc】</code></pre>
<p>​    </p>
<h3 id="进阶4：常见函数"><a href="#进阶4：常见函数" class="headerlink" title="进阶4：常见函数"></a>进阶4：常见函数</h3><pre><code>一、单行函数
1、字符函数
    concat拼接
    substr截取子串
    upper转换成大写
    lower转换成小写
    trim去前后指定的空格和字符
    ltrim去左边空格
    rtrim去右边空格
    replace替换
    lpad左填充
    rpad右填充
    instr返回子串第一次出现的索引
    length 获取字节个数

2、数学函数
    round 四舍五入
    rand 随机数
    floor向下取整
    ceil向上取整
    mod取余
    truncate截断
3、日期函数
    now当前系统日期+时间
    curdate当前系统日期
    curtime当前系统时间
    str_to_date 将字符转换成日期
    date_format将日期转换成字符
4、流程控制函数
    if 处理双分支
    case语句 处理多分支
        情况1：处理等值判断
        情况2：处理条件判断

5、其他函数
    version版本
    database当前库
    user当前连接用户</code></pre>
<p>​    </p>
<p>二、分组函数</p>
<pre><code>    sum 求和
    max 最大值
    min 最小值
    avg 平均值
    count 计数

    特点：
    1、以上五个分组函数都忽略null值，除了count(*)
    2、sum和avg一般用于处理数值型
        max、min、count可以处理任何数据类型
    3、都可以搭配distinct使用，用于统计去重后的结果
    4、count的参数可以支持：
        字段、*、常量值，一般放1

       建议使用 count(*)</code></pre>
<h3 id="进阶5：分组查询"><a href="#进阶5：分组查询" class="headerlink" title="进阶5：分组查询"></a>进阶5：分组查询</h3><pre><code>语法：
select 查询的字段，分组函数
from 表
group by 分组的字段</code></pre>
<p>​<br>​    特点：<br>​    1、可以按单个字段分组<br>​    2、和分组函数一同查询的字段最好是分组后的字段<br>​    3、分组筛选<br>​            针对的表    位置            关键字<br>​    分组前筛选：    原始表        group by的前面        where<br>​    分组后筛选：    分组后的结果集    group by的后面        having<br>​<br>​    4、可以按多个字段分组，字段之间用逗号隔开<br>​    5、可以支持排序<br>​    6、having后可以支持别名</p>
<h3 id="进阶6：多表连接查询"><a href="#进阶6：多表连接查询" class="headerlink" title="进阶6：多表连接查询"></a>进阶6：多表连接查询</h3><pre><code>笛卡尔乘积：如果连接条件省略或无效则会出现
解决办法：添加上连接条件</code></pre>
<h4 id="一、传统模式下的连接-：等值连接——非等值连接"><a href="#一、传统模式下的连接-：等值连接——非等值连接" class="headerlink" title="一、传统模式下的连接 ：等值连接——非等值连接"></a>一、传统模式下的连接 ：等值连接——非等值连接</h4><pre><code>1.等值连接的结果 = 多个表的交集
2.n表连接，至少需要n-1个连接条件
3.多个表不分主次，没有顺序要求
4.一般为表起别名，提高阅读性和性能</code></pre>
<h4 id="二、sql99语法：通过join关键字实现连接"><a href="#二、sql99语法：通过join关键字实现连接" class="headerlink" title="二、sql99语法：通过join关键字实现连接"></a>二、sql99语法：通过join关键字实现连接</h4><pre><code>含义：1999年推出的sql语法
支持：
等值连接、非等值连接 （内连接）
外连接
交叉连接

语法：

select 字段，...
from 表1
【inner|left outer|right outer|cross】join 表2 on  连接条件
【inner|left outer|right outer|cross】join 表3 on  连接条件
【where 筛选条件】
【group by 分组字段】
【having 分组后的筛选条件】
【order by 排序的字段或表达式】

好处：语句上，连接条件和筛选条件实现了分离，简洁明了！</code></pre>
<h4 id="三、自连接"><a href="#三、自连接" class="headerlink" title="三、自连接"></a>三、自连接</h4><p>案例：查询员工名和直接上级的名称</p>
<p>sql99</p>
<pre><code>SELECT e.last_name,m.last_name
FROM employees e
JOIN employees m ON e.`manager_id`=m.`employee_id`;</code></pre>
<p>sql92</p>
<pre><code>SELECT e.last_name,m.last_name
FROM employees e,employees m 
WHERE e.`manager_id`=m.`employee_id`;</code></pre>
<h3 id="进阶7：子查询"><a href="#进阶7：子查询" class="headerlink" title="进阶7：子查询"></a>进阶7：子查询</h3><p>含义：</p>
<pre><code>一条查询语句中又嵌套了另一条完整的select语句，其中被嵌套的select语句，称为子查询或内查询
在外面的查询语句，称为主查询或外查询</code></pre>
<p>特点：</p>
<pre><code>1、子查询都放在小括号内
2、子查询可以放在from后面、select后面、where后面、having后面，但一般放在条件的右侧
3、子查询优先于主查询执行，主查询使用了子查询的执行结果
4、子查询根据查询结果的行数不同分为以下两类：
① 单行子查询
    结果集只有一行
    一般搭配单行操作符使用：&gt; &lt; = &lt;&gt; &gt;= &lt;= 
    非法使用子查询的情况：
    a、子查询的结果为一组值
    b、子查询的结果为空

② 多行子查询
    结果集有多行
    一般搭配多行操作符使用：any、all、in、not in
    in： 属于子查询结果中的任意一个就行
    any和all往往可以用其他查询代替</code></pre>
<h3 id="进阶8：分页查询"><a href="#进阶8：分页查询" class="headerlink" title="进阶8：分页查询"></a>进阶8：分页查询</h3><p>应用场景：</p>
<pre><code>实际的web项目中需要根据用户的需求提交对应的分页查询的sql语句</code></pre>
<p>语法：</p>
<pre><code>select 字段|表达式,...
from 表
【where 条件】
【group by 分组字段】
【having 条件】
【order by 排序的字段】
limit 【起始的条目索引，】条目数;</code></pre>
<p>特点：</p>
<pre><code>1.起始条目索引从0开始

2.limit子句放在查询语句的最后

3.公式：select * from  表 limit （page-1）*sizePerPage,sizePerPage
假如:
每页显示条目数sizePerPage
要显示的页数 page</code></pre>
<h3 id="进阶9：联合查询"><a href="#进阶9：联合查询" class="headerlink" title="进阶9：联合查询"></a>进阶9：联合查询</h3><p>引入：<br>    union 联合、合并</p>
<p>语法：</p>
<pre><code>select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】
select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】
select 字段|常量|表达式|函数 【from 表】 【where 条件】 union  【all】
.....
select 字段|常量|表达式|函数 【from 表】 【where 条件】</code></pre>
<p>特点：</p>
<pre><code>1、多条查询语句的查询的列数必须是一致的
2、多条查询语句的查询的列的类型几乎相同
3、union代表去重，union all代表不去重</code></pre>
<h2 id="DML语言"><a href="#DML语言" class="headerlink" title="DML语言"></a>DML语言</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>语法：<br>    insert into 表名(字段名，…)<br>    values(值1，…);</p>
<p>特点：</p>
<pre><code>1、字段类型和值类型一致或兼容，而且一一对应
2、可以为空的字段，可以不用插入值，或用null填充
3、不可以为空的字段，必须插入值
4、字段个数和值的个数必须一致
5、字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致</code></pre>
<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>修改单表语法：</p>
<pre><code>update 表名 set 字段=新值,字段=新值
【where 条件】</code></pre>
<p>修改多表语法：</p>
<pre><code>update 表1 别名1,表2 别名2
set 字段=新值，字段=新值
where 连接条件
and 筛选条件</code></pre>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>方式1：delete语句 </p>
<p>单表的删除： ★<br>    delete from 表名 【where 筛选条件】</p>
<p>多表的删除：<br>    delete 别名1，别名2<br>    from 表1 别名1，表2 别名2<br>    where 连接条件<br>    and 筛选条件;</p>
<p>方式2：truncate语句</p>
<pre><code>truncate table 表名</code></pre>
<p>两种方式的区别【面试题】</p>
<pre><code>#1.truncate不能加where条件，而delete可以加where条件

#2.truncate的效率高一丢丢

#3.truncate 删除带自增长的列的表后，如果再插入数据，数据从1开始
#delete 删除带自增长列的表后，如果再插入数据，数据从上一次的断点处开始

#4.truncate删除不能回滚，delete删除可以回滚</code></pre>
<h2 id="DDL语句"><a href="#DDL语句" class="headerlink" title="DDL语句"></a>DDL语句</h2><h3 id="库和表的管理"><a href="#库和表的管理" class="headerlink" title="库和表的管理"></a>库和表的管理</h3><p>库的管理：</p>
<pre><code>一、创建库
create database 库名
二、删除库
drop database 库名</code></pre>
<p>表的管理：</p>
<h4 id="1-创建表"><a href="#1-创建表" class="headerlink" title="1.创建表"></a>1.创建表</h4><pre><code>CREATE TABLE IF NOT EXISTS stuinfo(
    stuId INT,
    stuName VARCHAR(20),
    gender CHAR,
    bornDate DATETIME
    );

DESC studentinfo;</code></pre>
<h4 id="2-修改表-alter"><a href="#2-修改表-alter" class="headerlink" title="2.修改表 alter"></a>2.修改表 alter</h4><pre><code>语法：ALTER TABLE 表名 ADD|MODIFY|DROP|CHANGE COLUMN 字段名 【字段类型】;

#①修改字段名
ALTER TABLE studentinfo CHANGE  COLUMN sex gender CHAR;

#②修改表名
ALTER TABLE stuinfo RENAME [TO]  studentinfo;
#③修改字段类型和列级约束
ALTER TABLE studentinfo MODIFY COLUMN borndate DATE ;

#④添加字段

ALTER TABLE studentinfo ADD COLUMN email VARCHAR(20) first;
#⑤删除字段
ALTER TABLE studentinfo DROP COLUMN email;</code></pre>
<h4 id="3-删除表"><a href="#3-删除表" class="headerlink" title="3.删除表"></a>3.删除表</h4><pre><code>DROP TABLE [IF EXISTS] studentinfo;</code></pre>
<p>​    </p>
<h3 id="常见类型"><a href="#常见类型" class="headerlink" title="常见类型"></a>常见类型</h3><pre><code>整型：

小数：
    浮点型
    定点型
字符型：
日期型：
Blob类型：</code></pre>
<h3 id="常见约束"><a href="#常见约束" class="headerlink" title="常见约束"></a>常见约束</h3><pre><code>NOT NULL
DEFAULT
UNIQUE
CHECK
PRIMARY KEY
FOREIGN KEY</code></pre>
<h2 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><pre><code>通过一组逻辑操作单元（一组DML——sql语句），将数据从一种状态切换到另外一种状态</code></pre>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><pre><code>（ACID）
原子性：要么都执行，要么都回滚
一致性：保证数据的状态操作前和操作后保持一致
隔离性：多个事务同时操作相同数据库的同一个数据时，一个事务的执行不受另外一个事务的干扰
持久性：一个事务一旦提交，则数据将持久化到本地，除非其他事务对其进行修改</code></pre>
<p>相关步骤：</p>
<pre><code>1、开启事务
2、编写事务的一组逻辑操作单元（多条sql语句）
3、提交事务或回滚事务</code></pre>
<h3 id="事务的分类："><a href="#事务的分类：" class="headerlink" title="事务的分类："></a>事务的分类：</h3><p>隐式事务，没有明显的开启和结束事务的标志</p>
<pre><code>比如
insert、update、delete语句本身就是一个事务</code></pre>
<p>显式事务，具有明显的开启和结束事务的标志</p>
<pre><code>    1、开启事务
    取消自动提交事务的功能

    2、编写事务的一组逻辑操作单元（多条sql语句）
    insert
    update
    delete

    3、提交事务或回滚事务</code></pre>
<h3 id="使用到的关键字"><a href="#使用到的关键字" class="headerlink" title="使用到的关键字"></a>使用到的关键字</h3><pre><code>set autocommit=0;
start transaction;
commit;
rollback;

savepoint  断点
commit to 断点
rollback to 断点</code></pre>
<h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><p>事务并发问题如何发生？</p>
<pre><code>当多个事务同时操作同一个数据库的相同数据时</code></pre>
<p>事务的并发问题有哪些？</p>
<pre><code>脏读：一个事务读取到了另外一个事务未提交的数据
不可重复读：同一个事务中，多次读取到的数据不一致
幻读：一个事务读取数据时，另外一个事务进行更新，导致第一个事务读取到了没有更新的数据</code></pre>
<p>如何避免事务的并发问题？</p>
<pre><code>通过设置事务的隔离级别
1、READ UNCOMMITTED
2、READ COMMITTED 可以避免脏读
3、REPEATABLE READ 可以避免脏读、不可重复读和一部分幻读
4、SERIALIZABLE可以避免脏读、不可重复读和幻读</code></pre>
<p>设置隔离级别：</p>
<pre><code>set session|global  transaction isolation level 隔离级别名;</code></pre>
<p>查看隔离级别：</p>
<pre><code>select @@tx_isolation;</code></pre>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>含义：理解成一张虚拟的表</p>
<p>视图和表的区别：</p>
<pre><code>    使用方式    占用物理空间

视图    完全相同    不占用，仅仅保存的是sql逻辑

表    完全相同    占用</code></pre>
<p>视图的好处：</p>
<pre><code>1、sql语句提高重用性，效率高
2、和表实现了分离，提高了安全性</code></pre>
<h3 id="视图的创建"><a href="#视图的创建" class="headerlink" title="视图的创建"></a>视图的创建</h3><p>​    语法：<br>​    CREATE VIEW  视图名<br>​    AS<br>​    查询语句;</p>
<h3 id="视图的增删改查"><a href="#视图的增删改查" class="headerlink" title="视图的增删改查"></a>视图的增删改查</h3><p>1、查看视图的数据 ★</p>
<pre><code>SELECT * FROM my_v4;
SELECT * FROM my_v1 WHERE last_name=&#39;Partners&#39;;

2、插入视图的数据
INSERT INTO my_v4(last_name,department_id) VALUES(&#39;虚竹&#39;,90);

3、修改视图的数据

UPDATE my_v4 SET last_name =&#39;梦姑&#39; WHERE last_name=&#39;虚竹&#39;;</code></pre>
<p>​<br>​    4、删除视图的数据<br>​    DELETE FROM my_v4;</p>
<h3 id="某些视图不能更新"><a href="#某些视图不能更新" class="headerlink" title="某些视图不能更新"></a>某些视图不能更新</h3><p>​    包含以下关键字的sql语句：分组函数、distinct、group  by、having、union或者union all<br>​    常量视图<br>​    Select中包含子查询<br>​    join<br>​    from一个不能更新的视图<br>​    where子句的子查询引用了from子句中的表</p>
<h3 id="视图逻辑的更新"><a href="#视图逻辑的更新" class="headerlink" title="视图逻辑的更新"></a>视图逻辑的更新</h3><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">方式一：</span><br><span class="line">	<span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="built_in">REPLACE</span> <span class="keyword">VIEW</span> test_v7</span><br><span class="line">	<span class="keyword">AS</span></span><br><span class="line">	<span class="keyword">SELECT</span> last_name <span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> employee_id&gt;<span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>​    </p>
<pre><code>#方式二:
ALTER VIEW test_v7
AS
SELECT employee_id FROM employees;

SELECT * FROM test_v7;</code></pre>
<h3 id="视图的删除"><a href="#视图的删除" class="headerlink" title="视图的删除"></a>视图的删除</h3><p>​    DROP VIEW test_v1,test_v2,test_v3;</p>
<h3 id="视图结构的查看"><a href="#视图结构的查看" class="headerlink" title="视图结构的查看"></a>视图结构的查看</h3><p>​    DESC test_v7;<br>​    SHOW CREATE VIEW test_v7;</p>
<h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>含义：一组经过预先编译的sql语句的集合<br>好处：</p>
<pre><code>1、提高了sql语句的重用性，减少了开发程序员的压力
2、提高了效率
3、减少了传输次数</code></pre>
<p>分类：</p>
<pre><code>1、无返回无参
2、仅仅带in类型，无返回有参
3、仅仅带out类型，有返回无参
4、既带in又带out，有返回有参
5、带inout，有返回有参
注意：in、out、inout都可以在一个存储过程中带多个</code></pre>
<h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h3><p>语法：</p>
<pre><code>create procedure 存储过程名(in|out|inout 参数名  参数类型,...)
begin
    存储过程体

end</code></pre>
<p>类似于方法：</p>
<pre><code>修饰符 返回类型 方法名(参数类型 参数名,...)&#123;

    方法体;
&#125;</code></pre>
<p>注意</p>
<pre><code>1、需要设置新的结束标记
delimiter 新的结束标记
示例：
delimiter $

CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名  参数类型,...)
BEGIN
    sql语句1;
    sql语句2;

END $

2、存储过程体中可以有多条sql语句，如果仅仅一条sql语句，则可以省略begin end

3、参数前面的符号的意思
in:该参数只能作为输入 （该参数不能做返回值）
out：该参数只能作为输出（该参数只能做返回值）
inout：既能做输入又能做输出</code></pre>
<h3 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h3><p>​    call 存储过程名(实参列表)</p>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><h5 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h5><p>学过的函数：LENGTH、SUBSTR、CONCAT等<br>语法：</p>
<pre><code>CREATE FUNCTION 函数名(参数名 参数类型,...) RETURNS 返回类型
BEGIN
    函数体

END</code></pre>
<h5 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h5><p>​    SELECT 函数名（实参列表）</p>
<h5 id="函数和存储过程的区别"><a href="#函数和存储过程的区别" class="headerlink" title="函数和存储过程的区别"></a>函数和存储过程的区别</h5><pre><code>        关键字        调用语法    返回值            应用场景
函数        FUNCTION    SELECT 函数()    只能是一个        一般用于查询结果为一个值并返回时，当有返回值而且仅仅一个
存储过程    PROCEDURE    CALL 存储过程()    可以有0个或多个        一般用于更新</code></pre>
<h2 id="流程控制结构"><a href="#流程控制结构" class="headerlink" title="流程控制结构"></a>流程控制结构</h2><h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><p>一、全局变量</p>
<p>作用域：针对于所有会话（连接）有效，但不能跨重启</p>
<pre><code>查看所有全局变量
SHOW GLOBAL VARIABLES;
查看满足条件的部分系统变量
SHOW GLOBAL VARIABLES LIKE &#39;%char%&#39;;
查看指定的系统变量的值
SELECT @@global.autocommit;
为某个系统变量赋值
SET @@global.autocommit=0;
SET GLOBAL autocommit=0;</code></pre>
<p>二、会话变量</p>
<p>作用域：针对于当前会话（连接）有效</p>
<pre><code>查看所有会话变量
SHOW SESSION VARIABLES;
查看满足条件的部分会话变量
SHOW SESSION VARIABLES LIKE &#39;%char%&#39;;
查看指定的会话变量的值
SELECT @@autocommit;
SELECT @@session.tx_isolation;
为某个会话变量赋值
SET @@session.tx_isolation=&#39;read-uncommitted&#39;;
SET SESSION tx_isolation=&#39;read-committed&#39;;</code></pre>
<h3 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h3><p>一、用户变量</p>
<p>声明并初始化：</p>
<pre><code>SET @变量名=值;
SET @变量名:=值;
SELECT @变量名:=值;</code></pre>
<p>赋值：</p>
<pre><code>方式一：一般用于赋简单的值
SET 变量名=值;
SET 变量名:=值;
SELECT 变量名:=值;


方式二：一般用于赋表 中的字段值
SELECT 字段名或表达式 INTO 变量
FROM 表;</code></pre>
<p>使用：</p>
<pre><code>select @变量名;</code></pre>
<p>二、局部变量</p>
<p>声明：</p>
<pre><code>declare 变量名 类型 【default 值】;</code></pre>
<p>赋值：</p>
<pre><code>方式一：一般用于赋简单的值
SET 变量名=值;
SET 变量名:=值;
SELECT 变量名:=值;


方式二：一般用于赋表 中的字段值
SELECT 字段名或表达式 INTO 变量
FROM 表;</code></pre>
<p>使用：</p>
<pre><code>select 变量名</code></pre>
<p>二者的区别：</p>
<pre><code>        作用域            定义位置        语法</code></pre>
<p>用户变量    当前会话        会话的任何地方        加@符号，不用指定类型<br>局部变量    定义它的BEGIN END中     BEGIN END的第一句话    一般不用加@,需要指定类型</p>
<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>一、if函数<br>    语法：if(条件，值1，值2)<br>    特点：可以用在任何位置</p>
<p>二、case语句</p>
<p>语法：</p>
<pre><code>情况一：类似于switch
case 表达式
when 值1 then 结果1或语句1(如果是语句，需要加分号) 
when 值2 then 结果2或语句2(如果是语句，需要加分号)
...
else 结果n或语句n(如果是语句，需要加分号)
end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）

情况二：类似于多重if
case 
when 条件1 then 结果1或语句1(如果是语句，需要加分号) 
when 条件2 then 结果2或语句2(如果是语句，需要加分号)
...
else 结果n或语句n(如果是语句，需要加分号)
end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）</code></pre>
<p>特点：<br>    可以用在任何位置</p>
<p>三、if elseif语句</p>
<p>语法：</p>
<pre><code>if 情况1 then 语句1;
elseif 情况2 then 语句2;
...
else 语句n;
end if;</code></pre>
<p>特点：<br>    只能用在begin end中！！！！！！！！！！！！！！！</p>
<p>三者比较：<br>            应用场合<br>    if函数        简单双分支<br>    case结构    等值判断 的多分支<br>    if结构        区间判断 的多分支</p>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>语法：</p>
<pre><code>【标签：】WHILE 循环条件  DO
    循环体
END WHILE 【标签】;</code></pre>
<p>特点：</p>
<pre><code>只能放在BEGIN END里面

如果要搭配leave跳转语句，需要使用标签，否则可以不用标签

leave类似于java中的break语句，跳出所在循环！！！</code></pre>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE</title>
    <url>/2020/08/24/JavaSE/</url>
    <content><![CDATA[<h1 id="0-Java概述"><a href="#0-Java概述" class="headerlink" title="0 Java概述"></a>0 Java概述</h1><ul>
<li>SUN公司</li>
<li>1995年</li>
<li>Java SE：标准版，开发桌面级应用 standard</li>
<li>Java EE：企业版，开发企业环境 enterprise</li>
<li>Java ME：小型版，开发移动端 micro</li>
<li>James Gosling</li>
</ul>
<a id="more"></a>

<h2 id="0-1-Java特点"><a href="#0-1-Java特点" class="headerlink" title="0.1 Java特点"></a>0.1 Java特点</h2><ul>
<li><p><strong>面向对象：</strong></p>
<ul>
<li>类：</li>
<li>对象：</li>
<li>封装：</li>
<li>继承：</li>
<li>多态：</li>
</ul>
</li>
<li><p><strong>健壮性：</strong>吸收C/C++语言的优点，去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等），提供了一个相对安全的内存管理和访问机制。</p>
</li>
<li><p><strong>跨平台性：</strong>通过Java语言编写的应用程序在不同的系统平台上都可以运行【JVM】</p>
</li>
</ul>
<h2 id="0-2-核心机制"><a href="#0-2-核心机制" class="headerlink" title="0.2 核心机制"></a>0.2 核心机制</h2><ul>
<li>Java虚拟机（Java Virtal Machine）</li>
<li>垃圾收集机制（Garbage Collection）</li>
</ul>
<h2 id="0-3-JDK、JRE"><a href="#0-3-JDK、JRE" class="headerlink" title="0.3 JDK、JRE"></a>0.3 JDK、JRE</h2><ul>
<li><p>JDK（Java Development Kit），Java开发工具包【Javac、Jar、Javadoc】</p>
</li>
<li><p>JRE（Java Runtime Environment），Java运行环境</p>
</li>
<li><p>JDK = JRE + 开发工具集</p>
</li>
<li><p>JRE = JVM + Java SE标准类库</p>
</li>
</ul>
<h2 id="0-4-注释"><a href="#0-4-注释" class="headerlink" title="0.4 注释"></a>0.4 注释</h2><ul>
<li><p>单行注释：//</p>
</li>
<li><p>多行注释：/*        */(不可嵌套)</p>
</li>
<li><p>文档注释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**   </span></span><br><span class="line"><span class="comment"><span class="doctag">@auther</span></span></span><br><span class="line"><span class="comment"><span class="doctag">@version</span></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1 基本语法"></a>1 基本语法</h1><h2 id="1-1-关键字和保留字"><a href="#1-1-关键字和保留字" class="headerlink" title="1.1 关键字和保留字"></a>1.1 关键字和保留字</h2><h3 id="1-1-关键字"><a href="#1-1-关键字" class="headerlink" title="1.1 关键字"></a>1.1 关键字</h3><p><strong>定义：</strong>被Java语言赋予了特殊含义，用作专门用途的字符串</p>
<p><strong>特点：</strong>所有字母均为小写</p>
<h3 id="1-2-保留字"><a href="#1-2-保留字" class="headerlink" title="1.2 保留字"></a>1.2 保留字</h3><p>goto、const</p>
<h2 id="1-2-标识符"><a href="#1-2-标识符" class="headerlink" title="1.2 标识符"></a>1.2 标识符</h2><p><strong>定义：</strong>对变量、方法、和类等要素命名是使用的字符序列</p>
<p><strong>规则：</strong></p>
<ul>
<li>由26个英文字母大小写、0-9、_、和$组成</li>
<li>数字不可以开头</li>
<li>不可以使用关键字和保留字</li>
<li>严格区分大小写</li>
<li>长度无限制</li>
<li>不能包括空格</li>
</ul>
<p><strong>规范：</strong></p>
<ul>
<li>包名：多单词组成时所有字母为小写</li>
<li>类名、接口名：多单词组成时，所有单词首字母大写</li>
<li>常量名、方法名：多单词组成时，第一个单词首字母小写，其他单词首字母大写</li>
<li>常量名：所有字母大写，多单词用_连接</li>
</ul>
<h2 id="1-3-变量"><a href="#1-3-变量" class="headerlink" title="1.3 变量"></a>1.3 变量</h2><h3 id="1-3-1-基本数据类型"><a href="#1-3-1-基本数据类型" class="headerlink" title="1.3.1 基本数据类型"></a>1.3.1 基本数据类型</h3><h4 id="1-3-1-1-分类"><a href="#1-3-1-1-分类" class="headerlink" title="1.3.1.1 分类"></a>1.3.1.1 分类</h4><ul>
<li><p>基本数据类型（primitive type）</p>
<ul>
<li>数值型<ul>
<li>整数类型（byte、short、int、long）</li>
<li>浮点类型（float、double）</li>
</ul>
</li>
<li>字符型（char）</li>
<li>布尔型（boolean）</li>
</ul>
</li>
<li><p>引用数据类型（reference type）</p>
<ul>
<li>类（class）【String】</li>
<li>接口（interface）</li>
<li>数组（[]）</li>
</ul>
</li>
</ul>
<h4 id="1-3-1-2-整数类型"><a href="#1-3-1-2-整数类型" class="headerlink" title="1.3.1.2 整数类型"></a>1.3.1.2 整数类型</h4><ul>
<li>整形常量默认为int型，声明long型常量后须加‘l’或‘L’</li>
<li>1字节（byte）= 8 位（bit）</li>
<li>byte    1字节     -128~127</li>
<li>short    2字节    -2<sup>15</sup>~2<sup>15</sup>-1</li>
<li>int    4字节    -2<sup>31</sup>~2<sup>31</sup>-1</li>
<li>long    8字节    -2<sup>63</sup>~2<sup>63</sup>-1</li>
</ul>
<h4 id="1-3-1-3-浮点类型"><a href="#1-3-1-3-浮点类型" class="headerlink" title="1.3.1.3 浮点类型"></a>1.3.1.3 浮点类型</h4><ul>
<li><p>浮点型常量默认为double型，声明float型常量后须加‘f’或‘F’</p>
</li>
<li><p>单精度float    4字节    -3.403E38~3.403E38</p>
</li>
<li><p>双精度double    5字节    -1.798E308~1.798E308</p>
</li>
</ul>
<h4 id="1-3-1-4-字符类型"><a href="#1-3-1-4-字符类型" class="headerlink" title="1.3.1.4 字符类型"></a>1.3.1.4 字符类型</h4><ul>
<li>定义char型变量，使用单引号’’，内部只能写一个字符</li>
<li>char可以表示转义字符</li>
</ul>
<p><strong>字符集：</strong></p>
<ul>
<li>ASCII</li>
<li>Unicode：UTF-8</li>
</ul>
<h4 id="1-3-1-5-布尔型"><a href="#1-3-1-5-布尔型" class="headerlink" title="1.3.1.5 布尔型"></a>1.3.1.5 布尔型</h4><ul>
<li>只能取两个值：true、false，不能取1和0</li>
</ul>
<h3 id="1-3-2-基本数据类型转换"><a href="#1-3-2-基本数据类型转换" class="headerlink" title="1.3.2 基本数据类型转换"></a>1.3.2 基本数据类型转换</h3><ul>
<li><strong>自动类型提升：</strong>当容量小的数据类型的变量与容量大的数据类型的变量做运算时，结果自动提升为容量大的数据类型</li>
<li>当byte、char、short三种类型的变量做运算时，结果为int型</li>
<li><strong>强制类型转换：</strong>()，可能导致精度损失</li>
</ul>
<h3 id="1-3-3-基本数据类型与String转换"><a href="#1-3-3-基本数据类型与String转换" class="headerlink" title="1.3.3 基本数据类型与String转换"></a>1.3.3 基本数据类型与String转换</h3><ul>
<li>String不是基本数据类型，而是引用数据类型</li>
<li>声明String类型变量时使用双引号””</li>
<li>String可以和8种基本数据类型变量做运算，且运算只能是连接运算：+</li>
<li>运算结果仍为String类型</li>
</ul>
<h3 id="1-3-4-进制转换"><a href="#1-3-4-进制转换" class="headerlink" title="1.3.4 进制转换"></a>1.3.4 进制转换</h3><ul>
<li><p>分类</p>
<ul>
<li>二进制（binary）：0，1，以0b或0B开头</li>
<li>十进制（decimal）</li>
<li>八进制（octal）：0-7，以数字0开头</li>
<li>十六进制（hex）：0-9和A-F，以0x或0X开头，不区分大小写</li>
</ul>
</li>
<li><p>int类型的整数第32位位符号位，long类型的整数第64位是符号位</p>
</li>
<li><p>二进制整数有以下三种形式：</p>
<ul>
<li>原码：最高位为符号位</li>
<li>负数的反码：对原码按位取反，最高位为1</li>
<li>负数的补码：反码+1</li>
<li>正数的原码、反码、补码都相同</li>
</ul>
</li>
<li><p>计算机以二进制补码的形式保存所有整数</p>
</li>
</ul>
<h3 id="1-3-5-运算符"><a href="#1-3-5-运算符" class="headerlink" title="1.3.5 运算符"></a>1.3.5 运算符</h3><h4 id="1-3-5-1-算术运算符"><a href="#1-3-5-1-算术运算符" class="headerlink" title="1.3.5.1 算术运算符"></a>1.3.5.1 算术运算符</h4><ul>
<li>正负号 +、-</li>
<li>加减乘除 +、-、*、/</li>
<li>取模 %</li>
<li>自加 ++1、1++</li>
<li>自减 –1、1–</li>
<li>字符串连接 +</li>
</ul>
<h4 id="1-3-5-2-赋值运算符"><a href="#1-3-5-2-赋值运算符" class="headerlink" title="1.3.5.2 赋值运算符"></a>1.3.5.2 赋值运算符</h4><ul>
<li>=、+=、-=、*=、/=、%=</li>
</ul>
<h4 id="1-3-5-3-关系运算符"><a href="#1-3-5-3-关系运算符" class="headerlink" title="1.3.5.3 关系运算符"></a>1.3.5.3 关系运算符</h4><ul>
<li>== 、!=、&lt;、&gt;、&lt;=、&gt;=</li>
</ul>
<h4 id="1-3-5-4-逻辑运算符"><a href="#1-3-5-4-逻辑运算符" class="headerlink" title="1.3.5.4 逻辑运算符"></a>1.3.5.4 逻辑运算符</h4><ul>
<li>逻辑与：&amp;</li>
<li>逻辑或：|</li>
<li>逻辑非：!</li>
<li>短路与：&amp;&amp;</li>
<li>短路或：||</li>
<li>逻辑异或：^（两者相同则false，不同则true）</li>
</ul>
<h4 id="1-3-5-5-位运算符"><a href="#1-3-5-5-位运算符" class="headerlink" title="1.3.5.5 位运算符"></a>1.3.5.5 位运算符</h4><ul>
<li>左移、右移：&lt;&lt;、&gt;&gt;</li>
<li>无符号右移：&gt;&gt;&gt;</li>
<li>与运算：&amp;</li>
<li>或运算：|</li>
<li>异或运算：^</li>
<li>取反运算：~</li>
</ul>
<h4 id="1-3-5-6-三元运算符"><a href="#1-3-5-6-三元运算符" class="headerlink" title="1.3.5.6 三元运算符"></a>1.3.5.6 三元运算符</h4><ul>
<li>(条件表达式)?表达式1:表达式2</li>
</ul>
<h2 id="1-4-流程控制"><a href="#1-4-流程控制" class="headerlink" title="1.4 流程控制"></a>1.4 流程控制</h2><h3 id="1-4-1-顺序结构"><a href="#1-4-1-顺序结构" class="headerlink" title="1.4.1 顺序结构"></a>1.4.1 顺序结构</h3><h3 id="1-4-2-分支结构"><a href="#1-4-2-分支结构" class="headerlink" title="1.4.2 分支结构"></a>1.4.2 分支结构</h3><ul>
<li><p>if…else</p>
</li>
<li><p>switch-case</p>
</li>
</ul>
<h3 id="1-4-3-循环结构"><a href="#1-4-3-循环结构" class="headerlink" title="1.4.3 循环结构"></a>1.4.3 循环结构</h3><ul>
<li><p>while</p>
</li>
<li><p>do…while</p>
</li>
<li><p>for</p>
</li>
<li><p>foreach</p>
</li>
</ul>
<h3 id="1-4-4-特殊关键字"><a href="#1-4-4-特殊关键字" class="headerlink" title="1.4.4 特殊关键字"></a>1.4.4 特殊关键字</h3><ul>
<li>continue<ul>
<li>循环结构</li>
<li>结束当次循环</li>
</ul>
</li>
<li>break<ul>
<li>switch-case、循环结构</li>
<li>结束当前循环</li>
</ul>
</li>
</ul>
<h1 id="2-数组（Array）"><a href="#2-数组（Array）" class="headerlink" title="2 数组（Array）"></a>2 数组（Array）</h1><ul>
<li>数组是有序排列的</li>
<li>数组属于引用数据类型的变量</li>
<li>数组的元素既可以是基本数据类型，也可以是引用数据类型</li>
<li>创建数组的对象会在内存中开辟一整块的连续空间，数组名引用的是连续空间的首地址</li>
<li>数组的长度一旦确定就不能更改</li>
<li>通过下标查询指定位置的元素的速度很快</li>
</ul>
<h2 id="2-X-排序"><a href="#2-X-排序" class="headerlink" title="2.X 排序"></a>2.X 排序</h2><ul>
<li>选择排序<ul>
<li>直接选择排序</li>
<li>堆排序</li>
</ul>
</li>
<li>交换排序<ul>
<li>冒泡排序</li>
<li>快速排序</li>
</ul>
</li>
<li>归并排序</li>
<li>桶排序</li>
<li>基数排序</li>
</ul>
<h1 id="3-面向对象"><a href="#3-面向对象" class="headerlink" title="3 面向对象"></a>3 面向对象</h1><h2 id="3-1-面向过程（POP）与面向对象（OOP）"><a href="#3-1-面向过程（POP）与面向对象（OOP）" class="headerlink" title="3.1 面向过程（POP）与面向对象（OOP）"></a>3.1 面向过程（POP）与面向对象（OOP）</h2><ul>
<li>面向过程：强调功能行为，以函数为基本单位，考虑怎么做</li>
<li>面向对象：强调具备了功能的对象，以对象为基本单位，考虑谁来做</li>
</ul>
<p><strong>三大特征：</strong></p>
<ul>
<li>封装</li>
<li>继承</li>
<li>多态</li>
</ul>
<h2 id="3-2-类和对象"><a href="#3-2-类和对象" class="headerlink" title="3.2 类和对象"></a>3.2 类和对象</h2><ul>
<li>类：对一类事物的描述，是抽象的、概念上的定义</li>
<li>对象：实际存在的该类事物的每个个体，也称为实例</li>
</ul>
<p><strong>类的成员：</strong></p>
<ul>
<li>属性：对应类中的成员变量</li>
<li>行为：对应类中的成员方法</li>
</ul>
<h2 id="3-3-属性"><a href="#3-3-属性" class="headerlink" title="3.3 属性"></a>3.3 属性</h2><p><strong>修饰符：</strong>private、protected、public、final</p>
<p><strong>成员变量：</strong></p>
<ul>
<li>直接在类中声明</li>
<li>修饰符private、protected、public、final等</li>
<li>有初始化默认值</li>
<li>在堆空间或静态域中加载</li>
</ul>
<p><strong>局部变量：</strong></p>
<ul>
<li>方法形参或者在内部、代码块、构造器内</li>
<li>不能用权限修饰符，可以用final修饰</li>
<li>没有默认初始值，必须显式赋值</li>
<li>在栈空间加载</li>
</ul>
<h2 id="3-4-方法"><a href="#3-4-方法" class="headerlink" title="3.4 方法"></a>3.4 方法</h2><p><strong>重载：</strong>在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者类型不同即可</p>
<h2 id="3-5-封装与隐藏"><a href="#3-5-封装与隐藏" class="headerlink" title="3.5 封装与隐藏"></a>3.5 封装与隐藏</h2><p><strong>封装：</strong>隐藏对象内部的复杂性，值对外公开简单的接口。</p>
<p><strong>类的修饰符：</strong></p>
<ul>
<li>private：类内部</li>
<li>缺省（default）：类内部、同一个包</li>
<li>protected：类内部、同一个包、不同包的子类</li>
<li>public：类内部、同一个包、不同包的子类、同一个工程</li>
</ul>
<h2 id="3-6-构造器（构筑方法）"><a href="#3-6-构造器（构筑方法）" class="headerlink" title="3.6 构造器（构筑方法）"></a>3.6 构造器（构筑方法）</h2><p><strong>特征：</strong></p>
<ul>
<li>具有与类相同的名称</li>
<li>不声明返回值的类型</li>
<li>不能被static、final、synchronized、abstract、native修饰</li>
<li>不能有return语句返回值</li>
</ul>
<p><strong>作用：</strong></p>
<ul>
<li>创建对象</li>
<li>给对象进行初始化</li>
</ul>
<p><strong>规范：</strong></p>
<ul>
<li>每个类至少有一个构造器</li>
<li>默认构造器的修饰符与所属类的修饰符一致</li>
<li>显式定义了构造器后，系统不再提供默认的构造器</li>
<li>一个类可以创建多个重载的构造器</li>
<li>父类的构造器不可被子类继承</li>
</ul>
<h2 id="3-7-扩展知识"><a href="#3-7-扩展知识" class="headerlink" title="3.7 扩展知识"></a>3.7 扩展知识</h2><h3 id="3-7-1-JavaBean"><a href="#3-7-1-JavaBean" class="headerlink" title="3.7.1 JavaBean"></a>3.7.1 JavaBean</h3><p>JavaBean是一种Java语言写成的可重用组件</p>
<p><strong>标准：</strong></p>
<ul>
<li>类是公共的</li>
<li>有一个无参的公共的构造器</li>
<li>有属性，且有对应的get、set方法</li>
</ul>
<h3 id="3-7-2-UML类图"><a href="#3-7-2-UML类图" class="headerlink" title="3.7.2 UML类图"></a>3.7.2 UML类图</h3><p><strong>组成结构：</strong></p>
<ul>
<li>类名</li>
<li>属性：<ul>
<li>+/-/# 属性名：类型</li>
<li>+：public</li>
<li>-：private</li>
<li>#：protected</li>
</ul>
</li>
<li>方法（若有下划线则表示构造器）</li>
</ul>
<h3 id="3-7-3-this"><a href="#3-7-3-this" class="headerlink" title="3.7.3 this"></a>3.7.3 this</h3><p>访问本类中的操作，若没有则从父类中查找</p>
<h3 id="3-7-4-package、import"><a href="#3-7-4-package、import" class="headerlink" title="3.7.4 package、import"></a>3.7.4 package、import</h3><p><strong>JDK中的主要的包：</strong></p>
<ul>
<li>java.long</li>
<li>java.net</li>
<li>java.io</li>
<li>java.util</li>
<li>java.text</li>
<li>java.sql</li>
<li>java.aet</li>
</ul>
<h2 id="3-8-继承"><a href="#3-8-继承" class="headerlink" title="3.8 继承"></a>3.8 继承</h2><p><strong>原因：</strong></p>
<p>多个类中存在相同属性和行为时，将这些内容单独抽取到一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可</p>
<p><strong>特点：</strong></p>
<ul>
<li>子类继承了父类的方法和属性</li>
<li>子类不是父类的子集，而是对父类的扩展</li>
<li>子类不能直接访问父类中私有的成员变量和方法</li>
<li>Java只支持单继承和多层继承，不允许多继承</li>
</ul>
<h2 id="3-9-重写"><a href="#3-9-重写" class="headerlink" title="3.9 重写"></a>3.9 重写</h2><p><strong>定义：</strong>在子类中可以根据需要对从父类中继承来的的的进行改造，也称为为方法的覆盖、重置。</p>
<p><strong>规范：</strong></p>
<ul>
<li>子类重写的方法必须和父类中被重写的方法具有相同的方法名称、参数列表</li>
<li>子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型</li>
<li>子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限</li>
<li>子类方法抛出的异常不能大于父类被重写方法的异常</li>
<li>子类和父类中同名同参数的方法必须同时声明为非static，即为重写；否则，不是重写。因为static方法是属于类的，子类无法覆盖父类的方法</li>
</ul>
<p><strong>super：</strong>调用父类中的指定操作</p>
<h2 id="3-10-多态"><a href="#3-10-多态" class="headerlink" title="3.10 多态"></a>3.10 多态</h2><p>父类的引用指向子类的对象</p>
<h3 id="3-10-1-instanceof"><a href="#3-10-1-instanceof" class="headerlink" title="3.10.1 instanceof"></a>3.10.1 instanceof</h3><p>检验x是否是类A的对象，返回值为boolean</p>
<h3 id="3-10-2-casting"><a href="#3-10-2-casting" class="headerlink" title="3.10.2 casting"></a>3.10.2 casting</h3><ul>
<li><p>子类到父类类型转换自动进行</p>
</li>
<li><p>父类到子类类型转换通过强制类型转换实现——造型</p>
</li>
<li><p>无继承关系的引用类型见的转换是非法的</p>
</li>
</ul>
<h3 id="3-10-3-和equals的区别"><a href="#3-10-3-和equals的区别" class="headerlink" title="3.10.3 ==和equals的区别"></a>3.10.3 ==和equals的区别</h3><ul>
<li>==既可以比较基本数据类型也可以比较引用数据类型，对于基本数据类型是比较值，对于引用数据类型是比较内存地址</li>
<li>equals是属于java.lang.Object的方法，如果没有重写默认和==相同</li>
<li>String中的equals方法是被重写过的，用来比较值</li>
<li>通常情况下，重写过的equals会比较类中所有相应属性是否相等</li>
</ul>
<h3 id="3-10-4-equals-的原则"><a href="#3-10-4-equals-的原则" class="headerlink" title="3.10.4 equals()的原则"></a>3.10.4 equals()的原则</h3><ul>
<li>对称性</li>
<li>自反性</li>
<li>传递性</li>
<li>一致性</li>
<li>x.equals(null) == false</li>
<li>x.equals(和x类型不同的对象) == false</li>
</ul>
<h3 id="3-10-5-toString"><a href="#3-10-5-toString" class="headerlink" title="3.10.5 toString()"></a>3.10.5 toString()</h3><p>在Object类中被定义，返回值是String，返回类名和他的引用地址</p>
<h3 id="3-10-6-包装类（Wrapper）"><a href="#3-10-6-包装类（Wrapper）" class="headerlink" title="3.10.6 包装类（Wrapper）"></a>3.10.6 包装类（Wrapper）</h3><p>将基本数据类型的数据变成类，就可以调用类中的方法对数据进行操作</p>
<ul>
<li>byte：Byte</li>
<li>short：Short</li>
<li>int：Integer</li>
<li>long：Long</li>
<li>float：Float</li>
<li>double：Double</li>
<li>boolean：Boolean</li>
<li>char：Character</li>
</ul>
<h4 id="3-10-6-1-装箱"><a href="#3-10-6-1-装箱" class="headerlink" title="3.10.6.1 装箱"></a>3.10.6.1 装箱</h4><ul>
<li>通过包装类的构造器实现</li>
<li>通过字符串参数构造包装类对象</li>
<li>自动装箱</li>
</ul>
<h4 id="3-10-6-2-拆箱"><a href="#3-10-6-2-拆箱" class="headerlink" title="3.10.6.2 拆箱"></a>3.10.6.2 拆箱</h4><ul>
<li>调用包装类的xxx.xxxValue()方法</li>
<li>自动拆箱</li>
</ul>
<h2 id="3-11-static"><a href="#3-11-static" class="headerlink" title="3.11 static"></a>3.11 static</h2><p><strong>类属性：</strong>该类中各个对象之间共享的变量</p>
<p><strong>类方法：</strong>与调用者无关的方法</p>
<p><strong>被static修饰后的特点：</strong></p>
<ul>
<li>随着类的加载而加载</li>
<li>优先于对象存在</li>
<li>修饰的成员，被所有对象所共享</li>
<li>访问权限允许时，可不创建对象，直接被类调用</li>
</ul>
<h3 id="3-11-1-代码块"><a href="#3-11-1-代码块" class="headerlink" title="3.11.1 代码块"></a>3.11.1 代码块</h3><ul>
<li>静态代码块（static修饰）：<ul>
<li>可以有输出语句</li>
<li>可以对类的属性、类的声明进行初始化操作</li>
<li>不可以对非静态的属性初始化</li>
<li>若有多个静态代码块，按照从上到下的顺序依次执行</li>
<li>静态代码块的执行优先于非静态代码块</li>
<li>静态代码块随着类的加载而加载，且只执行一次</li>
</ul>
</li>
<li>非静态代码块：<ul>
<li>可以有输出语句</li>
<li>可以对类的属性、类的声明进行初始化操作</li>
<li>除了调用非静态的结构外，还可以调用静态的变量和方法</li>
<li>若有多个静态代码块，按照从上到下的顺序依次执行</li>
<li>每次创建对象都会执行一次，且先于构造器执行</li>
</ul>
</li>
</ul>
<h3 id="3-12-final"><a href="#3-12-final" class="headerlink" title="3.12 final"></a>3.12 final</h3><ul>
<li>final修饰的类不能被继承</li>
<li>final修饰的方法不能被子类重写</li>
<li>final修饰的变量即为常量</li>
<li>static final修饰的变量即为全局常量</li>
</ul>
<h2 id="3-13-abstract"><a href="#3-13-abstract" class="headerlink" title="3.13 abstract"></a>3.13 abstract</h2><ul>
<li>abstract只能修饰类和方法</li>
<li>抽象方法以 ; 结束</li>
<li>含有抽象方法的类必须声明为抽象类</li>
<li>抽象类不能被实例化</li>
<li>abstract不能修饰变量、代码块、构造器</li>
<li>abstract不能修饰私有方法、静态方法、final方法、final类</li>
</ul>
<h2 id="3-14-接口"><a href="#3-14-接口" class="headerlink" title="3.14 接口"></a>3.14 接口</h2><ul>
<li>class SubClass extends SuperClass implements InterFaceA{}</li>
<li>一个类可以有多个接口，接口也可以继承其他接口</li>
<li>实现接口的类中必须提供接口中所有方法的具体实现内容，方可实现实例化。否则仍为抽象类</li>
<li>接口的主要用途就是被实现类实现</li>
<li>接口与实现类之间存在多态性</li>
<li>接口是一种特殊的抽象类</li>
</ul>
<p><strong>接口和抽象类的对比：</strong></p>
<ul>
<li>抽象类：<ul>
<li>抽象类是包含抽象方法的类</li>
<li>由构造方法、抽象方法、普通方法、常量、变量组成</li>
<li>子类继承抽象类</li>
<li>抽象类可以实现多个接口</li>
<li>设计模式：模板方法</li>
<li>都通过对象的多态性产生实例化对象</li>
<li>单继承</li>
</ul>
</li>
<li>接口：<ul>
<li>抽象方法和全局常量的集合</li>
<li>由抽象方法、常量、（jdk 8.0：默认方法、静态方法）组成</li>
<li>子类实现接口</li>
<li>接口不能继承抽象类，但能继承接口</li>
<li>设计模式：简单工厂、工厂方法、代理模式</li>
<li>都通过对象的多态产生实例化对象</li>
<li>可以多继承</li>
<li>因此优先使用接口</li>
</ul>
</li>
</ul>
<h2 id="3-15-内部类（inner-class）"><a href="#3-15-内部类（inner-class）" class="headerlink" title="3.15 内部类（inner class）"></a>3.15 内部类（inner class）</h2><p>位于另一个类内部的类</p>
<h1 id="4-异常处理"><a href="#4-异常处理" class="headerlink" title="4 异常处理"></a>4 异常处理</h1><h2 id="4-1-分类"><a href="#4-1-分类" class="headerlink" title="4.1 分类"></a>4.1 分类</h2><ul>
<li><p>Error：Java虚拟机无法解决的严重问题</p>
<ul>
<li>StackOverflowError</li>
<li>OOM</li>
</ul>
</li>
<li><p>Exception</p>
<ul>
<li>空指针访问</li>
<li>读取不存在的文件</li>
<li>网络连接中断</li>
<li>数组角标越界</li>
</ul>
</li>
<li><p>编译时异常（理想捕获时期）</p>
<ul>
<li>编译器必须处置</li>
</ul>
</li>
<li><p>运行时异常</p>
<ul>
<li>编译器不要求强制处置【java.lang.RuntimeException】</li>
</ul>
</li>
</ul>
<h2 id="4-2-常见异常"><a href="#4-2-常见异常" class="headerlink" title="4.2 常见异常"></a>4.2 常见异常</h2><ul>
<li>java.lang.RuntimeException<ul>
<li>ClassCastException</li>
<li>ArrayOutOfBoundsException</li>
<li>NullPointerException</li>
<li>ArithmeticException</li>
<li>NumeberFormatException</li>
<li>InputMismatchException</li>
</ul>
</li>
<li>java.io.IOException<ul>
<li>FileNotFoundException</li>
<li>EOFException</li>
</ul>
</li>
<li>java,lang.ClassNotFoundException</li>
<li>java.lang.InterruptedException</li>
<li>java.io.FileNotFoundException</li>
<li>java.sql.SQLException</li>
</ul>
<h3 id="4-3-异常处理机制"><a href="#4-3-异常处理机制" class="headerlink" title="4.3 异常处理机制"></a>4.3 异常处理机制</h3><h3 id="4-3-1-try-catch-finally"><a href="#4-3-1-try-catch-finally" class="headerlink" title="4.3.1 try-catch-finally"></a>4.3.1 try-catch-finally</h3><h3 id="4-3-2-throws-异常类型"><a href="#4-3-2-throws-异常类型" class="headerlink" title="4.3.2 throws + 异常类型"></a>4.3.2 throws + 异常类型</h3><h1 id="5-多线程"><a href="#5-多线程" class="headerlink" title="5 多线程"></a>5 多线程</h1><h2 id="5-1-基本概念"><a href="#5-1-基本概念" class="headerlink" title="5.1 基本概念"></a>5.1 基本概念</h2><ul>
<li>程序：为完成特定任务、用某种语言编写的一组指令的集合</li>
<li>进程：程序的一次执行过程，或是正在运行的一个程序<ul>
<li>进程有自身产生、存在和消亡的过程</li>
<li>程序是静态的，进程是动态的</li>
<li>进程是资源分配的基本单位</li>
</ul>
</li>
<li>线程：一个程序内部的一条执行路径<ul>
<li>若一个进程同一时间并行执行多个线程，即多线程</li>
<li>线程是调度和执行的单位，每个线程拥有独立的的运行栈和程序计数器，线程的开销小</li>
<li>一个进程中的多个线程共享相同的内存单元</li>
</ul>
</li>
<li>并行：多个CPU同时执行多个任务</li>
<li>并发：单个CPU同时执行多个任务</li>
<li>多线程的优点：<ul>
<li>提高程序的响应</li>
<li>提供CPU的利用率</li>
<li>改善程序结构</li>
</ul>
</li>
</ul>
<h2 id="5-2-线程的创建和使用"><a href="#5-2-线程的创建和使用" class="headerlink" title="5.2 线程的创建和使用"></a>5.2 线程的创建和使用</h2><h3 id="5-2-1-继承Thread类"><a href="#5-2-1-继承Thread类" class="headerlink" title="5.2.1 继承Thread类"></a>5.2.1 继承Thread类</h3><ul>
<li>定义子类继承Thread类</li>
<li>子类中重写Thread类中的run方法</li>
<li>创建Thread子类对象，即线程对象</li>
<li>调用线程对象start方法：启动线程，调用run方法</li>
</ul>
<h3 id="5-2-2-实现Runnable接口"><a href="#5-2-2-实现Runnable接口" class="headerlink" title="5.2.2 实现Runnable接口"></a>5.2.2 实现Runnable接口</h3><ul>
<li>定义子类实现Runnable接口</li>
<li>子类重写Runnable接口中的run方法</li>
<li>通过Thread类含参构造器创建线程对象</li>
<li>将Runnable接口的子类对象作为实际参数传递给Thread类的构造器中</li>
<li>调用Thread类的start方法：开启线程，调用Runnable子类接口的run方法</li>
</ul>
<p>实现的好处：</p>
<ul>
<li>避免了单继承的局限性</li>
<li>多个线程可以共享同一个接口实现类的对象</li>
</ul>
<h3 id="5-2-3-Thread的方法"><a href="#5-2-3-Thread的方法" class="headerlink" title="5.2.3 Thread的方法"></a>5.2.3 Thread的方法</h3><ul>
<li><p>void start()：启动线程并执行run()方法</p>
</li>
<li><p>run()：调度线程</p>
</li>
<li><p>String getName()：返回线程的名称</p>
</li>
<li><p>void setName(String name)：设置线程的名称</p>
</li>
<li><p>static Thread currentThread()：返回当前线程</p>
</li>
<li><p>static void yield()：线程让步并就绪</p>
</li>
<li><p>join()：调用其他线程并阻塞，知道调用的线程执行完</p>
</li>
<li><p>static void sleep(long millis)：令当前线程在指定时间段内放弃对CPU的控制</p>
</li>
<li><p>stop()：强制线程结束，不推荐使用</p>
</li>
<li><p>boolean isAlive：判断线程是否存活</p>
</li>
</ul>
<h3 id="5-2-4-Java的调度方法"><a href="#5-2-4-Java的调度方法" class="headerlink" title="5.2.4 Java的调度方法"></a>5.2.4 Java的调度方法</h3><ul>
<li>同优先级线程组成先到先服务队列，使用时间片策略</li>
<li>高优先级线程采用优先调度的抢占式策略</li>
</ul>
<h3 id="5-2-5-线程的分类"><a href="#5-2-5-线程的分类" class="headerlink" title="5.2.5 线程的分类"></a>5.2.5 线程的分类</h3><ul>
<li>守护线程</li>
<li>用户线程</li>
</ul>
<h2 id="5-3-线程的生命周期"><a href="#5-3-线程的生命周期" class="headerlink" title="5.3 线程的生命周期"></a>5.3 线程的生命周期</h2><ul>
<li>新建</li>
<li>就绪</li>
<li>运行</li>
<li>阻塞</li>
<li>死亡</li>
</ul>
<p><strong>转换：</strong></p>
<ul>
<li>新建&gt;就绪：start()</li>
<li>就绪&gt;运行：获取CPU</li>
<li>运行&gt;就绪：失去CPU或者yield()</li>
<li>运行&gt;阻塞：sleep()/join()/等待同步锁/wait()/suspend()</li>
<li>阻塞&gt;就绪：sleep()时间到/join()结束/获取同步锁/notify()/notifyAll()/resume()</li>
<li>运行&gt;死亡：执行完run()/stop()/出现Error、Exception且没处理</li>
</ul>
<h2 id="5-4-线程的同步"><a href="#5-4-线程的同步" class="headerlink" title="5.4 线程的同步"></a>5.4 线程的同步</h2><ul>
<li><p>synchronized同步代码块</p>
</li>
<li><p>synchronized同步方法</p>
</li>
<li><p>Lock</p>
<ul>
<li>java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具</li>
<li>ReentrantLock类实现了Lock，可以显式地加锁、释放锁</li>
</ul>
</li>
</ul>
<p><strong>释放锁的操作：</strong></p>
<ul>
<li>同步代码块、同步方法执行结束</li>
<li>遇到break、return终止执行</li>
<li>出现未处理的Error或Exception异常结束</li>
<li>wait()方法导致当前线程暂停</li>
</ul>
<p><strong>不释放锁的操作：</strong></p>
<ul>
<li>Thread.sleep()、Thread.yield()暂停线程</li>
<li>suspend()挂起线程<ul>
<li>避免使用suspend()和resume()</li>
</ul>
</li>
</ul>
<p><strong>死锁：</strong>不同的线程分别占用对方需要的同步资源不放弃，都在等待自己需要的同步资源</p>
<p><strong>synchronized和Lock的对比：</strong></p>
<ul>
<li>Lock是显式锁，需要手动开启和关闭锁</li>
<li>synchronized是隐式锁，出了作用域自动释放锁</li>
<li>Lock只有代码块锁</li>
<li>synchronized有代码块锁和方法锁</li>
<li>Lock锁，JVM花费少，性能好，扩展性强</li>
</ul>
<h2 id="5-5-线程的通信"><a href="#5-5-线程的通信" class="headerlink" title="5.5 线程的通信"></a>5.5 线程的通信</h2><ul>
<li>wait()</li>
<li>notify()</li>
<li>notifyAll()</li>
</ul>
<h2 id="5-6-JDK5-0新增线程创建方式"><a href="#5-6-JDK5-0新增线程创建方式" class="headerlink" title="5.6 JDK5.0新增线程创建方式"></a>5.6 JDK5.0新增线程创建方式</h2><ul>
<li>使用Callable接口</li>
<li>使用线程池</li>
</ul>
<h1 id="6-Java常用类"><a href="#6-Java常用类" class="headerlink" title="6 Java常用类"></a>6 Java常用类</h1><h2 id="6-1-字符串相关类"><a href="#6-1-字符串相关类" class="headerlink" title="6.1 字符串相关类"></a>6.1 字符串相关类</h2><h3 id="6-1-1-String"><a href="#6-1-1-String" class="headerlink" title="6.1.1 String"></a>6.1.1 String</h3><ul>
<li>代表字符串</li>
<li>是一个final类</li>
<li>是常量，双引号，创建后值不能修改</li>
<li>字符内容存储在一个字符数组value中</li>
</ul>
<p><strong>String str = “abc”;和String str = new String(“abc”);有什么区别？</strong></p>
<ul>
<li>前者是字符串常量，存储在字符串常量池，可以共享</li>
<li>后者是非常量对象，存储在堆中</li>
</ul>
<p><strong>字符串特性：</strong></p>
<ul>
<li>常量和常量的拼接结果在常量池中，且常量池中不会存在相同的常量</li>
<li>只要有一个是变量，结果就在堆中</li>
<li>若拼接的结果调用intern()方法，返回值在常量池</li>
</ul>
<p><strong>常用方法：</strong></p>
<ul>
<li>length()</li>
<li>charAt()</li>
<li>isEmpty()</li>
<li>toLowerCase()：转换为小写</li>
<li>toUpperCase()</li>
<li>trim()：返回字符串副本，忽略头部和尾部空白</li>
<li>equals()：判断字符串内容是否相同</li>
<li>concat()</li>
<li>substring()</li>
<li>contains()</li>
<li>indexOf()</li>
<li>lastIndexOf()</li>
<li>replace()</li>
<li>matches()：判断字符串是否匹配给定的正则表达式</li>
</ul>
<p><strong>类型转换：</strong></p>
<ul>
<li>基本数据类型、包装类&gt;字符串：valueOf()</li>
<li>字符数组&gt;字符串：String(char[])</li>
<li>字符串&gt;字符数组：toCharArray()、getChars()</li>
</ul>
<h3 id="6-1-2-StringBuffer"><a href="#6-1-2-StringBuffer" class="headerlink" title="6.1.2 StringBuffer"></a>6.1.2 StringBuffer</h3><ul>
<li>可变的字符序列</li>
<li>必须使用构造器生成对象<ul>
<li>StringBuffer()</li>
<li>StringBuffer(int size)</li>
<li>StringBuffer(String str)</li>
</ul>
</li>
</ul>
<p><strong>常用方法：</strong></p>
<ul>
<li>append()</li>
<li>delete()</li>
<li>replace()</li>
<li>insert()</li>
<li>reverse()：逆转</li>
<li>拼接和插入时可扩容</li>
</ul>
<h3 id="6-1-3-StringBuilder"><a href="#6-1-3-StringBuilder" class="headerlink" title="6.1.3 StringBuilder"></a>6.1.3 StringBuilder</h3><p><strong>对比三者：</strong></p>
<ul>
<li>String：不可变字符序列</li>
<li>StringBuffer：可变字符序列、效率低、线程安全</li>
<li>StringBuilder：可变字符序列、效率高、线程不安全</li>
</ul>
<h2 id="6-2-JDK8之前的日期时间API"><a href="#6-2-JDK8之前的日期时间API" class="headerlink" title="6.2 JDK8之前的日期时间API"></a>6.2 JDK8之前的日期时间API</h2><ul>
<li>java.long.system</li>
<li>java.util.Date</li>
<li>java.text.SiampleDateFormate</li>
<li>java.util.Calendar</li>
</ul>
<h2 id="6-3-JDK8中新的日期时间API"><a href="#6-3-JDK8中新的日期时间API" class="headerlink" title="6.3 JDK8中新的日期时间API"></a>6.3 JDK8中新的日期时间API</h2><ul>
<li>java.time</li>
<li>java.time.chrono</li>
<li>java.time.format<ul>
<li>java.time.format.DateTimeFormatter</li>
</ul>
</li>
<li>java.time.tenporal</li>
<li>java.time.zone</li>
</ul>
<h2 id="6-4-Java比较器"><a href="#6-4-Java比较器" class="headerlink" title="6.4 Java比较器"></a>6.4 Java比较器</h2><h3 id="6-4-1-自然排序"><a href="#6-4-1-自然排序" class="headerlink" title="6.4.1 自然排序"></a>6.4.1 自然排序</h3><ul>
<li>java.lang.Comparable</li>
</ul>
<h3 id="6-4-2-定制排序"><a href="#6-4-2-定制排序" class="headerlink" title="6.4.2 定制排序"></a>6.4.2 定制排序</h3><ul>
<li>java.util.Comparator</li>
</ul>
<h2 id="6-5-System类"><a href="#6-5-System类" class="headerlink" title="6.5 System类"></a>6.5 System类</h2><ul>
<li>位于java.lang包</li>
<li>构造器是private的，无法创建对象</li>
<li>内部成员变量和成员方法都是static的，方便调用</li>
<li>成员变量：in、out、err</li>
<li>成员方法：<ul>
<li>native long currentTimeMillis()</li>
<li>void exit()</li>
<li>void gc()</li>
<li>String getProperty()</li>
</ul>
</li>
</ul>
<h2 id="6-6-Math类"><a href="#6-6-Math类" class="headerlink" title="6.6 Math类"></a>6.6 Math类</h2><ul>
<li>abs</li>
<li>acos/asin/atan/cos/sin/tan</li>
<li>sqrt</li>
<li>pow</li>
<li>log</li>
<li>exp</li>
<li>max/min</li>
<li>random()</li>
<li>long round(double x)</li>
<li>toDegress/toRadians</li>
</ul>
<h2 id="6-7-BigInteger和BigDecimal"><a href="#6-7-BigInteger和BigDecimal" class="headerlink" title="6.7 BigInteger和BigDecimal"></a>6.7 BigInteger和BigDecimal</h2><ul>
<li>BigInteger 可以表示不可变的任意精度的整数</li>
<li>商业计算中，要求数字精度比较高，故用到 java.math.BigDecimal 类 </li>
</ul>
<h1 id="7-枚举类和注解"><a href="#7-枚举类和注解" class="headerlink" title="7 枚举类和注解"></a>7 枚举类和注解</h1><h2 id="7-1-枚举类"><a href="#7-1-枚举类" class="headerlink" title="7.1 枚举类"></a>7.1 枚举类</h2><ul>
<li>枚举类的属性不允许被改动，所以用 private final 修饰</li>
<li>枚举类应该在构造器中为其赋值</li>
<li>若枚举类显式的定义了带参数的构造器 , 则在列出枚举值时也必须对应的传入参数</li>
<li>自定义枚举类：<ul>
<li>私有化 类的构造器，保证不能在类的外部创建其对象</li>
<li>在 类的内部创建枚举类的实例。声明为： public static final</li>
<li>对象如果有实例变量，应该声明为 private final ，并在构造器中初始化</li>
</ul>
</li>
</ul>
<h3 id="7-1-1-enum"><a href="#7-1-1-enum" class="headerlink" title="7.1.1 enum"></a>7.1.1 enum</h3><ul>
<li>默认继承 java.lang.Enum 类</li>
<li>构造器只能使用 private 修饰符</li>
<li>所有实例必须显式的列出，自动使用 public static final 修饰</li>
<li>必须在第一行声明枚举对象</li>
<li>JDK 1.5可以使用switch-case枚举</li>
<li>方法：<ul>
<li>values()</li>
<li>valueOf()</li>
<li>toString()</li>
</ul>
</li>
</ul>
<h2 id="7-2-注解（Annotation）"><a href="#7-2-注解（Annotation）" class="headerlink" title="7.2 注解（Annotation）"></a>7.2 注解（Annotation）</h2><ul>
<li>Annotation 其实就是代码里的 特殊标记 , 这些标记可以在编译 , 类加<br>载 , 运行时被读取 , 并执行相应 的处理</li>
<li>框架 = 注解 + 反射 + 设计模式</li>
<li>示例：<ul>
<li>@Override: 限定重写父类方法 , 该注解只能 用于方法</li>
<li>@Deprecated : 用于表示所修饰的元素 类 , 方法等 已过 时。通常是因为<br>所修饰的结构危险或存在更好的选择</li>
<li>@SuppressWarnings : 抑制编译器警告</li>
</ul>
</li>
<li>元注解<ul>
<li>修饰其他注解</li>
<li>Retention、Target、Documented、Inherited</li>
</ul>
</li>
<li>JDK 8 新特性：<ul>
<li>可重复的注解</li>
<li>可用于类型的注解</li>
</ul>
</li>
</ul>
<h1 id="8-Java集合"><a href="#8-Java集合" class="headerlink" title="8 Java集合"></a>8 Java集合</h1><ul>
<li>数组的优劣：<ul>
<li>初始化后长度就确定了</li>
<li>声明的类型决定了初始化时的类型</li>
<li>初始化后长度不可变</li>
<li>提供的属性和方法少</li>
<li>存储的数据是有序的、可以重复的</li>
</ul>
</li>
<li>Java集合的分类：<ul>
<li>Collection：单列数据，定义了存取一组对象的方法的集合<ul>
<li>List：元素有序、可重复的集合<ul>
<li>ArrayList</li>
<li>LinkedList</li>
<li>Vector</li>
</ul>
</li>
<li>Set：元素无序、不可重复的集合<ul>
<li>HashSet<ul>
<li>LinkedHashSet</li>
</ul>
</li>
<li>SortedSet<ul>
<li>TreeSet</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Map：双列数据，保存映射关系“k-v对”的集合</li>
</ul>
</li>
</ul>
<h2 id="8-1-Collection"><a href="#8-1-Collection" class="headerlink" title="8.1 Collection"></a>8.1 Collection</h2><ul>
<li>是List、Set、Queue接口的父接口</li>
<li>JDK不提供该接口的直接实现，而是提供更具体的子接口</li>
<li>JDK 5 之前会把容器中所有的对象当成Object类型处理</li>
<li>JDK 5.0 以后，增加了泛型，Java 集合可以记住对象的数据类型</li>
<li>方法：<ul>
<li>add()/addAll()</li>
<li>size()</li>
<li>clear()</li>
<li>isEmpty()</li>
<li>cotains()/containsAll()</li>
<li>remove()/removeAll()：取两个集合的差集</li>
<li>retainAll()：取两个结合的交集</li>
<li>equals()</li>
<li>toArray()</li>
<li>hashcode()</li>
<li>iterator()</li>
</ul>
</li>
</ul>
<h2 id="8-2-Iterator"><a href="#8-2-Iterator" class="headerlink" title="8.2 Iterator"></a>8.2 Iterator</h2><ul>
<li>Iterator 即迭代器，主要用于遍历 Collection 集合中的元素</li>
<li>GOF 给迭代器模式的定义为：提供一种方法访问一个容器对象中各个元素，又不需暴露该对象的内部细节</li>
<li>继承了java.lang.Iterator接口</li>
<li>仅用于遍历集合</li>
<li>每次调用iterator()方法都得到以和全新的迭代器对象</li>
<li>方法：<ul>
<li>hasNext()</li>
<li>next()</li>
<li>remove()</li>
</ul>
</li>
<li>Java 5.0 提供了 foreach 循环遍历集合和数组<ul>
<li>不需获取集合和数组的长度，无需放翁引用元素</li>
<li>底层调用迭代器完成</li>
</ul>
</li>
</ul>
<h2 id="8-3-List"><a href="#8-3-List" class="headerlink" title="8.3 List"></a>8.3 List</h2><ul>
<li>元素有序，且可重复</li>
<li>可以根据序号存取容器中的元素</li>
<li>方法：<ul>
<li>add()</li>
<li>get()</li>
<li>indexOf()</li>
<li>lastIndexOf()</li>
<li>remove()</li>
<li>set()</li>
<li>subList</li>
</ul>
</li>
<li>实现类：<ul>
<li>ArrayList：默认选择，适合随机访问和修改</li>
<li>LinkedList：适合频繁的插入删除元素</li>
<li>Vector：<ul>
<li>和ArrayList几乎相同，唯一区别在于Vector是同步类</li>
<li>线程安全，但速度比ArrayList慢</li>
<li>每次扩容请求最大空间的2倍，而ArrayList是1.5倍</li>
<li>有一个子类Stack</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="8-4-Set"><a href="#8-4-Set" class="headerlink" title="8.4 Set"></a>8.4 Set</h2><ul>
<li>Set接口没有提供额外的方法</li>
<li>不允许包含相同的元素</li>
<li>判断两个对象是否相同根据equals()方法</li>
</ul>
<h3 id="8-4-1-HashSet"><a href="#8-4-1-HashSet" class="headerlink" title="8.4.1 HashSet"></a>8.4.1 HashSet</h3><ul>
<li>不能保证元素的排列顺序</li>
<li>不是线程安全的</li>
<li>元素可以是 null</li>
<li>判断两个元素是否相等：<ul>
<li>hashCode()相等</li>
<li>equals()相等</li>
</ul>
</li>
<li>相同的对象必须具有相同的散列码</li>
<li>数组 + 链表</li>
<li>数组初始容量为16，使用率超过0.75，扩容为2倍</li>
</ul>
<h3 id="8-4-2-LinkedHashSet"><a href="#8-4-2-LinkedHashSet" class="headerlink" title="8.4.2 LinkedHashSet"></a>8.4.2 LinkedHashSet</h3><ul>
<li>根据hashCode值决定元素的存储位置</li>
<li>使用双向链表维护元素的次序</li>
<li>插入性能略低于HashSet，迭代访问全部元素性能好</li>
<li>不允许元素重复</li>
</ul>
<h3 id="8-4-3-TreeSet"><a href="#8-4-3-TreeSet" class="headerlink" title="8.4.3 TreeSet"></a>8.4.3 TreeSet</h3><ul>
<li>是SortedSet接口的实现类</li>
<li>元素处于排序状态</li>
<li>底层使用红黑树存储数据</li>
<li>查询速度比List快</li>
<li>自然排序：<ul>
<li>compareTo()、默认升序</li>
<li>添加进TreeSet必须的类必须实现Comoarable类</li>
<li>TreeSet中添加的应该是同一个类的对象</li>
<li>判断两个元素是否相等：compareTo()</li>
</ul>
</li>
<li>定制排序<ul>
<li>重写compareTo()方法</li>
<li>判断两个元素是否相等：通过Comparator比较两个元素返回了0</li>
</ul>
</li>
</ul>
<h2 id="8-6-Map"><a href="#8-6-Map" class="headerlink" title="8.6 Map"></a>8.6 Map</h2><ul>
<li>方法：<ul>
<li>put()/putAll()</li>
<li>remove()</li>
<li>clear()</li>
<li>get()</li>
<li>containsKey()</li>
<li>containsValue()</li>
<li>size()</li>
<li>isEmpty()</li>
<li>equals()</li>
<li>Set keySet()</li>
<li>Collection values()</li>
<li>Set entrySet()</li>
</ul>
</li>
</ul>
<h3 id="8-6-1-HashMap"><a href="#8-6-1-HashMap" class="headerlink" title="8.6.1 HashMap"></a>8.6.1 HashMap</h3><ul>
<li>是 Map 接口使用频率最高的实现类</li>
<li>允许使用null键，null值</li>
<li>内部类：Node</li>
<li>不保证映射的顺序</li>
<li>所有的key构成的集合是Set：无序的、不可重复的<ul>
<li>key类要重写：equals()和hashCode()</li>
</ul>
</li>
<li>所有的value构成的集合是Collection：无序的、可以重复的<ul>
<li>value()类要重写：equals()</li>
</ul>
</li>
<li>一个 key-value 构成一个entry</li>
<li>所有的entry构成的集合是Set：无序的、不可重复的</li>
<li>JDK 7 以前版本：数组 + 链表（链地址法）</li>
<li>JDK 8：数组 + 链表 + 红黑树</li>
</ul>
<h3 id="8-6-2-LinkedHashMap"><a href="#8-6-2-LinkedHashMap" class="headerlink" title="8.6.2 LinkedHashMap"></a>8.6.2 LinkedHashMap</h3><ul>
<li>在 HashMap 的基础上，使用了一堆双向链表记录添加元素的顺序</li>
<li>可以维护Map的迭代器</li>
<li>内部类：Entry</li>
</ul>
<h3 id="8-6-3-TreeMap"><a href="#8-6-3-TreeMap" class="headerlink" title="8.6.3 TreeMap"></a>8.6.3 TreeMap</h3><ul>
<li>所有的k-v对处于有序状态</li>
<li>使用红黑树存储数据</li>
<li>判断两个key相等的标椎：compareTo()或compara()返回()</li>
</ul>
<h3 id="8-6-4-HashTable"><a href="#8-6-4-HashTable" class="headerlink" title="8.6.4 HashTable"></a>8.6.4 HashTable</h3><ul>
<li>线程安全</li>
<li>实现原理和HashMap相同，功能相同</li>
<li>不允许使用null作为key、value</li>
<li>不能保证 k-v 对的顺序</li>
<li>判读 k、v 相等的标准和 HashMap 一致</li>
</ul>
<h3 id="8-6-5-Properties"><a href="#8-6-5-Properties" class="headerlink" title="8.6.5 Properties"></a>8.6.5 Properties</h3><ul>
<li>用于处理属性文件</li>
<li>key、value都是字符串类型</li>
<li>setProperty()/getProperty()</li>
</ul>
<h2 id="8-7-Collections工具类"><a href="#8-7-Collections工具类" class="headerlink" title="8.7 Collections工具类"></a>8.7 Collections工具类</h2><ul>
<li>reverse()</li>
<li>shuffle()</li>
<li>sort()</li>
<li>swap()</li>
<li>max()/min()</li>
<li>frequency()</li>
<li>copy()</li>
<li>replaceAll()</li>
<li>synchronizedXxx()：包装为线程安全的集合</li>
</ul>
<h1 id="9-泛型"><a href="#9-泛型" class="headerlink" title="9 泛型"></a>9 泛型</h1><ul>
<li><p>所谓泛型就是允许在定义类 、 接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。这个类型参数将在使用时例如继承或实现这个接口用这个类型声明变量、创建对象时确定即传入实际的类型参数也称为类型实参。</p>
</li>
<li><p>解决元素存储的安全性问题</p>
</li>
<li><p>解决获取元素时，强制类型转换的问题</p>
</li>
<li><p>能够在编译时而不是运行时检测错误</p>
</li>
<li><p>通配符 &lt;?&gt;</p>
</li>
</ul>
<h1 id="10-IO流"><a href="#10-IO流" class="headerlink" title="10 IO流"></a>10 IO流</h1><h2 id="10-1-File类"><a href="#10-1-File类" class="headerlink" title="10.1 File类"></a>10.1 File类</h2><ul>
<li>javaj.io.File</li>
<li>File 能新建、删除、重命名文件和目录，但不能访问文件本身</li>
<li>Java程序中表示一个真实的文件或目录，必须有一个File对象</li>
<li>Java中的一个File对象不一定有一个真实的文件或目录</li>
<li>File对象可以作为参数传递给流的构造器</li>
<li>路径分隔符：public static final String separator &gt;&gt;跨平台</li>
</ul>
<h2 id="10-2-IO流"><a href="#10-2-IO流" class="headerlink" title="10.2 IO流"></a>10.2 IO流</h2><ul>
<li><p>用于处理设备之间的数据传输</p>
</li>
<li><p>分类：</p>
<ul>
<li>数据单位：<ul>
<li>字节流（8bit）</li>
<li>字符流（16bit）</li>
</ul>
</li>
<li>流向：<ul>
<li>输入流</li>
<li>输出流</li>
</ul>
</li>
<li>角色：<ul>
<li>节点流：直接从数据源或目的地读写数据</li>
<li>处理流：不直接连接到数据源或目的地，而是连接在已存在的流之上，通过对数据的处理为程序提供更强大的读写功能</li>
</ul>
</li>
</ul>
</li>
<li><p>InputStream：字节输入流</p>
</li>
<li><p>OutputStream：字节输出流</p>
</li>
<li><p>Reader：字符输入流</p>
</li>
<li><p>Writer：字符输出流</p>
</li>
<li><p>IO流不属于内存的资源，不能被垃圾回收机制管理，应显式地关闭文件IO资源</p>
</li>
<li><p>缓冲流：</p>
<ul>
<li>BufferedInputStream</li>
<li>BufferedOutputStream</li>
<li>BufferedReader</li>
<li>BufferedWriter</li>
</ul>
</li>
<li><p>转换流：</p>
<ul>
<li>InputStreamReader：I &gt; R</li>
<li>OutputStreamWriter：W &gt; O</li>
</ul>
</li>
<li><p>字符编码：</p>
<ul>
<li>ASCII</li>
<li>ISO8859-1</li>
<li>GB2312</li>
<li>GBK</li>
<li>Unicode</li>
<li>UTF-8</li>
<li>编码：字符串 &gt; 字节数组</li>
<li>解码：字符数组 &gt; 字符串</li>
</ul>
</li>
<li><p>打印流：</p>
<ul>
<li>PrintStream</li>
<li>PrintStream</li>
</ul>
</li>
<li><p>数据流：</p>
<ul>
<li>DataInputStream</li>
<li>DataOutputStream</li>
</ul>
</li>
<li><p>对象流：</p>
<ul>
<li>ObjectInputStream</li>
<li>ObjectOutputStream</li>
</ul>
</li>
<li><p>随机存取文件流：</p>
<ul>
<li>RondomAccessFile类</li>
</ul>
</li>
</ul>
<h1 id="11-网络编程"><a href="#11-网络编程" class="headerlink" title="11 网络编程"></a>11 网络编程</h1><h2 id="11-1-IP和端口号"><a href="#11-1-IP和端口号" class="headerlink" title="11.1 IP和端口号"></a>11.1 IP和端口号</h2><ul>
<li>IP地址：<ul>
<li>Internet上的计算机的唯一地址</li>
<li>本地回环地址：127.0.0.1</li>
<li>主机名：localhost</li>
<li>分类：<ul>
<li>IPV4：4个字节</li>
<li>IPV6：128个字节</li>
<li>公网地址</li>
<li>私有地址：192.168.x.x</li>
</ul>
</li>
</ul>
</li>
<li>端口号：不同的进程具有不同的端口号</li>
<li>16位整数：0~65535</li>
<li>分类：<ul>
<li>公认端口：0~1023</li>
<li>注册端口：1024~49151</li>
<li>动态/私有端口：49152~65535</li>
<li>端口号 + IP地址 = 套接字</li>
</ul>
</li>
<li>域名解析：域名 &gt; IP地址：先找主机hosts，是否有输入的域名地址，如果没有则从DNS服务器中查找</li>
</ul>
<h2 id="11-2-网络协议"><a href="#11-2-网络协议" class="headerlink" title="11.2 网络协议"></a>11.2 网络协议</h2><ul>
<li>计算机网络实现通信必须有的一些约定</li>
</ul>
<h3 id="11-2-1-TCP-IP协议簇"><a href="#11-2-1-TCP-IP协议簇" class="headerlink" title="11.2.1 TCP/IP协议簇"></a>11.2.1 TCP/IP协议簇</h3><ul>
<li>TCP/IP协议模型：物理链路层、IP层、传输层、应用层</li>
<li>IP协议是网络层的主要协议</li>
<li>传输控制协议TCP（transmission control protocol）：<ul>
<li>使用前需要“三次握手”建立连接</li>
<li>点对点通信，是可靠的</li>
<li>两个应用进程：客户端、服务端</li>
<li>可进行大数据量的传输</li>
<li>传输完毕，需要“四次挥手”释放连接，效率低</li>
</ul>
</li>
<li>用户数据报协议（user datagram protocol）：<ul>
<li>将数据。源。目的封装成数据报，不需要建立连接</li>
<li>每个数据报的大小限制在64K以内</li>
<li>不可靠</li>
<li>支持广播发送</li>
<li>发送完毕不需要释放连接，开销小，速度快</li>
</ul>
</li>
</ul>
<h3 id="11-2-2-Socket"><a href="#11-2-2-Socket" class="headerlink" title="11.2.2 Socket"></a>11.2.2 Socket</h3><ul>
<li>IP地址 + 端口号 = 套接字</li>
<li>通信的两端都要有套接字</li>
<li>网络通信就是套接字的通信</li>
<li>Socket允许程序吧网络连接当成一个流，数据在两个Socket间通过IO传输</li>
<li>主动发起通信的应用程序为客户端，等待通信请求的为服务端</li>
<li>分类：<ul>
<li>流套接字（stream socket）：tcp</li>
<li>数据报套接字（datagram socket）：udp</li>
</ul>
</li>
</ul>
<h3 id="11-2-3-TCP网络编程"><a href="#11-2-3-TCP网络编程" class="headerlink" title="11.2.3 TCP网络编程"></a>11.2.3 TCP网络编程</h3><ul>
<li><p>客户端：</p>
<ul>
<li>创建Socket：Socket类</li>
<li>打开连接到Socket的输入流/输出流<ul>
<li>getInputStream()</li>
<li>getOutputStream()</li>
</ul>
</li>
<li>按照一定协议对Socket进行读/写操作</li>
<li>关闭Socket</li>
</ul>
</li>
<li><p>服务端：</p>
<ul>
<li>调用ServerSocket监听客户端的请求</li>
<li>调用accept()接受连接</li>
<li>调用getOutputStream()和getInputStream()获取输出流和输入流</li>
<li>关闭ServerSocket和Socket对象<h3 id="11-2-4-UDP网络编程"><a href="#11-2-4-UDP网络编程" class="headerlink" title="11.2.4 UDP网络编程"></a>11.2.4 UDP网络编程</h3></li>
</ul>
</li>
<li><p>UDO数据报通过数据包套接字DatagramSocket发送和接收</p>
</li>
<li><p>UDP数据报使用DatagramPacket进行封装，包含了发送端和接收端的IP地址和端口号</p>
</li>
<li><p>因此无需建立发送端和接收端的连接</p>
</li>
</ul>
<h3 id="11-2-5-URL编程"><a href="#11-2-5-URL编程" class="headerlink" title="11.2.5 URL编程"></a>11.2.5 URL编程</h3><ul>
<li>URL（uniform resource locator）：统一资源定位符，表示Internet上某一资源的地址</li>
<li>组成：<ul>
<li>&lt;传输协议&gt;://&lt;主机名&gt;:&lt;端口号&gt;/&lt;文件名&gt;#片段名?参数列表</li>
</ul>
</li>
<li>java.net</li>
<li>使用 try-catch 捕获异常</li>
<li>一个URL对象一旦生成，属性不能被改变</li>
<li>URI（uniform resource identifier）：统一资源标识符<ul>
<li>URL（uniform resource locator）：统一资源定位符</li>
<li>URN（uniform resource locater）：统一资源命名</li>
</ul>
</li>
</ul>
<h1 id="12-反射"><a href="#12-反射" class="headerlink" title="12 反射"></a>12 反射</h1><h2 id="12-1-概述"><a href="#12-1-概述" class="headerlink" title="12.1 概述"></a>12.1 概述</h2><ul>
<li><p>反射机制允许程序在执行期借助于反射API取得任何类的内部信息，并能之间操作任意对象的内部属性和方法</p>
</li>
<li><p>加载完类后，在堆内存的方法区就产生了一个Class类型的对象，这个对象就包含了完整的类的结构信息。</p>
</li>
<li><p>正常方式：</p>
<ul>
<li>引入需要的包类名称</li>
<li>new()实例化对象</li>
<li>取得实例化对象</li>
</ul>
</li>
<li><p>反射：</p>
<ul>
<li>实例化对象</li>
<li>getClass()</li>
<li>得到完整的包名</li>
</ul>
</li>
<li><p>动态语言：</p>
<ul>
<li>运行时可以改变其结构的语言<ul>
<li>C#、JavaScript、PHP、Python</li>
</ul>
</li>
</ul>
</li>
<li><p>静态语言：</p>
<ul>
<li>运行时结构不可改变的语言<ul>
<li>Java、C、C++</li>
</ul>
</li>
</ul>
</li>
<li><p>Java不是动态语言 但 Java 可以称之为准动态语言。即 Java 有一定的动态性，我们可以利用反射机制、字节码操作获得类似动态语言的特性 。</p>
</li>
<li><p>获取Class类的方法：</p>
<ul>
<li>Class clazz = String.class;</li>
<li>Class clazz = “classA”.getClass()</li>
<li>Class clazz = Class.forName(“java.lang.String”)</li>
</ul>
</li>
</ul>
<h2 id="12-2-类的加载"><a href="#12-2-类的加载" class="headerlink" title="12.2 类的加载"></a>12.2 类的加载</h2><ul>
<li><p>加载过程：</p>
<ul>
<li>加载：将 class 文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的 java.lang.Class 对象，作为方法区中类数据的访问入口（即引用地址）。所有需要访问和使用类数据只能通过这个 Class 对象。这个加载的过程需要类加载器参与。</li>
<li>链接：将类的二进制数据合并到JRE中</li>
<li>初始化：JVM负责对类初始化</li>
</ul>
</li>
<li><p>类加载器的作用：</p>
<ul>
<li>类加载</li>
<li>类缓存</li>
</ul>
</li>
<li><p>类加载器的分类：</p>
<ul>
<li>引导类加载器：用 C++ 编写的，是 JVM 自带的类加载器，负责 Java 平台核心库，用来装载核心类库。该加载器无法直接获取</li>
<li>扩展类加载器：负责 jre / ext 目录下的 jar 包或-D java.ext.dirs 指定目录下的 jar 包装入工作库</li>
<li>系统类加载器：负责 java classpath 或-D java.class.path 所指的目录下的类与 jar 包装入工作 ，是最常用的加载器</li>
</ul>
</li>
<li><p>自底向上检查类是否已加载</p>
</li>
<li><p>自顶向下尝试加载类</p>
<h2 id="12-3-创建运行时类的对象"><a href="#12-3-创建运行时类的对象" class="headerlink" title="12.3 创建运行时类的对象"></a>12.3 创建运行时类的对象</h2></li>
<li><p>创建类的对象：</p>
<ul>
<li>调用Class对象的newInstance()<ul>
<li>类必须有一个无参数的构造器</li>
<li>类的构造器必须有足够的访问权限</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="12-4-获取运行时类的完整结构"><a href="#12-4-获取运行时类的完整结构" class="headerlink" title="12.4 获取运行时类的完整结构"></a>12.4 获取运行时类的完整结构</h2><ul>
<li>实现的全部接口：<ul>
<li>public Class&lt;?&gt;[] getInterfaces ()</li>
</ul>
</li>
<li>所继承的父类：<ul>
<li>public Class&lt;? Super T&gt; getSuperclass</li>
</ul>
</li>
<li>全部的构造器：<ul>
<li>public Constructor<T>[] getConstructors</li>
<li>public Constructor<T>[] getDeclaredConstructors</li>
</ul>
</li>
<li>全部的方法：<ul>
<li>public Method[] getDeclaredMethods</li>
<li>public Method[] getMethods ()</li>
</ul>
</li>
<li>全部的 Field：<ul>
<li>public Field[] getFields ()</li>
<li>public Field[] getDeclaredFields ()</li>
</ul>
</li>
<li>注解：<ul>
<li>get Annotation(Class<T> annotationClass )</li>
<li>getDeclaredAnnotations ()</li>
</ul>
</li>
</ul>
<h2 id="12-5-调用运行时类的指定结构"><a href="#12-5-调用运行时类的指定结构" class="headerlink" title="12.5 调用运行时类的指定结构"></a>12.5 调用运行时类的指定结构</h2><ul>
<li><p>调用指定方法：</p>
<ul>
<li>首先 getMethod (String name,Class …parameterTypes)</li>
<li>然后 Object invoke(Object obj , Object[] args)</li>
</ul>
</li>
<li><p>调用指定属性：</p>
<ul>
<li>public Field getField (String name)</li>
<li>public Field getDeclaredField (String name)</li>
</ul>
</li>
<li><p>setAccessible方法：</p>
<ul>
<li>Method 和 Field 、 Constructor 对象都有 setAccessible() 方法 。</li>
<li>setAccessible 启动和禁用访问安全检查的开关 。</li>
<li>参数 值 为 true 则指示反射的对象在使用时应该取消 Java 语言访问检查 。<ul>
<li>提高反射的效率 。 如果代码中必须用反射 而该句代码需要频繁的被<br>调用 那么请设置为 true 。</li>
<li>使得 原本无法访问的私有成员也可以访问</li>
</ul>
</li>
<li>参数 值 为 false 则指示反射的对象应该实施 Java 语言访问检查 。</li>
</ul>
</li>
</ul>
<h2 id="12-6-动态代理"><a href="#12-6-动态代理" class="headerlink" title="12.6 动态代理"></a>12.6 动态代理</h2><ul>
<li>步骤：<ul>
<li>创建一个实现接口 InvocationHandler 的类，它必须实现 invoke 方法，以完成代理的具体操作。</li>
<li>创建被代理的类以及接口</li>
<li>通过 Proxy 的静态方法newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h) 创建一个 Subject 接口代理</li>
<li>通过 Subject 代理调用 RealSubject 实现类的方法</li>
</ul>
</li>
<li>AOP（Aspect Orient Programming）</li>
</ul>
<h1 id="13-Java-8-的新特性"><a href="#13-Java-8-的新特性" class="headerlink" title="13 Java 8 的新特性"></a>13 Java 8 的新特性</h1><ul>
<li>速度更快</li>
<li>代码更少 增加了新的语法 Lambda 表达式</li>
<li>强大的 Stream API</li>
<li>便于并行</li>
<li>最大化减少空指针异常： Optional</li>
<li>Nashorn 引擎，允许在 JVM 上运行 JS 应用 Java 8</li>
</ul>
<h2 id="13-1-Lambda表达式"><a href="#13-1-Lambda表达式" class="headerlink" title="13.1 Lambda表达式"></a>13.1 Lambda表达式</h2><ul>
<li><p>Lambda是一个匿名函数 ，我们可以把 Lambda 表达式理解为是 一段可以传递的代码 （将代码像数据一样进行传递）。</p>
</li>
<li><p>Lambda 操作符：</p>
<ul>
<li>-&gt;</li>
<li>左侧：指定了 Lambda 表达式需要的 参 数 列表</li>
<li>右侧：指定了 Lambda 体 是抽象方法的实现逻辑，即Lambda 表达式要执行的功能</li>
</ul>
</li>
<li><p>类型推断：Lambda表达式中无需指定类型，程序依然可以编译，这是因为 javac 根据程序的上下文，在后台推断出了参数的类型。 </p>
</li>
</ul>
<h2 id="13-2-函数式接口"><a href="#13-2-函数式接口" class="headerlink" title="13.2 函数式接口"></a>13.2 函数式接口</h2><ul>
<li><p>只包含一个抽象方法的接口</p>
</li>
<li><p>可以通过Lambda表达式创建该接口的对象</p>
</li>
<li><p>使用@FunctionallInterface 注解检查接口是否是函数式接口</p>
</li>
<li><p>java.util.function</p>
</li>
<li><p>分类：</p>
<ul>
<li>消费型接口</li>
<li>供给型接口</li>
<li>函数型接口</li>
<li>断定型接口</li>
</ul>
</li>
</ul>
<h2 id="13-3-方法引用和构造器引用"><a href="#13-3-方法引用和构造器引用" class="headerlink" title="13.3 方法引用和构造器引用"></a>13.3 方法引用和构造器引用</h2><ul>
<li>方法引用：<ul>
<li>函数表达式的一个实例，通过方法的名字指向一个方法</li>
<li>使用操作符 ““::” 将类或对象与方法名分隔开来</li>
</ul>
</li>
<li>构造器引用：<ul>
<li>ClassName::new </li>
</ul>
</li>
</ul>
<h2 id="13-4-Stream-API"><a href="#13-4-Stream-API" class="headerlink" title="13.4 Stream API"></a>13.4 Stream API</h2><ul>
<li><p>是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列</p>
</li>
<li><p>Stream 自己不会存储元素。</p>
</li>
<li><p>Stream 不会改变源对象。相反，他们会返回一个持有结果的新 Stream 。</p>
</li>
<li><p>Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</p>
</li>
<li><p>创建方式：</p>
<ul>
<li>通过集合：<ul>
<li>default Stream<E> stream() : 返回一个顺序流</li>
<li>default Stream<E> parallelStream() : 返回一个并行流</li>
</ul>
</li>
<li>通过数组：<ul>
<li>static <T> Stream<T> stream(T[] array): 返回一个流</li>
</ul>
</li>
<li>通过Stream的of()：<ul>
<li>public static<T> Stream<T> of(T… values) : 返回一个流</li>
</ul>
</li>
<li>创建无限流：<ul>
<li>迭代<br>public static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f)</li>
<li>生成<br>public static<T> Stream<T> generate(Supplier<T> s)</li>
</ul>
</li>
</ul>
</li>
<li><p>中间操作：</p>
<ul>
<li>筛选与切片</li>
<li>映射</li>
<li>排序</li>
</ul>
</li>
<li><p>终止操作：</p>
<ul>
<li>匹配与查找</li>
<li>归约</li>
<li>收集</li>
</ul>
</li>
</ul>
<h2 id="13-5-Optional-类"><a href="#13-5-Optional-类" class="headerlink" title="13.5 Optional 类"></a>13.5 Optional 类</h2><ul>
<li><p>Optional<T> 类 (java.util.Optional) 是一个容器类 它可以保存类型 T 的值，代表<br>这个 值存在，或者仅仅保存 null ，表示这个值不存在。原来 用 null 表示一个值不<br>存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常 。</p>
<h1 id="14-Java-9、10、11-新特性"><a href="#14-Java-9、10、11-新特性" class="headerlink" title="14 Java 9、10、11 新特性"></a>14 Java 9、10、11 新特性</h1></li>
</ul>
<h2 id="14-1-Java-9-新特性"><a href="#14-1-Java-9-新特性" class="headerlink" title="14.1 Java 9 新特性"></a>14.1 Java 9 新特性</h2><ul>
<li><p>模块化系统</p>
<ul>
<li>Jigsaw -&gt; Modularity</li>
</ul>
</li>
<li><p>jShell 命令</p>
</li>
<li><p>多版本兼容 jar 包</p>
</li>
<li><p>接口的私有方法</p>
</li>
<li><p>钻石操作符的使用升级</p>
</li>
<li><p>语法改进：try 语句</p>
</li>
<li><p>String 存储结构变更</p>
</li>
<li><p>便利的集合特性： of()</p>
</li>
<li><p>增强的 Stream API</p>
</li>
<li><p>全新的 HTTP 客户端 API</p>
</li>
<li><p>Deprecated 的相关 API</p>
</li>
<li><p>javadoc 的 HTML 5 支持</p>
</li>
<li><p>Javascript 引擎升级： Nashorn</p>
</li>
<li><p>java 的动态编译器</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>0018.四数之和</title>
    <url>/2020/10/05/0018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; quadruplets = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> quadruplets;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>] + nums[i + <span class="number">3</span>] &gt; target) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[length - <span class="number">3</span>] + nums[length - <span class="number">2</span>] + nums[length - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; length - <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] + nums[j + <span class="number">1</span>] + nums[j + <span class="number">2</span>] &gt; target) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] + nums[length - <span class="number">2</span>] + nums[length - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> left = j + <span class="number">1</span>, right = length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                    <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                        quadruplets.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));</span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                            left++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        left++;</span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                            right--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> quadruplets;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(n^3)，其中 nn 是数组的长度。排序的时间复杂度是 O(n \log n)O(nlogn)，枚举四元组的时间复杂度是 O(n^3)，因此总时间复杂度为 O(n^3+nlogn)=O(n3)。</p>
</li>
<li><p>空间复杂度：O(logN)。我们忽略存储答案的空间，额外的排序的空间复杂度为 O(logN)。然而我们修改了输入的数组 nums，在实际情况下不一定允许，因此也可以看成使用了一个额外的数组存储了 nums 的副本并进行排序，空间复杂度为 O(N)。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>0201.数组范围按位与</title>
    <url>/2020/10/06/0201.%E6%95%B0%E7%BB%84%E8%8C%83%E5%9B%B4%E6%8C%89%E4%BD%8D%E4%B8%8E/</url>
    <content><![CDATA[<p><strong>位移</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(m != n)&#123;</span><br><span class="line">            m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m &lt;&lt; count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(logn)。算法的时间复杂度取决于 mm 和 nn 的二进制位数，由于 m≤n，因此时间复杂度取决于 n 的二进制位数。</li>
<li>空间复杂度：O(1)。我们只需要常数空间存放若干变量。</li>
</ul>
<p><strong>Brian Kernighan 算法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (m &lt; n) &#123;</span><br><span class="line">            <span class="comment">// 抹去最右边的 1</span></span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(logn)。和位移方法类似，算法的时间复杂度取决于 m 和 n 二进制展开的位数。尽管和位移方法具有相同的渐近复杂度，但 Brian Kernighan 的算法需要的迭代次数会更少，因为它跳过了两个数字之间的所有零位。</li>
<li>空间复杂度：O(1)。我们只需要常数空间存放若干变量。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>0401.汉明距离</title>
    <url>/2020/10/06/0401.%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<p><strong>位移</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> xor = x ^ y;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(xor != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(xor % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">                ++count;</span><br><span class="line">            xor &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(1)，在 Python 和 Java 中 Integer 的大小是固定的，处理时间也是固定的。 32 位整数需要 32 次迭代。</li>
<li>空间复杂度：O(1)，使用恒定大小的空间。</li>
</ul>
<p><strong>Brian Kernighan 算法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> xor = x ^ y;</span><br><span class="line">    <span class="keyword">int</span> distance = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (xor != <span class="number">0</span>) &#123;</span><br><span class="line">      distance += <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// remove the rightmost bit of &#x27;1&#x27;</span></span><br><span class="line">      xor = xor &amp; (xor - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> distance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(1)。</li>
<li>空间复杂度：O(1)。我们只需要常数空间存放若干变量。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>0769.最多能完成排序的块1</title>
    <url>/2020/10/05/0769.%E6%9C%80%E5%A4%9A%E8%83%BD%E5%AE%8C%E6%88%90%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9D%971/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxChunksToSorted</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            max = Math.max(arr[i], max);</span><br><span class="line">            <span class="keyword">if</span>(max == i) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(N)，其中 N 为数组 <code>arr</code> 的长度。</li>
<li>空间复杂度: O(1)。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>0091. 解码方法</title>
    <url>/2020/10/07/0091.%20%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = s.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> c = b;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;1&#x27;</span> || s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;2&#x27;</span> &amp;&amp; s.charAt(i) &lt; <span class="string">&#x27;7&#x27;</span>)&#123; </span><br><span class="line">                c = s.charAt(i) != <span class="string">&#x27;0&#x27;</span> ? a + b : a; <span class="comment">// a + b : 11 ~ 19, 21 ~ 26; a : 10, 20</span></span><br><span class="line">                a = b;</span><br><span class="line">                b = c;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;0&#x27;</span>)&#123; <span class="comment">// 00, 30, 40...</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// 01, 02, 03...; 27, 28, 29, 31...</span></span><br><span class="line">                a = b;</span><br><span class="line">                b = c;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度 O(N) ： N 为字符串 s 的长度，其决定了循环次数。</li>
<li>空间复杂度 O(1) ： 字符串 s 使用常量大小的额外空间。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>0075.颜色分类.md</title>
    <url>/2020/10/07/0075.%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<p><strong>两趟扫描法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">1</span>)&#123;</span><br><span class="line">                w++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                b++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; r)&#123;</span><br><span class="line">                nums[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i &gt;= r &amp;&amp; i &lt; r + w)&#123;</span><br><span class="line">                nums[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums[i] = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(N)。</li>
<li>空间复杂度：O(N)。</li>
</ul>
<p><strong>双指针：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                swap(nums, i, l);</span><br><span class="line">                l++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == <span class="number">2</span>)&#123;</span><br><span class="line">                swap(nums, i, r);</span><br><span class="line">                r--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(N)。</li>
<li>空间复杂度：O(1)。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>0008.字符串转换整数（atoi）</title>
    <url>/2020/10/07/0008.%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0%EF%BC%88atoi%EF%BC%89/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> state = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(state == <span class="number">0</span> &amp;&amp; c == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                state = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(state == <span class="number">0</span> &amp;&amp; (c == <span class="string">&#x27;-&#x27;</span> || c == <span class="string">&#x27;+&#x27;</span>))&#123;</span><br><span class="line">                state = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(state != <span class="number">3</span> &amp;&amp; c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                state = <span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                state = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(state == <span class="number">1</span>)&#123;</span><br><span class="line">                sign = c == <span class="string">&#x27;-&#x27;</span> ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(state == <span class="number">2</span>)&#123;</span><br><span class="line">                ans = ans * <span class="number">10</span> + (c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span>(ans * sign &gt;= Integer.MAX_VALUE)&#123;</span><br><span class="line">                    <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(ans * sign &lt;= Integer.MIN_VALUE)&#123;</span><br><span class="line">                    <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(state == <span class="number">3</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = ans != <span class="number">0</span> ? ans * sign : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中 nn 为字符串的长度。我们只需要依次处理所有的字符，处理每个字符需要的时间为 O(1)。</li>
<li>空间复杂度：O(1)，自动机的状态只需要常数空间存储。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>01431.拥有最多糖果的孩子</title>
    <url>/2020/10/07/1431.%E6%8B%A5%E6%9C%89%E6%9C%80%E5%A4%9A%E7%B3%96%E6%9E%9C%E7%9A%84%E5%AD%A9%E5%AD%90/</url>
    <content><![CDATA[<p><strong>一遍哈希表</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Boolean&gt; <span class="title">kidsWithCandies</span><span class="params">(<span class="keyword">int</span>[] candies, <span class="keyword">int</span> extraCandies)</span> </span>&#123;</span><br><span class="line">        List&lt;Boolean&gt; res = <span class="keyword">new</span> ArrayList&lt;Boolean&gt;();</span><br><span class="line">        <span class="keyword">int</span> maxCandy = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> candy : candies)&#123;</span><br><span class="line">            maxCandy = Math.max(maxCandy, candy);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; candies.length; i++)&#123;</span><br><span class="line">            res.add(candies[i] + extraCandies &gt;= maxCandy);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(n)。</p>
</li>
<li><p>空间复杂度：O(1)。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 47. 礼物的最大价值</title>
    <url>/2020/10/07/%E5%89%91%E6%8C%87Offer47.%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = grid.length;</span><br><span class="line">        <span class="keyword">int</span> c = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[r + <span class="number">1</span>][c + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= c; j++)&#123;</span><br><span class="line">                dp[i][j] = grid[i - <span class="number">1</span>][j - <span class="number">1</span>] + Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[r][c];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(mn)。</li>
<li>空间复杂度：O(1)。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 48.最长不含重复字符的子字符串</title>
    <url>/2020/10/07/%E5%89%91%E6%8C%87Offer48.%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p><strong>滑动窗口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(r &lt; s.length())&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(r++);</span><br><span class="line">            <span class="keyword">while</span>(set.contains(c))&#123;</span><br><span class="line">                set.remove(s.charAt(l++));</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(c);</span><br><span class="line">            res = Math.max(res, r - l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)。</li>
<li>空间复杂度：O(<em>n</em>)。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>HashSet</tag>
      </tags>
  </entry>
  <entry>
    <title>0344.反转字符串</title>
    <url>/2020/10/08/0344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">char</span> tmp = s[l];</span><br><span class="line">            s[l] = s[r];</span><br><span class="line">            s[r] = tmp;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(n)。</p>
</li>
<li><p>空间复杂度：O(1)。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 40.最小的k个数</title>
    <url>/2020/10/07/%E5%89%91%E6%8C%87Offer40.%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<p><strong>暴力法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(arr, <span class="number">0</span>, k);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(nlogn)，其中 n 是数组 arr 的长度。算法的时间复杂度即排序的时间复杂度。</li>
<li>空间复杂度：O(logn)，排序所需额外的空间复杂度为 O(logn)。</li>
</ul>
<p><strong>小顶堆</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span> || arr.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125; </span><br><span class="line">        Queue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;((v1, v2) -&gt; v2 - v1);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a : arr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pq.size() &lt; k)&#123;</span><br><span class="line">                pq.offer(a);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a &lt; pq.peek())&#123;</span><br><span class="line">                pq.poll();</span><br><span class="line">                pq.offer(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p : pq)&#123;</span><br><span class="line">            res[idx++] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(nlogk)，其中 n 是数组 arr 的长度。由于大根堆实时维护前 k 小值，所以插入删除都是 O(logk) 的时间复杂度，最坏情况下数组里 n 个数都会插入，所以一共需要 O(nlogk) 的时间复杂度。</p>
</li>
<li><p>空间复杂度：O(k)，因为大根堆里最多 k 个数。</p>
</li>
</ul>
<p><strong>快速排序</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li><p>时间复杂度 </p>
</li>
<li><p>空间复杂度</p>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>堆</tag>
        <tag>快速排序</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 45. 把数组排成最小的数</title>
    <url>/2020/10/08/%E5%89%91%E6%8C%87Offer45.%E6%8A%8A%E6%95%B0%E7%BB%84%E7%BB%84%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        String[] str = <span class="keyword">new</span> String[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            str[i] = String.valueOf(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(str, (x, y) -&gt; (x + y).compareTo(y + x));</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(String s : str)&#123;</span><br><span class="line">            res.append(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度 O(NlogN) ： N 为最终返回值的字符数量（strs 列表的长度≤N）；使用快排或内置函数的平均时间复杂度为 O(NlogN) ，最差为 O(N^2) 。</li>
<li>空间复杂度 O(N) ： 字符串列表 strs 占用线性大小的额外空间。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>0048.旋转图像</title>
    <url>/2020/10/08/0048.%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (n + <span class="number">1</span>)/ <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n / <span class="number">2</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[n - j - <span class="number">1</span>][i];</span><br><span class="line">                matrix[n - j - <span class="number">1</span>][i] = matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>];</span><br><span class="line">                matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>] = matrix[j][n - i - <span class="number">1</span>];</span><br><span class="line">                matrix[j][n - i - <span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(N^2) 是两重循环的复杂度。</li>
<li>空间复杂度：O(1) 由于旋转操作是 <em>就地</em> 完成的。</li>
</ul>
<p><strong>转置加翻转</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = matrix.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// transpose matrix</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = matrix[j][i];</span><br><span class="line">        matrix[j][i] = matrix[i][j];</span><br><span class="line">        matrix[i][j] = tmp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// reverse each row</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n / <span class="number">2</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = matrix[i][j];</span><br><span class="line">        matrix[i][j] = matrix[i][n - j - <span class="number">1</span>];</span><br><span class="line">        matrix[i][n - j - <span class="number">1</span>] = tmp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(N^2).</li>
<li>空间复杂度：O(1) 由于旋转操作是 <em>就地</em> 完成的。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
</search>
