<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>0001.两数之和</title>
    <url>/2020/09/11/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/two-sum/">https://leetcode-cn.com/problems/two-sum/</a></p>
<p><strong>一遍哈希表</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">      Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">          <span class="keyword">int</span> temp = target - nums[i];</span><br><span class="line">          <span class="keyword">if</span>(map.containsKey(temp))&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;map.get(temp), i&#125;; </span><br><span class="line">          &#125;</span><br><span class="line">          map.put(nums[i], i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(n)，<br>只遍历了包含有 n 个元素的列表一次。在表中进行的每次查找只花费 O(1) 的时间。</p>
</li>
<li><p>空间复杂度：O(n)，<br>所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 n 个元素。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>0002.两数相加</title>
    <url>/2020/09/11/0002.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/add-two-numbers/">https://leetcode-cn.com/problems/add-two-numbers/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    	ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    	ListNode p = l1, q = l2, curr = dummyHead;</span><br><span class="line">    	<span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">while</span> (p != <span class="keyword">null</span> || q != <span class="keyword">null</span>) &#123;</span><br><span class="line">        	<span class="keyword">int</span> x = (p != <span class="keyword">null</span>) ? p.val : <span class="number">0</span>;</span><br><span class="line">        	<span class="keyword">int</span> y = (q != <span class="keyword">null</span>) ? q.val : <span class="number">0</span>;</span><br><span class="line">        	<span class="keyword">int</span> sum = carry + x + y;</span><br><span class="line">        	carry = sum / <span class="number">10</span>;</span><br><span class="line">        	curr.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">        	curr = curr.next;</span><br><span class="line">        	<span class="keyword">if</span> (p != <span class="keyword">null</span>) p = p.next;</span><br><span class="line">        	<span class="keyword">if</span> (q != <span class="keyword">null</span>) q = q.next;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        	curr.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> dummyHead.next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(max⁡(m,n))，假设 m 和 n 分别表示 l1 和 l2 的长度，上面的算法最多重复 max⁡(m,n) 次。</li>
<li>空间复杂度：O(max⁡(m,n))， 新列表的长度最多为 max(m,n)+1。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>ListNode</tag>
      </tags>
  </entry>
  <entry>
    <title>0015.三数之和</title>
    <url>/2020/10/05/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/3sum/">https://leetcode-cn.com/problems/3sum/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> target = - nums[i];</span><br><span class="line">            <span class="keyword">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[left] + nums[right] == target)&#123;</span><br><span class="line">                    res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(nums[i], nums[left], nums[right])));</span><br><span class="line"></span><br><span class="line">                    ++left;</span><br><span class="line">                    --right;</span><br><span class="line">                    <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left - <span class="number">1</span>])&#123;</span><br><span class="line">                        ++left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right + <span class="number">1</span>])&#123;</span><br><span class="line">                        --right;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[left] + nums[right] &lt; target)&#123;</span><br><span class="line">                    ++left;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    --right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(N^2)，其中 NN 是数组 nums 的长度。</p>
</li>
<li><p>空间复杂度：O(logN)。我们忽略存储答案的空间，额外的排序的空间复杂度为 O(logN)。然而我们修改了输入的数组 nums，在实际情况下不一定允许，因此也可以看成使用了一个额外的数组存储了 nums 的副本并进行排序，空间复杂度为 O(N)。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>0032.最长有效括号</title>
    <url>/2020/09/14/0032.%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/">https://leetcode-cn.com/problems/longest-valid-parentheses/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">                maxLength = Math.max(maxLength, l * <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l &lt; r)&#123;</span><br><span class="line">                l = <span class="number">0</span>;</span><br><span class="line">                r = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        l = <span class="number">0</span>;</span><br><span class="line">        r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">                maxLength = Math.max(maxLength, l * <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l &gt; r)&#123;</span><br><span class="line">                l = <span class="number">0</span>;</span><br><span class="line">                r = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><input disabled="" type="checkbox"> 时间复杂度：o(n)</li>
<li><input disabled="" type="checkbox"> 空间复杂度：o(1)</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>0033.搜索旋转排序数组</title>
    <url>/2020/09/14/0033.%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">https://leetcode-cn.com/problems/search-in-rotated-sorted-array/</a></p>
<p><strong>二分查找：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[l] &lt;= nums[mid])&#123;</span><br><span class="line">                <span class="keyword">if</span>(target &gt;= nums[l] &amp;&amp; target &lt; nums[mid])&#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(target &gt; nums[mid] &amp;&amp; target &lt;= nums[r])&#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：o(logn)</li>
<li>空间复杂度：o(1)</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>0034.在排序数组中查找元素的第一个和最后一个位置</title>
    <url>/2020/09/14/0034.%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/</a></p>
<p><strong>二分查找：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l_index = <span class="number">0</span>,r_index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= target)&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        l_index = nums[left] != target ? -<span class="number">1</span>:left;</span><br><span class="line"></span><br><span class="line">        left = <span class="number">0</span>;</span><br><span class="line">        right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;= target)&#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        r_index = nums[right] != target ? -<span class="number">1</span>:right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;l_index,r_index&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：o(logn)</li>
<li>空间复杂度：o(1)</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>0039.组合总和</title>
    <url>/2020/09/14/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/combination-sum">https://leetcode-cn.com/problems/combination-sum</a></p>
<p><strong>回溯法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; combine = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        dfs(candidates, target, ans, combine, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; combine, <span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(idx == candidates.length)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(combine));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(candidates, target, ans, combine, idx + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(target - candidates[idx] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            combine.add(candidates[idx]);</span><br><span class="line">            dfs(candidates, target - candidates[idx], ans, combine, idx);</span><br><span class="line">            combine.remove(combine.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(S)，其中 S 为所有可行解的长度之和。从分析给出的搜索树我们可以看出时间复杂度取决于搜索树所有叶子节点的深度之和，即所有可行解的长度之和。在这题中，我们很难给出一个比较紧的上界，我们知道 O(n×2^n)是一个比较松的上界，即在这份代码中，n 个位置每次考虑选或者不选，如果符合条件，就加入答案的时间代价。但是实际运行的时候，因为不可能所有的解都满足条件，递归的时候我们还会用 target - candidates[idx] &gt;= 0 进行剪枝，所以实际运行情况是远远小于这个上界的。</li>
<li>空间复杂度：O(target)。除答案数组外，空间复杂度取决于递归的栈深度，在最差情况下需要递归 O(target)层。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title>0046.全排列</title>
    <url>/2020/09/18/0046.%E5%85%A8%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/permutations">https://leetcode-cn.com/problems/permutations</a></p>
<p><strong>回溯法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        backtrack(nums, res, tmp, visited);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; tmp, <span class="keyword">int</span>[] visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp.size() == nums.length)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(tmp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            visited[i] = <span class="number">1</span>;</span><br><span class="line">            tmp.add(nums[i]);</span><br><span class="line">            backtrack(nums, res, tmp, visited);</span><br><span class="line">            visited[i] = <span class="number">0</span>;</span><br><span class="line">            tmp.remove(tmp.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title>0047.全排列2</title>
    <url>/2020/09/18/0047.%E5%85%A8%E6%8E%92%E5%88%972/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/permutations-ii">https://leetcode-cn.com/problems/permutations-ii</a></p>
<p><strong>回溯法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] vis;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; perm = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backtrack(nums, ans, <span class="number">0</span>, perm);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, List&lt;List&lt;Integer&gt;&gt; ans, <span class="keyword">int</span> idx, List&lt;Integer&gt; perm)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == nums.length) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(perm));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[i] || (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !vis[i - <span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            perm.add(nums[i]);</span><br><span class="line">            vis[i] = <span class="keyword">true</span>;</span><br><span class="line">            backtrack(nums, ans, idx + <span class="number">1</span>, perm);</span><br><span class="line">            vis[i] = <span class="keyword">false</span>;</span><br><span class="line">            perm.remove(idx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n×n!)，其中 n 为序列的长度。</li>
<li>空间复杂度：O(n)。我们需要 O(n) 的标记数组，同时在递归的时候栈深度会达到 O(n)，因此总空间复杂度为 O(n+n)=O(2n)=O(n)。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title>0094.二叉树的中序遍历</title>
    <url>/2020/09/14/0094.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal">https://leetcode-cn.com/problems/binary-tree-inorder-traversal</a></p>
<p><strong>递归：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        inorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root.left, res);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        inorder(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</li>
<li>空间复杂度：O(n)。空间复杂度取决于递归的栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。</li>
</ul>
<p><strong>利用栈迭代：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stk = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span> || !stk.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stk.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.pop();</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</li>
<li>空间复杂度：O(n)。空间复杂度取决于栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n)。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>0104.二叉树的最大深度</title>
    <url>/2020/09/18/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree</a></p>
<p><strong>递归</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = maxDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> r = maxDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(l, r) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(n)，</p>
</li>
<li><p>空间复杂度：O(height)。</p>
</li>
</ul>
<p><strong>非递归</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中 n 为二叉树的节点个数。与方法一同样的分析，每个节点只会被访问一次。</li>
<li>空间复杂度：此方法空间的消耗取决于队列存储的元素数量，其在最坏情况下会达到 O(n)。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>0106. 从中序与后序遍历序列构造二叉树</title>
    <url>/2020/09/25/0106.%20%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal">https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal</a></p>
<p><strong>递归</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> build(inorder, postorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>, <span class="number">0</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">build</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder, <span class="keyword">int</span> il, <span class="keyword">int</span> ir, <span class="keyword">int</span> pl, <span class="keyword">int</span> pr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(il &gt; ir)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(il == ir)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(inorder[il]);</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(postorder[pr]);</span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = il; i &lt;= ir; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == root.val)&#123;</span><br><span class="line">                index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = build(inorder, postorder, il, index - <span class="number">1</span>, pl, pl + index - il - <span class="number">1</span>);</span><br><span class="line">        root.right = build(inorder, postorder, index + <span class="number">1</span>, ir, pl + index - il, pr - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>0116. 填充每个节点的下一个右侧节点指针</title>
    <url>/2020/09/28/0116.%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node">https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        Node leftmost = root;</span><br><span class="line">        <span class="keyword">while</span> (leftmost.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node head = leftmost;</span><br><span class="line">            <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">                head.left.next = head.right;</span><br><span class="line">                <span class="keyword">if</span> (head.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    head.right.next = head.next.left;</span><br><span class="line">                &#125;</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            leftmost = leftmost.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</li>
<li>空间复杂度：O(1)。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>0117. 填充每个节点的下一个右侧节点指针2</title>
    <url>/2020/09/28/0117.%20%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%882/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii">https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Node last, nextStart;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        Node start = root;</span><br><span class="line">        <span class="keyword">while</span>(start != <span class="keyword">null</span>)&#123;</span><br><span class="line">            last = <span class="keyword">null</span>;</span><br><span class="line">            nextStart = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span>(Node p = start; p != <span class="keyword">null</span>; p = p.next)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    handle(p.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(p.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    handle(p.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            start = nextStart;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Node p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(last != <span class="keyword">null</span>)&#123;</span><br><span class="line">            last.next = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nextStart == <span class="keyword">null</span>)&#123;</span><br><span class="line">            nextStart = p;</span><br><span class="line">        &#125;</span><br><span class="line">        last = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</li>
<li>空间复杂度：O(1)。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>0154.二叉树的后序遍历</title>
    <url>/2020/09/29/0145.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal">https://leetcode-cn.com/problems/binary-tree-postorder-traversal</a></p>
<p><strong>递归：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        postorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode node, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        postorder(node.left, res);</span><br><span class="line">        postorder(node.right, res);</span><br><span class="line">        res.add(node.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</li>
<li>空间复杂度：O(n)。空间复杂度取决于递归的栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。</li>
</ul>
<p><strong>利用栈迭代：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (root.right == <span class="keyword">null</span> || root.right == prev) &#123;</span><br><span class="line">                res.add(root.val);</span><br><span class="line">                prev = root;</span><br><span class="line">                root = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</li>
<li>空间复杂度：O(n)。空间复杂度取决于栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n)。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>0189.旋转数组</title>
    <url>/2020/09/16/0189.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/rotate-array">https://leetcode-cn.com/problems/rotate-array</a></p>
<p><strong>三次反转</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k = k % nums.length;</span><br><span class="line">        reverse(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, k, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[start];</span><br><span class="line">            nums[start] = nums[end];</span><br><span class="line">            nums[end] = temp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(n)，</p>
</li>
<li><p>空间复杂度：O(1)。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>0198.打家劫舍</title>
    <url>/2020/09/22/0198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/house-robber">https://leetcode-cn.com/problems/house-robber</a></p>
<p><strong>动态规划 + 滚动数组：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> first = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> second = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = second;</span><br><span class="line">            second = Math.max(first + nums[i], tmp);</span><br><span class="line">            first = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中 n 是数组长度。只需要对数组遍历一次。</li>
<li>空间复杂度：O(1)。使用滚动数组，可以只存储前两间房屋的最高总金额，而不需要存储整个数组的结果，因此空间复杂度是 O(1)。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>0200.岛屿数量</title>
    <url>/2020/09/18/0200.%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/number-of-islands">https://leetcode-cn.com/problems/number-of-islands</a></p>
<p><strong>dfs</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r &gt;= nr || c &gt;= nc || grid[r][c] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        grid[r][c] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">        dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">        dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">        dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> nr = grid.length;</span><br><span class="line">        <span class="keyword">int</span> nc = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> num_islands = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; nr; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; nc; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    ++num_islands;</span><br><span class="line">                    dfs(grid, r, c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num_islands;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(MN)，其中 M 和 N 分别为行数和列数。</p>
</li>
<li><p>空间复杂度：O(MN)，在最坏情况下，整个网格均为陆地，深度优先搜索的深度达到 MN。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>0206.反转链表</title>
    <url>/2020/09/24/0206.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/reverse-linked-list">https://leetcode-cn.com/problems/reverse-linked-list</a></p>
<p><strong>非递归</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode tmp = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度： O(n) 。总共有 n 个节点，我们每个遍历一次。</li>
<li>空间复杂度： O(1) 。</li>
</ul>
<p><strong>递归</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode tmp = head.next;</span><br><span class="line">        head.next = pre;</span><br><span class="line">        pre = head;</span><br><span class="line">        reverseList(tmp);</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度： O(n) 。总共有 n 个节点，我们每个遍历一次。</li>
<li>空间复杂度： O(n) 。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>0213.打家劫舍2</title>
    <url>/2020/09/22/0213.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D2/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/house-robber-ii">https://leetcode-cn.com/problems/house-robber-ii</a></p>
<p><strong>动态规划 + 滚动数组：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(myRob(nums, <span class="number">0</span>, len - <span class="number">2</span>), myRob(nums, <span class="number">1</span>, len - <span class="number">1</span>)); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myRob</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> second = nums[start];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = second;</span><br><span class="line">            second = Math.max(first + nums[i], tmp);</span><br><span class="line">            first = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中 n 是数组长度。只需要对数组遍历一次。</li>
<li>空间复杂度：O(1)。使用滚动数组，可以只存储前两间房屋的最高总金额，而不需要存储整个数组的结果，因此空间复杂度是 O(1)。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>0328.奇偶链表</title>
    <url>/2020/09/18/0328.%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/odd-even-linked-list">https://leetcode-cn.com/problems/odd-even-linked-list</a></p>
<p><strong>奇偶链表</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode dummyNode1 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode dummyNode2 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">        ListNode p = head, p1 = dummyNode1, p2 = dummyNode2;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                p1.next = p;</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p2.next = p;</span><br><span class="line">                p2 = p2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">            index ++;</span><br><span class="line">        &#125;</span><br><span class="line">        p2.next = <span class="keyword">null</span>; </span><br><span class="line">        p1.next = dummyNode2.next;</span><br><span class="line">        <span class="keyword">return</span> dummyNode1.next;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度： O(n) 。总共有 n 个节点，我们每个遍历一次。</p>
<p>空间复杂度： O(1) 。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>0300.最长子序列</title>
    <url>/2020/09/23/0300.%E6%9C%80%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence">https://leetcode-cn.com/problems/longest-increasing-subsequence</a></p>
<p><strong>动态规划：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &lt; nums[i])&#123;</span><br><span class="line">                    tmp = Math.max(tmp, dp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i] = tmp + <span class="number">1</span>;</span><br><span class="line">                maxLength = Math.max(maxLength, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n^2)，其中 n 为数组 nums 的长度。动态规划的状态数为 nn，计算状态 dp[i] 时，需要 O(n) 的时间遍历 dp[0…i−1] 的所有状态，所以总时间复杂度为 O(n^2)。</li>
<li>空间复杂度：O(n)，需要额外使用长度为 n 的 dp 数组。</li>
</ul>
<p><strong>贪心 + 二分查找：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> j = res;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (i + j) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(result[mid] &lt; num)&#123;</span><br><span class="line">                    i = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    j = mid; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result[i] = num;</span><br><span class="line">            <span class="keyword">if</span>(res == j)&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度 O(NlogN) ： 遍历 nums 列表需 O(N)，在每个 nums[i] 二分法需 O(logN)。</li>
<li>空间复杂度 O(N) ： result 列表占用线性大小额外空间。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>0337.打家劫舍3</title>
    <url>/2020/09/22/0337.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D3/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/house-robber-iii">https://leetcode-cn.com/problems/house-robber-iii</a></p>
<p><strong>动态规划</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = dfs(root);</span><br><span class="line">        <span class="keyword">return</span> Math.max(res[<span class="number">0</span>], res[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] dfs(TreeNode node)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] l = dfs(node.left);</span><br><span class="line">        <span class="keyword">int</span>[] r = dfs(node.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> selected = node.val + l[<span class="number">1</span>] + r[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> notSelected = Math.max(l[<span class="number">0</span>], l[<span class="number">1</span>]) + Math.max(r[<span class="number">0</span>], r[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;selected, notSelected&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)。</li>
<li>空间复杂度：O(n)。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Tree</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>0404.左叶子之和</title>
    <url>/2020/09/19/0404.%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/sum-of-left-leaves">https://leetcode-cn.com/problems/sum-of-left-leaves</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span> &amp;&amp; root.left.left == <span class="keyword">null</span> &amp;&amp; root.left.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            sum += root.left.val;</span><br><span class="line">        &#125;</span><br><span class="line">        sumOfLeftLeaves(root.left); </span><br><span class="line">        sumOfLeftLeaves(root.right);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度： O(n) 。总共有 n 个节点，我们每个遍历一次。</li>
<li>空间复杂度： O(1) 。空间复杂度与深度优先搜索使用的栈的最大深度相关。在最坏的情况下，树呈现链式结构，深度为 O(n)，对应的空间复杂度也为 O(n)。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>0538. 把二叉搜索树转换为累加树</title>
    <url>/2020/09/21/0538.%20%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree">https://leetcode-cn.com/problems/convert-bst-to-greater-tree</a></p>
<p><strong>反中序遍历：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        convertBST(root.right);</span><br><span class="line">        sum += root.val;</span><br><span class="line">        root.val = sum;</span><br><span class="line">        convertBST(root.left);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(n)，其中 nn 是二叉搜索树的节点数。每一个节点恰好被遍历一次。</p>
</li>
<li><p>空间复杂度：O(n)，为递归过程中栈的开销，平均情况下为 O(logn)，最坏情况下树呈现链状，为 O(n)。</p>
</li>
</ul>
<p><strong>Morris遍历：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        </span><br><span class="line">        whille(rode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                sum += node.val;</span><br><span class="line">                node.val = sum;</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                TreeNode suc = getSuccessor(node);</span><br><span class="line">                <span class="keyword">if</span>(suc.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    suc.left = node;</span><br><span class="line">                    node = node.right;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    suc.left = <span class="keyword">null</span>;</span><br><span class="line">                    sum += node.val;</span><br><span class="line">                    node.val = sum;</span><br><span class="line">                    node = node.left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">getSuccessor</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        TreeNode suc = node.right;</span><br><span class="line">        <span class="keyword">while</span>(suc.left != <span class="keyword">null</span> &amp;&amp; suc.left != node)&#123;</span><br><span class="line">            suc = suc.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> suc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)，其中 n 是二叉搜索树的节点数。没有左子树的节点只被访问一次，有左子树的节点被访问两次。</p>
<p>空间复杂度：O(1)。只操作已经存在的指针（树的空闲指针），因此只需要常数的额外空间。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>0617.合并二叉树</title>
    <url>/2020/09/23/0617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/merge-two-binary-trees">https://leetcode-cn.com/problems/merge-two-binary-trees</a></p>
<p><strong>递归</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        TreeNode t = <span class="keyword">new</span> TreeNode(); </span><br><span class="line">        <span class="keyword">if</span>(t1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> t = t2;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> t =t1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            t.val = t1.val + t2.val;</span><br><span class="line">        &#125;</span><br><span class="line">        t.left = mergeTrees(t1.left, t2.left);</span><br><span class="line">        t.right = mergeTrees(t1.right, t2.right);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(min(m,n))，其中 m 和 n 分别是两个二叉树的节点个数。对两个二叉树同时进行深度优先搜索，只有当两个二叉树中的对应节点都不为空时才会对该节点进行显性合并操作，因此被访问到的节点数不会超过较小的二叉树的节点数。</li>
<li>空间复杂度：O(min(m,n))，其中 m 和 n 分别是两个二叉树的节点个数。空间复杂度取决于递归调用的层数，递归调用的层数不会超过较小的二叉树的最大高度，最坏情况下，二叉树的高度等于节点数。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>0701.二叉搜索树中的插入操作</title>
    <url>/2020/09/30/0701.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree">https://leetcode-cn.com/problems/insert-into-a-binary-search-tree</a></p>
<p><strong>递归：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; val) &#123;</span><br><span class="line">            root.right = insertIntoBST(root.right, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root.left = insertIntoBST(root.left, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>迭代：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode pos = root;</span><br><span class="line">        <span class="keyword">while</span>(pos != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(val &lt; pos.val)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pos.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    pos = pos.left;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    pos.left = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(pos.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    pos = pos.right;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    pos.right = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(N)，其中 N 为树中节点的数目。最坏情况下，我们需要将值插入到树的最深的叶子结点上，而叶子节点最深为 O(N)。</li>
<li>空间复杂度：O(1)。我们只使用了常数大小的空间。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>0068.监控二叉树</title>
    <url>/2020/09/22/0968.%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-tree-cameras">https://leetcode-cn.com/problems/binary-tree-cameras</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCameraCover</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lrd(root) == <span class="number">0</span>)&#123;</span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 0代表结点待覆盖</span></span><br><span class="line"><span class="comment">    	1代表结点已覆盖</span></span><br><span class="line"><span class="comment">    	2代表结点已安装监控</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lrd</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = lrd(node.left);</span><br><span class="line">        <span class="keyword">int</span> r = lrd(node.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l == <span class="number">0</span> || r == <span class="number">0</span>)&#123;</span><br><span class="line">            sum++;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l == <span class="number">1</span> &amp;&amp; r == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l + r &gt;= <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>1295. 统计位数为偶数的数字</title>
    <url>/2020/10/03/1295.%E7%BB%9F%E8%AE%A1%E4%BD%8D%E6%95%B0%E4%B8%BA%E5%81%B6%E6%95%B0%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-numbers-with-even-number-of-digits">https://leetcode-cn.com/problems/find-numbers-with-even-number-of-digits</a></p>
<p><strong>最佳：对数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>((<span class="keyword">int</span>)(Math.log10(num) + <span class="number">1</span>) % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>把数字转成字符串</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (String.valueOf(nums[i]).length() % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>循环除以10</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(nums[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                nums[i] /= <span class="number">10</span>;</span><br><span class="line">                tmp++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>直接比较</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> findNumbers(<span class="built_in">int</span>[] nums) &#123;</span><br><span class="line">    <span class="built_in">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>((nums[i]&gt;=<span class="number">10</span>&amp;&amp;nums[i]&lt;<span class="number">100</span>)||(nums[i]&gt;=<span class="number">1000</span>&amp;&amp;nums[i]&lt;<span class="number">10000</span>))</span><br><span class="line">            count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>String</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/08/24/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2020/09/14/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="1-遍历二叉树"><a href="#1-遍历二叉树" class="headerlink" title="1 遍历二叉树"></a>1 遍历二叉树</h2><h3 id="1-1-先序遍历"><a href="#1-1-先序遍历" class="headerlink" title="1.1 先序遍历"></a>1.1 先序遍历</h3><h4 id="1-1-1-递归实现"><a href="#1-1-1-递归实现" class="headerlink" title="1.1.1 递归实现"></a>1.1.1 递归实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderRecur</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     System.put.print(treeNode.Data); </span><br><span class="line">     preOrderRecur(treeNode.left);</span><br><span class="line">     preOrderRecur(treeNode.right);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-2-非递归方式实现"><a href="#1-1-2-非递归方式实现" class="headerlink" title="1.1.2 非递归方式实现"></a>1.1.2 非递归方式实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty)&#123;</span><br><span class="line">        TreeNode res = stack.Pop();</span><br><span class="line">        <span class="keyword">if</span> (res.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(res.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(res.right);</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(res.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="1-2-中序遍历"><a href="#1-2-中序遍历" class="headerlink" title="1.2 中序遍历"></a>1.2 中序遍历</h3><h4 id="1-2-1-递归实现"><a href="#1-2-1-递归实现" class="headerlink" title="1.2.1 递归实现"></a>1.2.1 递归实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">MidTraversal</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;  </span><br><span class="line">		MidTraversa(node.left);</span><br><span class="line">     	System.out.print(node.val+<span class="string">&quot; &quot;</span>);</span><br><span class="line">     	MidTraversa(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-2-非递归实现"><a href="#1-2-2-非递归实现" class="headerlink" title="1.2.2 非递归实现"></a>1.2.2 非递归实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode curr = root;</span><br><span class="line">    <span class="keyword">while</span>(curr != <span class="keyword">null</span> || !(stack.isEmpty()))&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr!= <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(curr);</span><br><span class="line">            curr = curr.left;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            curr = stack.pop();</span><br><span class="line">            list.add(curr.val);</span><br><span class="line">            curr = curr.right;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-后序遍历"><a href="#1-3-后序遍历" class="headerlink" title="1.3 后序遍历"></a>1.3 后序遍历</h3><h4 id="1-3-1-递归实现"><a href="#1-3-1-递归实现" class="headerlink" title="1.3.1 递归实现"></a>1.3.1 递归实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postTraversal</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123; </span><br><span class="line">        postTraversal(node.left);</span><br><span class="line">        postTraversal(node.right);</span><br><span class="line">        System.out.print(node.val+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-2-非递归实现"><a href="#1-3-2-非递归实现" class="headerlink" title="1.3.2 非递归实现"></a>1.3.2 非递归实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode curr = root;</span><br><span class="line">    TreeNode last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(curr);</span><br><span class="line">            curr = curr.left;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = stack.peek();</span><br><span class="line">        <span class="keyword">if</span> (curr.right == <span class="keyword">null</span> || curr.right == last) &#123;</span><br><span class="line">            res.add(curr.val);</span><br><span class="line">            stack.pop();</span><br><span class="line">            last = curr;</span><br><span class="line">            curr = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curr = curr.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-层次遍历"><a href="#1-4-层次遍历" class="headerlink" title="1.4 层次遍历"></a>1.4 层次遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;()；</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        List&lt;Integer&gt; level = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= queue.size(); ++i) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            level.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(node.left)；</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(level);</span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-常见算法"><a href="#2-常见算法" class="headerlink" title="2 常见算法"></a>2 常见算法</h2><h3 id="2-1-二叉树的最大深度"><a href="#2-1-二叉树的最大深度" class="headerlink" title="2.1 二叉树的最大深度"></a>2.1 二叉树的最大深度</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = maxDepth(root.left);</span><br><span class="line">    <span class="keyword">int</span> right = maxDepth(root.right);</span><br><span class="line">    <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-二叉树的镜像"><a href="#2-2-二叉树的镜像" class="headerlink" title="2.2 二叉树的镜像"></a>2.2 二叉树的镜像</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode l = mirrorTree(root.right);</span><br><span class="line">    TreeNode r = mirrorTree(root.left);</span><br><span class="line">    root.left = l;</span><br><span class="line">    root.right = r;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-判断二叉树是否对称"><a href="#2-3-判断二叉树是否对称" class="headerlink" title="2.3 判断二叉树是否对称"></a>2.3 判断二叉树是否对称</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> real(pRoot.left,pRoot.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">real</span><span class="params">(TreeNode root1,TreeNode root2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root1 == <span class="keyword">null</span> &amp;&amp; root2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root1 ==<span class="keyword">null</span> || root2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root1.val != root2.val)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> real(root1.left,root2.right)&amp;&amp;real(root1.right,root2.left);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="2-4-路径总和"><a href="#2-4-路径总和" class="headerlink" title="2.4 路径总和"></a>2.4 路径总和</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listAll = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> listAll;</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        target -= root.val;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span> &amp;&amp; root.left==<span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            listAll.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(list));</span><br><span class="line">        &#125;</span><br><span class="line">        FindPath(root.left,target);</span><br><span class="line">        FindPath(root.right,target);</span><br><span class="line">        list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> listAll;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-重建二叉树"><a href="#2-5-重建二叉树" class="headerlink" title="2.5 重建二叉树"></a>2.5 重建二叉树</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> reConstructBinaryTree(pre,<span class="number">0</span>,pre.length-<span class="number">1</span>,in,<span class="number">0</span>,in.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> startpre,<span class="keyword">int</span> endpre,<span class="keyword">int</span> [] in,<span class="keyword">int</span> startin,<span class="keyword">int</span> endin)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(startpre &gt; endpre || startin &gt; endin)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(pre[startpre]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =startin;i&lt;=endin;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i] == pre[startpre])&#123;</span><br><span class="line">            root.left = reConstructBinaryTree(pre,startpre+<span class="number">1</span>,startpre+i-startin,in,startin,i-<span class="number">1</span>);</span><br><span class="line">            root.right = reConstructBinaryTree(pre,startpre+i-startin+<span class="number">1</span>,endpre,in,i+<span class="number">1</span>,endin);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-6-最近公共祖先"><a href="#2-6-最近公共祖先" class="headerlink" title="2.6 最近公共祖先"></a>2.6 最近公共祖先</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span> || root == p || root == q)&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    <span class="keyword">if</span>(left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left != <span class="keyword">null</span> ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-7-反序列化"><a href="#2-7-反序列化" class="headerlink" title="2.7 反序列化"></a>2.7 反序列化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="keyword">null</span> || data.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] dataArr = data.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    <span class="comment">// 层次遍历逆向还原二叉树</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    TreeNode root = toNode(dataArr[index]);</span><br><span class="line">    LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (index &lt; dataArr.length - <span class="number">2</span> &amp;&amp; !queue.isEmpty()) &#123;</span><br><span class="line">        TreeNode cur = queue.remove();</span><br><span class="line">        <span class="comment">// 添加左子节点</span></span><br><span class="line">        TreeNode leftNode = toNode(dataArr[++index]);</span><br><span class="line">        cur.left = leftNode;</span><br><span class="line">        <span class="comment">// 队列中的节点用于为其赋值孩子节点，若该节点本身为 null，</span></span><br><span class="line">        <span class="comment">// 没有孩子节点，便不再添加到队列中，下同理</span></span><br><span class="line">        <span class="keyword">if</span> (leftNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(leftNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加右子节点</span></span><br><span class="line">        TreeNode rightNode = toNode(dataArr[++index]);</span><br><span class="line">        cur.right = rightNode;</span><br><span class="line">        <span class="keyword">if</span> (rightNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(rightNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">toNode</span><span class="params">(String val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="string">&quot;null&quot;</span>.equals(val)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(Integer.parseInt(val));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer27.二叉树的镜像</title>
    <url>/2020/09/16/%E5%89%91%E6%8C%87Offer27.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof">https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode l = mirrorTree(root.right);</span><br><span class="line">        TreeNode r = mirrorTree(root.left);</span><br><span class="line">        root.left = l;</span><br><span class="line">        root.right = r;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(n)，</p>
</li>
<li><p>空间复杂度：O(n)。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer46. 把数字翻译成字符串</title>
    <url>/2020/09/28/%E5%89%91%E6%8C%87Offer46.%20%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof">https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof</a></p>
<p><strong>dp</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        String s = String.valueOf(num);</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= s.length(); i++)&#123;</span><br><span class="line">            String tmp = s.substring(i - <span class="number">2</span>, i);</span><br><span class="line">            <span class="keyword">int</span> c = tmp.compareTo(<span class="string">&quot;10&quot;</span>) &gt;= <span class="number">0</span> &amp;&amp; tmp.compareTo(<span class="string">&quot;25&quot;</span>) &lt;= <span class="number">0</span> ? a + b : b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度 O(N) ： N 为字符串 s 的长度（即数字 num 的位数 log(num) ），其决定了循环次数。</li>
<li>空间复杂度 O(N) ： 字符串 s 使用 O(N) 大小的额外空间。</li>
</ul>
<p><strong>求余</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num &lt; <span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num % <span class="number">100</span> &gt;= <span class="number">10</span> &amp;&amp; num % <span class="number">100</span> &lt;= <span class="number">25</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> translateNum(num / <span class="number">10</span>) + translateNum(num / <span class="number">100</span>); </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> translateNum(num / <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, x, y = num % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span>(num != <span class="number">0</span>) &#123;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">            x = num % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">10</span> * x + y;</span><br><span class="line">            <span class="keyword">int</span> c = (tmp &gt;= <span class="number">10</span> &amp;&amp; tmp &lt;= <span class="number">25</span>) ? a + b : a;</span><br><span class="line">            b = a;</span><br><span class="line">            a = c;</span><br><span class="line">            y = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>时间复杂度 O(N) ： N 为字符串 s 的长度（即数字 num 的位数 log(num) ），其决定了循环次数。</p>
</li>
<li><p>空间复杂度 O(1) ： 几个变量使用常数大小的额外空间。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>反转链表</title>
    <url>/2020/09/03/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，反转链表后，输出新链表的表头。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment">	ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">    this.val = val;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode p = <span class="keyword">null</span>;</span><br><span class="line">        ListNode q = head;</span><br><span class="line">        ListNode temp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(q!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            temp = q.next;</span><br><span class="line">            q.next = p;</span><br><span class="line">            p = q;</span><br><span class="line">            q = temp;          </span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LinkedList</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>小红书笔试题2.笔记草稿</title>
    <url>/2020/09/22/%E5%B0%8F%E7%BA%A2%E4%B9%A6%E7%AC%94%E8%AF%95%E9%A2%982.%E7%AC%94%E8%AE%B0%E8%8D%89%E7%A8%BF/</url>
    <content><![CDATA[<p>1.输入字符包括，”(“  ,  “)”  和  “&lt;”和其他字符。 </p>
<p>2.其他字符表示笔记内容。 </p>
<p>3.()之间表示注释内容，任何字符都无效。  括号保证成对出现。 </p>
<p> 4.”&lt;”表示退格,  删去前面一个笔记内容字符。括号不受”&lt;”影响  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xiaohongshuCode2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        stringBuffer = <span class="keyword">new</span> StringBuffer(sc.nextLine());</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stringBuffer.length();)&#123;</span><br><span class="line">            <span class="keyword">if</span>(stringBuffer.charAt(i) == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                list.add(i);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(stringBuffer.charAt(i) == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> end = list.size() - <span class="number">1</span>;</span><br><span class="line">                stringBuffer.delete(list.get(end), i + <span class="number">1</span>);</span><br><span class="line">                i = list.get(end);</span><br><span class="line">                list.remove(end);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(stringBuffer.charAt(i) == <span class="string">&#x27;&lt;&#x27;</span>)&#123;</span><br><span class="line">                stringBuffer.delete(i - <span class="number">1</span>, i + <span class="number">1</span>);</span><br><span class="line">                i--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(stringBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>StringBuffer：</strong></p>
<ul>
<li>delete（int begin,int end）有两个参数，使用时删除索引从begin开始（包含begin）到end（不包含end）的所有字符；</li>
<li>deleteCharAt（int index）只有一个参数，使用时删除索引为index的字符；</li>
</ul>
<p><a href="https://www.nowcoder.com/questionTerminal/0823ca800ee04706a7e2dafc837dc236">https://www.nowcoder.com/questionTerminal/0823ca800ee04706a7e2dafc837dc236</a></p>
]]></content>
      <categories>
        <category>笔试</category>
      </categories>
      <tags>
        <tag>笔试</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>小红书笔试题3.笔记精选</title>
    <url>/2020/09/22/%E5%B0%8F%E7%BA%A2%E4%B9%A6%E7%AC%94%E8%AF%95%E9%A2%983.%E7%AC%94%E8%AE%B0%E7%B2%BE%E9%80%89/</url>
    <content><![CDATA[<p>1.不能出现连续编号的笔记。 </p>
<p>2.总点赞总数最多 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xiaohongshuCode3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            nums[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(nums[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pre = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> cur = nums[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = cur;</span><br><span class="line">            <span class="keyword">if</span> (pre + nums[i] &gt; tmp)&#123;</span><br><span class="line">                cur = pre + nums[i];</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(cur + <span class="string">&quot; &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔试</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>度小满笔试1.涂色</title>
    <url>/2020/09/21/%E5%BA%A6%E5%B0%8F%E6%BB%A1%E7%AC%94%E8%AF%951.%E6%B6%82%E8%89%B2/</url>
    <content><![CDATA[<ul>
<li><p>给定两个字符串，判断相同字符的个数</p>
<ul>
<li><p>输入：</p>
<p>ABC</p>
<p>ACC</p>
</li>
<li><p>输出：</p>
<p>2</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DuXiaoManCode1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str1 = sc.next();</span><br><span class="line">        String str2 = sc.next();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str1.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hashMap.containsKey(str1.charAt(i)))&#123;</span><br><span class="line">                hashMap.put(str1.charAt(i), hashMap.get(str1.charAt(i)) + <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                hashMap.put(str1.charAt(i), <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str2.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hashMap.containsKey(str2.charAt(i)))&#123;</span><br><span class="line">                <span class="keyword">if</span>(hashMap.get(str2.charAt(i)) == <span class="number">1</span>)&#123;</span><br><span class="line">                    hashMap.remove(str2.charAt(i));</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    hashMap.put(str2.charAt(i), hashMap.get(str2.charAt(i)) - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔试</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>度小满笔试2.昆虫走迷宫</title>
    <url>/2020/09/21/%E5%BA%A6%E5%B0%8F%E6%BB%A1%E7%AC%94%E8%AF%952.%E6%98%86%E8%99%AB%E8%B5%B0%E8%BF%B7%E5%AE%AB/</url>
    <content><![CDATA[<ul>
<li><p>@代表昆虫位置，.代表可以通行，#代表不可越过的墙壁，*代表可以越过的墙壁，求昆虫走出迷宫最小破壁次数</p>
<ul>
<li><p>输入：</p>
<p>3</p>
<p>3 3</p>
<p>###</p>
<p>*@#</p>
<p>.##</p>
<p>3 3</p>
<p>@##</p>
<p>…</p>
<p>#**</p>
<p>3 3</p>
<p>#.#</p>
<p>*@#</p>
<p>###</p>
</li>
<li><p>输出：</p>
<p>1</p>
<p>0</p>
<p>1</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> nums = sc.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> m = sc.nextInt();</span><br><span class="line">            <span class="keyword">int</span> n = sc.nextInt();</span><br><span class="line">            <span class="keyword">char</span>[][] input = <span class="keyword">char</span>[m][n];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">                String s = sc.next();</span><br><span class="line">                <span class="keyword">char</span>[] sctmp = s.toCharArray();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; sctmp.length; k++)&#123;</span><br><span class="line">                    input[j][k] = sctmp[k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b.length; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; a[<span class="number">0</span>].length; k++)&#123;</span><br><span class="line">                    res[i][j] = Integer.MAX_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span>[][] visited = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; input.length; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k =<span class="number">0</span>; k &lt; input[<span class="number">0</span>].length; k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[j][k] == <span class="string">&#x27;@&#x27;</span>)&#123;</span><br><span class="line">                        <span class="keyword">new</span> Main().dfs(input, res, visited, m, n, j, k, <span class="number">0</span>);</span><br><span class="line">                        System.out.println(b[j][k] == Integer.MAX_VALUE ? -<span class="number">1</span> : b[j][k]);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] input, <span class="keyword">int</span>[][] res, <span class="keyword">int</span>[][] visited, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> countNew = count;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt; m || j &gt; m)&#123;</span><br><span class="line">            retrun <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res[i][j] != Integer.MAX_VALUE &amp;&amp; res[i][j] &lt;= countNew)&#123;</span><br><span class="line">            <span class="keyword">return</span> res[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(visited[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(input[i][j] == <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(input[i][j] == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> countNew++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        visited[i][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> a = dfs(input, res, visited, m, n, i + <span class="number">1</span>, j, countNew);</span><br><span class="line">        <span class="keyword">int</span> b = dfs(input, res, visited, m, n, i - <span class="number">1</span>, j, countNew);</span><br><span class="line">        <span class="keyword">int</span> c = dfs(input, res, visited, m, n, i, j + <span class="number">1</span>, countNew);</span><br><span class="line">        <span class="keyword">int</span> d = dfs(input, res, visited, m, n, i, j - <span class="number">1</span>, countNew);</span><br><span class="line">        visited[i][j] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> min = Math,min(res[i][j], Math.min(Math.min(a, b), Math.min(c, d)));</span><br><span class="line">        <span class="keyword">if</span>(input[i][j] == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">            min++;</span><br><span class="line">        &#125;</span><br><span class="line">        res[i][j] = Math.min(min, res[i][j]);</span><br><span class="line">        <span class="keyword">return</span> res[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔试</category>
      </categories>
      <tags>
        <tag>笔试</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>排序</title>
    <url>/2020/09/17/%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><table>
<thead>
<tr>
<th align="center">排序算法</th>
<th align="center">平均时间复杂度</th>
<th align="center">最好情况</th>
<th align="center">最坏情况</th>
<th align="center">空间复杂度</th>
<th align="center">排序方式</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">冒泡排序</td>
<td align="center">O(n^2)</td>
<td align="center">O(n)</td>
<td align="center">O(n^2)</td>
<td align="center">O(1)</td>
<td align="center">In-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">选择排序</td>
<td align="center">O(n^2)</td>
<td align="center">O(n^2)</td>
<td align="center">O(n^2)</td>
<td align="center">O(1)</td>
<td align="center">In-place</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">插入排序</td>
<td align="center">O(n^2)</td>
<td align="center">O(n)</td>
<td align="center">O(n^2)</td>
<td align="center">O(1)</td>
<td align="center">In-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">希尔排序</td>
<td align="center">O(nlogn)</td>
<td align="center">O(nlog^2 n)</td>
<td align="center">O(n^1.5)</td>
<td align="center">O(1)</td>
<td align="center">In-place</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">归并排序</td>
<td align="center">O(nlogn)</td>
<td align="center">O(nlogn)</td>
<td align="center">O(nlogn)</td>
<td align="center">O(n)</td>
<td align="center">Out-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">快速排序</td>
<td align="center">O(nlogn)</td>
<td align="center">O(nlogn)</td>
<td align="center">O(n^2)</td>
<td align="center">O(nlogn)</td>
<td align="center">In-place</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">堆排序</td>
<td align="center">O(nlogn)</td>
<td align="center">O(nlogn)</td>
<td align="center">O(nlogn)</td>
<td align="center">O(1)</td>
<td align="center">In-place</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">计数排序</td>
<td align="center">O(n+k)</td>
<td align="center">O(n+k)</td>
<td align="center">O(n+k)</td>
<td align="center">O(k)</td>
<td align="center">Out-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">桶排序</td>
<td align="center">O(n+k)</td>
<td align="center">O(n+k)</td>
<td align="center">O(n^2)</td>
<td align="center">O(n+k)</td>
<td align="center">Out-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">基数排序</td>
<td align="center">O(n*k)</td>
<td align="center">O(n*k)</td>
<td align="center">O(n*k)</td>
<td align="center">O(n+k)</td>
<td align="center">Out-place</td>
<td align="center">稳定</td>
</tr>
</tbody></table>
<a id="more"></a>

<ul>
<li>平均情况下，快些归队的时间复杂度好O(nlogn)</li>
<li>最坏情况下，除快速排序外，都与平均情况相同</li>
<li>快些选队不稳定</li>
<li>插入排序和冒泡排序适合基本有序的序列</li>
<li>经过一趟排序就可以保证一个关键字到达最终位置的是：冒泡、快速、堆</li>
<li>选择排序和折半插入与原始序列无关</li>
</ul>
<h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1 冒泡排序"></a>1 冒泡排序</h2><ul>
<li>比较相邻的元素，如果前一个大于后一个，就交换位置；</li>
<li>每循环一次，最大的元素会位于数列的最后一个位置</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bubbleSort(<span class="keyword">int</span>[] array)&#123;</span><br><span class="line">    <span class="keyword">if</span>(array.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - <span class="number">1</span> - i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[j] &gt; array[j + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = array[j];</span><br><span class="line">                array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">                array[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2 选择排序"></a>2 选择排序</h2><ul>
<li>遍历数列，选择最小值放到第一个位置</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] selectSort(<span class="keyword">int</span>[] array)&#123;</span><br><span class="line">    <span class="keyword">if</span>(array.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; array.length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[j] &lt; array[minIndex])&#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = array[minIndex];</span><br><span class="line">        array[minIndex] = array[j];</span><br><span class="line">        array[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3 插入排序"></a>3 插入排序</h2><ul>
<li>从第二个元素开始，将其插入到合适的位置</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] insertSort(<span class="keyword">int</span>[] array)&#123;</span><br><span class="line">    <span class="keyword">if</span>(array.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> current;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i ++)&#123;</span><br><span class="line">        current = array[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> preIndex = i;</span><br><span class="line">        <span class="keyword">while</span>(preIndex &gt; <span class="number">0</span> &amp;&amp; current &lt; array[preIndex])&#123;</span><br><span class="line">            array[preIndex + <span class="number">1</span>] = array[preIndex];</span><br><span class="line">            preIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        array[preIndex + <span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4 希尔排序"></a>4 希尔排序</h2><ul>
<li>将整个数列分组进行插入排序</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] shellSort(<span class="keyword">int</span>[] array)&#123;</span><br><span class="line">    <span class="keyword">if</span>(array.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">int</span> gap = array.length / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(gap &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = gap; i &lt; array.length; i++)&#123;</span><br><span class="line">            temp = array[i];</span><br><span class="line">            <span class="keyword">int</span> pre = i - gap;</span><br><span class="line">            <span class="keyword">while</span>(pre &gt; <span class="number">0</span> &amp;&amp; temp &lt; array[pre])&#123;</span><br><span class="line">                array[pre + <span class="number">1</span>] = array[pre];</span><br><span class="line">                pre -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            array[pre + gap] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        gap /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5 归并排序"></a>5 归并排序</h2><ul>
<li>将数列等分为两个数列递归进行归并排序</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mergeSort(<span class="keyword">int</span>[] array)&#123;</span><br><span class="line">    <span class="keyword">if</span>(array.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = array.length / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span>[] left = Arrays.copyOfRange(array, <span class="number">0</span>, mid);</span><br><span class="line">    <span class="keyword">int</span>[] right = Arrays.copyOfRange(array, mid, array.length);</span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] merge(<span class="keyword">int</span>[] l, <span class="keyword">int</span>[] r)&#123;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[l.length + r.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>; k &lt; res.length; k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; l.length)&#123;</span><br><span class="line">            res[k] = r[j++];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j &gt; r.length)&#123;</span><br><span class="line">            res[k] = l[i++];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(l[i] &gt; r[j])&#123;</span><br><span class="line">            res[k] = r[j++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res[k] = l[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6 快速排序"></a>6 快速排序</h2><ul>
<li>遍历数列，把基准排到合适位置后，递归</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] quickSort(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)&#123;</span><br><span class="line">    <span class="keyword">if</span>(array.length &lt; <span class="number">1</span> || start &lt; <span class="number">0</span> || end &gt; array.length || start &gt; end)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> parIndex = partition(array, start, end);</span><br><span class="line">    quickSort(array, start, parIndex - <span class="number">1</span>);</span><br><span class="line">    quickSort(array, parIndex + <span class="number">1</span>, end);</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] partition(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = start;</span><br><span class="line">    <span class="keyword">int</span> index = pivot + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt;= end; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i] &lt; array[pivot])&#123;</span><br><span class="line">            swap(array, i, index);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(array, pivot, index - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> index - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pulic <span class="keyword">void</span> <span class="title">swap</span><span class="params">()</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = array[i];</span><br><span class="line">    array[i] = array[j];</span><br><span class="line">    array[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7 堆排序"></a>7 堆排序</h2><ul>
<li>取大顶堆的堆顶元素作为数列的最后一个值，递归</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] HeapSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">    len = array.length;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">1</span>) <span class="keyword">return</span> array;</span><br><span class="line">    buildMaxHeap(array);</span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        swap(array, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">        len--;</span><br><span class="line">        adjustHeap(array, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (len/<span class="number">2</span> - <span class="number">1</span>); i &gt;= <span class="number">0</span>; i--) &#123; </span><br><span class="line">        adjustHeap(array, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxIndex = i;</span><br><span class="line">    <span class="comment">//如果有左子树，且左子树大于父节点，则将最大指针指向左子树</span></span><br><span class="line">    <span class="keyword">if</span> (i * <span class="number">2</span> &lt; len &amp;&amp; array[i * <span class="number">2</span>] &gt; array[maxIndex])</span><br><span class="line">        maxIndex = i * <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//如果有右子树，且右子树大于父节点，则将最大指针指向右子树</span></span><br><span class="line">    <span class="keyword">if</span> (i * <span class="number">2</span> + <span class="number">1</span> &lt; len &amp;&amp; array[i * <span class="number">2</span> + <span class="number">1</span>] &gt; array[maxIndex])</span><br><span class="line">        maxIndex = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。</span></span><br><span class="line">    <span class="keyword">if</span> (maxIndex != i) &#123;</span><br><span class="line">        swap(array, maxIndex, i);</span><br><span class="line">        adjustHeap(array, maxIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pulic <span class="keyword">void</span> <span class="title">swap</span><span class="params">()</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = array[i];</span><br><span class="line">    array[i] = array[j];</span><br><span class="line">    array[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-计数排序"><a href="#8-计数排序" class="headerlink" title="8 计数排序"></a>8 计数排序</h2><ul>
<li>统计每个值出现的次数，反向填充数组</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] CountingSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array.length == <span class="number">0</span>) <span class="keyword">return</span> array;</span><br><span class="line">    <span class="keyword">int</span> bias, min = array[<span class="number">0</span>], max = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i] &gt; max)</span><br><span class="line">            max = array[i];</span><br><span class="line">        <span class="keyword">if</span> (array[i] &lt; min)</span><br><span class="line">            min = array[i];</span><br><span class="line">    &#125;</span><br><span class="line">    bias = <span class="number">0</span> - min;</span><br><span class="line">    <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(bucket, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        bucket[array[i] + bias]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; array.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bucket[i] != <span class="number">0</span>) &#123;</span><br><span class="line">        	array[index] = i - bias;</span><br><span class="line">            bucket[i]--;</span><br><span class="line">            index++;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-桶排序"><a href="#9-桶排序" class="headerlink" title="9 桶排序"></a>9 桶排序</h2><ul>
<li>遍历数列，将其放到不同的桶中排序后拼接</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">BucketSort</span><span class="params">(ArrayList&lt;Integer&gt; array, <span class="keyword">int</span> bucketSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.size() &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    <span class="keyword">int</span> max = array.get(<span class="number">0</span>), min = array.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array.get(i) &gt; max)</span><br><span class="line">            max = array.get(i);</span><br><span class="line">        <span class="keyword">if</span> (array.get(i) &lt; min)</span><br><span class="line">            min = array.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> bucketCount = (max - min) / bucketSize + <span class="number">1</span>;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = <span class="keyword">new</span> ArrayList&lt;&gt;(bucketCount);</span><br><span class="line">    ArrayList&lt;Integer&gt; resultArr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketCount; i++) &#123;</span><br><span class="line">        bucketArr.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.size(); i++) &#123;</span><br><span class="line">        bucketArr.get((array.get(i) - min) / bucketSize).add(array.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketCount; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bucketSize == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucketArr.get(i).size(); j++)</span><br><span class="line">                resultArr.add(bucketArr.get(i).get(j));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucketCount == <span class="number">1</span>)</span><br><span class="line">                bucketSize--;</span><br><span class="line">            ArrayList&lt;Integer&gt; temp = BucketSort(bucketArr.get(i), bucketSize);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; temp.size(); j++)</span><br><span class="line">                resultArr.add(temp.get(j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-基数排序"><a href="#10-基数排序" class="headerlink" title="10 基数排序"></a>10 基数排序</h2><ul>
<li>先根据数据的位数分桶，再进行计数排序</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] RadixSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        max = Math.max(max, array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxDigit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (max != <span class="number">0</span>) &#123;</span><br><span class="line">        max /= <span class="number">10</span>;</span><br><span class="line">        maxDigit++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">10</span>, div = <span class="number">1</span>;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        bucketList.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxDigit; i++, mod *= <span class="number">10</span>, div *= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = (array[j] % mod) / div;</span><br><span class="line">            bucketList.get(num).add(array[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucketList.size(); j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; bucketList.get(j).size(); k++)</span><br><span class="line">                array[index++] = bucketList.get(j).get(k);</span><br><span class="line">            bucketList.get(j).clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>































]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>携程笔试题1.订单记录</title>
    <url>/2020/09/23/%E6%90%BA%E7%A8%8B%E7%AC%94%E8%AF%95%E9%A2%981.%E8%AE%A2%E5%8D%95%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>输入一个时间值A，需要在这批记录中找到符合入离店时间范围（A大于等于入店时间，并且A小于等于离店时间）内的所有记录。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xiechengCode1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span> a = sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = sc.nextInt();</span><br><span class="line">            <span class="keyword">int</span> low = sc.nextInt();</span><br><span class="line">            <span class="keyword">int</span> high = sc.nextInt();</span><br><span class="line">            <span class="keyword">if</span>(a &gt;= low &amp;&amp; a &lt;= high)&#123;</span><br><span class="line">                res[i] = index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(res);</span><br><span class="line">        <span class="keyword">if</span>(res[n - <span class="number">1</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(res[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(res[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔试</category>
      </categories>
      <tags>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>携程笔试题2.LRU Cache</title>
    <url>/2020/09/28/%E6%90%BA%E7%A8%8B%E7%AC%94%E8%AF%95%E9%A2%982.LRU%20Cache/</url>
    <content><![CDATA[<p>设计一个数据结构，实现LRU Cache的功能(Least Recently Used – 最近最少使用缓存)。它支持如下2个操作： get 和 put。</p>
<ul>
<li>int get(int key) <ul>
<li>如果key已存在，则返回key对应的值value（始终大于0）；</li>
<li>如果key不存在，则返回-1。</li>
</ul>
</li>
<li>void put(int key, int value) <ul>
<li>如果key不存在，将value插入；</li>
<li>如果key已存在，则使用value替换原先已经存在的值。如果容量达到了限制，LRU Cache需要在插入新元素之前，将最近最少使用的元素删除。</li>
</ul>
</li>
</ul>
<p>请特别注意“使用”的定义：新插入或获取key视为被使用一次；而将已经存在的值替换更新，不算被使用。</p>
<p>限制：请在O(1)的时间复杂度内完成上述2个操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xiechengCode2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LRUCache</span><span class="params">(Scanner sc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = Integer.parseInt(sc.nextLine());</span><br><span class="line">        LinkedHashMap&lt;Integer,Integer&gt; mmap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        String[] temp;</span><br><span class="line">        <span class="keyword">int</span> key,value;</span><br><span class="line">        <span class="keyword">while</span> (sc.hasNext())&#123;</span><br><span class="line">            temp = sc.nextLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            key = Integer.parseInt(temp[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;p&quot;</span>.equals(temp[<span class="number">0</span>]))&#123;</span><br><span class="line">                value = Integer.parseInt(temp[<span class="number">2</span>]);</span><br><span class="line">                <span class="keyword">if</span> (mmap.containsKey(key))&#123;<span class="comment">//覆盖已有，其它什么都不做</span></span><br><span class="line">                    mmap.put(key,value);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (curr==n)&#123;<span class="comment">//如果队满了，插入新值并删除队首元素。</span></span><br><span class="line">                    mmap.put(key,value);</span><br><span class="line">                    key = mmap.entrySet().iterator().next().getKey();<span class="comment">//队首元素key</span></span><br><span class="line">                    mmap.remove(key);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    mmap.put(key,value);</span><br><span class="line">                    curr++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (mmap.containsKey(key))&#123;<span class="comment">//查询已有值，然后删除再插入在队尾</span></span><br><span class="line">                    value = mmap.get(key);</span><br><span class="line">                    System.out.println(value);</span><br><span class="line">                    mmap.remove(key);</span><br><span class="line">                    mmap.put(key,value);</span><br><span class="line">                &#125;<span class="keyword">else</span> System.out.println(-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        LRUCache(sc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔试</category>
      </categories>
      <tags>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>携程笔试题3.bit count</title>
    <url>/2020/09/28/%E6%90%BA%E7%A8%8B%E7%AC%94%E8%AF%95%E9%A2%983.bit%20count/</url>
    <content><![CDATA[<p>输入一个long类型的数值, 求该数值的二进制表示中的1的个数 .</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> xiecheng;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xiechengCode3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">long</span> n = sc.nextLong();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            n &amp;= n - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        sc.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔试</category>
      </categories>
      <tags>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题 08.11. 硬币</title>
    <url>/2020/09/21/%E9%9D%A2%E8%AF%95%E9%A2%98%2008.11.%20%E7%A1%AC%E5%B8%81/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/coin-lcci">https://leetcode-cn.com/problems/coin-lcci</a></p>
<p><strong>动态规划：无限背包</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">waysToChange</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] coins = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">25</span>&#125;;</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> coin : coins)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = coin; i &lt;= n; i++)&#123;</span><br><span class="line">                dp[i] = (dp[i] + dp[i - coin]) % <span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>0018.四数之和</title>
    <url>/2020/10/05/0018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/4sum/">https://leetcode-cn.com/problems/4sum/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; quadruplets = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> quadruplets;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>] + nums[i + <span class="number">3</span>] &gt; target) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[length - <span class="number">3</span>] + nums[length - <span class="number">2</span>] + nums[length - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; length - <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] + nums[j + <span class="number">1</span>] + nums[j + <span class="number">2</span>] &gt; target) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] + nums[length - <span class="number">2</span>] + nums[length - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> left = j + <span class="number">1</span>, right = length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                    <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                        quadruplets.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));</span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                            left++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        left++;</span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                            right--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> quadruplets;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(n^3)，其中 nn 是数组的长度。排序的时间复杂度是 O(n \log n)O(nlogn)，枚举四元组的时间复杂度是 O(n^3)，因此总时间复杂度为 O(n^3+nlogn)=O(n3)。</p>
</li>
<li><p>空间复杂度：O(logN)。我们忽略存储答案的空间，额外的排序的空间复杂度为 O(logN)。然而我们修改了输入的数组 nums，在实际情况下不一定允许，因此也可以看成使用了一个额外的数组存储了 nums 的副本并进行排序，空间复杂度为 O(N)。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>0201.数组范围按位与</title>
    <url>/2020/10/06/0201.%E6%95%B0%E7%BB%84%E8%8C%83%E5%9B%B4%E6%8C%89%E4%BD%8D%E4%B8%8E/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/bitwise-and-of-numbers-range">https://leetcode-cn.com/problems/bitwise-and-of-numbers-range</a></p>
<p><strong>位移</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(m != n)&#123;</span><br><span class="line">            m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m &lt;&lt; count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(logn)。算法的时间复杂度取决于 mm 和 nn 的二进制位数，由于 m≤n，因此时间复杂度取决于 n 的二进制位数。</li>
<li>空间复杂度：O(1)。我们只需要常数空间存放若干变量。</li>
</ul>
<p><strong>Brian Kernighan 算法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (m &lt; n) &#123;</span><br><span class="line">            <span class="comment">// 抹去最右边的 1</span></span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(logn)。和位移方法类似，算法的时间复杂度取决于 m 和 n 二进制展开的位数。尽管和位移方法具有相同的渐近复杂度，但 Brian Kernighan 的算法需要的迭代次数会更少，因为它跳过了两个数字之间的所有零位。</li>
<li>空间复杂度：O(1)。我们只需要常数空间存放若干变量。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>0769.最多能完成排序的块</title>
    <url>/2020/10/05/0769.%E6%9C%80%E5%A4%9A%E8%83%BD%E5%AE%8C%E6%88%90%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9D%971/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/max-chunks-to-make-sorted">https://leetcode-cn.com/problems/max-chunks-to-make-sorted</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxChunksToSorted</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            max = Math.max(arr[i], max);</span><br><span class="line">            <span class="keyword">if</span>(max == i) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(N)，其中 N 为数组 <code>arr</code> 的长度。</li>
<li>空间复杂度: O(1)。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>0091. 解码方法</title>
    <url>/2020/10/07/0091.%20%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/decode-ways">https://leetcode-cn.com/problems/decode-ways</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = s.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> c = b;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;1&#x27;</span> || s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;2&#x27;</span> &amp;&amp; s.charAt(i) &lt; <span class="string">&#x27;7&#x27;</span>)&#123; </span><br><span class="line">                c = s.charAt(i) != <span class="string">&#x27;0&#x27;</span> ? a + b : a; <span class="comment">// a + b : 11 ~ 19, 21 ~ 26; a : 10, 20</span></span><br><span class="line">                a = b;</span><br><span class="line">                b = c;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;0&#x27;</span>)&#123; <span class="comment">// 00, 30, 40...</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// 01, 02, 03...; 27, 28, 29, 31...</span></span><br><span class="line">                a = b;</span><br><span class="line">                b = c;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度 O(N) ： N 为字符串 s 的长度，其决定了循环次数。</li>
<li>空间复杂度 O(1) ： 字符串 s 使用常量大小的额外空间。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>0075.颜色分类</title>
    <url>/2020/10/07/0075.%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/sort-colors">https://leetcode-cn.com/problems/sort-colors</a></p>
<p><strong>两趟扫描法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">1</span>)&#123;</span><br><span class="line">                w++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                b++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; r)&#123;</span><br><span class="line">                nums[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i &gt;= r &amp;&amp; i &lt; r + w)&#123;</span><br><span class="line">                nums[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums[i] = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(N)。</li>
<li>空间复杂度：O(N)。</li>
</ul>
<p><strong>双指针：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                swap(nums, i, l);</span><br><span class="line">                l++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == <span class="number">2</span>)&#123;</span><br><span class="line">                swap(nums, i, r);</span><br><span class="line">                r--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(N)。</li>
<li>空间复杂度：O(1)。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>0008.字符串转换整数（atoi）</title>
    <url>/2020/10/07/0008.%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0%EF%BC%88atoi%EF%BC%89/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/">https://leetcode-cn.com/problems/string-to-integer-atoi/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> state = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(state == <span class="number">0</span> &amp;&amp; c == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                state = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(state == <span class="number">0</span> &amp;&amp; (c == <span class="string">&#x27;-&#x27;</span> || c == <span class="string">&#x27;+&#x27;</span>))&#123;</span><br><span class="line">                state = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(state != <span class="number">3</span> &amp;&amp; c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                state = <span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                state = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(state == <span class="number">1</span>)&#123;</span><br><span class="line">                sign = c == <span class="string">&#x27;-&#x27;</span> ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(state == <span class="number">2</span>)&#123;</span><br><span class="line">                ans = ans * <span class="number">10</span> + (c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span>(ans * sign &gt;= Integer.MAX_VALUE)&#123;</span><br><span class="line">                    <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(ans * sign &lt;= Integer.MIN_VALUE)&#123;</span><br><span class="line">                    <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(state == <span class="number">3</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = ans != <span class="number">0</span> ? ans * sign : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中 nn 为字符串的长度。我们只需要依次处理所有的字符，处理每个字符需要的时间为 O(1)。</li>
<li>空间复杂度：O(1)，自动机的状态只需要常数空间存储。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>01431.拥有最多糖果的孩子</title>
    <url>/2020/10/07/1431.%E6%8B%A5%E6%9C%89%E6%9C%80%E5%A4%9A%E7%B3%96%E6%9E%9C%E7%9A%84%E5%AD%A9%E5%AD%90/</url>
    <content><![CDATA[<p>拥有最多糖果的孩子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Boolean&gt; <span class="title">kidsWithCandies</span><span class="params">(<span class="keyword">int</span>[] candies, <span class="keyword">int</span> extraCandies)</span> </span>&#123;</span><br><span class="line">        List&lt;Boolean&gt; res = <span class="keyword">new</span> ArrayList&lt;Boolean&gt;();</span><br><span class="line">        <span class="keyword">int</span> maxCandy = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> candy : candies)&#123;</span><br><span class="line">            maxCandy = Math.max(maxCandy, candy);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; candies.length; i++)&#123;</span><br><span class="line">            res.add(candies[i] + extraCandies &gt;= maxCandy);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(n)。</p>
</li>
<li><p>空间复杂度：O(1)。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 47. 礼物的最大价值</title>
    <url>/2020/10/07/%E5%89%91%E6%8C%87Offer47.%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof">https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = grid.length;</span><br><span class="line">        <span class="keyword">int</span> c = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[r + <span class="number">1</span>][c + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= c; j++)&#123;</span><br><span class="line">                dp[i][j] = grid[i - <span class="number">1</span>][j - <span class="number">1</span>] + Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[r][c];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(mn)。</li>
<li>空间复杂度：O(1)。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 48.最长不含重复字符的子字符串</title>
    <url>/2020/10/07/%E5%89%91%E6%8C%87Offer48.%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof">https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof</a></p>
<p><strong>滑动窗口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(r &lt; s.length())&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(r++);</span><br><span class="line">            <span class="keyword">while</span>(set.contains(c))&#123;</span><br><span class="line">                set.remove(s.charAt(l++));</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(c);</span><br><span class="line">            res = Math.max(res, r - l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)。</li>
<li>空间复杂度：O(n)。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>HashSet</tag>
      </tags>
  </entry>
  <entry>
    <title>0344.反转字符串</title>
    <url>/2020/10/08/0344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/reverse-string">https://leetcode-cn.com/problems/reverse-string</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">char</span> tmp = s[l];</span><br><span class="line">            s[l] = s[r];</span><br><span class="line">            s[r] = tmp;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(n)。</p>
</li>
<li><p>空间复杂度：O(1)。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 40.最小的k个数</title>
    <url>/2020/10/07/%E5%89%91%E6%8C%87Offer40.%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof">https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof</a></p>
<p><strong>暴力法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(arr, <span class="number">0</span>, k);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(nlogn)，其中 n 是数组 arr 的长度。算法的时间复杂度即排序的时间复杂度。</li>
<li>空间复杂度：O(logn)，排序所需额外的空间复杂度为 O(logn)。</li>
</ul>
<p><strong>小顶堆</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span> || arr.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125; </span><br><span class="line">        Queue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;((v1, v2) -&gt; v2 - v1);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a : arr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pq.size() &lt; k)&#123;</span><br><span class="line">                pq.offer(a);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a &lt; pq.peek())&#123;</span><br><span class="line">                pq.poll();</span><br><span class="line">                pq.offer(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p : pq)&#123;</span><br><span class="line">            res[idx++] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(nlogk)，其中 n 是数组 arr 的长度。由于大根堆实时维护前 k 小值，所以插入删除都是 O(logk) 的时间复杂度，最坏情况下数组里 n 个数都会插入，所以一共需要 O(nlogk) 的时间复杂度。</p>
</li>
<li><p>空间复杂度：O(k)，因为大根堆里最多 k 个数。</p>
</li>
</ul>
<p><strong>快速排序</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li><p>时间复杂度 </p>
</li>
<li><p>空间复杂度</p>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>堆</tag>
        <tag>快速排序</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 45. 把数组排成最小的数</title>
    <url>/2020/10/08/%E5%89%91%E6%8C%87Offer45.%E6%8A%8A%E6%95%B0%E7%BB%84%E7%BB%84%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof">https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        String[] str = <span class="keyword">new</span> String[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            str[i] = String.valueOf(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(str, (x, y) -&gt; (x + y).compareTo(y + x));</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(String s : str)&#123;</span><br><span class="line">            res.append(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度 O(NlogN) ： N 为最终返回值的字符数量（strs 列表的长度≤N）；使用快排或内置函数的平均时间复杂度为 O(NlogN) ，最差为 O(N^2) 。</li>
<li>空间复杂度 O(N) ： 字符串列表 strs 占用线性大小的额外空间。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>0048.旋转图像</title>
    <url>/2020/10/08/0048.%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/rotate-image">https://leetcode-cn.com/problems/rotate-image</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (n + <span class="number">1</span>)/ <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n / <span class="number">2</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[n - j - <span class="number">1</span>][i];</span><br><span class="line">                matrix[n - j - <span class="number">1</span>][i] = matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>];</span><br><span class="line">                matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>] = matrix[j][n - i - <span class="number">1</span>];</span><br><span class="line">                matrix[j][n - i - <span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(N^2) 是两重循环的复杂度。</li>
<li>空间复杂度：O(1) 由于旋转操作是 <em>就地</em> 完成的。</li>
</ul>
<p><strong>转置加翻转</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = matrix.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// transpose matrix</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = matrix[j][i];</span><br><span class="line">        matrix[j][i] = matrix[i][j];</span><br><span class="line">        matrix[i][j] = tmp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// reverse each row</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n / <span class="number">2</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = matrix[i][j];</span><br><span class="line">        matrix[i][j] = matrix[i][n - j - <span class="number">1</span>];</span><br><span class="line">        matrix[i][n - j - <span class="number">1</span>] = tmp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(N^2).</li>
<li>空间复杂度：O(1) 由于旋转操作是 <em>就地</em> 完成的。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>0283.移动零</title>
    <url>/2020/10/08/0283.%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/move-zeroes">https://leetcode-cn.com/problems/move-zeroes</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                nums[count++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = count; i &lt;= n; i++)&#123;</span><br><span class="line">            nums[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(n)。</p>
</li>
<li><p>空间复杂度：O(1)。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>0529.扫雷游戏</title>
    <url>/2020/10/08/0529.%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/minesweeper/">https://leetcode-cn.com/problems/minesweeper/</a></p>
<p><strong>dfs</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dirX = &#123;-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] dirY = &#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span>[][] updateBoard(<span class="keyword">char</span>[][] board, <span class="keyword">int</span>[] click) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = click[<span class="number">0</span>], y = click[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(board[x][y] == <span class="string">&#x27;M&#x27;</span>)&#123;</span><br><span class="line">            board[x][y] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dfs(board, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> board;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tx = x + dirX[i];</span><br><span class="line">            <span class="keyword">int</span> ty = y + dirY[i];</span><br><span class="line">            <span class="keyword">if</span>(tx &lt; <span class="number">0</span> || tx &gt;= board.length || ty &lt; <span class="number">0</span> || ty &gt;= board[<span class="number">0</span>].length)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(board[tx][ty] == <span class="string">&#x27;M&#x27;</span>)&#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            board[x][y] = (<span class="keyword">char</span>)(cnt + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            board[x][y] = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tx = x + dirX[i];</span><br><span class="line">                <span class="keyword">int</span> ty = y + dirY[i];</span><br><span class="line">                <span class="keyword">if</span>(tx &lt; <span class="number">0</span> || tx &gt;= board.length || ty &lt; <span class="number">0</span> || ty &gt;= board[<span class="number">0</span>].length || board[tx][ty] != <span class="string">&#x27;E&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dfs(board, tx, ty);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(nm)，其中 n 和 m 分别代表面板的宽和高。最坏情况下会遍历整个面板。</li>
<li>空间复杂度：O(nm)。空间复杂度取决于递归的栈深度，而递归栈深度在最坏情况下有可能遍历整个面板而达到 O(nm)。</li>
</ul>
<p><strong>bfs</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dirX = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] dirY = &#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span>[][] updateBoard(<span class="keyword">char</span>[][] board, <span class="keyword">int</span>[] click) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = click[<span class="number">0</span>], y = click[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (board[x][y] == <span class="string">&#x27;M&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 规则 1</span></span><br><span class="line">            board[x][y] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            bfs(board, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> board;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> sx, <span class="keyword">int</span> sy)</span> </span>&#123;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">boolean</span>[][] vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[board.length][board[<span class="number">0</span>].length];</span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;sx, sy&#125;);</span><br><span class="line">        vis[sx][sy] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] pos = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>, x = pos[<span class="number">0</span>], y = pos[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> tx = x + dirX[i];</span><br><span class="line">                <span class="keyword">int</span> ty = y + dirY[i];</span><br><span class="line">                <span class="keyword">if</span> (tx &lt; <span class="number">0</span> || tx &gt;= board.length || ty &lt; <span class="number">0</span> || ty &gt;= board[<span class="number">0</span>].length) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 不用判断 M，因为如果有 M 的话游戏已经结束了</span></span><br><span class="line">                <span class="keyword">if</span> (board[tx][ty] == <span class="string">&#x27;M&#x27;</span>) &#123;</span><br><span class="line">                    ++cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 规则 3</span></span><br><span class="line">                board[x][y] = (<span class="keyword">char</span>) (cnt + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 规则 2</span></span><br><span class="line">                board[x][y] = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tx = x + dirX[i];</span><br><span class="line">                    <span class="keyword">int</span> ty = y + dirY[i];</span><br><span class="line">                    <span class="comment">// 这里不需要在存在 B 的时候继续扩展，因为 B 之前被点击的时候已经被扩展过了</span></span><br><span class="line">                    <span class="keyword">if</span> (tx &lt; <span class="number">0</span> || tx &gt;= board.length || ty &lt; <span class="number">0</span> || ty &gt;= board[<span class="number">0</span>].length || board[tx][ty] != <span class="string">&#x27;E&#x27;</span> || vis[tx][ty]) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;tx, ty&#125;);</span><br><span class="line">                    vis[tx][ty] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>0461.汉明距离</title>
    <url>/2020/10/06/0461.%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/hamming-distance">https://leetcode-cn.com/problems/hamming-distance</a></p>
<p><strong>位移</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> xor = x ^ y;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(xor != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(xor % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">                ++count;</span><br><span class="line">            xor &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(1)，在 Python 和 Java 中 Integer 的大小是固定的，处理时间也是固定的。 32 位整数需要 32 次迭代。</li>
<li>空间复杂度：O(1)，使用恒定大小的空间。</li>
</ul>
<p><strong>Brian Kernighan 算法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> xor = x ^ y;</span><br><span class="line">    <span class="keyword">int</span> distance = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (xor != <span class="number">0</span>) &#123;</span><br><span class="line">      distance += <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// remove the rightmost bit of &#x27;1&#x27;</span></span><br><span class="line">      xor = xor &amp; (xor - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> distance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(1)。</li>
<li>空间复杂度：O(1)。我们只需要常数空间存放若干变量。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>0547.朋友圈</title>
    <url>/2020/10/08/0547.%E6%9C%8B%E5%8F%8B%E5%9C%88/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/friend-circles/">https://leetcode-cn.com/problems/friend-circles/</a></p>
<p><strong>dfs</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[M.length];</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">                dfs(M, visited, i);   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] M, <span class="keyword">int</span>[] visited, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M.length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(M[i][j] == <span class="number">1</span> &amp;&amp; visited[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                visited[j] = <span class="number">1</span>;</span><br><span class="line">                dfs(M, visited, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(N^2)。</p>
</li>
<li><p>空间复杂度：O(N)。</p>
</li>
</ul>
<p><strong>bfs</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[M.length];</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                queue.add(i);</span><br><span class="line">                <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">                    <span class="keyword">int</span> t = queue.remove();</span><br><span class="line">                    visited[t] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M.length; j++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(M[t][j] == <span class="number">1</span> &amp;&amp; visited[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                            queue.add(j);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自己仿照 <a href="https://xray1025.top/2020/09/18/0200.%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/">#200.岛屿数量</a> 写的特别慢</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(M == <span class="keyword">null</span> || M.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> r = M.length;</span><br><span class="line">        <span class="keyword">int</span> c = M[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(M[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    ++cnt;</span><br><span class="line">                    dfs(M, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] M, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(M[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                M[i][j] = <span class="number">0</span>;</span><br><span class="line">                dfs(M, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>0872.叶子相似的树</title>
    <url>/2020/10/08/0872.%E5%8F%B6%E5%AD%90%E7%9B%B8%E4%BC%BC%E7%9A%84%E6%A0%91/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/leaf-similar-trees/">https://leetcode-cn.com/problems/leaf-similar-trees/</a></p>
<p><strong>dfs</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">leafSimilar</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; leaves1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; leaves2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root1, leaves1);</span><br><span class="line">        dfs(root2, leaves2);</span><br><span class="line">        <span class="keyword">return</span> leaves1.equals(leaves2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode node, List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                list.add(node.val);</span><br><span class="line">            &#125;</span><br><span class="line">            dfs(node.left, list);</span><br><span class="line">            dfs(node.right, list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(T1 + T2)，其中 T1, T2 是给定的树的长度。</li>
<li>空间复杂度：O(T1 + T2)，存储叶值所使用的空间。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>0141.环形链表</title>
    <url>/2020/10/09/0141.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/linked-list-cycle/">https://leetcode-cn.com/problems/linked-list-cycle/</a></p>
<p><strong>HashSet</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Set&lt;ListNode&gt; nodeSeen = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nodeSeen.contains(head))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nodeSeen.add(head);</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度： O(n) 。</li>
<li>空间复杂度： O(n) 。</li>
</ul>
<p><strong>双指针</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head.next;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度： O(n) 。</li>
<li>空间复杂度： O(1) 。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>0142.环形链表2</title>
    <url>/2020/10/09/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A82/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">https://leetcode-cn.com/problems/linked-list-cycle-ii/</a></p>
<p><strong>HashSet</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        ListNode node = head;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(node))&#123;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                set.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度： O(n) 。</li>
<li>空间复杂度： O(n) 。</li>
</ul>
<p><strong>双指针</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度： O(n) 。</li>
<li>空间复杂度： O(1) 。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>0217.存在重复元素</title>
    <url>/2020/10/12/0217.%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/contains-duplicate/">https://leetcode-cn.com/problems/contains-duplicate/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(num))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(n)。</p>
</li>
<li><p>空间复杂度：O(n)。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>ArrayList</tag>
        <tag>HashSet</tag>
      </tags>
  </entry>
  <entry>
    <title>0219.存在重复元素2</title>
    <url>/2020/10/12/0219.%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A02/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/contains-duplicate-ii/">https://leetcode-cn.com/problems/contains-duplicate-ii/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(nums[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">            <span class="keyword">if</span>(map.size() &gt; k)&#123;</span><br><span class="line">                map.remove(nums[i - k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(nlog(min(n,k)))，我们需要遍历这个 n 长度的数组。对于每次遍历，在 BST 中 搜索，插入 或者 删除 都需要花费 O(logmin(k,n)) 的时间。</li>
<li>空间复杂度：O(min(n,k))，空间复杂度由 BST 的大小决定，其大小的上限由 k 和 n 共同决定。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>HashMap</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>0220.存在重复元素3</title>
    <url>/2020/10/12/0220.%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A03/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/contains-duplicate-iii/">https://leetcode-cn.com/problems/contains-duplicate-iii/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        TreeSet&lt;Long&gt; treeSet = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            Long c = treeSet.ceiling((<span class="keyword">long</span>)nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(c != <span class="keyword">null</span> &amp;&amp; c &lt;= nums[i] + t)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Long f = treeSet.floor((<span class="keyword">long</span>)nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(f != <span class="keyword">null</span> &amp;&amp; nums[i] &lt;= f + t)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            treeSet.add((<span class="keyword">long</span>)nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(treeSet.size() &gt; k)&#123;</span><br><span class="line">                treeSet.remove((<span class="keyword">long</span>)nums[i - k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(nlog(min(n,k)))，我们需要遍历这个 n 长度的数组。对于每次遍历，在 BST 中 搜索，插入或者删除都需要花O(logmin(k,n)) 的时间。</li>
<li>空间复杂度：O(min(n,k))，空间复杂度由 BST 的大小决定，其大小的上限由 k 和 n 共同决定。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>ArrayList</tag>
        <tag>TreeSet</tag>
      </tags>
  </entry>
  <entry>
    <title>0530.二叉搜索树的最小绝对差</title>
    <url>/2020/10/12/0530.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/">https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pre;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ans = Integer.MAX_VALUE;</span><br><span class="line">        pre = -<span class="number">1</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(node.left);</span><br><span class="line">        <span class="keyword">if</span>(pre == -<span class="number">1</span>)&#123;</span><br><span class="line">            pre = node.val;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans = Math.min(ans, node.val - pre);</span><br><span class="line">            pre = node.val;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</li>
<li>空间复杂度：O(n)。空间复杂度取决于递归的栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis</title>
    <url>/2020/10/23/0000.Mybatis/</url>
    <content><![CDATA[<h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><ul>
<li>Mybatis是一个orm类型的半自动框架，执行了对JDBC的封装，是一个持久层框架，它可以通过XML文件或者注解来配置原生信息，不在需要去做更多繁琐重复的过程，如创建连接，加载驱动！</li>
</ul>
<h1 id="Mybatis的优缺点"><a href="#Mybatis的优缺点" class="headerlink" title="Mybatis的优缺点"></a>Mybatis的优缺点</h1><h3 id="Mybaits的优点："><a href="#Mybaits的优点：" class="headerlink" title="Mybaits的优点："></a>Mybaits的优点：</h3><ul>
<li><p>基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用。</p>
</li>
<li><p>与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接；</p>
</li>
<li><p>很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）</p>
</li>
<li><p>能够与Spring很好的集成；</p>
</li>
<li><p>提供映射标签，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护。</p>
</li>
</ul>
<h3 id="MyBatis框架的缺点："><a href="#MyBatis框架的缺点：" class="headerlink" title="MyBatis框架的缺点："></a>MyBatis框架的缺点：</h3><ul>
<li><p>SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求。</p>
</li>
<li><p>SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</p>
</li>
</ul>
<h1 id="和-的区别是什么"><a href="#和-的区别是什么" class="headerlink" title="#{}和${}的区别是什么"></a>#{}和${}的区别是什么</h1><ul>
<li>#{}：是预编译处理。</li>
<li>${}：是字符串替换。</li>
<li>Mybatis在处理#{}时，会将sql中的#{}替换为？号，调用PreparedStatement的set方法来赋值；</li>
<li>mybatis在处理${}时，就是将${}替换成变量的值.</li>
<li>使用#{}可以有效的防止SQL注入，提高系统的安全性！</li>
</ul>
<blockquote>
<p>sql注入：</p>
</blockquote>
<h1 id="如何在在mapper中如何传递多个参数"><a href="#如何在在mapper中如何传递多个参数" class="headerlink" title="如何在在mapper中如何传递多个参数?"></a>如何在在mapper中如何传递多个参数?</h1><p>答：多个参数封装成map</p>
<blockquote>
<ol>
<li>映射文件的命名空间，SQL片段的ID，就可以调用对应的映射文件的SQL，</li>
<li>由于我们的参数超过两个，而方法只有一个Object参数收集，因此我们使用Map集合来装载我们的参数</li>
</ol>
</blockquote>
<h1 id="Mybatis全局配置文件中有哪些标签-分别代表什么意思"><a href="#Mybatis全局配置文件中有哪些标签-分别代表什么意思" class="headerlink" title="Mybatis全局配置文件中有哪些标签?分别代表什么意思?"></a>Mybatis全局配置文件中有哪些标签?分别代表什么意思?</h1><blockquote>
<p>configuration 配置<br>properties 属性:可以加载properties配置文件的信息<br>settings 设置：可以设置mybatis的全局属性<br>typeAliases 类型命名<br>typeHandlers 类型处理器<br>objectFactory 对象工厂<br>plugins 插件<br>environments 环境<br>environment 环境变量<br>transactionManager 事务管理器<br>dataSource 数据源<br>mappers 映射器</p>
</blockquote>
<h1 id="属性优化"><a href="#属性优化" class="headerlink" title="属性优化"></a>属性优化</h1><p>为符合高内聚低耦合的思想，在mybatis中属性可以采用外部引入的方式获得，方式为创建一个properties后缀的文件，然后再mybatis项目的配置文件中使用properties标签，引用外部属性</p>
<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!--引入外部配置文件--&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;db.properties&quot;</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--使用“$&#123;&#125;”来引用--&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>与此同时也可以再properties标签中创建property标签来定义name和value值，但是当外部引入文件和内部配置文件的name值相同时，优先使用外部配置文件</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;properties resource=<span class="string">&quot;db.properties&quot;</span>&gt;</span><br><span class="line">       &lt;property name=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;root&quot;</span>/&gt;</span><br><span class="line">       &lt;property name=<span class="string">&quot;password&quot;</span> value=<span class="string">&quot;123456&quot;</span>/&gt;</span><br><span class="line">   &lt;/properties&gt;</span><br></pre></td></tr></table></figure>

<p>同时再mybatis中存在着标签的默认顺序，当配置文件中的标签顺序不符合规定时，会发生错误，默认顺序为<br>(properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,reflectorFactory?,plugins?,environments?,databaseIdProvider?,mappers?)”，顺序错误即报错</p>
<h1 id="别名优化"><a href="#别名优化" class="headerlink" title="别名优化"></a>别名优化</h1><p>别名优化有多种实现方式，可以通过注解的方式实现，也可以通过配置文件中的typeAliases标签中的typeAlias标签来实现，或者使用typeAliases标签中的package标签来实现</p>
<h2 id="注解的方式实现别名优化"><a href="#注解的方式实现别名优化" class="headerlink" title="注解的方式实现别名优化"></a>注解的方式实现别名优化</h2><p>定义一个实体类，然后在实体类上创建注解，使用注解：@Alias来实现<br>例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.type.Alias;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Alias(&quot;User&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span>  String name;</span><br><span class="line">    <span class="keyword">private</span>  String pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此代码便将实体类com.pojo.User类的别名定义为User，在mybatis中访问时只需要使用User即可访问该实体类</p>
<h2 id="typeAliases标签的子标签package来实现"><a href="#typeAliases标签的子标签package来实现" class="headerlink" title="typeAliases标签的子标签package来实现"></a>typeAliases标签的子标签package来实现</h2><p>指定一个包名，MyBatis 会在包名下面搜索需要的 Java实体类。适合实体类比较多时使用，无法自定义名称，使用时默认名称为这个类类名的首字母小写，官方建议是小写字母，但大写也是可行的</p>
<h2 id="typeAliases标签的子标签typeAlias来实现"><a href="#typeAliases标签的子标签typeAlias来实现" class="headerlink" title="typeAliases标签的子标签typeAlias来实现"></a>typeAliases标签的子标签typeAlias来实现</h2><p>适合实体类比较少时使用，可以自定义名称,例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;typeAlias type=<span class="string">&quot;com.pojo.User&quot;</span> alias=<span class="string">&quot;User&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<h1 id="映射器（mappers）"><a href="#映射器（mappers）" class="headerlink" title="映射器（mappers）"></a>映射器（mappers）</h1><p>既然 MyBatis 的行为已经由上述元素配置完了，我们现在就要来定义 SQL 映射语句了。 但首先，我们需要告诉 MyBatis 到哪里去找到这些语句。 在自动查找资源方面，Java 并没有提供一个很好的解决方案，所以最好的办法是直接告诉 MyBatis 到哪里去找映射文件。 你可以使用相对于类路径的资源引用，或完全限定资源定位符（包括 <code>file:///</code> 形式的 URL），或类名和包名等。例如：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!-- 使用相对于类路径的资源引用 --&gt;</span><br><span class="line">&lt;mappers&gt;</span><br><span class="line">  &lt;mapper resource=<span class="string">&quot;org/mybatis/builder/AuthorMapper.xml&quot;</span>/&gt;</span><br><span class="line">  &lt;mapper resource=<span class="string">&quot;org/mybatis/builder/BlogMapper.xml&quot;</span>/&gt;</span><br><span class="line">  &lt;mapper resource=<span class="string">&quot;org/mybatis/builder/PostMapper.xml&quot;</span>/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 使用完全限定资源定位符（URL） --&gt;</span><br><span class="line">&lt;mappers&gt;</span><br><span class="line">  &lt;mapper url=<span class="string">&quot;file:///var/mappers/AuthorMapper.xml&quot;</span>/&gt;</span><br><span class="line">  &lt;mapper url=<span class="string">&quot;file:///var/mappers/BlogMapper.xml&quot;</span>/&gt;</span><br><span class="line">  &lt;mapper url=<span class="string">&quot;file:///var/mappers/PostMapper.xml&quot;</span>/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;</span><br><span class="line">&lt;mappers&gt;</span><br><span class="line">  &lt;mapper <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.mybatis.builder.AuthorMapper&quot;</span>/&gt;</span><br><span class="line">  &lt;mapper <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.mybatis.builder.BlogMapper&quot;</span>/&gt;</span><br><span class="line">  &lt;mapper <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.mybatis.builder.PostMapper&quot;</span>/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;</span><br><span class="line">&lt;mappers&gt;</span><br><span class="line">  &lt;<span class="keyword">package</span> name=<span class="string">&quot;org.mybatis.builder&quot;</span>/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>方法三、四需要接口和Mapper配置文件同名，并在同一包下</li>
</ul>
<h1 id="生命周期和作用域"><a href="#生命周期和作用域" class="headerlink" title="生命周期和作用域"></a>生命周期和作用域</h1><p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201022192606.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201022192618.png" alt="img"></p>
<h4 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h4><p>这个类可以被实例化、使用和丢弃，一旦创建了 <code>SqlSessionFactory</code>，就不再需要它了。因此 <code>SqlSessionFactoryBuilder</code> 实例的最佳作用域是方法作用域（也就是局部方法变量）。你可以重用 <code>SqlSessionFactoryBuilder</code> 来创建多个 <code>SqlSessionFactory</code> 实例，但最好还是不要一直保留着它，以保证所有的 <code>XML</code> 解析资源可以被释放给更重要的事情。</p>
<h4 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h4><p><code>SqlSessionFactory</code> 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。使用<code>SqlSessionFactory</code> 的最佳实践是在应用运行期间不要重复创建多次，多次重建<code>SqlSessionFactory</code> 被视为一种代码“坏习惯”。因此<code>SqlSessionFactory</code> 的最佳作用域是应用作用域。有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。</p>
<h4 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h4><p>每个线程都应该有它自己的 <code>SqlSession</code> 实例。<code>SqlSession</code>的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。绝对不能将 <code>SqlSession</code> 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。也绝不能将 <code>SqlSession</code> 实例的引用放在任何类型的托管作用域中，比如 <code>Servlet</code> 框架中的 <code>HttpSession</code>。如果你现在正在使用一种 <code>Web</code> 框架，考虑将 <code>SqlSession</code> 放在一个和 <code>HTTP</code> 请求相似的作用域中。换句话说，每次收到 <code>HTTP</code> 请求，就可以打开一个 <code>SqlSession</code>，返回一个响应后，就关闭它。这个关闭操作很重要，为了确保每次都能执行关闭操作，你应该把这个关闭操作放到 <code>finally</code> 块中。下面的示例就是一个确保 <code>SqlSession</code> 关闭的标准模式：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (SqlSession session = sqlSessionFactory.<span class="keyword">open</span><span class="constructor">Session()</span>) &#123;</span><br><span class="line">  <span class="comment">// 你的应用逻辑代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在所有代码中都遵循这种使用模式，可以保证所有数据库资源都能被正确地关闭。</p>
<h4 id="映射器实例"><a href="#映射器实例" class="headerlink" title="映射器实例"></a>映射器实例</h4><p>映射器是一些绑定映射语句的接口。映射器接口的实例是从 <code>SqlSession</code> 中获得的。虽然从技术层面上来讲，任何映射器实例的最大作用域与请求它们的 <code>SqlSession</code> 相同。但方法作用域才是映射器实例的最合适的作用域。也就是说，映射器实例应该在调用它们的方法中被获取，使用完毕之后即可丢弃。映射器实例并不需要被显式地关闭。尽管在整个请求作用域保留映射器实例不会有什么问题，但是你很快会发现，在这个作用域上管理太多像<code>SqlSession</code> 的资源会让你忙不过来。因此，最好将映射器放在方法作用域内。就像下面的例子一样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  BlogMapper mapper = session.getMapper(BlogMapper.class);</span><br><span class="line">  <span class="comment">// 你的应用逻辑代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="当实体类中的属性名和表中的字段名不一样-，怎么办-？"><a href="#当实体类中的属性名和表中的字段名不一样-，怎么办-？" class="headerlink" title="当实体类中的属性名和表中的字段名不一样 ，怎么办 ？"></a>当实体类中的属性名和表中的字段名不一样 ，怎么办 ？</h1><p>第1种：通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&lt;select id=”selectorder” parametertype=”int” resultetype=”me.gacl.domain.order”&gt;       </span><br><span class="line">      <span class="keyword">select</span> order_id <span class="keyword">id</span>, order_no orderno ,order_price price </span><br><span class="line">            <span class="keyword">form</span> orders </span><br><span class="line">            <span class="keyword">where</span> order_id=<span class="comment">#&#123;id&#125;;    </span></span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure>

<p>第2种：通过来映射字段名和实体类属性名的一一对应的关系。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;getOrder&quot; parameterType=&quot;int&quot; resultMap=&quot;orderresultmap&quot;&gt;</span><br><span class="line">        <span class="keyword">select</span> * <span class="keyword">from</span> orders <span class="keyword">where</span> order_id=<span class="comment">#&#123;id&#125;</span></span><br><span class="line">    &lt;/<span class="keyword">select</span>&gt;</span><br><span class="line"></span><br><span class="line">   &lt;resultMap <span class="keyword">type</span>=”me.gacl.domain.order” <span class="keyword">id</span>=”orderresultmap”&gt;</span><br><span class="line">        &lt;!–用<span class="keyword">id</span>属性来映射主键字段–&gt;</span><br><span class="line">        &lt;<span class="keyword">id</span> property=”<span class="keyword">id</span>” <span class="keyword">column</span>=”order_id”&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!–用<span class="keyword">result</span>属性来映射非主键字段，property为实体类属性名，<span class="keyword">column</span>为数据表中的属性–&gt;</span><br><span class="line">        &lt;<span class="keyword">result</span> property = “orderno” <span class="keyword">column</span> =”order_no”/&gt;</span><br><span class="line">        &lt;<span class="keyword">result</span> property=”price” <span class="keyword">column</span>=”order_price” /&gt;</span><br><span class="line">    &lt;/reslutMap&gt;</span><br></pre></td></tr></table></figure>

<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h2 id="日志工厂"><a href="#日志工厂" class="headerlink" title="日志工厂"></a>日志工厂</h2><p>如果程序出现了错误，需要排错，那么就需要用到日志。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201022192637.png" alt="在这里插入图片描述"></p>
<ul>
<li>SLF4J</li>
<li>LOG4J 【常用】</li>
<li>LOG4J2</li>
<li>JDK_LOGGING</li>
<li>COMMONS_LOGGING</li>
<li>STDOUT_LOGGING 【常用】</li>
<li>NO_LOGGING</li>
</ul>
<h2 id="STDOUT-LOGGING"><a href="#STDOUT-LOGGING" class="headerlink" title="STDOUT_LOGGING"></a>STDOUT_LOGGING</h2><p><strong>STDOUT_LOGGING标准日志输出</strong><br>标准日志，不需要其余操作，只需在mybatis核心配置文件中配置即可</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--日志--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201022192647.png" alt="在这里插入图片描述"></p>
<h2 id="Log4j"><a href="#Log4j" class="headerlink" title="Log4j"></a>Log4j</h2><ul>
<li>Log4j是<a href="https://baike.baidu.com/item/Apache/8512995">Apache</a>的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是<a href="https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E5%8F%B0/2438626">控制台</a>、文件、<a href="https://baike.baidu.com/item/GUI">GUI</a>组件</li>
<li>我们也可以控制每一条日志的输出格式；</li>
<li>通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。</li>
<li>通过一个<a href="https://baike.baidu.com/item/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/286550">配置文件</a>来灵活地进行配置，而不需要修改应用的代码。</li>
</ul>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>1.导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.编写配置文件log4j.properties</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码</span><br><span class="line">log4j.rootLogger&#x3D;DEBUG,console,file</span><br><span class="line"></span><br><span class="line">#控制台输出的相关设置</span><br><span class="line">log4j.appender.console &#x3D; org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.console.Target &#x3D; System.out</span><br><span class="line">log4j.appender.console.Threshold&#x3D;DEBUG</span><br><span class="line">log4j.appender.console.layout &#x3D; org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.console.layout.ConversionPattern&#x3D;[%c]-%m%n</span><br><span class="line"></span><br><span class="line">#文件输出的相关设置</span><br><span class="line">log4j.appender.file &#x3D; org.apache.log4j.RollingFileAppender</span><br><span class="line">log4j.appender.file.File&#x3D;.&#x2F;log&#x2F;xr.log</span><br><span class="line">log4j.appender.file.MaxFileSize&#x3D;10mb</span><br><span class="line">log4j.appender.file.Threshold&#x3D;DEBUG</span><br><span class="line">log4j.appender.file.layout&#x3D;org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.file.layout.ConversionPattern&#x3D;[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n</span><br><span class="line"></span><br><span class="line">#日志输出级别</span><br><span class="line">log4j.logger.org.mybatis&#x3D;DEBUG</span><br><span class="line">log4j.logger.java.sql&#x3D;DEBUG</span><br><span class="line">log4j.logger.java.sql.Statement&#x3D;DEBUG</span><br><span class="line">log4j.logger.java.sql.ResultSet&#x3D;DEBUG</span><br><span class="line">log4j.logger.java.sql.PreparedStatement&#x3D;DEBUG</span><br></pre></td></tr></table></figure>

<p>3.在mybatis核心配置文件中配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意顺序</p>
<p>测试<br><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201022193000.png" alt="在这里插入图片描述"></p>
<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>1.在要使用Log4j 的类中，导入包 import org.apache.log4j.Logger;<br>2.创建日志对象，参数为当前的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Logger logger = Logger.getLogger(UserDaoTest.class);</span><br></pre></td></tr></table></figure>

<p>3.使用和日志级别</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">logger.info(<span class="string">&quot;info:进入了testLog4j&quot;</span>);</span><br><span class="line">logger.debug(<span class="string">&quot;debug:进入了testLog4j&quot;</span>);</span><br><span class="line">logger.error(<span class="string">&quot;error:进入了testLog4j&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="Mybatis动态sql有什么用？执行原理？有哪些动态sql？"><a href="#Mybatis动态sql有什么用？执行原理？有哪些动态sql？" class="headerlink" title="Mybatis动态sql有什么用？执行原理？有哪些动态sql？"></a>Mybatis动态sql有什么用？执行原理？有哪些动态sql？</h1><blockquote>
<p>有九种动态sql标签：trim,where,set,foreach,if,choose,when,bind,otherwise<br>Mybatis的动态sql可以在xml映射文件内，以标签的形式编写动态sql，执行原理是根据表达式的值，完成逻辑判断并动态拼接sql的功能！</p>
<h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>使用动态 SQL 最常见情景是根据条件包含 where 子句的一部分</p>
<h3 id="choose、when、otherwise"><a href="#choose、when、otherwise" class="headerlink" title="choose、when、otherwise"></a>choose、when、otherwise</h3><p>有时候，我们不想使用所有的条件，而只是想从多个条件中选择一个使用。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。</p>
<h3 id="trim、where、set"><a href="#trim、where、set" class="headerlink" title="trim、where、set"></a>trim、where、set</h3><p><em>where</em> 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，<em>where</em> 元素也会将它们去除。</p>
<p><em>set</em> 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）。</p>
<h3 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h3><p>这个元素可以用来定义可重用的 SQL 代码片段，以便在其它语句中使用。 参数可以静态地（在加载的时候）确定下来，并且可以在不同的 include 元素中定义不同的参数值。比如：</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">&lt;sql id=<span class="string">&quot;userColumns&quot;</span>&gt; $&#123;<span class="keyword">alias</span>&#125;<span class="string">.id</span>,$&#123;<span class="keyword">alias</span>&#125;<span class="string">.username</span>,$&#123;<span class="keyword">alias</span>&#125;<span class="string">.password</span> &lt;<span class="string">/sql</span>&gt;</span><br></pre></td></tr></table></figure>

<p>这个 SQL 片段可以在其它语句中使用，例如：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">select</span> id=&quot;selectUsers&quot; resultType=&quot;map&quot;&gt;</span><br><span class="line">  <span class="keyword">select</span></span><br><span class="line">    &lt;<span class="keyword">include</span> refid=&quot;userColumns&quot;&gt;&lt;property <span class="type">name</span>=&quot;alias&quot; <span class="keyword">value</span>=&quot;t1&quot;/&gt;&lt;/<span class="keyword">include</span>&gt;,</span><br><span class="line">    &lt;<span class="keyword">include</span> refid=&quot;userColumns&quot;&gt;&lt;property <span class="type">name</span>=&quot;alias&quot; <span class="keyword">value</span>=&quot;t2&quot;/&gt;&lt;/<span class="keyword">include</span>&gt;</span><br><span class="line">  <span class="keyword">from</span> some_table t1</span><br><span class="line">    <span class="keyword">cross</span> <span class="keyword">join</span> some_table t2</span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><p>动态 SQL 的另一个常见使用场景是对集合进行遍历（尤其是在构建 IN 条件语句的时候）。比如：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">select</span> id=&quot;selectPostIn&quot; resultType=&quot;domain.blog.Post&quot;&gt;</span><br><span class="line">  <span class="keyword">SELECT</span> *</span><br><span class="line">  <span class="keyword">FROM</span> POST P</span><br><span class="line">  <span class="keyword">WHERE</span> ID <span class="keyword">in</span></span><br><span class="line">  &lt;<span class="keyword">foreach</span> item=&quot;item&quot; <span class="keyword">index</span>=&quot;index&quot; collection=&quot;list&quot;</span><br><span class="line">      <span class="keyword">open</span>=&quot;(&quot; separator=&quot;,&quot; <span class="keyword">close</span>=&quot;)&quot;&gt;</span><br><span class="line">        #&#123;item&#125;</span><br><span class="line">  &lt;/<span class="keyword">foreach</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure>

<p><em>foreach</em> 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及集合项迭代之间的分隔符。这个元素也不会错误地添加多余的分隔符</p>
</blockquote>
<h1 id="什么是Mybatis的一级、二级缓存-如何开启-什么样的数据适合缓存"><a href="#什么是Mybatis的一级、二级缓存-如何开启-什么样的数据适合缓存" class="headerlink" title="什么是Mybatis的一级、二级缓存,如何开启?什么样的数据适合缓存?"></a>什么是Mybatis的一级、二级缓存,如何开启?什么样的数据适合缓存?</h1><p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201022212413.png" alt="img"></p>
<h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><h3 id="一级缓存介绍"><a href="#一级缓存介绍" class="headerlink" title="一级缓存介绍"></a>一级缓存介绍</h3><ul>
<li><p>在应用运行过程中，我们有可能在一次数据库会话中，执行多次查询条件完全相同的SQL，MyBatis提供了一级缓存的方案优化这部分场景，如果是相同的SQL语句，会优先命中一级缓存，避免直接对数据库进行查询，提高性能。</p>
</li>
<li><p>每个SqlSession中持有了Executor，每个Executor中有一个LocalCache。当用户发起查询时，MyBatis根据当前执行的语句生成<code>MappedStatement</code>，在Local Cache进行查询，如果缓存命中的话，直接返回结果给用户，如果缓存没有命中的话，查询数据库，结果写入<code>Local Cache</code>，最后返回结果给用户。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201022213005.png" alt="img"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>MyBatis一级缓存的生命周期和SqlSession一致。</li>
<li>MyBatis一级缓存内部设计简单，只是一个没有容量限定的HashMap，在缓存的功能性上有所欠缺。</li>
<li>MyBatis的一级缓存最大范围是SqlSession内部，有多个SqlSession或者分布式的环境下，数据库写操作会引起脏数据，建议设定缓存级别为Statement。</li>
<li>会话提交或退出时，一级缓存会提交到二级缓存。</li>
</ol>
<h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><h3 id="二级缓存介绍"><a href="#二级缓存介绍" class="headerlink" title="二级缓存介绍"></a>二级缓存介绍</h3><p>在上文中提到的一级缓存中，其最大的共享范围就是一个SqlSession内部，如果多个SqlSession之间需要共享缓存，则需要使用到二级缓存。开启二级缓存后，会使用CachingExecutor装饰Executor，进入一级缓存的查询流程前，先在CachingExecutor进行二级缓存的查询，具体的工作流程如下所示。</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/28399eba.png" alt="img"></p>
<p>二级缓存开启后，同一个namespace下的所有操作语句，都影响着同一个Cache，即二级缓存被多个SqlSession共享，是一个全局的变量。</p>
<p>当开启缓存后，数据的查询执行的流程就是 二级缓存 -&gt; 一级缓存 -&gt; 数据库。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol>
<li>MyBatis的二级缓存相对于一级缓存来说，实现了<code>SqlSession</code>之间缓存数据的共享，同时粒度更加的细，能够到<code>namespace</code>级别，通过Cache接口实现类不同的组合，对Cache的可控性也更强。</li>
<li>MyBatis在多表查询时，极大可能会出现脏数据，有设计上的缺陷，安全使用二级缓存的条件比较苛刻。</li>
<li>在分布式环境下，由于默认的MyBatis Cache实现都是基于本地的，分布式环境下必然会出现读取到脏数据，需要使用集中式缓存将MyBatis的Cache接口实现，有一定的开发成本，直接使用Redis、Memcached等分布式缓存可能成本更低，安全性也更高。</li>
</ol>
<h2 id="全文总结"><a href="#全文总结" class="headerlink" title="全文总结"></a>全文总结</h2><h1 id="什么是MyBatis的接口绑定？有哪些实现方式？"><a href="#什么是MyBatis的接口绑定？有哪些实现方式？" class="headerlink" title="什么是MyBatis的接口绑定？有哪些实现方式？"></a>什么是MyBatis的接口绑定？有哪些实现方式？</h1><blockquote>
<p>接口绑定就是在mybatis中任意定义接口，然后把接口里面的方法和sql语句绑定，我们直接调用接口方法就可以，这样比起原来sqlsession提供的方法我们可以有更加灵活的选择和设置！<br>有两种实现方式：</p>
<ol>
<li>在接口的方法上面加上@select，@update等注解，里面包含sql语句来绑定</li>
<li>通过xml里面写sql语句来绑定，在这种情况下，要指定xml映射文件里面的namespace必须为接口的全路径名，当sql语句比较简单的时候，用注解绑定，当sql语句比较复杂的时候，用xml绑定，一般使用xml绑定的比较多！</li>
</ol>
</blockquote>
<h1 id="使用MyBatis的mapper接口调用时有哪些要求？"><a href="#使用MyBatis的mapper接口调用时有哪些要求？" class="headerlink" title="使用MyBatis的mapper接口调用时有哪些要求？"></a>使用MyBatis的mapper接口调用时有哪些要求？</h1><blockquote>
<p>1.接口实现类继承sqlsessionDaosupport，需要编写mapper接口，mapper接口实现类，mapper.xml文件！<br>    mapper.xml中的namespace为mapper接口的地址<br>    mapper接口中的方法名和mapper.xml中的定义的statement的id保持一致<br>    Spring中定义<br>2.使用mapper扫描器</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/2020/10/15/0000.Redis/</url>
    <content><![CDATA[<h1 id="Redis面试题"><a href="#Redis面试题" class="headerlink" title="Redis面试题"></a>Redis面试题</h1><h1 id="1、Redis支持的数据类型？"><a href="#1、Redis支持的数据类型？" class="headerlink" title="1、Redis支持的数据类型？"></a>1、Redis支持的数据类型？</h1><h2 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h2><p>格式: <code>set key value</code></p>
<p>string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。</p>
<p>string类型是Redis最基本的数据类型，一个键最大能存储512MB。</p>
<h2 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h2><p>格式: <code>hmset name key1 value1 key2 value2</code></p>
<p>Redis hash 是一个键值(key=&gt;value)对集合。</p>
<p>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p>
<h2 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h2><p>Redis 列表是简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部（左边）或者尾部（右边）</p>
<p>格式: <code>lpush name value</code></p>
<p>在 key 对应 list 的头部添加字符串元素</p>
<p>格式: <code>rpush name value</code></p>
<p>在 key 对应 list 的尾部添加字符串元素</p>
<p>格式: <code>lrem name index</code></p>
<p>key 对应 list 中删除 count 个和 value 相同的元素</p>
<p>格式: <code>llen name</code></p>
<p>返回 key 对应 list 的长度</p>
<h2 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h2><p>格式: <code>sadd name value</code></p>
<p>Redis的Set是string类型的无序集合。</p>
<p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p>
<h2 id="zset-sorted-set：有序集合"><a href="#zset-sorted-set：有序集合" class="headerlink" title="zset(sorted set：有序集合)"></a>zset(sorted set：有序集合)</h2><p>格式: <code>zadd name score value</code></p>
<p>Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。</p>
<p>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p>
<p>zset的成员是唯一的,但分数(score)却可以重复。</p>
<h2 id="Redis-优点"><a href="#Redis-优点" class="headerlink" title="Redis 优点"></a>Redis 优点</h2><ol>
<li><p>速度快：数据存在内存中，不像MySQL那样需要从外存中进行IO操作</p>
</li>
<li><p>支持的数据类型很多，单个value 的最大限制为 1 GB</p>
</li>
<li><p>持久化的存储：RDB 和 AOF</p>
</li>
<li><p>支持高可用：</p>
</li>
<li><ol>
<li>①Redis Sentinel，提供高可用方案，实现主从故障的自动转移；<ol start="2">
<li>②Redis Cluster，提供集群方案，实现基于槽的分片方案，支持更大的 Redis 规模</li>
</ol>
</li>
</ol>
</li>
<li><p>丰富的特性：</p>
</li>
<li><ol>
<li>①订阅发布功能 pub/sub<ol start="2">
<li>②Key的过期策略</li>
<li>③事务</li>
<li>④支持多个 DB</li>
<li>⑤计数</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="Redis-缺点"><a href="#Redis-缺点" class="headerlink" title="Redis 缺点"></a>Redis 缺点</h2><ol>
<li>Redis 是内存数据库，存储的数据量容易收到机器内存大小的限制</li>
<li>如果进行完整重同步，由于需要生成 RDB 文件并传输，会占用主机的 CPU。Redis 2.8中，已经有了部分重同步功能，但还是有可能出现完整重同步的（新上线的备机）</li>
<li>修改配置文件，进行重启，将硬盘中的数据加载进内存，时间比较久。在这个过程中，Redis 不能提供服务</li>
</ol>
<h2 id="（X）跳表的实现"><a href="#（X）跳表的实现" class="headerlink" title="（X）跳表的实现"></a>（X）跳表的实现</h2><blockquote>
<p>在<strong>有序双向链表（从小到大排列）</strong>的基础上，增加了多层索引链表。在查找时，就可以在不同索引链表间跳跃，达到快速查询的目的。</p>
</blockquote>
<ul>
<li>查询</li>
</ul>
<p>从最高层（设定的Max_level）第一个元素开始向右遍历</p>
<p>找到最后一个小于目标节点值的节点，向下层移动</p>
<p>重复这个步骤，直到找到相应的节点为止。 （途中经过的一系列节点称之为搜索路径）</p>
<ul>
<li>随机层数</li>
</ul>
<p>跳跃表会记录当前的最高层数maxLevel，遍历时从maxLevel开始遍历，性能会高很多</p>
<ul>
<li>插入<ul>
<li>在搜索插入点的过程中，将搜索路径找出来，然后创建一个新节点（分配一个层数）</li>
<li>将搜索路径上的节点和新节点通过前向后向指针连接起来。</li>
<li>如果新节点的高度h高于maxLevel，就更新maxLevel</li>
</ul>
</li>
<li>删除<ul>
<li>先找到搜索路径，删除节点</li>
<li>对于每层的相关节点，重排一下前向后向的指针</li>
<li>更新maxLevel</li>
</ul>
</li>
<li>更新<ul>
<li>先删除节点</li>
<li>再插入节点</li>
<li>不判断位置是否需要调整</li>
</ul>
</li>
<li>若Score一样，怎么办</li>
<li>比较value</li>
<li>元素排名的计算<ul>
<li>每个forward指针有一个跨度属性：表示前一个节点通过forward指针跳到当前节点，中间经过多少节点。</li>
<li>计算元素排名时，将 搜索路径 所有节点的跨度相加，就可以得出最终的rank值</li>
</ul>
</li>
</ul>
<h2 id="为什么用跳表而不是平衡树"><a href="#为什么用跳表而不是平衡树" class="headerlink" title="为什么用跳表而不是平衡树"></a>为什么用跳表而不是平衡树</h2><ul>
<li><p>范围查找时，平衡树比跳表复杂。</p>
<ul>
<li>在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。</li>
<li>而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。</li>
</ul>
</li>
<li><p>插入调整问题：</p>
<ul>
<li>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂</li>
<li>而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。</li>
</ul>
</li>
</ul>
<h1 id="2、什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？"><a href="#2、什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？" class="headerlink" title="2、什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？"></a>2、什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？</h1><h2 id="Redis-的持久化方式"><a href="#Redis-的持久化方式" class="headerlink" title="Redis 的持久化方式"></a>Redis 的持久化方式</h2><ul>
<li><p>【全量】RDB 持久化：在指定的时间间隔内将内存中的数据集快照写入磁盘。</p>
<ul>
<li>实际操作过程：fork 一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储</li>
</ul>
</li>
<li><p>【增量】AOF 持久化：以日志的形式记录每一个 写、删、改操作（不记录查询操作）。以文本的形式记录，可以打开文件看到详细的操作记录</p>
</li>
</ul>
<h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>【优点】</p>
<ul>
<li>备份的频率、周期可以灵活的设置</li>
<li>非常适合冷备份，可以将一个单独的文件压缩后转移到其它存储介质上</li>
<li>性能最大话：开始持久化时，Redis 服务进程只需 fork 出子进程，之后再由子进程完成这些持久化的工作，这样避免了服务器进程执行 IO 操作</li>
<li>恢复速度快：相对于 AOF 机制，RDB 的恢复速度更快，更适合恢复数据，特别时数据集非常大的情况下</li>
</ul>
<p>【缺点】</p>
<ul>
<li>若系统未在持久化之前出现宕机，从宕机到上一次备份后的数据全部丢失</li>
<li>RDB 通过fork 子进程来协助完成数据持久化的操作，因此，数据集较大时，可能会导致服务器停止服务几百毫秒（建议在业务低估，即半夜时执行）</li>
</ul>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>【优点】</p>
<ol>
<li>相比于 RDB ，有更高的数据安全性。提供了3中同步策略，每秒同步，每修改(执行一个命令)同步、不同步</li>
</ol>
<ul>
<li>每秒同步：每秒进行一次同步，是异步完成的，效率很高，系统一旦出现宕机，一秒内的数据就会将会丢失</li>
<li>每修改同步：可以视为同步持久化，每次发生数据变化都会被立即记录到磁盘中，效率最低</li>
<li>不同步：</li>
</ul>
<ol>
<li>该机制对日志文件的写入操作是append模式，因此在写入过程中即使发生宕机，也不会破坏日志文件已经存在的内容</li>
</ol>
<ul>
<li>使用 append-only 模式写入，没有任何磁盘寻址开销，写入性能高</li>
<li>如果写入一半数据系统崩溃，在 Redis 下一次启动前，可以通过 redis-check-aof 工具来帮助我们解决数据一致性问题</li>
</ul>
<ol>
<li>如果 AOF 文件过大，可以使用 rewrite 机制，</li>
<li>AOF 日志文件记录了所有的修改操作。可以修改这个文件完成数据的重建</li>
</ol>
<p>【缺点】</p>
<ol>
<li>相同数量的数据集，AOF 文件比 RDB 文件大；恢复时速度比 RDB 慢</li>
<li>AOF 在运行效率上往往会慢于 RDB。总之，每秒的同步策略比较高，同步禁用策略的效率和 RDB 一样高</li>
</ol>
<h2 id="持久化方式如何选择"><a href="#持久化方式如何选择" class="headerlink" title="持久化方式如何选择"></a>持久化方式如何选择</h2><ul>
<li>仅使用 RDB：万一服务器宕机，会丢失很多数据</li>
<li>仅使用 AOF：恢复速度很慢</li>
<li>RDB-AOF混合方案：bgsave 做全量持久化，AOF 做增量持久化。Redis 实例重启时，会使用 bgsave 重新构建内存，再使用 AOF 读取最近使用的指令，使 Redis 恢复到重启之前的状态</li>
</ul>
<h2 id="突然掉电怎么办"><a href="#突然掉电怎么办" class="headerlink" title="突然掉电怎么办"></a>突然掉电怎么办</h2><p>取决于 AOF 的 sync 属性，如果每次写指令都同步，就不会丢失数据；如果每秒同步，最多就丢失1秒数据</p>
<h1 id="3、Redis-有哪些架构模式？讲讲各自的特点"><a href="#3、Redis-有哪些架构模式？讲讲各自的特点" class="headerlink" title="3、Redis 有哪些架构模式？讲讲各自的特点"></a>3、Redis 有哪些架构模式？讲讲各自的特点</h1><h2 id="单机版"><a href="#单机版" class="headerlink" title="单机版"></a>单机版</h2><ul>
<li><p>特点：</p>
<ul>
<li>简单</li>
</ul>
</li>
<li><p>问题：</p>
<ul>
<li>内存容量有限</li>
<li>处理能力有限</li>
<li>无法高可用。</li>
</ul>
</li>
</ul>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>Redis 的复制（replication）功能允许用户根据一个 Redis 服务器来创建任意多个该服务器的复制品，其中被复制的服务器为主服务器（master），而通过复制创建出来的服务器复制品则为从服务器（slave）。</p>
<p>只要主从服务器之间的网络连接正常，主从服务器两者会具有相同的数据，主服务器就会一直将发生在自己身上的数据更新同步 给从服务器，从而一直保证主从服务器的数据相同。</p>
<p>特点：</p>
<ul>
<li>master/slave 角色</li>
<li>master/slave 数据相同</li>
<li>降低 master 读压力在转交从库</li>
</ul>
<p>问题：</p>
<ul>
<li>无法保证高可用</li>
<li>没有解决 master 写的压力</li>
</ul>
<h2 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h2><p>Redis sentinel 是一个分布式系统中监控 redis 主从服务器，并在主服务器下线时自动进行故障转移。其中三个特性：</p>
<ul>
<li>监控（Monitoring）：Sentinel 会不断地检查主服务器和从服务器是否运作正常。</li>
<li>提醒（Notification）：当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</li>
<li>自动故障迁移（Automatic failover）：当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作。</li>
</ul>
<p>特点：</p>
<ul>
<li>保证高可用</li>
<li>监控各个节点</li>
<li>自动故障迁移</li>
</ul>
<p>缺点：</p>
<ul>
<li>主从模式，切换需要时间丢数据</li>
<li>没有解决 master 写的压力</li>
</ul>
<h2 id="集群（proxy-型）"><a href="#集群（proxy-型）" class="headerlink" title="集群（proxy 型）"></a>集群（proxy 型）</h2><p>Twemproxy 是一个 Twitter 开源的一个 redis 和 memcache 快速/轻量级代理服务器；Twemproxy 是一个快速的单线程代理程序，支持 Memcached ASCII 协议和 redis 协议。</p>
<p>特点：</p>
<ul>
<li>多种 hash 算法：MD5、CRC16、CRC32、CRC32a、hsieh、murmur、Jenkins</li>
<li>支持失败节点自动删除</li>
<li>后端 Sharding 分片逻辑对业务透明，业务方的读写方式和操作单个 Redis 一致</li>
</ul>
<p>缺点：</p>
<ul>
<li>增加了新的 proxy，需要维护其高可用。</li>
<li>failover 逻辑需要自己实现，其本身不能支持故障的自动转移可扩展性差，进行扩缩容都需要手动干预</li>
</ul>
<h2 id="集群（直连型）："><a href="#集群（直连型）：" class="headerlink" title="集群（直连型）："></a>集群（直连型）：</h2><p>从redis 3.0之后版本支持redis-cluster集群，Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。</p>
<p>特点：</p>
<ul>
<li>无中心架构（不存在哪个节点影响性能瓶颈），少了 proxy 层。</li>
<li>数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布。</li>
<li>可扩展性，可线性扩展到 1000 个节点，节点可动态添加或删除。</li>
<li>高可用性，部分节点不可用时，集群仍可用。通过增加 Slave 做备份数据副本<br>  -实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave到 Master 的角色提升。</li>
</ul>
<p>缺点：</p>
<ul>
<li>资源隔离性较差，容易出现相互影响的情况。</li>
<li>数据通过异步复制,不保证数据的强一致性</li>
</ul>
<h1 id="4、使用过Redis分布式锁么，它是怎么实现的？"><a href="#4、使用过Redis分布式锁么，它是怎么实现的？" class="headerlink" title="4、使用过Redis分布式锁么，它是怎么实现的？"></a>4、使用过Redis分布式锁么，它是怎么实现的？</h1><p>先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。</p>
<p>如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？</p>
<p>set指令有非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的！</p>
<h1 id="5、使用过Redis做异步队列么，怎么用的？有什么缺点？"><a href="#5、使用过Redis做异步队列么，怎么用的？有什么缺点？" class="headerlink" title="5、使用过Redis做异步队列么，怎么用的？有什么缺点？"></a>5、使用过Redis做异步队列么，怎么用的？有什么缺点？</h1><p>一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。</p>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li>在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。</li>
</ul>
<p>能不能生产一次消费多次呢？</p>
<p>使用pub/sub主题订阅者模式，可以实现1:N的消息队列。</p>
<h1 id="6、什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？"><a href="#6、什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？" class="headerlink" title="6、什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？"></a>6、什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？</h1><ul>
<li><h2 id="穿透、雪崩、击穿的思维导图"><a href="#穿透、雪崩、击穿的思维导图" class="headerlink" title="穿透、雪崩、击穿的思维导图"></a>穿透、雪崩、击穿的思维导图</h2><p>​    </p>
<p>  <img src="https://cdn.nlark.com/yuque/0/2020/svg/1200640/1587200664360-7c300f02-d01c-4559-899a-9cb66430a32a.svg" alt="img"></p>
</li>
</ul>
<pre><code>## 缓存“穿透”是什么

穿透：指查询一个**不存在**的数据，由于缓存中没有，就会被动写，从数据库中查询数据，数据库中也不存在这个数据，就无法写入缓存。这导致每次查询这个不存在的数据时，都要去DB中去查询，缓存失去了它的意义。



## 缓存“穿透”如何避免

方案一：缓存空对象

- 从数据库中查询到的数据为空时，将这个空结果进行缓存，具体的值要使用特殊的标识（能和真正的缓存数据区分开）
- 对这个数据设置较短的过期时间（例如：5分钟）

&gt; 为什么设置较短的过期时间？因为缓存久了没有意义，浪费缓存的内存



方案二：BloomFilter 布隆过滤器

构建布隆过滤器，在布隆过滤器中存储对应的 key 是否存在，若存在 ，说明 key 对应的值不为空（未必存在）

- 根据 key 查询布隆过滤器。如果值不存在，直接返回；如果值存在，继续向下执行

- 根据 key 查询缓存中的值。若存在，就返回；若不存在，继续向下执行

- 查询 DB 对应的值，存在，就更新到缓存，并返回该值



## 缓存“雪崩”是什么

缓存雪崩：缓存由于某些原因无法提供服务（例如：缓存挂掉），所有请求打到 DB 中，导致 DB 负荷增大，最终挂掉的情况



## 缓存“雪崩”如何避免

一、缓存高可用：通过搭建缓存的高可用，避免缓存挂掉，导致无法提供服务的情况，降低缓存雪崩的情况

二、本地缓存：即使 Redis 缓存挂了，也可以将 DB 查询到的结果缓存到本地，避免后序的请求全部到达 DB中。

但是使用本地缓存也会出现相关的问题：

1. 如何保证本地缓存的实时性？

1. 1. 消息队列：数据更新时，发布数据更新的信息；会有相应的消费者消费消息，从而更新本地缓存
    2. 过期时间：设置较短的过期时间，过期之后从 DB 重新查询数据
    3. 手动过期：【如何避免缓存击穿——方案二】

1. 每个进程可能会本地缓存相同的数据，导致数据浪费

1. 1. 配置本地缓存的过期策略和缓存数量上限

三、请求 DB 限流：通过限制 DB 的每秒请求数，避免把 DB 也打挂。

这样有两个好处：

1. 有一部分用户还是可以正常使用的
2. 未来缓存服务恢复后，整个系统可以正常使用，不用处理 DB 也挂了的情况

四、提前演练：在项目上线前，对缓存挂掉的情况进行演练，看看后端的负载情况以及可能出现的问题，在这个基础上进行一些预案设定



## 缓存“击穿”是什么

缓存击穿：指某个热度非常高的数据，在某个时间点过期，在这个时间点，恰好有对这个key的大量请求，这些请求发现缓存数据过期，会从 DB 中查询数据并写回缓存，但是这时候的请求量太大可能使DB挂掉

- 对于一些设置了过期时间的 key，如果这些 key 可能会在某些时间点会被高并发的访问，是一种非常“热点”的数据，需要考虑这个问题。
- 区别：

  - 和缓存“穿透”的区别：这个 key 是真实存在对应值的
  - 和缓存“雪崩”的区别：前者针对某一个 key，后者针对很多 key



## 缓存“击穿”如何避免

一、互斥锁：请求发现缓存中数据不存在时，去查 DB 前，使用分布式锁，保证有且只有一个线程去查询 DB，并更新到缓存。流程如下：

1. 获取分布式锁：若超时，则抛出异常，返回；若成功，继续执行
2. 查询缓存：若缓存中存在值，就直接返回；若不存在，就继续向下执行。（获取到锁的时候，可能已经被前面的线程查询过数据库，并将数据更新到缓存中了）
3. 查询 DB，并更新到缓存中，返回值

二、手动过期：在缓存上，不设置过期时间；在功能上，将过期时间存在 key 对应的 value 中。流程如下：

1. 获取缓存：通过 value 的过期时间，判断是否过期，若没有过期，则直接返回；若过期，继续执行
2. 通过后台的一个异步线程进行缓存的构建，也就是“手动过期”。通过后台的异步线程，保证有且只有一个线程查询 DB
3. 返回数据：同时，虽然数据已经过期，但还是直接返回。通过这样的方式，保证服务的可用性，但是损失了一定的时效性

两个方案的优缺点：

|      | 互斥锁                             | 手动过期       |
| ---- | ---------------------------------- | -------------- |
| 优点 | 保证一致性                         | 用户无需等待   |
| 缺点 | 1、代码复杂度增加2、存在死锁的风险 | 无法保证一致性 |

## 缓存预热是什么？如何实现？

缓存预热

缓存系统刚启动时，没有任何数据，如果依靠用户请求的方式来重建缓存数据，对数据库的压力会非常大。

此时最好是在启动时，把热点数据加载好。这样，用户在请求时，读取的是缓存的数据，无需读取 DB 来重建缓存数据。

如何实现

1. 数据量不大时，项目启动时，自动进行初始化
2. 写一个脚本，手动执行它，加载热点数据
3. 写一个管理界面，手动点击，将相应的热点数据写到缓存中</code></pre>
<h1 id="7、Redis常用命令"><a href="#7、Redis常用命令" class="headerlink" title="7、Redis常用命令"></a>7、Redis常用命令</h1><p>管理命令</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta"># dbsize 返回当前数据库 key 的数量。</span></span><br><span class="line"><span class="meta"># info 返回当前 redis 服务器状态和一些统计信息。</span></span><br><span class="line"><span class="meta"># monitor 实时监听并返回redis服务器接收到的所有请求信息。</span></span><br><span class="line"><span class="meta"># shutdown 把数据同步保存到磁盘上，并关闭redis服务。</span></span><br><span class="line"><span class="meta"># config get parameter 获取一个 redis 配置参数信息。（个别参数可能无法获取）</span></span><br><span class="line"><span class="meta"># config set parameter value 设置一个 redis 配置参数信息。（个别参数可能无法获取）</span></span><br><span class="line"><span class="meta"># config resetstat 重置 info 命令的统计信息。（重置包括：keyspace 命中数、</span></span><br><span class="line"><span class="meta"># keyspace 错误数、 处理命令数，接收连接数、过期 key 数）</span></span><br><span class="line"><span class="meta"># debug object key 获取一个 key 的调试信息。</span></span><br><span class="line"><span class="meta"># debug segfault 制造一次服务器当机。</span></span><br><span class="line"><span class="meta"># flushdb 删除当前数据库中所有 key,此方法不会失败。小心慎用</span></span><br><span class="line"><span class="meta"># flushall 删除全部数据库中所有 key，此方法不会失败。小心慎用</span></span><br></pre></td></tr></table></figure>

<h2 id="工具命令"><a href="#工具命令" class="headerlink" title="工具命令"></a>工具命令</h2><figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta">#redis-server：Redis 服务器的 daemon 启动程序</span></span><br><span class="line"><span class="meta">#redis-cli：Redis 命令行操作工具。当然，你也可以用 telnet 根据其纯文本协议来操作</span></span><br><span class="line"><span class="meta">#redis-benchmark：Redis 性能测试工具，测试 Redis 在你的系统及你的配置下的读写性能</span></span><br><span class="line">$redis-benchmark -n <span class="number">100000</span> –c <span class="number">50</span></span><br><span class="line"><span class="meta">#模拟同时由 50 个客户端发送 100000 个 SETs/GETs 查询</span></span><br><span class="line"><span class="meta">#redis-check-aof：更新日志检查</span></span><br><span class="line"><span class="meta">#redis-check-dump：本地数据库检查</span></span><br></pre></td></tr></table></figure>

<h1 id="8、为什么Redis-单线程却能支撑高并发？"><a href="#8、为什么Redis-单线程却能支撑高并发？" class="headerlink" title="8、为什么Redis 单线程却能支撑高并发？"></a>8、为什么Redis 单线程却能支撑高并发？</h1><p>1.redis是基于内存的，内存的读写速度非常快（纯内存）。</p>
<p>2.redis是单线程的，省去了很多上下文切换线程的时间（避免线程切换和竞态消耗）。</p>
<p>3.Redis全程使用hash结构，读取速度快，还有一些特殊的数据结构，对数据存储进行了优化，如压缩表，对短数据进行压缩存储，再如，跳表，使用有序的数据结构加快读取的速度。</p>
<p>4.redis使用多路复用技术，可以处理并发的连接（非阻塞IO）。</p>
<p>多路I/O复用模型是利用select、poll、epoll可以同时监察多个流的IO事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或者多个流的IO事件时，就从阻塞状态中唤醒，于是程序就会轮训一遍所有的流（epoll是只轮训发出了事件的流），并且只一次按顺序的处理就绪的流，这种做法就避免了大量的无用操作，这里的“多路”是指多个网络连接，“复用”是指复用同一个线程，采用多路IO复用技术可以让单个线程高效的处理多个连接请求</p>
<h1 id="9、Redis常见性能问题和解决方案："><a href="#9、Redis常见性能问题和解决方案：" class="headerlink" title="9、Redis常见性能问题和解决方案："></a>9、Redis常见性能问题和解决方案：</h1><p>1).Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以Master最好不要写内存快照。</p>
<p>2).Master AOF持久化，如果不重写AOF文件，这个持久化方式对性能的影响是最小的，但是AOF文件会不断增大，AOF文件过大会影响Master重启的恢复速度。Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化，如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。</p>
<p>3).Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。</p>
<p>4).Redis主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内</p>
<h1 id="10、Redis的并发竞争问题如何解决"><a href="#10、Redis的并发竞争问题如何解决" class="headerlink" title="10、Redis的并发竞争问题如何解决?"></a>10、Redis的并发竞争问题如何解决?</h1><p>Redis为单进程单线程模式，采用队列模式将并发访问变为串行访问。Redis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争，但是在Jedis客户端对Redis进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成。对此有2种解决方法：</p>
<ul>
<li>客户端角度，为保证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。</li>
<li>服务器角度，利用setnx实现锁。</li>
</ul>
<p>注：对于第一种，需要应用程序自己处理资源的同步，可以使用的方法比较通俗，可以使用synchronized也可以使用lock；第二种需要用到Redis的setnx命令，但是需要注意一些问题。</p>
<h1 id="11、说说Redis的内存淘汰策略"><a href="#11、说说Redis的内存淘汰策略" class="headerlink" title="11、说说Redis的内存淘汰策略"></a>11、说说Redis的内存淘汰策略</h1><p><strong>redis 提供 6种数据淘汰策略：</strong></p>
<ol>
<li><strong>volatile-lru</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li>
<li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li>
<li><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li>
<li><strong>allkeys-lru</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）</li>
<li><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</li>
<li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。</li>
</ol>
<p>4.0版本后增加以下两种：</p>
<ol>
<li><strong>volatile-lfu</strong>：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰</li>
<li><strong>allkeys-lfu</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key</li>
</ol>
<h1 id="12、为什么要用-redis-为什么要用缓存？"><a href="#12、为什么要用-redis-为什么要用缓存？" class="headerlink" title="12、为什么要用 redis/为什么要用缓存？"></a>12、为什么要用 redis/为什么要用缓存？</h1><p>主要从“高性能”和“高并发”这两点来看待这个问题</p>
<p><strong>高性能：</strong></p>
<p>假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p>
<p><strong>高并发：</strong></p>
<p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p>
<h1 id="13、为什么要用-redis-而不用-map-guava-做缓存"><a href="#13、为什么要用-redis-而不用-map-guava-做缓存" class="headerlink" title="13、为什么要用 redis 而不用 map/guava 做缓存?"></a>13、为什么要用 redis 而不用 map/guava 做缓存?</h1><p>缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。</p>
<p>使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 或 memcached服务的高可用，整个程序架构上较为复杂。</p>
<h1 id="14、redis-的线程模型"><a href="#14、redis-的线程模型" class="headerlink" title="14、redis 的线程模型"></a>14、redis 的线程模型</h1><p>redis 内部使用文件事件处理器 <code>file event handler</code>，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。</p>
<p>文件事件处理器的结构包含 4 个部分：</p>
<ul>
<li>多个 socket</li>
<li>IO 多路复用程序</li>
<li>文件事件分派器</li>
<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li>
</ul>
<p>多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</p>
<h1 id="15、redis-和-memcached-的区别"><a href="#15、redis-和-memcached-的区别" class="headerlink" title="15、redis 和 memcached 的区别"></a>15、redis 和 memcached 的区别</h1><ol>
<li><strong>redis支持更丰富的数据类型（支持更复杂的应用场景）</strong>：Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。memcache支持简单的数据类型，String。</li>
<li><strong>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中。</strong></li>
<li><strong>集群模式</strong>：memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 redis 目前是原生支持 cluster 模式的.</li>
<li><strong>Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的多路 IO 复用模型。</strong></li>
</ol>
<table>
<thead>
<tr>
<th><strong>对比参数</strong></th>
<th><strong>Redis</strong></th>
<th><strong>Memcached</strong></th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>1、支持内存2、非关系型数据库</td>
<td>1、支持内存2、key-value键值对形式3、缓存系统</td>
</tr>
<tr>
<td>数据存储类型</td>
<td>1、String2、List3、Set4、Hash5、Sort Set [俗称ZSet]</td>
<td>1、文本型2、1进制类型[新版增加]</td>
</tr>
<tr>
<td>查询[操作]类型</td>
<td>1、批量操作2、事务支持[ 虽然是假的事务]3、每个类型不同的CRUD</td>
<td>1、CRUD2、少量的其他命令</td>
</tr>
<tr>
<td>附加功能</td>
<td>1、发布/订阅模式2、主从分区3、序列化支持4、脚本支持[Lua脚本]</td>
<td>1、多线程服务支持</td>
</tr>
<tr>
<td>网络IO模型</td>
<td>1、单进程模式</td>
<td>2、多线程、非阻塞|O模式</td>
</tr>
<tr>
<td>事件库</td>
<td>自封装简易事件库AeEvent</td>
<td>贵族血统的L ibEvent事件库</td>
</tr>
<tr>
<td>|持久化支持</td>
<td>1、RDB2、AOF</td>
<td>不支持</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring</title>
    <url>/2020/10/15/0000.Spring/</url>
    <content><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p>​        Spring 是一个开源框架，是为了解决企业应用程序开发复杂性而创建的（替代更加重量级的企业级Java技术， 尤其是EJB），它完成了大量开发中的通用步骤，留给开发者的仅仅是与特定应用相关的部分，从而大大提高了企业应用的开发效率。</p>
<a id="more"></a>

<h1 id="Spring面试题"><a href="#Spring面试题" class="headerlink" title="Spring面试题"></a>Spring面试题</h1><h1 id="1、什么是-Spring-框架"><a href="#1、什么是-Spring-框架" class="headerlink" title="1、什么是 Spring 框架?"></a>1、什么是 Spring 框架?</h1><p>Spring 是一种轻量级开发框架，旨在提高开发人员的开发效率以及系统的可维护性。Spring 官网：<a href="https://spring.io/%E3%80%82">https://spring.io/。</a></p>
<p>一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助开发。这些模块是：核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。比如：Core Container 中的 Core 组件是Spring 所有组件的核心，Beans 组件和 Context 组件是实现IOC和依赖注入的基础，AOP组件用来实现面向切面编程。</p>
<p>Spring 官网列出的 Spring 的 6 个特征:</p>
<ul>
<li><strong>核心技术</strong> ：依赖注入(DI)，AOP，事件(events)，资源，i18n，验证，数据绑定，类型转换，SpEL。</li>
<li><strong>测试</strong> ：模拟对象，TestContext框架，Spring MVC 测试，WebTestClient。</li>
<li><strong>数据访问</strong> ：事务，DAO支持，JDBC，ORM，编组XML。</li>
<li><strong>Web支持</strong> : Spring MVC和Spring WebFlux Web框架。</li>
<li><strong>集成</strong> ：远程处理，JMS，JCA，JMX，电子邮件，任务，调度，缓存。</li>
<li><strong>语言</strong> ：Kotlin，Groovy，动态语言。</li>
</ul>
<h1 id="2、Spring模块？"><a href="#2、Spring模块？" class="headerlink" title="2、Spring模块？"></a>2、Spring模块？</h1><p>下图对应的是 Spring4.x 版本。目前最新的5.x版本中 Web 模块的 Portlet 组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/spring.jpg"></p>
<ul>
<li><strong>Spring Core：</strong> 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IoC 依赖注入功能。</li>
<li><strong>Spring Aspects</strong> ： 该模块为与AspectJ的集成提供支持。</li>
<li><strong>Spring AOP</strong> ：提供了面向切面的编程实现。</li>
<li><strong>Spring JDBC</strong> : Java数据库连接。</li>
<li><strong>Spring JMS</strong> ：Java消息服务。</li>
<li><strong>Spring ORM</strong> : 用于支持Hibernate等ORM工具。</li>
<li><strong>Spring Web</strong> : 为创建Web应用程序提供支持。</li>
<li><strong>Spring Test</strong> : 提供了对 JUnit 和 TestNG 测试的支持。</li>
</ul>
<h2 id="Spring框架的优点是什么？"><a href="#Spring框架的优点是什么？" class="headerlink" title="Spring框架的优点是什么？"></a>Spring框架的优点是什么？</h2><ul>
<li>轻量：Spring 是轻量的，基本的版本大约2MB。</li>
<li>控制反转：Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。</li>
<li>面向切面的编程(AOP)：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。</li>
<li>容器：Spring 包含并管理应用中对象的生命周期和配置。</li>
<li>MVC框架：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。</li>
<li>事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。</li>
<li>异常处理：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常。</li>
</ul>
<h1 id="3、Spring-IOC-amp-AOP"><a href="#3、Spring-IOC-amp-AOP" class="headerlink" title="3、Spring IOC &amp; AOP"></a>3、Spring IOC &amp; AOP</h1><h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><p>IoC（Inverse of Control:控制反转）是一种<strong>设计思想</strong>，就是 <strong>将原本在程序中手动创建对象的控制权，交由Spring框架来管理。</strong> IoC 在其他语言中也有应用，并非 Spring 特有。 <strong>IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。</strong></p>
<p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 <strong>IoC 容器就像是一个工厂一样，当需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</strong> 在实际项目中一个 Service 类可能有几百甚至上千个类作为它的底层，假如需要实例化这个 Service，可能要每次都要搞清这个 Service 所有底层类的构造函数。如果利用 IoC 的话，只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。</p>
<p><strong>Spring IoC的初始化过程：</strong></p>
<p><strong><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201015160750.png" alt="image.png"></strong></p>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</p>
<p><strong>Spring AOP就是基于动态代理的</strong>，如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用<strong>Cglib</strong> ，这时候Spring AOP会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理。</p>
<p>当然也可以使用 AspectJ ,Spring AOP 已经集成了AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p>
<p>使用 AOP 之后可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。</p>
<h2 id="Spring-AOP-和-AspectJ-AOP-有什么区别？"><a href="#Spring-AOP-和-AspectJ-AOP-有什么区别？" class="headerlink" title="Spring AOP 和 AspectJ AOP 有什么区别？"></a>Spring AOP 和 AspectJ AOP 有什么区别？</h2><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p>
<p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p>
<p>如果切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。</p>
<h1 id="4、Spring-中的-bean-的作用域有哪些"><a href="#4、Spring-中的-bean-的作用域有哪些" class="headerlink" title="4、Spring 中的 bean 的作用域有哪些?"></a>4、Spring 中的 bean 的作用域有哪些?</h1><ul>
<li>singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li>
<li>prototype : 每次请求都会创建一个新的 bean 实例。</li>
<li>request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。</li>
<li>session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。</li>
<li>global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话</li>
</ul>
<h1 id="5、Spring-中的单例-bean-的线程安全问题了解吗？"><a href="#5、Spring-中的单例-bean-的线程安全问题了解吗？" class="headerlink" title="5、Spring 中的单例 bean 的线程安全问题了解吗？"></a>5、Spring 中的单例 bean 的线程安全问题了解吗？</h1><p>大部分时候并没有在系统中使用多线程，所以很少有人会关注这个问题。单例 bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候，对这个对象的非静态成员变量的写操作会存在线程安全问题。</p>
<p>常见的有两种解决办法：</p>
<ol>
<li>在Bean对象中尽量避免定义可变的成员变量（不太现实）。</li>
<li>在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。</li>
</ol>
<h1 id="6、-Component-和-Bean-的区别是什么？"><a href="#6、-Component-和-Bean-的区别是什么？" class="headerlink" title="6、@Component 和 @Bean 的区别是什么？"></a>6、@Component 和 @Bean 的区别是什么？</h1><ol>
<li>作用对象不同: <code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</li>
<li><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中（可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。<code>@Bean</code> 注解通常是在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了Spring这是某个类的示例，当需要用它的时候Spring进行装配加载。</li>
<li><code>@Bean</code> 注解比 <code>Component</code> 注解的自定义性更强，而且很多地方只能通过 <code>@Bean</code> 注解来注册bean。比如当引用第三方库中的类需要装配到 <code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</li>
</ol>
<p><code>@Bean</code>注解使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransferService <span class="title">transferService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码相当于下面的 xml 配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transferService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.acme.TransferServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>下面这个例子是通过 <code>@Component</code> 无法实现的。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line"><span class="function"><span class="keyword">public</span> OneService <span class="title">getService</span>(<span class="params">status</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> (status)  &#123;</span><br><span class="line">        <span class="keyword">when</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> serviceImpl1();</span><br><span class="line">        <span class="keyword">when</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> serviceImpl2();</span><br><span class="line">        <span class="keyword">when</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> serviceImpl3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7、将一个类声明为Spring的-bean-的注解有哪些"><a href="#7、将一个类声明为Spring的-bean-的注解有哪些" class="headerlink" title="7、将一个类声明为Spring的 bean 的注解有哪些?"></a>7、将一个类声明为Spring的 bean 的注解有哪些?</h1><p>一般使用 <code>@Autowired</code> 注解自动装配 bean，要想把类标识成可用于 <code>@Autowired</code> 注解自动装配的 bean 的类,采用以下注解可实现：</p>
<ul>
<li><code>@Component</code> ：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个Bean不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li>
<li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li>
<li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao层。</li>
<li><code>@Controller</code> : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</li>
</ul>
<h1 id="8、Spring-中的-bean-生命周期"><a href="#8、Spring-中的-bean-生命周期" class="headerlink" title="8、Spring 中的 bean 生命周期?"></a>8、Spring 中的 bean 生命周期?</h1><ul>
<li>Bean 容器找到配置文件中 Spring Bean 的定义。</li>
<li>Bean 容器利用 Java Reflection API 创建一个Bean的实例。</li>
<li>如果涉及到一些属性值 利用 <code>set()</code>方法设置一些属性值。</li>
<li>如果 Bean 实现了 <code>BeanNameAware</code> 接口，调用 <code>setBeanName()</code>方法，传入Bean的名字。</li>
<li>如果 Bean 实现了 <code>BeanClassLoaderAware</code> 接口，调用 <code>setBeanClassLoader()</code>方法，传入 <code>ClassLoader</code>对象的实例。</li>
<li>与上面的类似，如果实现了其他 <code>*.Aware</code>接口，就调用相应的方法。</li>
<li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessBeforeInitialization()</code> 方法</li>
<li>如果Bean实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法。</li>
<li>如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。</li>
<li>如果有和加载这个 Bean的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessAfterInitialization()</code> 方法</li>
<li>当要销毁 Bean 的时候，如果 Bean 实现了 <code>DisposableBean</code> 接口，执行 <code>destroy()</code> 方法。</li>
<li>当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。</li>
</ul>
<h1 id="9、SpringMVC-工作原理"><a href="#9、SpringMVC-工作原理" class="headerlink" title="9、SpringMVC 工作原理?"></a>9、SpringMVC 工作原理?</h1><ol>
<li><p>客户端（浏览器）发送请求，直接请求到 <code>DispatcherServlet</code>。</p>
</li>
<li><p><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code>，解析请求对应的 <code>Handler</code>。</p>
</li>
<li><p>解析到对应的 <code>Handler</code>（也就是平常说的 <code>Controller</code> 控制器）后，开始由 <code>HandlerAdapter</code> 适配器处理。</p>
</li>
<li><p><code>HandlerAdapter</code> 会根据 <code>Handler</code>来调用真正的处理器开处理请求，并处理相应的业务逻辑。</p>
</li>
<li><p>处理器处理完业务后，会返回一个 <code>ModelAndView</code> 对象，<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</p>
</li>
<li><p><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</p>
</li>
<li><p><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</p>
</li>
<li><p>把 <code>View</code> 返回给请求者（浏览器）</p>
<h5 id="SpringMVC-的流程"><a href="#SpringMVC-的流程" class="headerlink" title="SpringMVC 的流程"></a>SpringMVC 的流程</h5></li>
</ol>
<pre><code>![image](https://cdn.jsdelivr.net/gh/xray1025/image01/20201015152955.png)





![image](https://cdn.jsdelivr.net/gh/xray1025/image01/20201015153017.png)</code></pre>
<h1 id="10、Spring-框架中用到了哪些设计模式？"><a href="#10、Spring-框架中用到了哪些设计模式？" class="headerlink" title="10、Spring 框架中用到了哪些设计模式？"></a>10、Spring 框架中用到了哪些设计模式？</h1><ul>
<li><strong>工厂设计模式</strong> : Spring使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li>
<li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li>
<li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li>
<li><strong>包装器设计模式</strong> : 项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让可以根据客户的需求能够动态切换不同的数据源。</li>
<li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li>
<li><strong>适配器模式</strong> :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li>
</ul>
<h1 id="11、Spring-管理事务的方式有几种？"><a href="#11、Spring-管理事务的方式有几种？" class="headerlink" title="11、Spring 管理事务的方式有几种？"></a>11、Spring 管理事务的方式有几种？</h1><ol>
<li>编程式事务，在代码中硬编码。(不推荐使用)</li>
<li>声明式事务，在配置文件中配置（推荐使用）</li>
</ol>
<p><strong>声明式事务又分为两种：</strong></p>
<ol>
<li>基于XML的声明式事务</li>
<li>基于注解的声明式事务</li>
</ol>
<h1 id="12、Spring-事务中的隔离级别有哪几种"><a href="#12、Spring-事务中的隔离级别有哪几种" class="headerlink" title="12、Spring 事务中的隔离级别有哪几种?"></a>12、Spring 事务中的隔离级别有哪几种?</h1><p><strong>TransactionDefinition 接口中定义了五个表示隔离级别的常量：</strong></p>
<ul>
<li><strong>TransactionDefinition.ISOLATION_DEFAULT:</strong> 使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.</li>
<li><strong>TransactionDefinition.ISOLATION_READ_UNCOMMITTED:</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></li>
<li><strong>TransactionDefinition.ISOLATION_READ_COMMITTED:</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li>
<li><strong>TransactionDefinition.ISOLATION_REPEATABLE_READ:</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li>
<li><strong>TransactionDefinition.ISOLATION_SERIALIZABLE:</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ul>
<h1 id="13、Spring-事务中哪几种事务传播行为"><a href="#13、Spring-事务中哪几种事务传播行为" class="headerlink" title="13、Spring 事务中哪几种事务传播行为?"></a>13、Spring 事务中哪几种事务传播行为?</h1><p><strong>支持当前事务的情况：</strong></p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_REQUIRED：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li>
<li><strong>TransactionDefinition.PROPAGATION_SUPPORTS：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li><strong>TransactionDefinition.PROPAGATION_MANDATORY：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</li>
</ul>
<p><strong>不支持当前事务的情况：</strong></p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_REQUIRES_NEW：</strong> 创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li>
<li><strong>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：</strong> 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li><strong>TransactionDefinition.PROPAGATION_NEVER：</strong> 以非事务方式运行，如果当前存在事务，则抛出异常。</li>
</ul>
<p><strong>其他情况：</strong></p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_NESTED：</strong> 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</li>
</ul>
<h1 id="14、-Transactional-rollbackFor-Exception-class-注解了解吗？"><a href="#14、-Transactional-rollbackFor-Exception-class-注解了解吗？" class="headerlink" title="14、@Transactional(rollbackFor = Exception.class)注解了解吗？"></a>14、@Transactional(rollbackFor = Exception.class)注解了解吗？</h1><p>Exception分为运行时异常RuntimeException和非运行时异常。事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以保证数据的一致性。</p>
<p>当<code>@Transactional</code>注解作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，也可以在方法级别使用该标注来覆盖类级别的定义。如果类或者方法加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。</p>
<p>在<code>@Transactional</code>注解中如果不配置<code>rollbackFor</code>属性,那么事物只会在遇到<code>RuntimeException</code>的时候才会回滚,加上<code>rollbackFor=Exception.class</code>,可以让事物在遇到非运行时异常时也回滚。</p>
<h1 id="15、Spring如何解决循环依赖"><a href="#15、Spring如何解决循环依赖" class="headerlink" title="15、Spring如何解决循环依赖"></a>15、Spring如何解决循环依赖</h1><h4 id="1、-循环依赖"><a href="#1、-循环依赖" class="headerlink" title="1、 循环依赖"></a>1、 循环依赖</h4><ul>
<li><p>–&gt;循环引用。—&gt;即2个或以上bean 互相持有对方，最终形成闭环。</p>
<p>eg：A依赖B，B依赖C，C又依赖A。【注意：这里不是函数的循环调用【是个死循环，除非有终结条件】，是对象相互依赖关系</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201015150352.png" alt="img"></p>
<h4 id="2、循环依赖的场景？"><a href="#2、循环依赖的场景？" class="headerlink" title="2、循环依赖的场景？"></a>2、循环依赖的场景？</h4><p>①构造器依赖（这个解决不了，具体原因往下看）。</p>
<p>②通过setter循环依赖。（这个可以解决）。</p>
<h4 id="3-如何发现？"><a href="#3-如何发现？" class="headerlink" title="3 如何发现？"></a>3 如何发现？</h4><ul>
<li><p>spring在创建对象之前（对象还未出现）的时候，会将放在一个Set容器里，beanName为key，表示该对象正在被创建中。</p>
</li>
<li><p>如果是构造器依赖，ABC构造器循环依赖，在创建A的时候singletonsCurrentlyInCreation中有A的beanName，然后发现需要B对象，先获取B，发现B不存在，那么继续创建B，先在singletonsCurrentlyInCreation中存放B的beanName，然后发现创建B对象的时候，需要先创建C，继续查询C，发现C不存在，那么现在singletonsCurrentlyInCreation中存放C的beanName，但是创建C的时候发现需要先创建A，获取A的时候spring发现singletonsCurrentlyInCreation存在A的beanName，那么表示A当前正在被创建中，spring抛出异常。</p>
</li>
</ul>
<h4 id="4-如何解决？"><a href="#4-如何解决？" class="headerlink" title="4.如何解决？"></a>4.如何解决？</h4><p>之前说到构造器依赖的时候，ABC创建失败的原因是因为A创建对象需要B，B创建对象需要C，C创建对象需要A，这个需求是在ABC都还未创建就彼此需要，彼此发现对象都不存在，所以才被抛出异常。</p>
<p>如但是通过setter的循环依赖，可以避免这个错误。</p>
<p>因为spring的创建分为3步。</p>
<p><img src="https://www.pianshen.com/images/544/0d52e6561321baa378f949ae43fab9e0.png" alt="img"></p>
<p>①createBeanInstance：初始化对象，类似于clazz.newInstance()</p>
<p>②populateBean：填充属性，bean的对象依赖属性就是在这一步进行填充</p>
<p>③initializeBean：调用spring配置中的init-method方法</p>
<p>经过上述三步，一个spring的bean才被完全创建。setter形式的循环依赖出现在第一步跟第二步之间，所以spring在存放bean的时候做了一点文章。</p>
<p>spring将单例bean的存放利用三个hashmap作为三个级别的缓存解决循环引用问题。</p>
<h4 id="5-三级缓存"><a href="#5-三级缓存" class="headerlink" title="5 三级缓存"></a>5 三级缓存</h4><p>三级缓存源码主要是指：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Cache of singleton objects: bean name --&gt; bean instance */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;(<span class="number">256</span>);</span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name --&gt; ObjectFactory */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;String, ObjectFactory&lt;?&gt;&gt;(<span class="number">16</span>);</span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name --&gt; bean instance */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;String, Object&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<p>这三级缓存分别指：</p>
<ul>
<li>一级缓存：singletonObjects，存放完全实例化属性赋值完成的Bean，直接可以使用。</li>
<li>二级缓存：earlySingletonObjects，存放早期Bean的引用，尚未属性装配的Bean</li>
<li>三级缓存：singletonFactories，存放实例化完成的Bean工厂。</li>
</ul>
<h4 id="6-解决"><a href="#6-解决" class="headerlink" title="6 解决"></a>6 解决</h4><ul>
<li><p>bean对象填充属性的时候，先判断该bean对象是否为单例，并且是否允许提前暴露（一般都为true），如果条件都符合，则调用addSingletonFactory方法，将创建改bean对象的工厂类存存放到第三级缓存registeredSingletons中，然后如果创建过程中，该bean对象完整创建，那么该对象会被registeredSingletons移除 然后加入到一级缓存singletonObjects中。</p>
</li>
<li><p>但是如果这个时候对象创建出现了循环引用，用之前的ABC对象举例。A对象装配之前，先讲自己的对象引用存放三级缓存中registeredSingletons然后，然后发现需要对象B，调用getSingleton(B)方法，获取B的过程，先去一级缓存中查询，如果没找到，再去二级缓存，三级缓存，这个时候因为B还没有创建，所以需要创建B对象，这个时候重复之前创建A的过程，B对象先将自己的对象引用存放到registeredSingletons中 然后，装配B对象，发现这个时候需要对象C，同理，先创建C。</p>
</li>
<li><p>注意！这个时候循环引用出现了，C的创建时需要装配A的，所以利索当然的调用getSingleton(A)方法，但是之前A虽然没有创建完全，不存在一级缓存singletonObjects,但是A的对象引用存在三级缓存registeredSingletons中，C获取到A之后，讲A从三级缓存registeredSingletons中删除，移到二级缓存earlySingletonObjects中，然后C创建完成，放置一级缓存singletonObjects中，B也创建完成，放置一级缓存singletonObjects中，随后A也创建完成，放置一级缓存singletonObjects中。</p>
</li>
</ul>
<p>循环引用的问题就此解决。</p>
<h1 id="16、Spring初始化过程？"><a href="#16、Spring初始化过程？" class="headerlink" title="16、Spring初始化过程？"></a>16、Spring初始化过程？</h1><p>在传统的Java应用中，Bean的生命周期非常简单。Java的关键词new用来实例化Bean（或许他是非序列化的）。这样就够用了。相反，Bean 的生命周期在spring容器中更加细致。理解Spring Bean的生命周期非常重要，或许要利用Spring提供的机会来订制Bean的创建过程。</p>
<p>1.容器寻找Bean的定义信息并且将其实例化。</p>
<p>2.使用依赖注入，Spring按照Bean定义信息配置Bean的所有属性。</p>
<p>3.如果Bean实现了BeanNameAware接口，工厂调用Bean的setBeanName()方法传递Bean的ID。</p>
<p>4.如果Bean实现了BeanFactoryAware接口，工厂调用setBeanFactory()方法传入工厂自身。</p>
<p>5.如果BeanPostProcessor和Bean关联，那么它们的postProcessBeforeInitialzation()方法将被调用。</p>
<p>6.如果Bean指定了init-method方法，它将被调用。</p>
<p>7.最后，如果有BeanPsotProcessor和Bean关联，那么它们的postProcessAfterInitialization()方法将被调用。</p>
<p>到这个时候，Bean已经可以被应用系统使用了，并且将被保留在Bean Factory中知道它不再需要。有两种方法可以把它从Bean Factory中删除掉。</p>
<p>1.如果Bean实现了DisposableBean接口，destory()方法被调用。</p>
<p>2.如果指定了订制的销毁方法，就调用这个方法。</p>
<p>Bean在Spring应用上下文的生命周期与在Bean工厂中的生命周期只有一点不同，唯一不同的是，如果Bean实现了ApplicationContextAwre接口，setApplicationContext()方法被调用。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2020/08/24/0000.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="0-设计模式"><a href="#0-设计模式" class="headerlink" title="0 设计模式"></a>0 设计模式</h1><pre><code>一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案

本质是面向对象设计原则的实际应用</code></pre>
<a id="more"></a>

<h2 id="0-1-分类"><a href="#0-1-分类" class="headerlink" title="0.1 分类"></a>0.1 分类</h2><p><strong>创建型模式：</strong></p>
<ul>
<li>单例模式<ul>
<li>工厂模式</li>
<li>抽象工厂模式 </li>
<li>建造者模式 </li>
<li>原型模式</li>
</ul>
</li>
</ul>
<p><strong>结构型模式：</strong></p>
<ul>
<li>适配器模式</li>
<li>桥接模式</li>
<li>装饰模式</li>
<li>组合模式</li>
<li>外观模式</li>
<li>享元模式</li>
<li>代理模式</li>
</ul>
<p><strong>行为型模式：</strong></p>
<ul>
<li>模板方法模式</li>
<li>命令模式</li>
<li>迭代器模式</li>
<li>观察者模式</li>
<li>中介者模式</li>
<li>备忘录模式</li>
<li>解释器模式</li>
<li>状态模式</li>
<li>策略模式</li>
<li>职责链模式</li>
<li>访问者模式</li>
</ul>
<h2 id="0-2-OOP七大原则"><a href="#0-2-OOP七大原则" class="headerlink" title="0.2 OOP七大原则"></a>0.2 OOP七大原则</h2><p><strong>开闭原则：</strong> 对扩展开放，对修改关闭；<br><strong>里氏替换原则：</strong> 继承必须确保超类拥有的性质在子类中仍然成立；<br><strong>依赖倒置原则：</strong> 面向接口编程，而不是面向实现编程；<br><strong>单一职责原则：</strong> 控制类的粒度大小，将对象解耦，提高内聚性；<br><strong>接口隔离原则：</strong> 为类建立需要的专用接口；<br><strong>迪米特法则：</strong> 只与直接朋友交谈；<br><strong>合成复用原则：</strong> 优先使用组合、聚合等关联关系，其次才考虑使用继承实现。</p>
<h2 id="0-3-UML类图"><a href="#0-3-UML类图" class="headerlink" title="0.3 UML类图"></a>0.3 UML类图</h2><pre><code>UML（unified modeling language） 统一建模语言</code></pre>
<ul>
<li>note 注释</li>
<li>class 类</li>
<li>interface 接口</li>
<li>dependency 依赖：一种使用的关系，即一个类的实现需要另一个类的协助</li>
<li>association 关联：一个类知道另一个类的属性和方法</li>
<li>generalization 泛化（继承）：指定子类如何特化父类所以的特征和行为</li>
<li>realization 实现：表示类是接口所有特征和行为的表现</li>
<li>aggregation 聚合：整体与部分的关系，并且部分可以离开整体而单独存在</li>
<li>composite 组合：整体与部分的关系，并且部分不可以离开整体而单独存在</li>
</ul>
<figure class="highlight fix"><table><tr><td class="code"><pre><span class="line"><span class="attr">泛化 </span>=<span class="string"> 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖</span></span><br></pre></td></tr></table></figure>

<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><h2 id="为什么用工厂模式"><a href="#为什么用工厂模式" class="headerlink" title="为什么用工厂模式"></a>为什么用工厂模式</h2><ul>
<li><p><strong>工厂模式都需要依赖接口</strong>，主体对象通过接口规定的方法获取对象，具体的实现逻辑由实现类完成，当实现逻辑变化时只需要修改实现类即可，达到了解耦的目的</p>
</li>
<li><p>降低重复代码，把创建过程统一管理方便维护</p>
</li>
<li><p>使用者不需要知道具体创建过程</p>
</li>
<li><p><strong>Spring源码中所有Bean的创建在源码中是简单工厂模式</strong>(不属于23种GOF设计模式之一)</p>
</li>
<li><ul>
<li>主体对象根据接口定义的方法调用，具体的实现逻辑由Spring源码完成，实现逻辑如下：</li>
<li>getBean-&gt;doGetBean-&gt;creatBean-&gt;doCreatBean-&gt;instantiateBean</li>
<li>具体的实例化操作由InstantiationStrategy接口规定，实现类调用instantiate()完成实例化，根据是否有方法需要被重写(是否使用方法注入)决定使用JDK的实例化方式(BeanUtils.<em>instantiateClass</em>(ctor))还是CGLIB的生成子类的实例化方法</li>
<li>本质还是调用某个方法返回一个对象</li>
</ul>
</li>
</ul>
<h2 id="还可以防止this引用逃逸"><a href="#还可以防止this引用逃逸" class="headerlink" title="还可以防止this引用逃逸"></a>还可以防止this引用逃逸</h2><ul>
<li><p>什么是this引用逃逸：</p>
</li>
<li><ul>
<li>在构造器构造还未彻底完成前（即实例初始化阶段还未完成），将自身this引用向外抛出并被其他线程复制（访问）了该引用，可能会问到该还未被初始化的变量，甚至可能会造成更大严重的问题</li>
<li>常见this引用逃逸错误：在构造函数中启动一个线程，当对象在其构造函数中创建一个线程时，this引用会被新创建的线程共享，在对象尚未完全构造之前，新的线程就可以看件它了。这一点和单例模式中使用不使用volatile会出现的问题类似，都是没有完全初始化好就被发现了</li>
<li>只有当构造函数返回时，this引用才应该从线程中逸出</li>
</ul>
</li>
<li><p>this引用逃逸发生的两个必要条件</p>
</li>
<li><ul>
<li>在构造函数中创建内部类</li>
<li>在构造函数中发布这个内部类</li>
</ul>
</li>
<li><p>错误示例伪码：构造过程中this逸出</p>
</li>
<li><ul>
<li>下面代码中初始化了事件监听器，事件监听器一旦注册成功，就能够监听用户的操作，调用对应的回调函数，比如监听到了e这个事件，那么就会执行doSomething()回调函数，函数中返回的是addListener的变量var，由于接受到监听事件是在构造函数中，所以很可能接受到事件时，var的值还没有在构造器中初始化完成，就会导致doSomething方法返回的值可能是0，也可能是10</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">getListener</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="keyword">var</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">getListener</span><span class="params">(EventSource source)</span></span>&#123;</span><br><span class="line">        <span class="comment">//注册事件，会一直监听，当发生事件e时，会执行回调函数doSomething</span></span><br><span class="line">        source.registerListener(</span><br><span class="line">            <span class="comment">//匿名内部类实现</span></span><br><span class="line">            <span class="keyword">new</span> EventListener()&#123;</span><br><span class="line">                <span class="comment">//此时getListener可能还未初始化完成，onEvent()中就持有this指针，有可能发生严重错误</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event e)</span></span>&#123;</span><br><span class="line">                    doSomething(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="keyword">var</span>=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doSomething</span><span class="params">(Event e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">var</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用工厂方法解决</p>
</li>
<li><ul>
<li>构造函数私有，有一个public的方法返回监听器，而不是上面的使用构造函数构造一个监听器对象</li>
</ul>
</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> SafeListener &#123;</span><br><span class="line">  <span class="keyword">private</span> final EventListener listener;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="constructor">SafeListener()</span> &#123;</span><br><span class="line">    listener = <span class="keyword">new</span> <span class="constructor">EventListener()</span> &#123;</span><br><span class="line">      public void on<span class="constructor">Event(Event <span class="params">e</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">do</span><span class="constructor">Something(<span class="params">e</span>)</span>;</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public static SafeListener <span class="keyword">new</span><span class="constructor">Instance(EventSource <span class="params">source</span>)</span> &#123;</span><br><span class="line">    SafeListener safe = <span class="keyword">new</span> <span class="constructor">SafeListener()</span>;</span><br><span class="line">    source.register<span class="constructor">Listener(<span class="params">safe</span>.<span class="params">listener</span>)</span>;</span><br><span class="line">    return safe;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h1><p><strong><a href="https://www.infoq.cn/article/double-checked-locking-with-delay-initialization/">双重检查锁定详细描述</a></strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Single</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Single instance=<span class="literal">null</span>;<span class="comment">//volatile必须有</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single</span>(<span class="params"></span>)</span>&#123;&#125;<span class="comment">//不给外界暴漏构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">null</span>)&#123;<span class="comment">//已经完成对象创建后不用再执行synchronized了，节省性能</span></span><br><span class="line">            synchronized (Single.class)&#123;</span><br><span class="line">                <span class="comment">//防止执行完if(s==null)后进入同步代码块前还有另一个线程也在同一位置，所有需要再判断一次防止写两次</span></span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="literal">null</span>)&#123;</span><br><span class="line">                    instance=<span class="keyword">new</span> Single();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">demo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String args[]</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(Single.getInstance());<span class="comment">//Single@677327b6</span></span><br><span class="line">        System.<span class="keyword">out</span>.println(Single.getInstance());<span class="comment">//Single@677327b6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="为什么使用volatile"><a href="#为什么使用volatile" class="headerlink" title="为什么使用volatile"></a>为什么使用volatile</h2><ul>
<li><p><strong>synchronized可以保证代码块的原子性和可见性，但是不能保证包裹的代码块内部的有序性</strong></p>
</li>
<li><ul>
<li>new一个对象，new Single可以分为三步</li>
</ul>
</li>
</ul>
<ol>
<li><ol>
<li><ol>
<li>分配对象的内存空间</li>
<li>初始化对象</li>
<li>设置 instance 指向刚分配的内存地址</li>
</ol>
</li>
</ol>
</li>
</ol>
<ul>
<li><ul>
<li>如果没有volatile修饰该对象，则<strong>这三步可能会发生重排序</strong>，变成</li>
</ul>
</li>
</ul>
<ol>
<li><ol>
<li><ol>
<li>分配对象的内存空间</li>
<li>设置 instance 指向刚分配的内存地址</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><strong>如果这里跳转到另外的线程了，**</strong>会发现instance!=null，那么就会return instance，但是此时instance还没有初始化**</p>
<ol>
<li><ol>
<li><ol>
<li>初始化对象</li>
</ol>
</li>
</ol>
</li>
</ol>
<ul>
<li><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1587288097853-b6000c80-20fb-4d42-b4b3-dd4c215c2ed1.png" alt="image.png"></li>
</ul>
</li>
</ul>
<h2 id="Spring中的单例设计模式"><a href="#Spring中的单例设计模式" class="headerlink" title="Spring中的单例设计模式"></a>Spring中的单例设计模式</h2><p>此处为语雀文档，点击链接查看：<a href="https://www.yuque.com/luka/note/beanfactory#EvQuu">https://www.yuque.com/luka/note/beanfactory#EvQuu</a></p>
<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><ul>
<li><p>适配器模式(adapter pattern)：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，在适配器模式中，通过增加一个新的适配器类来解决接口不兼容的问题，使得原本没有任何关系的类可以协同工作</p>
</li>
<li><p>根据适配器类与适配者类的关系不同，适配器模式可分为对象适配器和类适配器两种</p>
</li>
<li><ul>
<li>在<strong>类适配器模式</strong>中，适配器与适配者之间是<strong>继承</strong>(或实现)关系</li>
<li>在<strong>对象适配器模式</strong>中，适配器与适配者之间是<strong>关联</strong>关系</li>
</ul>
</li>
</ul>
<h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ul>
<li>Target（目标抽象类）：目标抽象类定义客户所需接口，被客户直接访问，可以是一个抽象类或接口，也可以是具体类</li>
<li>Adapter（适配器类）：适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过实现Target接口并继承/关联一个Adaptee对象使二者产生联系</li>
<li>Adaptee（适配者类）：适配者类作为被适配的角色，它定义了一个已经存在的功能接口(旧方法)，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码</li>
</ul>
<h2 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1587457070222-66c806e1-7d30-4d90-a205-b9c12643c754.png" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//已经存在的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adapteeRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;适配者的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//目标类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//适配器类模式，实现Target接口，继承Adaptee</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="comment">//Target接口中规定的方法，会被用户直接访问的</span></span><br><span class="line">    <span class="comment">//方法内部回调用Adaptee类的方法，所以起到了中转适配的作用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...一些操作...</span></span><br><span class="line">        <span class="keyword">super</span>.adapteeRequest();</span><br><span class="line">        <span class="comment">//...一些操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h2><ul>
<li>对象适配器与类适配器不同之处在于，类适配器通过继承来完成适配，对象适配器则是通过关联来完成</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1587457308209-31e42c9e-b26a-4a6a-bcf1-be0d0141f8c2.png" alt="image.png"></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="comment">// 适配者是对象适配器的一个属性</span></span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee = <span class="keyword">new</span> Adaptee();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        adaptee.adapteeRequest();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="适配器模式总结"><a href="#适配器模式总结" class="headerlink" title="适配器模式总结"></a>适配器模式总结</h2><p>优点：</p>
<ul>
<li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构</li>
<li>增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用</li>
<li>类适配器模式：由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强</li>
<li>对象适配器模式：一个对象适配器可以把多个不同的适配者适配到同一个目标，</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>类适配器模式：</p>
</li>
<li><ul>
<li>目标抽象类只能为接口，不能为类，有一定的局限性</li>
<li>Java只能单继承，类适配器模式中一次只能适配一个适配类(adaptee)</li>
</ul>
</li>
<li><p>对象适配器模式：</p>
</li>
<li><ul>
<li>与类适配器模式相比，要在适配器中置换适配者类的某些方法比较麻烦，没有子类那么方便</li>
</ul>
</li>
</ul>
<p>适用场景：</p>
<ul>
<li>系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要，甚至没有这些类的源代码</li>
</ul>
<h2 id="Spring中的适配器模式"><a href="#Spring中的适配器模式" class="headerlink" title="Spring中的适配器模式"></a>Spring中的适配器模式</h2><p>详见AOP模块</p>
<p>此处为语雀文档，点击链接查看：<a href="https://www.yuque.com/luka/note/aop#GMj1r">https://www.yuque.com/luka/note/aop#GMj1r</a></p>
<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>代理模式分为静态代理和动态代理</p>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>假设现在项目经理有一个需求：在项目现有所有类的方法前后打印日志。</p>
<p>如何在不修改已有代码的前提下，完成这个需求？</p>
<p>首先想到的是静态代理。具体做法是：</p>
<p>1.为现有的每一个类都编写一个对应的代理类，并且让它实现和目标类相同的接口（假设都有）</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1266758/1586510323777-262ad8b5-2cc2-4376-8109-057025883c6d.jpg" alt="image"></p>
<p>2.在创建代理对象时，通过<strong>构造器塞入一个目标对象</strong>，然后在<strong>代理对象的方法内部调用目标对象同名方法</strong>，并在<strong>调用前后打印日志</strong>。</p>
<p>   也就是说，代理对象 = 增强代码 + 目标对象（原对象）。有了代理对象后，就不用原对象了</p>
<p>   <img src="https://cdn.nlark.com/yuque/0/2020/jpg/1266758/1586510323900-47b5fb3f-65f3-48d3-b339-9532b54da2bb.jpg" alt="image"></p>
<h3 id="静态代理的缺陷"><a href="#静态代理的缺陷" class="headerlink" title="静态代理的缺陷"></a>静态代理的缺陷</h3><p><strong>程序员要手动为每一个目标类编写对应的代理类</strong>。如果当前系统已经有成百上千个类，工作量太大了。所以，现在我们的努力方向是：如何少写或者不写代理类，却能完成代理功能？</p>
<ul>
<li><strong>能否不写代理类，而直接得到代理Class对象，然后根据它创建代理实例（反射）。</strong></li>
</ul>
<p>Class对象包含了一个类的所有信息，比如构造器、方法、字段等。如果我们不写代理类，这些信息从哪获取呢？苦思冥想，突然灵光一现：代理类和目标类理应实现同一组接口。<strong>之所以实现相同接口，是为了尽可能保证代理对象的内部结构和目标对象一致，这样我们对代理对象的操作最终都可以转移到目标对象身上，代理对象只需专注于增强代码的编写</strong>。<strong>同时，代理类必须继承Proxy类，所以只能且必须和目标类实现同一组接口。</strong>所以，可以这样说：<strong>接口拥有代理对象和目标对象共同的类信息</strong>。所以，我们可以从接口那得到理应由代理类提供的信息。<strong>但是别忘了，接口是无法创建对象的，怎么办？</strong></p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>介绍动态代理前可以看看这个关于<a href="https://blog.csdn.net/zxysshgood/article/details/78684229">源码</a>的分析，还包括代理类的反汇编。</p>
<p>JDK提供了java.lang.reflect.InvocationHandler接口和 java.lang.reflect.Proxy类，这两个类相互配合，入口是Proxy，所以我们先聊它。</p>
<p><strong>Proxy有个静态方法：getProxyClass(ClassLoader, interfaces)，只要你给它传入类加载器和一组接口，它就给你返回代理Class对象</strong>。</p>
<p>用通俗的话说，<strong>getProxyClass()这个方法，会从你传入的接口Class中，“拷贝”类结构信息到一个新的Class对象中，但新的Class对象带有构造器，是可以创建对象的。</strong>打个比方，一个大内太监（接口Class），空有一身武艺（类信息），但是无法传给后人。现在江湖上有个妙手神医（Proxy类），发明了克隆大法（getProxyClass），不仅能克隆太监的一身武艺，还保留了小DD（构造器）…</p>
<p>所以，一旦我们明确接口，完全可以通过接口的Class对象，创建一个代理Class，通过代理Class即可创建代理对象。</p>
<p>所以，按我理解，Proxy.getProxyClass()这个方法的本质就是：以Class造Class。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1266758/1586510323966-94f8f8dd-d037-47f9-8269-d6a988902966.jpg" alt="image"></p>
<h3 id="静态代理和动态代理的区别"><a href="#静态代理和动态代理的区别" class="headerlink" title="静态代理和动态代理的区别"></a>静态代理和动态代理的区别</h3><p>静态代理</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1266758/1586510324027-f6541a6c-3bf7-4ce9-9611-e830a4c78300.jpg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<p>动态代理</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1266758/1586510324122-a22bb377-9228-49ad-bb69-8e2617ff31b3.jpg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<h3 id="使用getProxyClass完成动态代理"><a href="#使用getProxyClass完成动态代理" class="headerlink" title="使用getProxyClass完成动态代理"></a>使用getProxyClass完成动态代理</h3><p>1.基于Calculator类和Calculator接口创建的calculatorProxyClazz代理class</p>
<p>2.获取代理Class的构造器</p>
<p>3.使用构造器创建一个代理对象(构造器的参数是InvocationHandler接口的对象)</p>
<p>4.InvocationHandler接口的对象必须重写invoke方法，实现对目标对象的增强</p>
<p>5.代理对象可调用的方法与目标对象的方法一致</p>
<p>6.每次调用代理对象的方式时，最终都会调用InvocationHandler的invoke()方法</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1266758/1586510324177-6989ebdc-44f7-4d49-beee-bd9f06407339.jpg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_14,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1266758/1586510324241-fdc9029c-5865-4f3d-b6db-cbe9857f2153.jpg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_14,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<ul>
<li>怎么实现的呢？</li>
</ul>
<p>上面说的根据代理Class的构造器创建对象时，需要传入InvocationHandler。<strong>通过构造器传入一个引用，那么必然有个成员变量去接收。</strong>代理对象内部有InvocationHandler的成员变量，变量名为h(继承自父类Proxy的)，而且代理对象的每个方法内部都会调用h.invoke()。InvocationHandler对象成了代理对象和目标对象的桥梁，不像静态代理这么直接。</p>
<ul>
<li>上面超链接的代理类反汇编：</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">printSomeThing</span><span class="params">(<span class="keyword">String</span> paramString)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">new</span> Object[] &#123; paramString &#125;);</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Error|RuntimeException localError) &#123;</span><br><span class="line">        <span class="keyword">throw</span> localError;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable localThrowable) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="静态代理和动态代理调用方法的区别"><a href="#静态代理和动态代理调用方法的区别" class="headerlink" title="静态代理和动态代理调用方法的区别"></a>静态代理和动态代理调用方法的区别</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1266758/1586510324286-8efc8def-4901-446a-8c1c-d50487b09c3f.jpg" alt="image"></p>
<p>仔细看上图右侧的动态代理，我在invocationHandler的invoke()方法中并没有写目标对象。因为一开始invocationHandler的invoke()里确实没有目标对象，需要我们手动new。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1266758/1586510324328-487f763e-6177-4955-a827-b62355826b16.jpg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_14,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<p>但这种写法不够优雅，属于硬编码。我这次代理A对象，下次想代理B对象还要进来改invoke()方法，太差劲了。改进一下，让调用者把目标对象作为参数传进来：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> ProxyTest &#123;</span><br><span class="line">        public static void main(String<span class="literal">[]</span> args) throws Throwable &#123;</span><br><span class="line">            CalculatorImpl target = <span class="keyword">new</span> <span class="constructor">CalculatorImpl()</span>;</span><br><span class="line">            <span class="comment">//传入目标对象</span></span><br><span class="line">            <span class="comment">//目的：1.根据它实现的接口生成代理对象 2.代理对象调用目标对象方法</span></span><br><span class="line">            Calculator calculatorProxy = (Calculator) get<span class="constructor">Proxy(<span class="params">target</span>)</span>;</span><br><span class="line">            calculatorProxy.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">            calculatorProxy.subtract(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span> static Object get<span class="constructor">Proxy(<span class="params">final</span> Object <span class="params">target</span>)</span> throws Exception &#123;</span><br><span class="line">        <span class="comment">//参数1：随便找个类加载器给它， 参数2：目标对象实现的接口，让代理对象实现相同接口</span></span><br><span class="line">        Class proxyClazz = <span class="module-access"><span class="module"><span class="identifier">Proxy</span>.</span></span>get<span class="constructor">ProxyClass(<span class="params">target</span>.<span class="params">getClass</span>()</span>.get<span class="constructor">ClassLoader()</span>, target.get<span class="constructor">Class()</span>.get<span class="constructor">Interfaces()</span>);</span><br><span class="line">        Constructor constructor = proxyClazz.get<span class="constructor">Constructor(InvocationHandler.<span class="params">class</span>)</span>;</span><br><span class="line">        Object proxy = constructor.<span class="keyword">new</span><span class="constructor">Instance(<span class="params">new</span> InvocationHandler()</span> &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Object invoke(Object proxy, Method <span class="keyword">method</span>, Object<span class="literal">[]</span> args) throws Throwable &#123;</span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="keyword">method</span>.get<span class="constructor">Name()</span> + <span class="string">&quot;方法开始执行...&quot;</span>);</span><br><span class="line">                Object result = <span class="keyword">method</span>.invoke(target, args);</span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(result);</span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="keyword">method</span>.get<span class="constructor">Name()</span> + <span class="string">&quot;方法执行结束...&quot;</span>);</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return proxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>这样就非常灵活，非常优雅了。无论现在系统有多少类，只要你<strong>把实例传进来，getProxy()都能给你返回对应的代理对象</strong>。就这样，我们完美地跳过了代理类，直接创建了代理对象！</p>
<p>不过实际编程中，一般不用getProxyClass()，而是使用Proxy类的另一个静态方法：Proxy.newProxyInstance()，直接返回代理实例，连中间得到代理Class对象的过程都帮你隐藏：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> ProxyTest &#123;</span><br><span class="line">        <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) throws Throwable &#123;</span><br><span class="line">            CalculatorImpl target = <span class="built_in">new</span> CalculatorImpl();</span><br><span class="line">            Calculator calculatorProxy = (Calculator) getProxy(target);</span><br><span class="line">            calculatorProxy.<span class="keyword">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">            calculatorProxy.subtract(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        private static <span class="keyword">Object</span> getProxy(final <span class="keyword">Object</span> target) throws <span class="keyword">Exception</span> &#123;</span><br><span class="line">            <span class="keyword">Object</span> proxy = Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(),<span class="comment">/*类加载器*/</span></span><br><span class="line">                target.getClass().getInterfaces(),<span class="comment">/*让代理对象和目标对象实现相同接口*/</span></span><br><span class="line">                <span class="built_in">new</span> InvocationHandler()&#123;<span class="comment">/*代理对象的方法最终都会被JVM导向它的invoke方法*/</span></span><br><span class="line">                    <span class="built_in">public</span> <span class="keyword">Object</span> invoke(<span class="keyword">Object</span> proxy, <span class="keyword">Method</span> <span class="keyword">method</span>, <span class="keyword">Object</span>[] args) throws Throwable &#123;</span><br><span class="line">                        <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="keyword">method</span>.getName() + &quot;方法开始执行...&quot;);</span><br><span class="line">                        <span class="keyword">Object</span> result = <span class="keyword">method</span>.invoke(target, args);</span><br><span class="line">                        <span class="keyword">System</span>.<span class="keyword">out</span>.println(result);</span><br><span class="line">                        <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="keyword">method</span>.getName() + &quot;方法执行结束...&quot;);</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">return</span> proxy;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h3 id="动态代理总结"><a href="#动态代理总结" class="headerlink" title="动态代理总结"></a>动态代理总结</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1266758/1586510324382-164e0b9b-9a82-43fc-bdce-6bdcefa1a627.jpg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<p><strong>补充：InvocationHandler</strong></p>
<p>   0.Java动态代理机制中有两个重要的类和接口InvocationHandler（接口）和Proxy（类），这一个类Proxy和接口InvocationHandler是实现动态代理的核心</p>
<p>   1.InvocationHandler接口是proxy代理实例的调用处理程序实现的一个接口，每一个proxy代理实例都有一个关联的调用处理程序；在代理实例调用方法时，方法调用被编码分派到调用处理程序的invoke方法</p>
<p>   <img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1586510324427-b0de2672-f514-45e1-bb7d-0fc95a53396a.png" alt="image"></p>
<p>   2.<strong>每一个动态代理类的调用处理程序都必须实现InvocationHandler接口</strong>，<strong>并且每个代理类的实例都关联到了实现该接口的动态代理类调用处理程序中</strong>，当我们通过动态代理对象调用一个方法时候，这个方法的调用就会被转发到实现InvocationHandler接口类的invoke方法来调用</p>
<p>   <strong>代理对象中拥有原对象的所有方法，这些方法只少有一行，使用InvocationHandler对象h调用invoke的语句，具体的增强和调用原对象的对应方法由InvocationHandler实现类完成：</strong></p>
<p>​     <img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1586510324464-81e23b07-3745-4808-8035-f163a6540dcf.png" alt="image"></p>
<p>​     调用invoke是会携带Method信息，invoke会在增强中调用原方法</p>
<p>   3.<strong>Proxy类</strong>就是用来<strong>创建一个代理对象的类</strong>，它提供了很多方法，但是我们最常用的是newProxyInstance方法</p>
<h3 id="动态代理的应用"><a href="#动态代理的应用" class="headerlink" title="动态代理的应用"></a>动态代理的应用</h3><ul>
<li>Spring AOP</li>
<li>RPC框架 Dubbo</li>
<li>断路器 Spring Cloud Hystrix</li>
<li>Mock单元测试</li>
</ul>
<h1 id="适配器模式和代理模式的区别"><a href="#适配器模式和代理模式的区别" class="headerlink" title="适配器模式和代理模式的区别"></a>适配器模式和代理模式的区别</h1><ul>
<li>适配器模式：本质上是将一个旧接口换成一个新接口，对原有方法进行增强，用户调用时调用新接口的方法。原接口功能由新接口实现类进行调用</li>
<li>代理模式：代理模式没有产生新接口，而是实现了原接口，并且返回一个代理对象给调用者。而CGLIB创建子类代理对象的方法也是一样，用的还是原来的接口</li>
<li>目的不完全一样：除了都能原有功能进行增强外，适配器模式初心是旧接口不满足需求，使用适配器完成新旧接口的转换，而代理模式是为了不让用户直接接触原对象，返回一个代理对象给用户调用</li>
</ul>
<h2 id="适配器模式示意图"><a href="#适配器模式示意图" class="headerlink" title="适配器模式示意图"></a>适配器模式示意图</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1266758/1587472095548-2b6da71c-9bec-4cbd-bf11-a67d74f8122e.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="1.jpg"></p>
<h2 id="代理模式示意图"><a href="#代理模式示意图" class="headerlink" title="代理模式示意图"></a>代理模式示意图</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1266758/1587472117679-1440a002-1ad3-4173-ad0c-3918c0e4ee38.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="2.jpg"></p>
<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><ul>
<li>策略模式：策略模式是对算法的包装，把使用算法的责任和算法本身分隔开，委派给不同的对象管理。策略模式通常把一系列的算法包装到一系列的策略类里面，作为一个抽象策略类的子类</li>
<li>主要解决：在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护</li>
<li>使用时机：一个系统有多个类，而区分它们的只是他们直接的行为</li>
<li>解决方式：将这些算法封装成一个一个的类，任意地替换</li>
<li>关键特点：实现同一个接口</li>
<li>优点：1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好</li>
</ul>
<h2 id="Spring中的策略模式"><a href="#Spring中的策略模式" class="headerlink" title="Spring中的策略模式"></a>Spring中的策略模式</h2><h3 id="实例化的策略模式"><a href="#实例化的策略模式" class="headerlink" title="实例化的策略模式"></a>实例化的策略模式</h3><ul>
<li><p>Spring实例化Bean时会判断设置的哪种实例化策略：getInstantiationStrategy()方法，而setInstantiationStrategy()方法是public的可以由用户选择实例化策略。默认的是Cglib方式实例化，但是如果没使用方法注入则仍然使用JDK方式初始化</p>
</li>
<li><p>实例化策略有两种</p>
</li>
<li><ul>
<li>一种使用JDK的反射原理实例化对象——BeanUtils.<em>instantiateClass</em>(constructorToUse)</li>
<li>另一种是使用CGLIB生成Bean的子类对象——instantiateWithMethodInjection(bd, beanName, owner)</li>
</ul>
</li>
<li><p>策略选择点：</p>
</li>
<li><ul>
<li>createBean()–&gt;doCreateBean()–&gt;createBeanInstance–&gt;instantiateBean–&gt;SimpleInstantiationStrategy类instantiate()的↓：</li>
<li>方法中的策略选择语句：if (!bd.hasMethodOverrides()) {…}</li>
<li>根据SimpleInstantiationStrategy类中的instantiateWithMethodInjection()是否被CGLIB重写，而选择调用JDK方式还是CGLIB方式</li>
<li>在使用<strong>方法注入</strong>的时候会才会使用CglibxxxStrategy中的实例化方法，平时只会使用JDK方式实例化</li>
</ul>
</li>
<li><p>类关系图：级联结构和下面的不同</p>
</li>
<li><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1587539451277-a95ec07e-d64b-4cff-b814-54a6cbdebc19.png" alt="image.png"></li>
</ul>
</li>
</ul>
<h3 id="代理方式的策略模式"><a href="#代理方式的策略模式" class="headerlink" title="代理方式的策略模式"></a>代理方式的策略模式</h3><ul>
<li><p>Spring AOP会根据被代理对象是否有接口而选择使用JdkDynamicAopProxy类/CglibAopProxy类的算法创建代理对象</p>
</li>
<li><p>策略选择点：</p>
</li>
<li><ul>
<li>DefaultAopProxyFactory类中createAopProxy()方法的语句↓(详见<a href="https://www.yuque.com/luka/note/aop#MhJYj">堆栈调用图</a>)：</li>
<li>如果targetClass有接口则使用JDK的方式创建代理对象，否则使用CGLIB的方式创建代理对象</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1587538194215-abb3832d-a485-4926-9a70-18392f6c60a1.png" alt="image.png"></li>
</ul>
</li>
<li><p>类结构图：</p>
</li>
<li><ul>
<li>两种策略都实现AopProxy接口，是策略模式的特点之一</li>
<li>策略模式中的并列实现接口，而实例化中的策略模式是级联的方式，其中一种策略间接实现接口</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1587537883215-343a7ac1-4a41-45e7-a6cd-c982341c6f9c.png" alt="image.png"></li>
</ul>
</li>
</ul>
<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li><p>当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象</p>
</li>
<li><p><strong>意图：</strong>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新</p>
</li>
<li><p><strong>主要解决：</strong>一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作</p>
</li>
<li><p><strong>何时使用：</strong>一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知</p>
</li>
<li><p><strong>如何解决：</strong>使用面向对象技术，可以将这种依赖关系弱化</p>
</li>
<li><p><strong>关键代码：</strong>在抽象类里有一个 ArrayList 存放观察者们</p>
</li>
<li><p><strong>优点：</strong></p>
</li>
<li><ul>
<li>观察者和被观察者是抽象耦合的</li>
<li>建立一套触发机制</li>
</ul>
</li>
<li><p><strong>缺点：</strong></p>
</li>
<li><ul>
<li>如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间</li>
<li>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃</li>
<li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化</li>
</ul>
</li>
<li><p><strong>使用场景：</strong></p>
</li>
<li><ul>
<li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用</li>
<li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度</li>
<li>一个对象必须通知其他对象，而并不知道这些对象是谁</li>
<li>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制</li>
</ul>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul>
<li>观察者模式使用三个类 Subject、Observer 和 Client</li>
<li>Subject 对象带有绑定观察者到 Client 对象和从 Client 对象解绑观察者的方法</li>
<li>创建 <em>Subject</em> 类、<em>Observer</em> 抽象类和扩展了抽象类 <em>Observer</em> 的实体类</li>
<li>被观察的Subject有所有观察者的对象，而每一个观察者都有被观察的Subject对象</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1266758/1598419382702-5c19c784-9c9c-4c45-be04-e825b23b564e.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></li>
<li>Subject类</li>
</ul>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"> </span><br><span class="line">public class Subject &#123;</span><br><span class="line">   </span><br><span class="line">   private List<span class="variable">&lt;Observer&gt;</span> observers </span><br><span class="line">      = new ArrayList<span class="variable">&lt;Observer&gt;</span>();</span><br><span class="line">   private int <span class="keyword">state</span>;</span><br><span class="line"> </span><br><span class="line">   public int getState() &#123;</span><br><span class="line">      return <span class="keyword">state</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   //状态变化，通知所有观察者</span><br><span class="line">   public void <span class="built_in">set</span>State(int <span class="keyword">state</span>) &#123;</span><br><span class="line">      this.<span class="keyword">state</span> = <span class="keyword">state</span>;</span><br><span class="line">      notifyAllObservers();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void attach(Observer observer)&#123;</span><br><span class="line">      observers.add(observer);      </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void notifyAllObservers()&#123;</span><br><span class="line">      <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">         observer.update();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Observer抽象类和实现类</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">   <span class="keyword">protected</span> <span class="type">Subject</span> subject;</span><br><span class="line">   public <span class="keyword">abstract</span> void update();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">BinaryObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">   public <span class="type">BinaryObserver</span>(<span class="type">Subject</span> subject)&#123;</span><br><span class="line">      <span class="keyword">this</span>.subject = subject;</span><br><span class="line">      <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   public void update() &#123;</span><br><span class="line">      <span class="type">System</span>.out.println( <span class="string">&quot;Binary String: &quot;</span> </span><br><span class="line">      + <span class="type">Integer</span>.toBinaryString( subject.getState() ) ); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">HexaObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">   public <span class="type">HexaObserver</span>(<span class="type">Subject</span> subject)&#123;</span><br><span class="line">      <span class="keyword">this</span>.subject = subject;</span><br><span class="line">      <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   public void update() &#123;</span><br><span class="line">      <span class="type">System</span>.out.println( <span class="string">&quot;Hex String: &quot;</span> </span><br><span class="line">      + <span class="type">Integer</span>.toHexString( subject.getState() ).toUpperCase() ); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用观察者观察Subject</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> ObserverPatternDemo &#123;</span><br><span class="line">   public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">      Subject subject = <span class="keyword">new</span> <span class="constructor">Subject()</span>;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">new</span> <span class="constructor">HexaObserver(<span class="params">subject</span>)</span>;</span><br><span class="line">      <span class="keyword">new</span> <span class="constructor">BinaryObserver(<span class="params">subject</span>)</span>;</span><br><span class="line"> </span><br><span class="line">      <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;First state change: 15&quot;</span>);   </span><br><span class="line">      subject.set<span class="constructor">State(15)</span>;</span><br><span class="line">      <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;Second state change: 10&quot;</span>);  </span><br><span class="line">      subject.set<span class="constructor">State(10)</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h1><h2 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构</li>
<li><strong>意图：</strong>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活</li>
<li><strong>何时使用：</strong>在不想增加很多子类的情况下扩展类</li>
<li><strong>优点：</strong>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能</li>
<li><strong>缺点：</strong>多层装饰比较复杂</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ul>
<li><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1599488169556-29522580-220f-47c5-a4d4-78eb6c4b31fb.png" alt="image.png"></p>
</li>
<li><p>第一步：定义奶茶接口（Component）</p>
</li>
<li><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1599488027636-f9c6fea6-9991-4457-9894-553af7e53f52.png" alt="image.png"></li>
</ul>
</li>
<li><p>第二步：定义两种不同种类的奶茶：珍珠奶茶和蜂蜜奶茶（ConcreteComponent）</p>
</li>
<li><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1599488033817-6389b760-5800-4171-a7fe-3f64fcae004f.png" alt="image.png"></li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1599488041801-491feb30-1c2d-460f-88f6-8af578256d2c.png" alt="image.png"></li>
</ul>
</li>
<li><p>第三步：定义口味</p>
</li>
<li><ul>
<li>装饰类的抽象方法，实现同样的接口</li>
<li>也可以不用抽象类，用抽象类方便实现多个装饰类</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Taste</span> <span class="keyword">implements</span> <span class="title">MilkTea</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">milkTeaName</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">milkTeaPrice</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第四步：具体的装饰类：具体口味（ConcreteDecorator）：加冰和加咖啡</p>
</li>
<li><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1599488640555-e9a632f6-7aee-419b-94c4-5a5af25fe5f8.png" alt="image.png"></li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1599488665640-b07a4f7f-f182-4ec3-a5ca-fa565223df75.png" alt="image.png"></li>
</ul>
</li>
<li><p>第五步：使用：用户买奶茶</p>
</li>
<li><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1599488710347-5ebaa282-dcb5-42c8-a385-ad8066bb26e1.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image.png"></li>
</ul>
</li>
</ul>
<h1 id="装饰器模式和代理模式的区别"><a href="#装饰器模式和代理模式的区别" class="headerlink" title="装饰器模式和代理模式的区别"></a>装饰器模式和代理模式的区别</h1><ol>
<li>对装饰器模式来说，装饰者（Decorator）和被装饰者（Decoratee）都实现一个接口。对代理模式来说，代理类（Proxy Class）和真实处理的类（Real Class）都实现同一个接口</li>
<li>不论我们使用哪一个模式，都可以很容易地在真实对象的方法前面或者后面加上自定义的方法</li>
<li>上面的例子中，装饰器模式是使用的调用者从外部传入的被装饰对象（coffee），调用者只想要你把他给你的对象装饰（加强）一下。而代理模式使用的是代理对象在自己的构造方法里面new的一个被代理的对象，不是调用者传入的。代理模式中，调用者不需要也不知道是否有其他实现类</li>
<li>装饰器模式关注于在一个对象上动态地添加方法，而代理模式关注于控制对对象的访问。换句话说，用代理模式，代理类可以对它的客户隐藏一个对象的具体信息。因此当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例；当使用装饰器模式的时候，我们通常的做法是将原始对象作为一个参数传给装饰器的构造器</li>
<li>装饰器模式和代理模式的使用场景不一样，比如IO流使用的是装饰者模式，可以层层增加功能。而代理模式则一般是用于增加特殊的功能，有些动态代理不支持多层嵌套</li>
<li>代理更多的是强调对对象的访问控制，而装饰器更多的强调给对象加强功能</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java核心技术36讲</title>
    <url>/2020/10/14/0000.JAVA%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF36%E8%AE%B2/</url>
    <content><![CDATA[<h4 id="谈谈你对Java平台的理解-“Java是解释执行”-这句话正确吗"><a href="#谈谈你对Java平台的理解-“Java是解释执行”-这句话正确吗" class="headerlink" title="谈谈你对Java平台的理解?“Java是解释执行”,这句话正确吗?"></a>谈谈你对Java平台的理解?“Java是解释执行”,这句话正确吗?</h4><ul>
<li>一次编译、到处运行”说的是Java语言跨平台的特性,Java的跨平台特性与Java虚拟机的存在密不可分,可在不同的环境中运行。比如说Windows平台和Linux平台都有相应的JDK,安装 好JDK后也就有了Java语言的运行环境。其实Java语言本身与其他的编程语言没有特别大的差异,并不是说Java语言可以跨平台,而是在不同的平台都有可以让Java语言运行的环境而已,所以 才有了Java一次编译,到处运行这样的效果。</li>
<li>程序从源代码到运行的三个阶段:编码——编译——运行——调试。Java在编译阶段则体现了跨平台的特点。编译过程大概是这样的:首先是将Java源代码转化成.CLASS文件字节码,这是第 一次编译。.class文件就是可以到处运行的文件。然后Java字节码会被转化为目标机器代码,这是是由JVM来执行的,即Java的第二次编译。</li>
<li>Java是解析运行吗? 不正确! Java源代码经过Javac编译成.class文件 .class文件经JVM解析或编译运行。</li>
</ul>
<h4 id="Exception和Error有什么区别"><a href="#Exception和Error有什么区别" class="headerlink" title="Exception和Error有什么区别?"></a>Exception和Error有什么区别?</h4><ul>
<li><code>Exception</code>和<code>Error</code>都是继承了<code>Throwable</code>类,在Java中只有<code>Throwable</code>类型的实例才可以被抛出(throw)或者捕获(catch),它是异常处理机制的基本组成类型。</li>
<li><code>Exception</code>是程序正常运行中,可以预料的意外情况,可能并且应该被捕获,进行相应处理。</li>
<li><code>Error</code>是指在正常情况下,不大可能出现的情况,绝大部分的Error都会导致程序(比如JVM自身)处于非正常的、不可恢复状态。既然是非正常情况,所以不便于也不需要捕获,常 见的比如<code>OutOfMemoryError</code>之类,都是<code>Error</code>的子类。</li>
<li><code>Exception</code>又分为<code>可检查(checked)</code>异常和<code>不检查(unchecked)</code>异常,可检查异常在源代码里必须显式地进行捕获处理,这是编译期检查的一部分</li>
<li>不检查异常就是所谓的运行时异常,类似 <code>NullPointerException</code>、<code>ArrayIndexOutOfBoundsException</code>之类,通常是可以编码避免的逻辑错误,具体根据需要来判断是否需要捕 获,并不会在编译期强制要求。<br><img src="https://img-blog.csdnimg.cn/20190406111450760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70"><blockquote>
<p><code>异常处理的基本原则</code>:<br>尽量不要捕获类似Exception这样的通用异常,而是应该捕获特定异常<br>不要生吞(swallow)异常。这是异常处理中要特别注意的事情,因为很可能会导致非常难以诊断的诡异情况。</p>
</blockquote>
</li>
</ul>
<h4 id="谈fnal、fnally、-fnalize有什么不同"><a href="#谈fnal、fnally、-fnalize有什么不同" class="headerlink" title="谈fnal、fnally、 fnalize有什么不同?"></a>谈fnal、fnally、 fnalize有什么不同?</h4><ul>
<li><code>fnal</code>可以用来修饰类、方法、变量,分别有不同的意义,<code>fnal</code>修饰的<code>class</code>代表不可以继承扩展,fnal的变量是不可以修改的,而fnal的方法也是不可以重写的(override)。</li>
<li><code>fnally</code>则是Java保证重点代码一定要被执行的一种机制。我们可以使用try-fnally或者try-catch-fnally来进行类似关闭JDBC连接、保证unlock锁等动作。</li>
<li><code>fnalize</code>是基础类java.lang.Object的一个方法,它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。fnalize机制现在已经不推荐使用,并且在JDK 9开始被标记 为deprecated。</li>
</ul>
<h4 id="强引用、软引用、弱引用、幻象引用有什么区别"><a href="#强引用、软引用、弱引用、幻象引用有什么区别" class="headerlink" title="强引用、软引用、弱引用、幻象引用有什么区别?"></a>强引用、软引用、弱引用、幻象引用有什么区别?</h4><ul>
<li><code>强引用</code>:我们平常典型编码Object obj = new Object()中的obj就是强引用。通过关键字new创建的对象所关联的引用就是强引用。 当JVM内存空间不足,JVM宁愿抛出OutOfMemoryError运 行时错误(OOM),使程序异常终止,也不会靠随意回收具有强引用的“存活”对象来解决内存不足的问题。对于一个普通的对象,如果没有其他的引用关系,只要超过了引用的作用域或者显式 地将相应(强)引用赋值为 null,就是可以被垃圾收集的了,具体回收时机还是要看垃圾收集策略。</li>
<li><code>软引用</code>:软引用通过<code>SoftReference</code>类实现。 软引用的生命周期比强引用短一些。只有当 JVM 认为内存不足时,才会去试图回收软引用指向的对象:即JVM 会确保在抛出 OutOfMemoryError 之前,清理软引用指向的对象。软引用可以和一个引用队列(ReferenceQueue)联合使用,如果软引用所引用的对象被垃圾回收器回收,Java虚拟机就会把这个软引用加入到与之关联的引用 队列中。后续,我们可以调用ReferenceQueue的poll()方法来检查是否有它所关心的对象被回收。如果队列为空,将返回一个null,否则该方法返回队列中前面的一个Reference对象</li>
<li><code>弱引用</code> 弱引用通过WeakReference类实现。 弱引用的生命周期比软引用短。在垃圾回收器线程扫描它所管辖的内存区域的过程中,一旦发现了具有弱引用的对象,不管当前内存空间足够与否,都会 回收它的内存。由于垃圾回收器是一个优先级很低的线程,因此不一定会很快回收弱引用的对象。弱引用可以和一个引用队列(ReferenceQueue)联合使用,如果弱引用所引用的对象被垃圾 回收,Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。弱应用同样可用于内存敏感的缓存。</li>
<li><code>幻象引用</code>,有时候也翻译成虚引用,你不能通过它访问对象。幻象引用仅仅是提供了一种确保对象被fnalize以后,做某些事情的机制。如果 一个对象仅持有虚引用,那么它就和没有任何引用一样,在任何时候都可能被垃圾回收器回收。虚引用必须和引用队列 (ReferenceQueue)联合使用。当垃圾回收器准备回收一个对象时,如 果发现它还有虚引用,就会在回收对象的内存之前,把这个虚引用加入到与之关联的引用队列中。</li>
</ul>
<h4 id="String、StringBufer、StringBuilder有什么区别"><a href="#String、StringBufer、StringBuilder有什么区别" class="headerlink" title="String、StringBufer、StringBuilder有什么区别?"></a>String、StringBufer、StringBuilder有什么区别?</h4><ul>
<li><code>String</code>被声明成为fnal class,所有属性也都是fnal的。也由于它的不可 变性,类似拼接、裁剪字符串等动作,都会产生新的String对象。Java为了避免在一个系统中产生大量的String对象,引入了字符串常量池，创建一个字符串时,首先检查池中是否有值相同的字符串对 象,如果有则不需要创建直接从池中刚查找到的对象引用;如果没有则新建字符串对象,返回对象引用,并且将新创建的对象放入池中。但是,通过new方法创建的String对象是不检查字符串 池的,而是直接在堆区或栈区创建一个新的对象,也不会把对象放入池中。上述原则只适用于通过直接量给String对象引用赋值的情况。<code>String</code>提供了<code>inter</code>()方法。调用该方法时,如果常量池中包括了一个等于此String对象的字符串(<code>由equals方法确定</code>),则返回池中的字符串。否则,将此String对象添加到池中,并且 返回此池中对象的引用</li>
<li><code>StringBufer和StringBuilde</code>r都实现了<code>AbstractStringBuilder</code>抽象类,拥有几乎一致对外提供的调用接口;其底层在内存中的存储方式与String相同,都是以一个有序的字符序列(char类型 的数组)进行存储,不同点是<code>StringBufer/StringBuilder</code>对象的<code>值是可以改变</code>的,并且值改变以后,对象引用不会发生改变;两者对象在构造过程中,首先按照默认大小申请一个字符数组,由 于会不断加入新数据,<code>当超过默认大小后</code>,会创建一个更大的数组,并将原先的数组内容复制过来,再丢弃旧的数组。因此,对于较大对象的扩容会涉及大量的内存复制操作,如果能够预先评 估大小,可提升性能。</li>
<li>唯一需要注意的是:<code>StringBufer是线程安全</code>的,但是<code>StringBuilder</code>是<code>线程不安全</code>的。可参看Java标准类库的源代码,<code>StringBufer</code>类中方法定义前面都会有<code>synchronize</code>关键字。为 此,StringBufer的性能要远低于StringBuilder。</li>
</ul>
<h4 id="谈谈Java反射机制-动态代理是基于什么原理"><a href="#谈谈Java反射机制-动态代理是基于什么原理" class="headerlink" title="谈谈Java反射机制,动态代理是基于什么原理"></a>谈谈Java反射机制,动态代理是基于什么原理</h4><ul>
<li><code>反射机制</code>是Java语言提供的一种基础功能,赋予程序在运行时自省(introspect,官方用语)的能力。通过反射我们可以直接操作类或者对象,比如获取某个对象的类定义,获取类 声明的属性和方法,调用方法或者构造对象,甚至可以运行时修改类定义。</li>
<li><code>动态代理</code>是一种方便运行时动态构建代理、动态处理代理方法调用的机制,很多场景都是利用类似机制做到的,比如用来包装RPC调用、面向切面的编程(AOP)。</li>
<li><code>JDK</code>动态代理:基于Java反射机制实现,必须要实现了接口的业务类才能用这种办法生成代理对象。新版本也开始结合ASM机制。</li>
<li><code>cglib</code>动态代理:基于ASM机制实现,通过生成业务类的子类作为代理类。</li>
</ul>
<h4 id="int和Integer有什么区别-谈谈Integer的值缓存范围。"><a href="#int和Integer有什么区别-谈谈Integer的值缓存范围。" class="headerlink" title="int和Integer有什么区别?谈谈Integer的值缓存范围。"></a>int和Integer有什么区别?谈谈Integer的值缓存范围。</h4><ul>
<li><code>int</code>是我们常说的整形数字,是Java的8个原始数据类型(Primitive Types,boolean、byte 、short、char、int、foat、double、long)之一。Java语言虽然号称一切都是对象, 但原始数据类型是例外。</li>
<li><code>Integer</code>是int对应的包装类,它有一个int类型的字段存储数据,并且提供了基本操作,比如数学运算、int和字符串之间转换等。在Java 5中,引入了自动装箱和自动拆箱功能 (boxing/unboxing),Java可以根据上下文,自动进行转换,极大地简化了相关编程。</li>
<li>Integer的值默认缓存 是-128到127之间。缓存上限值实际是可以根据需要调整的,JVM提供了参数设置: <code>-XX:AutoBoxCacheMax=N</code>。</li>
<li>不管是Integer还Boolean等,都被声明为“private fnal”,所以,它们同样是不可变类型!</li>
</ul>
<h4 id="对比Vector、ArrayList、LinkedList有何区别"><a href="#对比Vector、ArrayList、LinkedList有何区别" class="headerlink" title="对比Vector、ArrayList、LinkedList有何区别?"></a>对比Vector、ArrayList、LinkedList有何区别?</h4><ul>
<li><code>Vector</code>是线程安全的动态数组,。<code>Vector</code>内部是使用对象数组来保存数据,可以根据需要自动增加 容量,当数组已满时,会创建新的数组,并拷贝原有数组数据。Vector在扩容时会<code>提高1倍</code></li>
<li><code>ArrayList</code>是动态数组实现,不是线程安全的,性能要好很多。与Vector近似,ArrayList也是可以根据需要调整容量,不过两者的调整逻辑有所区 别。ArrayList扩容时是增加50%。</li>
<li><code>Vector和ArrayList作为动态数组</code>,其内部元素以数组形式顺序存储的,所以非常适合随机访问的场合。除了尾部插入和删除元素,往往性能会相对较差,比如我们在中间位置插 入一个元素,需要移动后续所有元素。</li>
<li><code>LinkedList</code>是Java提供的双向链表,它不需要像上面两种那样调整容量,也不是线程安全的。LinkedList进行节点插入、删除却要高效得多,但是随机访问性能则要比动态数组慢。<blockquote>
<p><code>TreeSet</code> 支持自然顺序访问,但是添加、删除、包含等操作要相对低效(log(n)时间)。<br><code>HashSet</code>则是利用哈希算法,理想情况下,如果哈希散列正常,可以提供常数时间的添加、删除、包含等操作,但是它不保证有序。<br><code>LinkedHashSet</code>,内部构建了一个记录插入顺序的双向链表,因此提供了按照插入顺序遍历的能力,与此同时,也保证了常数时间的添加、删除、包含等操作,这些操作性能略 低于HashSet,因为需要维护链表的开销。<br>在遍历元素时,<code>HashSet</code>性能受自身容量影响,所以初始化时,除非有必要,不然不要将其背后的HashMap容量设置过大。而对于LinkedHashSet,由于其内部链表提供的方便,遍历性能只和元素多少有关系。<br><code>Java提供的默认排序算法</code>:<br>对于原始数据类型,目前使用的是所谓双轴快速排序,是一种改进的快速排序算法,早期版本是相对传统的快速排序<br>对于对象数据类型,目前则是使用TimSort,思想上也是一种归并和二分插入排序结合的优化排序算法</p>
</blockquote>
</li>
</ul>
<h4 id="对比Hashtable、HashMap、TreeMap-有什么不同"><a href="#对比Hashtable、HashMap、TreeMap-有什么不同" class="headerlink" title="对比Hashtable、HashMap、TreeMap 有什么不同?"></a>对比Hashtable、HashMap、TreeMap 有什么不同?</h4><ul>
<li><code>元素特性</code>：HashTable 中的key、value都不能为null;HashMap中的key、value可以为null,很显然只能有一个key为null的键值对,但是允许有多个值为null的键值对;TreeMap 中当未实现 Comparator 接口时,key 不可以为null;当实现 Comparator 接口时,若未对null情况进行判断,则key不可以为null,反之亦然。</li>
<li><code>顺序特性</code>：HashTable 、HashMap具有无序特性。TreeMap 是利用红黑树来实现的(树中的每个节点的值,都会大于或等于它的左子树种的所有节点的值,并且小于或等于它的右子树中的所有节点的 值),实现了SortMap接口,能够对保存的记录根据键进行排序。所以一般需要排序的情况下是选择TreeMap 来进行,默认为升序排序方式(深度优先搜索),可自定义实现Comparator接口 实现排序方式。</li>
<li><code>初始化与增长方式</code>：初始化时:HashTable 在不指定容量的情况下的默认容量为11,且不要求底层数组的容量一定要为2的整数次幂;HashMap默认容量为16,且要求容量一定为2的整数次幂。 扩容时:Hashtable将容量变为原来的2倍加1;HashMap扩容将容量变为原来的2倍。</li>
<li><code>HashMap</code>基于哈希思想,实现对数据的读写。当我们将键值对传递给<code>put()</code>方法时,它调用<code>键对象的hashCode()</code>方法来计算<code>hashcode</code>,然后找到<code>bucket</code>位置来储存值对象。当获取对象时, 通过键对象的<code>equals()方法找到正确的键值对,然后返回值对象</code>。HashMap使用<code>链表来解决碰撞问题</code>,当发生碰撞了,对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存 键值对对象。当两个不同的键对象的hashcode相同时,它们会储存在同一个bucket位置的链表中,可通过键对象的equals()方法用来找到键值对。如果链表大小超过阈值 ( 8),链表就会被改造为树形结构(红黑树)。</li>
</ul>
<blockquote>
<p>解决哈希冲突有哪些典型方法呢?<br><code>开放定址法</code>：当关键字key的哈希地址p=H(key)出现冲突时,以p为基础,产生另一个哈希地址p1,如果p1仍然冲突,再以p为基础,产生另一个哈希地址p2,…,直到找出一个不冲突的哈 希地址pi ,将相应元素存入其中。<br><code>再哈希法</code>：当哈希地址Hi=RH1(key)发生冲突时,再计算Hi=RH2(key)……,直到冲突不再产生。这种方法不易产生聚集,但增加了计算时间。<br><code>链地址法</code>：这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表,并将单链表的头指针存在哈希表的第i个单元中,因而查找、插入和删除主要在同义词链中进行。链地址法适用 于经常进行插入和删除的情况。</p>
</blockquote>
<h4 id="Java提供了哪些IO方式-NIO如何实现多路复用"><a href="#Java提供了哪些IO方式-NIO如何实现多路复用" class="headerlink" title="Java提供了哪些IO方式? NIO如何实现多路复用?"></a>Java提供了哪些IO方式? NIO如何实现多路复用?</h4><ul>
<li><code>传统的java.io包,它基于流模型实现</code>,提供了我们最熟知的一些IO功能,比如File抽象、输入输出流等。交互方式是同步、阻塞的方式。</li>
<li>很多时候,人们也把java.net下面提供的部分网络API,比如Socket、ServerSocket、HttpURLConnection也归类到同步阻塞IO类库,因为网络通信同样是IO行为。</li>
<li><code>在Java 1.4中引入了NIO框架(java.nio包)</code>,提供了Channel、Selector、Bufer等新的抽象,可以构建多路复用的、<code>同步非阻塞IO程序</code>,同时提供了更接近操作系统底层 的高性能数据操作方式。</li>
<li><code>在Java 7中,NIO有了进一步的改进,也就是NIO 2</code>,引入了异<code>步非阻塞IO方式</code>,也有很多人叫它AIO(Asynchronous IO)。异步IO操作基于事件和回调机制,可以简单 理解为,应用操作直接返回,而不会阻塞在那里,当后台处理完成,操作系统会通知相应线程进行后续工作。</li>
</ul>
<blockquote>
<p><code>NIO多路复用的局限性是什么呢?</code><br>由于nio实际上是<code>同步非阻塞io</code>,是一个线程在同步的进行事件处理,当一组事channel处理完毕以后,去检查有没有又可以处理的channel。这也就是同步+非阻塞。同步,指每个准备好 的channel处理是依次进行的,非阻塞,是指线程不会傻傻的等待读。只有当channel准备好后,才会进行。那么就会有这样一个问题,当每个channel所进行的都是耗时操作时,由于是同步操 作,就会积压很多channel任务,从而完成影响。那么就需要对nio进行类似负载均衡的操作,如用线程池去进行管理读写,将channel分给其他的线程去执行,这样既充分利用了每一个线程,又不至于都堆积在一个线程中,等待执行</p>
</blockquote>
<h4 id="谈谈接口和抽象类有什么区别？"><a href="#谈谈接口和抽象类有什么区别？" class="headerlink" title="谈谈接口和抽象类有什么区别？"></a>谈谈接口和抽象类有什么区别？</h4><ul>
<li><code>接口</code>是对行为的抽象，它是抽象方法的集合，利用接口可以达到API定义和实现分离的目的。接口，不能实例化；不能包含任何非常量成员,同时，没有非静态方法实现，也就是说要么是抽象方法，要么是静态方法。 Java标准类库中，定义了非常多的接口，比如java.util.List。</li>
<li><code>抽象类</code>是不能实例化的类，用abstract关键字修饰class，其目的主要是代码重用。除了不能实例化，形式上和一般的Java类并没有太大区别，可以有一个或者多个抽象方法，也可<br>以没有抽象方法。抽象类大多用于抽取相关Java类的共用方法实现或者是共同成员变量，然后通过继承的方式达到代码复用的目的。 Java标准库中，比如collection框架，很多通用<br>部分就被抽取成为抽象类，例如java.util.AbstractList。</li>
</ul>
<blockquote>
<p>进行面向对象编程，掌握基本的设计原则是必须的，我今天介绍最通用的部分，也就是所谓的<code>S.O.L.I.D</code>原则。<br><code>单一职责</code>类或者对象最好是只有单一职责，在程序设计中如果发现某个类承担着多种义务，可以考虑进行拆分。<br><code>开关原则</code>设计要对扩展开放，对修改关闭。换句话说，程序设计应保证平滑的扩展性，尽量避免因为新增同类功能而修改已有实现，这样可以少产出些回归（regression）问题。<br><code>里氏替换</code>这是面向对象的基本要素之一，进行继承关系抽象时，凡是可以用父类或者基类的地方，都可以用子类替换。<br><code>接口分离</code>我们在进行类和接口设计时，如果在一个接口里定义了太多方法，其子类很可能面临两难，就是只有部分方法对它是有意义的，这就破坏了程序的内聚性。对于这种情况，可以通过拆分成功能单一的多个接口，将行为进行解耦。在未来维护中，如果某个接口设计有变，不会对使用其他接口的子类构成影响<br><code>依赖反转</code>实体应该依赖于抽象而不是实现。也就是说高层次模块，不应该依赖于低层次模块，而是应该基于抽象。实践这一原则是保证产品代码之间适当耦合度的法宝</p>
</blockquote>
<h4 id="谈谈你知道的设计模式？请手动实现单例模式，-Spring等框架中使用了哪些模式？"><a href="#谈谈你知道的设计模式？请手动实现单例模式，-Spring等框架中使用了哪些模式？" class="headerlink" title="谈谈你知道的设计模式？请手动实现单例模式， Spring等框架中使用了哪些模式？"></a>谈谈你知道的设计模式？请手动实现单例模式， Spring等框架中使用了哪些模式？</h4><ul>
<li>设计模式可以分为创建型模式、结构型模式和行为型模式。</li>
<li><code>创建型模式</code>，是对对象创建过程的各种问题和解决方案的总结，包括各种工厂模式（Factory、 Abstract Factory）、单例模式（Singleton）、构建器模式（Builder）、原型模式（ProtoType）。</li>
<li><code>结构型模式</code>，是针对软件设计结构的总结，关注于类、对象继承、组合方式的实践经验。常见的结构型模式，包括桥接模式（Bridge）、适配器模式（Adapter）、装饰者模式（Decorator）、代理模式（Proxy）、组合模式（Composite）、外观模式（Facade）、享元模式（Flyweight）等。</li>
<li><code>行为型模式</code>，是从类或对象之间交互、职责划分等角度总结的模式。比较常见的行为型模式有策略模式（Strategy）、解释器模式（Interpreter）、命令模式（Command）、观察者模式（Observer）、迭代器模式（Iterator）、模板方法模式（Template Method）、访问者模式（Visitor）。更多相关内容你可以参考：<a href="https://en.wikipedia.org/wiki/Design_Patterns">https://en.wikipedia.org/wiki/Design_Patterns</a></li>
</ul>
<blockquote>
<ul>
<li><code>InputStream</code>是一个抽象类，标准类库中提供了FileInputStream、 ByteArrayInputStream等各种不同的子类，分别从不同角度对InputStream进行了功能扩展，这是典型的装饰器模式应用案例。识别装饰器模式，可以通过识别类设计特征来进行判断，也就是其类构造函数以相同的抽象类或者接口为输入参数<br><code>创建型模式</code>尤其是工厂模式，在我们的代码中随处可见，我举个相对不同的API设计实践。比如， JDK最新版本中 HTTP/2 Client API，下面这个创建HttpRequest的过程，就是典型的构建器模式（Builder），通常会被实现成fuent风格的API，也有人叫它方法链。使用构建器模式，可以比较优雅地解决构建复杂对象的麻烦，这里的“复杂”是指类似需要输入的参数组合较多，如果用构造函数，我们往往需要为每一种可能的输入参数组合实现相应的构造函数，一系列复杂的构造函数会让代码阅读性和可维护性变得很差。</li>
</ul>
</blockquote>
<blockquote>
<p><code>Spring等如何在API设计中使用设计模式</code><br>BeanFactory和ApplicationContext应用了工厂模式<br>在Bean的创建中， Spring也为不同scope定义的对象，提供了单例和原型等模式实现。<br>AOP领域则是使用了代理模式、装饰器模式、适配器模式等。<br>各种事件监听器，是观察者模式的典型应用。<br>类似JdbcTemplate等则是应用了模板模式。</p>
</blockquote>
<h4 id="synchronized和ReentrantLock有什么区别？"><a href="#synchronized和ReentrantLock有什么区别？" class="headerlink" title="synchronized和ReentrantLock有什么区别？"></a>synchronized和ReentrantLock有什么区别？</h4><ul>
<li><code>synchronized</code>是Java内建的同步机制,它提供了互斥的语义和可见性，当一个线程已经获取当前锁时，其他试图获取的线程只能等待或者阻塞在那里。</li>
<li><code>ReentrantLock</code>，通常翻译为再入锁，是Java 5提供的锁实现，它的语义和synchronized基本相同。再入锁通过代码直接调用lock()方法获取，代码书写也更加灵活。与此同时， ReentrantLock提供了很多实用的方法，能够实现很多synchronized无法做到的细节控制，比如可以控制fairness，也就是公平性，或者利用定义条件等。但是，编码中也需要注意，必须要明确调用unlock()方法释放，不然就会一直持有该锁。</li>
</ul>
<h4 id="synchronized底层如何实现？什么是锁的升级、降级？"><a href="#synchronized底层如何实现？什么是锁的升级、降级？" class="headerlink" title="synchronized底层如何实现？什么是锁的升级、降级？"></a>synchronized底层如何实现？什么是锁的升级、降级？</h4><ul>
<li><code>synchronized</code>代码块是由一对儿<code>monitorenter/monitorexit</code>指令实现的， Monitor对象是同步的基本实现单元。在Java 6之前， Monitor的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作。现代的（Oracle） JDK中， JVM对此进行了大刀阔斧地改进，提供了三种不同的Monitor实现，也就是常说的三种不同的锁：偏向锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。</li>
<li>所谓锁的升级、降级，就是JVM优化synchronized运行的机制，当JVM检测到不同的竞争状况时，会自动切换到适合的锁实现，这种切换就是锁的升级、降级。</li>
<li>当没有竞争出现时，<code>默认会使用偏斜锁</code>。 <code>JVM</code>会利用<code>CAS</code>操作，在对象头上的<code>Mark Word</code>部分设置线程ID，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁。这样做的假设是基于在很多应用场景中，大部分对象生命周期中最多会被一个线程锁定，使用偏斜锁可以降低无竞争开销。</li>
<li>如果有另外的线程试图锁定某个已经被偏斜过的对象， JVM就需要撤销（revoke）偏斜锁，并切换到轻量级锁实现。轻量级锁依赖CAS操作Mark Word来试图获取锁，如果重试成功，就使用普通的轻量级锁；否则，进一步升级为重量级锁。</li>
</ul>
<blockquote>
<p><code>你知道“自旋锁”是做什么的吗？它的使用场景是什么？</code><br><code>自旋锁</code>:竞争锁的失败的线程，并不会真实的在操作系统层面挂起等待，而是JVM会让线程做几个空循环(基于预测在不久的将来就能获得)，在经过若干次循环后，如果可以获得锁，那么进入临界区，如果还不能获得锁，才会真实的将线程在操作系统层面进行挂起。<br><code>适用场景</code>:自旋锁可以减少线程的阻塞，这对于锁竞争不激烈，且占用锁时间非常短的代码块来说，有较大的性能提升，因为自旋的消耗会小于线程阻塞挂起操作的消耗。如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用cpu做无用功，线程自旋的消耗大于线程阻塞挂起操作的消耗，造成cpu的浪费<br><code>在单核CPU上，自旋锁是无用</code>，因为当自旋锁尝试获取锁不成功会一直尝试，这会一直占用CPU，其他线程不可能运行，<br>同时由于其他线程无法运行，所以当前线程无法释放锁。</p>
</blockquote>
<h4 id="一个线程两次调用start-方法会出现什么情况？谈谈线程的生命周期和状态转移。"><a href="#一个线程两次调用start-方法会出现什么情况？谈谈线程的生命周期和状态转移。" class="headerlink" title="一个线程两次调用start()方法会出现什么情况？谈谈线程的生命周期和状态转移。"></a>一个线程两次调用start()方法会出现什么情况？谈谈线程的生命周期和状态转移。</h4><ul>
<li>Java的线程是不允许启动两次的，第二次调用必然会抛出IllegalThreadStateException，这是一种运行时异常，多次调用start被认为是编程错误。</li>
<li>新建（NEW），表示线程被创建出来还没真正启动的状态，可以认为它是个Java内部状态。</li>
<li>就绪（RUNNABLE），表示该线程已经在JVM中执行，当然由于执行需要计算资源，它可能是正在运行，也可能还在等待系统分配给它CPU片段，在就绪队列里面排队。</li>
<li>阻塞（BLOCKED），这个状态和我们前面两讲介绍的同步非常相关，阻塞表示线程在等待Monitor lock。比如，线程试图通过synchronized去获取某个锁，但是其他线程已经独占了，那么当前线程就会处于阻塞状态。</li>
<li>等待（WAITING），表示正在等待其他线程采取某些操作。一个常见的场景是类似生产者消费者模式，发现任务条件尚未满足，就让当前消费者线程等待（wait），另外的生产者线程去准备任务数据，然后通过类似notify等动作，通知消费线程可以继续工作了。 Thread.join()也会令线程进入等待状态。</li>
<li>计时等待（TIMED_WAIT），其进入条件和等待状态类似，但是调用的是存在超时条件的方法，比如wait或join等方法的指定超时版本</li>
</ul>
<h4 id="什么情况下Java程序会产生死锁-如何定位、修复"><a href="#什么情况下Java程序会产生死锁-如何定位、修复" class="headerlink" title="什么情况下Java程序会产生死锁?如何定位、修复?"></a>什么情况下Java程序会产生死锁?如何定位、修复?</h4><ul>
<li><code>死锁</code>是一种特定的程序状态,在实体之间,由于<code>循环依赖导致</code>彼此一直处于等待之中,没有任何个体可以继续前进。死锁不仅仅是在线程之间会发生,存在资源独占的进程之间同样也可能出现死锁。通常来说,我们大多是聚焦在多线程场景中的死锁,指两个或多个线程之间,由于互<code>相持有对方需要的锁</code>,而永久处于阻塞的状态。<br><img src="https://img-blog.csdnimg.cn/20190408224832820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70"></li>
<li><code>定位死锁</code>最常见的方式就是利用<code>jstack</code>等工具<code>获取线程栈</code>,然后定位互相之间的依赖关系,进而找到死锁。如果是比较明显的死锁,往往jstack等就能直接定位,类似JConsole甚至 可以在图形界面进行有限的死锁检测。</li>
<li>使用Java提供的标准管理API,ThreadMXBean,其直接就提供 fndDeadlockedThreads﻿()方法用于定位死锁。但是要注意的是,对线程进行快照本身是一个相对重量级的操作,还是要慎重选择频度和时机。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadMXBeanTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadMXBean mbean = ManagementFactory.getThreadMXBean();</span><br><span class="line"></span><br><span class="line">        Runnable dlCheck = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">long</span>[] threadIds = mbean.findDeadlockedThreads();</span><br><span class="line">                <span class="keyword">if</span> (threadIds != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ThreadInfo[] threadInfos = mbean.getThreadInfo(threadIds);</span><br><span class="line">                    System.out.println(<span class="string">&quot;Detected deadlock threads:&quot;</span>);</span><br><span class="line">                    <span class="keyword">for</span> (ThreadInfo threadInfo : threadInfos) &#123;</span><br><span class="line">                        System.out.println(threadInfo.getThreadName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ScheduledExecutorService scheduler =Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 稍等5秒,然后每10秒进行一次死锁扫描</span></span><br><span class="line">        scheduler.scheduleAtFixedRate(dlCheck, <span class="number">5L</span>, <span class="number">10L</span>, TimeUnit.SECONDS);</span><br><span class="line">        Test1  t=<span class="keyword">new</span> Test1();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                t.t1();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                t.t2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="class"><span class="keyword">class</span> <span class="title">Test1</span></span>&#123;</span><br><span class="line">        Object obj1=<span class="keyword">new</span> Object();</span><br><span class="line">        Object obj2=<span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">t1</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj1)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:    obj1--------&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (obj2)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;   obj2--------&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">t2</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj2)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;    t2  obj2--------&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (obj1)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;   t2  obj1--------&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如<code>何在编程中尽量预防死锁呢?</code><br>尽量避免使用多个锁,并且只有需要时才持有锁<br>如果必须使用多个锁,尽量设计好锁的获取顺序<br>使用带超时的方法,为程序带来更多可控性。<br><code>有时候并不是阻塞导致的死锁,只是某个线程进入了死循环,导致其他线程一直等待,这种问题如何诊断呢?</code><br>可以通过linux下top命令查看cpu使用率较高的java进程,进而用<code>top -Hp pid</code>查看该java进程下cpu使用率较高的线程。再用jstack命令查看线程具体调用情况,排查问题</p>
</blockquote>
<h4 id="Java并发包提供了哪些并发工具类？"><a href="#Java并发包提供了哪些并发工具类？" class="headerlink" title="Java并发包提供了哪些并发工具类？"></a>Java并发包提供了哪些并发工具类？</h4><ul>
<li>提供了比synchronized更加高级的各种同步结构，包括<code>CountDownLatch</code>、 <code>CyclicBarrier</code>、 <code>Semaphore</code>等。CountDownLatch，允许一个或多个线程等待某些操作完成。CyclicBarrier，一种辅助性的同步结构，允许多个线程等待到达某个屏障。Semaphore， Java版本的信号量实现，它通过控制一定数量的允许（permit）的方式，来达到限制通用资源访问的目的。</li>
<li>各种<code>线程安全的容器</code>，比如最常见的<code>ConcurrentHashMap</code>、有序的<code>ConcunrrentSkipListMap</code>，或者通过类似快照机制，实现线程安全的动态数组<code>CopyOnWriteArrayList</code>等。</li>
<li>各种<code>并发队列</code>实现，如各种<code>BlockedQueue</code>实现，比较典型的<code>ArrayBlockingQueue</code>、 <code>SynchorousQueue</code>或针对特定场景的<code>PriorityBlockingQueue</code>等。</li>
<li>强大的<code>Executor</code>框架，可以创建各种不同类型的线程池，调度任务运行等，绝大部分情况下，不再需要自己从头实现线程池和任务调度器。</li>
</ul>
<blockquote>
<p><code>你使用过类似CountDownLatch的同步结构解决实际问题吗？</code><br>一个页面有A,B,C三个网络请求，其中请求C需要请求A和请求B的返回数据作为参数，用过CountdownLatch解决。<br>需求是每个对象一个线程，分别在每个线程里计算各自的数据，最终等到所有线程计算完毕，我还需要将每个有共通的对象进行合并，所以用它很合适。</p>
</blockquote>
<h4 id="并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别？"><a href="#并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别？" class="headerlink" title="并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别？"></a>并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别？</h4><p><img src="https://img-blog.csdnimg.cn/20190409124720516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70" alt="线程安全队列一览"></p>
<ul>
<li><code>Concurrent</code>类型基于<code>lock-free</code>，在常见的多线程访问场景，一般可以提供较高吞吐量。而<code>LinkedBlockingQueue</code>内部则是<code>基于锁</code>，并提供了<code>BlockingQueue</code>的等待性方法。</li>
<li><code>ArrayBlockingQueue</code>是最典型的的有界队列，其内部以<code>fnal</code>的数组保存数据，数组的大小就决定了队列的边界，所以我们在创建ArrayBlockingQueue时，都要指定容量</li>
<li><code>LinkedBlockingQueue</code>，容易被<code>误解为无边界</code>，但其实其行为和内部代码都是<code>基于有界的逻辑实现</code>的，只不过如果我们没有在创建队列时就指定容量，那么其容量限制就自动被设置为<code>Integer.MAX_VALUE</code>，成为了无界队列。</li>
<li><code>SynchronousQueue</code>，这是一个非常奇葩的队列实现，每个删除操作都要等待插入操作，反之每个插入操作也都要等待删除动作。其内<code>部容量是0</code></li>
<li><code>PriorityBlockingQueue</code>是无边界的优先队列，虽然严格意义上来讲，其大小总归是要受系统资源影响</li>
<li><code>DelayedQueue</code>和<code>LinkedTransferQueue</code>同样是<code>无边界的队列</code>。对于无边界的队列，有一个自然的结果，就是put操作永远也不会发生其他<code>BlockingQueue</code>的那种等待情况。</li>
</ul>
<blockquote>
<p><code>在日常的应用开发中，如何进行选择呢？</code><br>考虑应用场景中<code>对队列边界的要求</code>。 ArrayBlockingQueue是有明确的容量限制的，而LinkedBlockingQueue则取决于我们是否在创建时指定， SynchronousQueue则干脆不能缓存任何元素。<br><code>从空间利用角度</code>，数组结构的ArrayBlockingQueue要比LinkedBlockingQueue紧凑，因为其不需要创建所谓节点，但是其初始分配阶段就需要一段连续的空间，所以初始内存需求更大。<br><code>通用场景中</code>， LinkedBlockingQueue的吞吐量一般优于ArrayBlockingQueue，因为它实现了更加细粒度的锁操作。<br>ArrayBlockingQueue实现比较简单，性能更好预测，属于表现稳定的“选手”。<br>如果我们需要实现的是两个线程之间接力性（handof）的场景，你可能会选择CountDownLatch，但是SynchronousQueue也是完美符合这种场景的，而且线程间协调和数据传输统一起来，代码更加规范。</p>
</blockquote>
<h4 id="Java并发类库提供的线程池有哪几种？-分别有什么特点？"><a href="#Java并发类库提供的线程池有哪几种？-分别有什么特点？" class="headerlink" title="Java并发类库提供的线程池有哪几种？ 分别有什么特点？"></a>Java并发类库提供的线程池有哪几种？ 分别有什么特点？</h4><p>Executors目前提供了5种不同的线程池创建配置：</p>
<ul>
<li><code>newCachedThreadPool()</code>，它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过60秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用<code>SynchronousQueue</code>作为工作队列。</li>
<li><code>newFixedThreadPool(int nThreads)</code>，重用<code>指定数目</code>（nThreads）的线程，其背后使用的是<code>无界的工作队列</code>，任何时候最多有nThreads个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目nThreads。</li>
<li><code>newSingleThreadExecutor()</code>，它的特点在于<code>工作线程数目被限制为1</code>，操作一个<code>无界的工作队列</code>，所以它保证了所有任务的都是被<code>顺序执行</code>，最多会有<code>一个任务处于活动状态</code>，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目。</li>
<li><code>newSingleThreadScheduledExecutor()</code>和<code>newScheduledThreadPool(int corePoolSize)</code>，创建的是<code>ScheduledExecutorService</code>，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程</li>
<li><code>newWorkStealingPool(int parallelism)</code>，这是一个经常被人忽略的线程池， <code>Java 8才加入这个创建方法</code>，其内部会构建<code>ForkJoinPool</code>，利用<code>Work-Stealing算法</code>，并行地处理任务，不保证处理顺序。</li>
</ul>
<blockquote>
<p><code>ThreadPoolExecutor参数详解</code><br>corePoolSize，所谓的核心线程数，可以大致理解为长期驻留的线程数目。于不同的线程池，这个值可能会有很大区别，比如newFixedThreadPool会将其设置为nThreads，而对于newCachedThreadPool则是为0。<br>maximumPoolSize，顾名思义，就是线程不够时能够创建的最大线程数<br>keepAliveTime和TimeUnit，这两个参数指定了额外的线程能够闲置多久，显然有些线程池不需要它。<br>workQueue，工作队列，必须是BlockingQueue。<br><code>线程池大小的选择策略：</code><br>如果我们的任务主要是进行计算，那么就意味着CPU的处理能力是稀缺的资源。如果线程太多，反倒可能导致大量<br>的上下文切换开销。所以，这种情况下，通常建议按照CPU核的数目N或者N+1。<br>如果是需要较多等待的任务，例如I/O操作比较多，可以参考Brain Goetz推荐的计算方法：<code>线程数 = CPU核数 × （1 + 平均等待时间/平均工作时间）</code></p>
</blockquote>
<h4 id="AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？"><a href="#AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？" class="headerlink" title="AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？"></a>AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？</h4><ul>
<li><code>AtomicIntger</code>是对int类型的一个封装，提供原子性的访问和更新操作，其原子性操作的实现是基于<code>CAS（compare-and-swap）</code>技术。</li>
<li>所谓CAS，表征的是一些列操作的集合，获取当前数值，进行一些运算，利用CAS指令试图进行更新。如果当前数值未变，代表没有其他线程进行并发修改，则成功更新。否则，可能出现不同的选择，要么进行重试，要么就返回一个成功或者失败的结果。</li>
<li>于CAS的使用，你可以设想这样一个场景：在数据库产品中，为保证索引的一致性，一个常见的选择是，保证只有一个线程能够排他性地修改一个索引分区，</li>
</ul>
<h4 id="请介绍类加载过程，什么是双亲委派模型？"><a href="#请介绍类加载过程，什么是双亲委派模型？" class="headerlink" title="请介绍类加载过程，什么是双亲委派模型？"></a>请介绍类加载过程，什么是双亲委派模型？</h4><ul>
<li>一般来说，我们把Java的类加载过程分为三个主要步骤：加载、链接、初始化，具体行为在Java虚拟机规范里有非常详细的定义。</li>
<li><code>首先是加载阶段</code>（Loading），它是Java将字节码数据从不同的数据源读取到JVM中，并映射为JVM认可的数据结构（Class对象），这里的数据源可能是各种各样的形态，如jar文件、 class文件，甚至是网络数据源等；如果输入数据不是ClassFile的结构，则会抛出ClassFormatError。加载阶段是用户参与的阶段，我们可以自定义类加载器，去实现自己的类加载过程。</li>
<li><code>第二阶段是链接</code>（Linking），这是核心的步骤，简单说是把原始的类定义信息平滑地转化入JVM运行的过程中。这里可进一步细分为三个步骤：<blockquote>
<p><code>验证</code>: 这是虚拟机安全的重要保障，JVM需要核验字节信息是符合Java虚拟机规范的，否则就被认为是VerifyError，这样就防止了恶意信息或者不合规的信息害JVM的运行，验证阶段有可能触发更多class的加载。<br><code>准备</code>，创建类或接口中的静态变量，并初始化静态变量的初始值。但这里的“初始化”和下面的显式初始化阶段是有区别的，侧重点在于分配所需要的内存空间，不会去执行更进一步的JVM指令<br><code>解析</code>，在这一步会将常量池中的<code>符号引用</code>替换为<code>直接引用</code>。在Java虚拟机规范中，详细介绍了类、接口、方法和字段等各个方面的解析。</p>
<ul>
<li><code>最后是初始化阶段</code>（initialization），这一步真正去执行类初始化的代码逻辑，包括静态字段赋值的动作，以及执行类定义中的静态初始化块内的逻辑，编译器在编译阶段就会把这部分逻辑整理好，父类型的初始化逻辑优先于当前类型的逻辑。</li>
</ul>
</blockquote>
</li>
<li>再来谈谈<code>双亲委派模型</code>，简单说就是当类加载器（Class-Loader）试图加载某个类型的时候，除非父加载器找不到相应类型，否则尽量将这个任务代理给当前加载器的父加载器去做。使用委派模型的目的是避免重复加载Java类型。<br><img src="https://img-blog.csdnimg.cn/20190409151248407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70" alt="双亲委派模型"></li>
</ul>
<h4 id="有哪些方法可以在运行时动态生成一个Java类？"><a href="#有哪些方法可以在运行时动态生成一个Java类？" class="headerlink" title="有哪些方法可以在运行时动态生成一个Java类？"></a>有哪些方法可以在运行时动态生成一个Java类？</h4><ul>
<li>我们可以从常见的Java类来源分析，通常的开发过程是，开发者编写Java代码，调用javac编译成class文件，然后通过类加载机制载入JVM，就成为应用运行时可以使用的Java类了。</li>
<li>有一种笨办法，直接用ProcessBuilder之类启动javac进程，并指定上面生成的文件作为输入，进行编译。最后，再利用类加载器，在运行时加载即可。</li>
<li>你可以考虑使用Java Compiler API，这是JDK提供的标准API，里面提供了与javac对等的编译器功能，具体请参考java.compiler相关文档。</li>
</ul>
<h4 id="谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError？"><a href="#谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError？" class="headerlink" title="谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError？"></a>谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError？</h4><ul>
<li>通常可以把<code>JVM</code>内存区域分为下面几个方面，其中，有的区域是<code>以线程为单位</code>，而有的区域则是<code>整个JVM</code>进程唯一的。</li>
<li><code>程序计数器</code>：在JVM规范中，每个线程都有它自己的程序计数器，并且任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行本地方法，则是未指定值（undefned）。</li>
<li><code>Java虚拟机栈</code>：早期也叫<code>Java栈</code>。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的<code>栈帧</code>（Stack Frame），对应着一次次的Java方法调用。前面谈程序计数器时，提到了当前方法；同理，在一个时间点，对应的只会有一个活动的栈帧，通常叫作<code>当前帧</code>，方法所在的类叫作当前类。如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，成为新的当前帧，一直到它返回结果或者执行结束。 JVM直接对Java栈的操作只有两个，就是对栈帧的<code>压栈和出栈</code>。栈帧中存储着<code>局部变量表</code>、<code>操作数栈</code>、<code>动态链接</code>、<code>方法正常退出</code>或者<code>异常退出</code>的定义等</li>
<li><code>堆（Heap）</code>，它是Java内存管理的核心区域，用来<code>放置Java对象实例</code>，几乎所有创建的Java<code>对象实例都是被直接分配在堆上</code>。堆被<code>所有的线程共享</code>，在虚拟机启动时，我们指定的<code>“Xmx”</code>之类参数就是用来指定最大堆空间等指标。堆也是垃圾收集器重点照顾的区域，所以堆内空间还会被不同的垃圾收集器进行进一步的细分，最有名的就是<code>新生代</code>、老<code>年代</code>的划分。</li>
<li><code>方法区（Method Area）</code>。这也是所有<code>线程共享的一块内存区域</code>，用于存储所谓的<code>元（Meta）数据</code>，例如<code>类结构信息</code>，以及对应的<code>运行时常量池</code>、<code>字段</code>、<code>方法代码</code>等。由于早期的Hotspot JVM实现，很多人习惯于将方法区称为永久代， Oracle JDK 8中将永久代移除，同时<code>增加了元数据区</code>（Metaspace）</li>
<li><code>运行时常量池</code>，这是<code>方法区的一部分</code>。如果仔细分析过反编译的类文件结构，你能看到<code>版本号</code>、<code>字段</code>、<code>方法</code>、<code>超类</code>、<code>接口</code>等各种信息，还有一项信息就是<code>常量池</code>。 Java的常量池可以存放各种常量信息，不管是编译期生成的各种字面量，还是需要在运行时决定的符号引用，所以它比一般语言的符号表存储的信息更加宽泛。</li>
<li><code>本地方法栈</code>（Native Method Stack）。它和Java虚拟机栈是非常相似的，支持对本地方法的调用，也是每个线程都会创建一个</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190409170529393.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70"></p>
<h4 id="Java对象是不是都创建在堆上的呢？"><a href="#Java对象是不是都创建在堆上的呢？" class="headerlink" title="Java对象是不是都创建在堆上的呢？"></a>Java对象是不是都创建在堆上的呢？</h4><ul>
<li>有一些观点，认为通过逃逸分析， JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择</li>
<li>目前很多书籍还是基于JDK 7以前的版本， JDK已经发生了很大变化， Intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是， Intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合对象实例都是分配在堆上。</li>
</ul>
<h4 id="什么是OOM问题，它可能在哪些内存区域发生？"><a href="#什么是OOM问题，它可能在哪些内存区域发生？" class="headerlink" title="什么是OOM问题，它可能在哪些内存区域发生？"></a>什么是OOM问题，它可能在哪些内存区域发生？</h4><ul>
<li>OOM如果通俗点儿说，就是JVM内存不够用了， javadoc中对<code>OutOfMemoryError</code>的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。在抛出OutOfMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理出空间。当然，也不是在任何情况下垃圾收集器都会被触发的，比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值， JVM可以判断出垃圾收集并不能解决这个问题，所以直接抛出OutOfMemoryError。<blockquote>
<p>从我前面分析的数据区的角度，除<code>了程序计数器，其他区域都有可能会因为可能的空间不足发OutOfMemoryError，简单总结如下</code>：</p>
</blockquote>
</li>
<li><code>堆内存不足是最常见的OOM原因之一</code>，抛出的错误信息是“java.lang.OutOfMemoryError:Java heap space”，原因可能千奇百怪，例如，可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小；或者出现JVM处理引用不及时，导致堆积起来，内存无法释放等。</li>
<li>而对于Java虚拟机栈和本地方法栈，这里要稍微复杂一点。如果我们写一段程序不断的进行递归调用，而且没有退出条件，就会导致不断地进行压栈。类似这种情况， JVM实际会抛出StackOverFlowError；当然，如果JVM试图去扩展栈空间的的时候失败，则会抛出OutOfMemoryError。</li>
<li><code>对于老版本的Oracle JDK</code>，因为永久代的大小是有限的，并且JVM对永久代垃圾回收（<code>如，常量池回收、卸载不再需要的类型</code>）非常不积极，所以当我们不断添加新类型的时候，永久代出现<code>OutOfMemoryError</code>也非常多见，尤其是在运行时存在大量动态类型生成的场合；类似Intern字符串缓存占用太多空间，也会导致<code>OOM</code>问题。对应的异常信息，会标记出来和永久代相关： “<code>java.lang.OutOfMemoryError: PermGen space</code>”。</li>
<li><code>随着元数据区的引入</code>，方法区内存已经不再那么窘迫，所以相应的OOM有所改观，出现OOM，异常信息则变成了： “<code>java.lang.OutOfMemoryError: Metaspace</code>”。</li>
<li>直接内存不足，也会导致OOM</li>
</ul>
<blockquote>
<p>我在试图分配一个100M bytes大数组的时候发生了OOME，但是GC日志显示，明明堆上还有远不止100M的空<br>间，你觉得可能问题的原因是什么？想要弄清楚这个问题，还需要什么信息呢？</p>
</blockquote>
<ul>
<li>从不同的垃圾收集器角度来看：首先，数组的分配是需要连续的内存空间的。所以对于使用年轻代和老年代来管理内存的垃圾收集器，堆大于 100M，表示的是新生代和老年代加起来总和大于100M，而新生代和老年代各自并没有大于 100M 的连续内存空间。进一步，又由于大数组一般直接进入老年代（会跳过对对象的年龄的判断），所以，是否可以认为老年代中没有连续大于 100M 的空间呢。</li>
<li>对于 G1 这种按 region 来管理内存的垃圾收集器，可能的情况是没有多个连续的 region，它们的内存总和大于 100M。当然，不管是哪种垃圾收集器以及收集算法，当内存空间不足时，都会触发 GC，只不过，可能 GC 之后，还是没有连续大于 100M 的内存空间，于是 OOM了。</li>
</ul>
<h4 id="如何监控和诊断JVM堆内和堆外内存使用？"><a href="#如何监控和诊断JVM堆内和堆外内存使用？" class="headerlink" title="如何监控和诊断JVM堆内和堆外内存使用？"></a>如何监控和诊断JVM堆内和堆外内存使用？</h4><ul>
<li>可以使用综合性的图形化工具，如JConsole、 VisualVM（注意，从Oracle JDK 9开始， VisualVM已经不再包含在JDK安装包中）等。这些工具具体使用起来相对比较直观，直接连接到Java进程，然后就可以在图形化界面里掌握内存使用情况。<blockquote>
<p>以JConsole为例，其内存页面可以显示常见的堆内存和各种堆外部分使用状态。</p>
</blockquote>
</li>
<li>也可以使用命令行工具进行运行时查询，如jstat和jmap等工具都提供了一些选项，可以查看堆、方法区等使用数据。</li>
<li>或者，也可以使用jmap等提供的命令，生成堆转储（Heap Dump）文件，然后利用jhat或Eclipse MAT等堆转储分析工具进行详细分析。</li>
<li>如果你使用的是Tomcat、 Weblogic等Java EE服务器，这些服务器同样提供了内存管理相关的功能。</li>
<li>另外，从某种程度上来说， GC日志等输出，同样包含着丰富的信息。</li>
<li><a href="https://docs.oracle.com/javase/7/docs/technotes/guides/management/jconsole.html">JConsole官方教程</a>。我这里特别推荐<a href="https://www.oracle.com/technetwork/java/javaseproducts/mission-control/java-mission-control-1998576.html">Java Mission Control（JMC）</a>，这是一个非常强大的工具，不仅仅能够使用JMX进行普通的管理、监控任务，还可以配合Java Flight Recorder（JFR）技术，以非常低的开销，收集和分析JVM底层的Profling和事件等信息。</li>
</ul>
<p><strong>堆内部是什么结构？</strong><br><img src="https://img-blog.csdnimg.cn/20190409174432758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70"><br>你可以看到，按照通常的GC年代方式划分， Java堆内分为：</p>
<p><strong>新生代</strong></p>
<ul>
<li>新生代是大部分对象创建和销毁的区域，在通常的Java应用中，绝大部分对象生命周期都是很短暂的。其内部又分为Eden区域，作为对象初始分配的区域；两个Survivor，有时候也叫from、 to区域，被用来放置从Minor GC中保留下来的对象。</li>
<li>JVM会随意选取一个Survivor区域作为“to”，然后会在GC过程中进行区域间拷贝，也就是将Eden中存活下来的对象和from区域的对象，拷贝到这个“to”区域。这种设计主要是为了防止内存的碎片化，并进一步清理无用对象。</li>
<li>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分， Hotspot JVM还有一个概念叫做（TLAB）。这是JVM为每个线程分配的一个私有缓存区域，否则，多线程同时分配内存时，为避免操作同一地址，可能需要使用加锁等机制，进而影响分配速度，TLAB仍然在堆上，它是分配在Eden区域内的。其内部结构比较直观易懂， start、 end就是起始地址， top（指针）则表示已经分配到哪里了。所以我们分配新对象， JVM就会移动top，当top和end相遇时，即表示该缓存已满， JVM会试图再从Eden里分配一块儿。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190409174715206.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70"></p>
<p><strong>老年代</strong></p>
<ul>
<li>放置长生命周期的对象，通常都是从Survivor区域拷贝过来的对象。当然，也有特殊情况，我们知道普通的对象会被分配在TLAB上；如果对象较大， JVM会试图直接分配在Eden其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间， JVM就会直接分配到老年代。</li>
</ul>
<p><strong>永久代</strong></p>
<ul>
<li><p>这部分就是早期Hotspot JVM的方法区实现方式了，储存Java类元数据、常量池、 Intern字符串缓存，在JDK 8之后就不存在永久代这块儿了。</p>
<p><strong>利用JVM参数，直接影响堆和内部区域的大小</strong></p>
</li>
<li><p>最大堆体积：<code>-Xmx value</code></p>
</li>
<li><p>初始的最小堆体积：<code>-Xms value</code></p>
</li>
<li><p>老年代和新生代的比例：<code>-XX:NewRatio=value</code>。默认情况下，这个数值是3，意味着老年代是新生代的3倍大；换句话说，新生代是堆大小的1/4。也可以不用比例的方式调整新生代的大小，直接<code>-XX:NewSize=value</code>参数，设定具体的内存大小数值。</p>
</li>
</ul>
<h4 id="Java常见的垃圾收集器有哪些？"><a href="#Java常见的垃圾收集器有哪些？" class="headerlink" title="Java常见的垃圾收集器有哪些？"></a>Java常见的垃圾收集器有哪些？</h4><ul>
<li><p><code>Serial GC</code>，它是最古老的垃圾收集器， “Serial”体现在其收集<code>工作是单线程</code>的，并且在进行垃圾收集过程中，会进入臭名昭著的<code>“Stop-The-World”</code>状态。当然，其<code>单线程设计</code>也意味着精简的GC实现，无需维护复杂的数据结构，初始化也简单，所以一直是Client模式下JVM的默认选项。</p>
</li>
<li><p>从年代的角度，通常将其老年代实现单独称作<code>Serial Old</code>，它采用了标记-整理（Mark-Compact）算法，区别于新生代的复制算法。Serial GC的对应JVM参数是：<code>-XX:+UseSerialGC</code></p>
</li>
<li><p><code>ParNew GC</code>，很明显是个<code>新生代GC</code>实现，它实际<code>是Serial GC的多线程版本</code>，最常见的应用场景是配合老年代的CMS GC工作，下面是对应参数 <code>-XX:+UseConcMarkSweepGC -XX:+UseParNewGC</code></p>
</li>
<li><p><code>CMS GC</code>，基于标记-清除（Mark-Sweep）算法 设计目标是尽量减少停顿时间，这一点对于Web等反应时间敏感的应用非常重要，一直到今天，仍然有很多系统使用CMS GC。但是， CMS采用的<code>标记-清除算法</code>，存在着<code>内存碎片化</code>问题，所以难以避免在长时间运行等情况下发生<code>full GC</code>，导致恶劣的停顿。另外，既然强调了并发（Concurrent）， CMS会<code>占用更多CPU资源</code>，并和用户线程争抢。</p>
</li>
<li><p><code>Parrallel GC</code>，在早期JDK 8等版本中，它是server模式JVM的默认GC选择,也被称作是吞吐量优先的GC。它的算法和Serial GC比较相似，尽管实现要复杂的多，其特点是<code>新生代和老年代GC都是并行进行</code>的，在常见的服务器环境中更加高效。开启选项是：<code>-XX:+UseParallelGC</code>  另外， Parallel GC引入了开发者友好的配置项，我们可以直接设置暂停时间或吞吐量等目标， JVM会自动进行适应性调整，例如下面参数：</p>
<blockquote>
<p><code>-XX:MaxGCPauseMillis=value</code>,<br>-XX:GCTimeRatio=N         //GC时间和用户时间比例 = 1 / (N+1)<br><code>查看jdk垃圾收集器</code>：java -XX:+PrintCommandLineFlags -version  </p>
</blockquote>
</li>
<li><p>G1 GC这是一种兼顾吞吐量和停顿时间的GC实现，是Oracle JDK 9以后的默认GC选项。 G1可以直观的设定停顿时间的目标，相比于CMS GC， G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</p>
</li>
<li><p>G1 GC仍然存在着年代的概念，但是其内存结构并不是简单的条带式划分，而是类似棋盘的一个个region。 Region之间是复制算法，但整体上实际可看作是标记-整理（MarkCompact）算法，可以有效地避免内存碎片，尤其是当Java堆非常大的时候， G1的优势更加明显。</p>
</li>
<li><p>G1吞吐量和停顿表现都非常不错，并且仍然在不断地完善，与此同时CMS已经在JDK 9中被标记为废弃（deprecated），所以G1 GC值得你深入掌握。</p>
</li>
</ul>
<h4 id="如何判断一个对象是否可以回收"><a href="#如何判断一个对象是否可以回收" class="headerlink" title="如何判断一个对象是否可以回收"></a>如何判断一个对象是否可以回收</h4><p>主要是两种基本算法， 引用计数和可达性分析</p>
<ul>
<li><code>引用计数算法</code>，顾名思义，就是为对象添加一个引用计数，用于记录对象被引用的情况，如果计数为0，即表示对象可回收。Java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。</li>
<li><code>Java选择的可达性分析</code>， Java的各种引用关系，在某种程度上，将可达性问题还进一步复杂化,这种类型的垃圾收集通常叫作追踪性垃圾收集。其原理简单来说，就是将对象及其引用关系看作一个图，选定活动的对象作为 <code>GC Roots</code>，然后跟踪引用链条，如果一个对象和<code>GC Roots之间不可达</code>，也就是不存在引用链条，那么即可认为是可回收对象。 JVM会把虚拟机栈和本地方法栈中正在引用的<code>对象、静态属性引用的对象和常量，作为GC Roots</code>。</li>
</ul>
<h4 id="常见的垃圾收集算法"><a href="#常见的垃圾收集算法" class="headerlink" title="常见的垃圾收集算法"></a>常见的垃圾收集算法</h4><ul>
<li><code>复制（Copying）算法</code>：将活着的对象复制到to区域，拷贝过程中将对象顺序放置，就可以避免内存碎片化。这么做的代价是，既然要进行复制，既要提前预留内存空间，有一定的浪费；另外，对于G1这种分拆成为大量regio GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，这个开销也不小，不管是内存占用或者时间开销。</li>
<li><code>标记-清除（Mark-Sweep）算法</code>，首先进行标记工作，标识出所有要回收的对象，然后进行清除。这么做除了标记、清除过程效率有限，另外就是不可避免的出现碎片化问题，这就导致其不适合特别大的堆；否则，一旦出现Full GC，暂停时间可能根本无法接受。</li>
<li><code>标记-整理（Mark-Compact）</code>，类似于标记-清除，但为避免内存碎片化，它会在清理过程中将对象移动，以确保移动后的对象占用连续的内存空间。</li>
</ul>
<h4 id="在垃圾收集的过程，对应到Eden、-Survivor、-Tenured等区域会发生什么变化呢？"><a href="#在垃圾收集的过程，对应到Eden、-Survivor、-Tenured等区域会发生什么变化呢？" class="headerlink" title="在垃圾收集的过程，对应到Eden、 Survivor、 Tenured等区域会发生什么变化呢？"></a>在垃圾收集的过程，对应到Eden、 Survivor、 Tenured等区域会发生什么变化呢？</h4><ul>
<li>这实际上取决于具体的GC方式，先来熟悉一下通常的垃圾收集流程，我画了一系列示意图，希望能有助于你理解清楚这个过程。</li>
</ul>
<p>第一， Java应用不断创建对象，通常都是分配在Eden区域，当其空间占用达到一定阈值时，触发minor GC。仍然被引用的对象（绿色方块）存活下来，被复制到JVM选择的Survivor区域，而没有被引用的对象（黄色方块）则被回收。注意，我给存活对象标记了“数字1”，这是为了表明对象的存活时间。</p>
<p><img src="https://img-blog.csdnimg.cn/20190409183348554.png"></p>
<p>第二， 经过一次<code>Minor GC</code>， Eden就会空闲下来，直到再次达到<code>Minor GC</code>触发条件，这时候，另外一个<code>Survivor</code>区域则会成为<code>to</code>区域， <code>Eden</code>区域的存活对象和<code>From</code>区域对象，都会被复制到<code>to</code>区域，并且存活的年龄计数会被加<code>1</code>。</p>
<p><img src="https://img-blog.csdnimg.cn/20190409183455640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70"></p>
<p>第三， 类似第二步的过程会发生很多次，直到有对象年龄计数达到阈值，这时候就会发生所谓的晋升（Promotion）过程，如下图所示，超过阈值的对象会被晋升到老年代。<br>这个阈值是可以通过参数指定：<code>-XX:MaxTenuringThreshold=&lt;N&gt;</code></p>
<p><img src="https://img-blog.csdnimg.cn/20190409183559189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70"></p>
<p>后面就是<code>老年代GC</code>，具体取决于选择的<code>GC</code>选项，对应不同的算法。通常我们把<code>老年代GC</code>叫作<code>Major GC，</code>将对整个<code>堆进行的清理</code>叫作<code>Full GC</code>，但是这个也没有那么绝对，因为不同的老年代GC算法其实表现差异很大，例如<code>CMS</code>， <code>“concurrent”</code>就体现在清理工作是与工作线程一起并发运行的。</p>
<p><strong>JDK又增加了两种全新的GC方式，分别是：</strong></p>
<ul>
<li><code>Epsilon GC</code>，简单说就是个<code>不做垃圾收集的GC</code>，似乎有点奇怪，有的情况下，例如在进行性能测试的时候，可能需要明确判断GC本身产生了多大的开销，这就是其典型应用场景。</li>
<li><code>ZGC</code>，这是Oracle开源出来的一个<code>超级GC</code>实现，具备令人惊讶的扩展能力，比如支持<code>T bytes级</code>别的堆大小，并且保证绝大部分情况下，<code>延迟都不会超过10 ms</code>。虽然目前还处于<code>实验阶段</code>，仅支持Linux 64位的平台，但其已经表现出的能力和潜力都非常令人期待。</li>
</ul>
<h4 id="java内存模型中的happen-before是什么？"><a href="#java内存模型中的happen-before是什么？" class="headerlink" title="java内存模型中的happen-before是什么？"></a>java内存模型中的happen-before是什么？</h4><ul>
<li>Happen-before关系，是Java内存模型中保证多线程操作可见性的机制，也是对早期语言规范中含糊的可见性概念的一个精确定义。</li>
<li>线程内执行的每个操作，都保证happen-before后面的操作，这就保证了基本的程序顺序规则，这是开发者在书写程序时的基本约定。</li>
<li>对于volatile变量，对它的写操作，保证happen-before在随后对该变量的读取操作。</li>
<li>对于一个锁的解锁操作，保证happen-before加锁操作。</li>
<li>对象构建完成，保证happen-before于fnalizer的开始动作。</li>
<li>甚至是类似线程内部操作的完成，保证happen-before其他Thread.join()的线程等。</li>
<li>这些happen-before关系是存在着传递性的，如果满足a happen-before b和b happen-before c，那么a happen-before c也成立。</li>
<li>JMM内部的实现通常是依赖于所谓的内存屏障，通过禁止某些重排序的方式，提供内存可见性保证，也就是实现了各种happen-before规则。与此同时，更多复杂度在于，需要尽量确保各种编译器、各种体系结构的处理器，都能够提供一致的行为。<blockquote>
<p><code>可从四个维度去理解JMM</code></p>
</blockquote>
</li>
<li>从JVM运行时视角来看， JVM内存可分为JVM栈、本地方法栈、 PC计数器、方法区、堆；其中前三区是线程所私有的，后两者则是所有线程共有的</li>
<li>从JVM内存功能视角来看， JVM可分为堆内存、非堆内存与其他。其中堆内存对应于上述的堆区；非堆内存对应于上述的JVM栈、本地方法栈、 PC计数器、方法区；其他则对应于直接内存</li>
<li>从线程运行视角来看， JVM可分为主内存与线程工作内存。 Java内存模型规定了所有的变量都存储在主内存中；每个线程的工作内存保存了被该线程使用到的变量，这些变量是主内存的副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量</li>
<li>从垃圾回收视角来看， JVM中的堆区=新生代+老年代。新生代主要用于存放新创建的对象与存活时长小的对象，新生代=E+S1+S2；老年代则用于存放存活时间长的对象</li>
</ul>
<h4 id="JVM优化Java代码时都做了什么"><a href="#JVM优化Java代码时都做了什么" class="headerlink" title="JVM优化Java代码时都做了什么?"></a>JVM优化Java代码时都做了什么?</h4><ul>
<li>JVM在对代码执行的优化可分为<code>运行时化</code>和<code>即时编译器优化</code>。<code>运行时优化主要是</code>解析执行和动态编译通用的一些机制,比如说锁机制(<code>如偏向锁</code>)、内存分配机制(<code>如TLAB</code>)。除此之外，还有一些专门优化器执行效率的，比如说模板解析器，内联缓存。</li>
<li>J<code>VM的即时编译器优化</code>是指将热点代码以方法为单位转换成机器码,直接运行在底层硬件之上。它采用了多种优化方式,包括静态编译器可以使用的如方法内联、逃逸分析,也􏰂包括基于程序运行<code>profle</code>的投机性优化，这个怎么理解了?比如我有一条<code>instanceof</code>指令,在编译之前的运行过程中,测试对像的类一直是同一个，那么即时编译器可以假设编译之后的执行过程中还会是这一个类，并且根据这个类直接返回<code>instanceof</code>的结果。如果出现了其他类,那么就抛弃这段编译后的机器码,并且切换回解析执行。</li>
</ul>
<h4 id="谈谈常用的分布式ID的设计方案-Snowflake是否受冬令时切换影响"><a href="#谈谈常用的分布式ID的设计方案-Snowflake是否受冬令时切换影响" class="headerlink" title="谈谈常用的分布式ID的设计方案?Snowflake是否受冬令时切换影响?"></a>谈谈常用的分布式ID的设计方案?Snowflake是否受冬令时切换影响?</h4><ul>
<li>基于数据库自增序列的实现。这种方式优缺点都非常明显，好处是简单易用,但是在扩展性和可靠性等方面存在局限性。</li>
<li>基于Twitter 早期开源的Snowflake的实现,以及相关改动方案。<br><img src="https://img-blog.csdnimg.cn/20190409221903872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70"></li>
<li>整体长度通常是64 (1 + 41 + 10+ 12 = 64)位,适合使用Java语言中的long类型来存储。</li>
<li>头部是1位的正负标识位。跟着的高位部分包含41位时间戳,通常使用<code>System.currentTimeMillis()</code></li>
<li>后面是<code>10位</code>的<code>WorkerID</code>,标准定义是5位数据中心 + 5位机器ID,组成了机器编􏱆号，以区分不同的集群节点。</li>
<li>最后的12位就是单位毫秒内可生成的序列号数目的理论极限。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程和JVM</title>
    <url>/2020/10/14/0000.%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h4 id="1-并行和并发有什么区别？"><a href="#1-并行和并发有什么区别？" class="headerlink" title="1.并行和并发有什么区别？"></a>1.并行和并发有什么区别？</h4><ul>
<li>并行是在不同实体上的多个事件，并发是在同一实体上的多个事件</li>
<li>在一台处理器上“同时”处理多个任务是并行，在多台处理器上同时处理多个任务。如hadoop分布式集群</li>
</ul>
<h4 id="2-ThreadLocal是什么？"><a href="#2-ThreadLocal是什么？" class="headerlink" title="2.ThreadLocal是什么？"></a>2.ThreadLocal是什么？</h4><ul>
<li>ThreadLocal 是一个本地线程副本变量工具类。主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰</li>
<li><code>ThreadLocal</code>内部还有一个静态内部类ThreadLocalMap，该内部类才是实现线程隔离机制的关键，get()、set()、remove()都是基于该内部类操作。ThreadLocalMap提供了一种用键值对方式存储每一个线程的变量副本的方法，key为当前ThreadLocal对象，value则是对应线程的变量副本。</li>
<li>每个<code>Thread</code>内部都有一个<code>ThreadLocal.ThreadLocalMap</code>类型的成员变量，该成员变量用来存储实际的<code>ThreadLocal</code>变量副本。</li>
<li><code>ThreadLocal</code>并不是为线程保存对象的副本，它仅仅只起到一个索引的作用。它的主要目的是为每一个线程隔离一个类的实例，这个实例的作用范围仅限于线程内部。</li>
</ul>
<h4 id="2-1-ThreadLocal为什么会内存泄漏？"><a href="#2-1-ThreadLocal为什么会内存泄漏？" class="headerlink" title="2.1 ThreadLocal为什么会内存泄漏？"></a>2.1 ThreadLocal为什么会内存泄漏？</h4><ul>
<li>每个Thread都有一个<code>ThreadLocal.ThreadLocalMap</code>的map，该map的key为<code>ThreadLocal</code>实例，它为一个弱引用,因为弱引用有利于GC回收。当ThreadLocal的key == null时，GC就会回收这部分空间，但是value却不一定能够被回收，因为他还与C当前线程存在一个强引用关系，会导致value无法回收，如果这个线程对象不会销毁那么这个强引用关系则会一直存在，就会出现内存泄漏情况。所以说只要这个线程对象能够及时被GC回收，就不会出现内存泄漏。如果碰到线程池，那就更坑了。</li>
</ul>
<h4 id="3-Lock接口拥有synchronized所不具备的哪些特性"><a href="#3-Lock接口拥有synchronized所不具备的哪些特性" class="headerlink" title="3.Lock接口拥有synchronized所不具备的哪些特性?"></a>3.Lock接口拥有synchronized所不具备的哪些特性?</h4><ul>
<li>与Synchronized不同，获取到锁的线程能够相应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放</li>
<li>超时获取锁，以及可以尝试非阻塞地获取锁(调用后可立即返回锁是否获取成功)</li>
<li>Lock是一个接口，它需要程序员自己定义了锁获取和释放的基本操作</li>
</ul>
<h4 id="4-线程和进程的区别？"><a href="#4-线程和进程的区别？" class="headerlink" title="4.线程和进程的区别？"></a>4.线程和进程的区别？</h4><ul>
<li>进程是资源分配最小单位，线程是程序执行的最小单位</li>
<li>线程是进程的一个执行单元。线程也被称为轻量级进程。</li>
<li>线程执行开销小，但是不利于资源的管理和保护。对资源的管理和保护要求高，不限制开销和效率时，使用多进程。</li>
<li>进程执行开销大，但是能够很好的进行资源管理和保护。要求效率高，频繁切换时，资源的保护管理要求不是很高时，使用多线程。</li>
</ul>
<h4 id="5-守护线程是什么？"><a href="#5-守护线程是什么？" class="headerlink" title="5.守护线程是什么？"></a>5.守护线程是什么？</h4><ul>
<li>守护线程，专门用于服务其他的线程，如果其他的线程（即用户自定义线程）都执行完毕，连main线程也执行完毕，那么jvm就会退出（即停止运行）——此时，连jvm都停止运行了，守护线程当然也就停止执行了。</li>
</ul>
<h4 id="6-创建线程有哪几种方式？"><a href="#6-创建线程有哪几种方式？" class="headerlink" title="6.创建线程有哪几种方式？"></a>6.创建线程有哪几种方式？</h4><ul>
<li>继承Thread类和实现Runnable接口，以及线程池技术</li>
<li>通过Callable接口并实现call()方法，该call()方法将作为线程执行体，并且有返回值</li>
</ul>
<h4 id="7-说一下-runnable-和-callable-有什么区别？"><a href="#7-说一下-runnable-和-callable-有什么区别？" class="headerlink" title="7.说一下 runnable 和 callable 有什么区别？"></a>7.说一下 runnable 和 callable 有什么区别？</h4><ul>
<li>相同点：两者都是接口。都可以用来创建多线程。都需要调用Thread.start()启动线程</li>
<li>不同点：实现Callable接口的任务线程能返回执行结果；而实现Runnable接口的任务线程不能返回结果。</li>
<li>Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛；</li>
<li>Callable接口支持返回执行结果，此时需要调用FutureTask.get()方法实现，此方法会阻塞主线程直到获取‘将来’结果；当不调用此方法时，主线程不会阻塞</li>
</ul>
<h4 id="8-说一下-synchronized-底层实现原理？"><a href="#8-说一下-synchronized-底层实现原理？" class="headerlink" title="8.说一下 synchronized 底层实现原理？"></a>8.说一下 synchronized 底层实现原理？</h4><ul>
<li>synchronized加在普通方法上，锁的当前对象的实例。也叫对象锁</li>
<li>synchronized加在static方法上.锁的事当前类的class对象。也就是当前类的字节码文件对象，当类加载进内存，就会产生字节码文件对象</li>
<li>同步方法块，锁是括号里面的对象。同步代码块是使用monitorenter和monitorexit指令实现的.JVM需要保证每一个monitorenter都有一个monitorexit与之相对应。任何对象都有一个monitor与之相关联，当且一个monitor被持有之后，他将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁；</li>
<li>同步方法依靠的是方法修饰符上的ACC_SYNCHRONIZED实现</li>
<li>synchronized用的锁是存在Java对象头里的.如果对象是数组类型，则虚拟机用3个字宽（Word）存储对象头，如果对象是非数组类型，则用2字宽存储对象头</li>
<li>java对象头里的Mark-Word里默认存储对象的HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等 </li>
</ul>
<h4 id="9-synchronized锁的升级与对比"><a href="#9-synchronized锁的升级与对比" class="headerlink" title="9.synchronized锁的升级与对比"></a>9.synchronized锁的升级与对比</h4><ul>
<li>jdk1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</li>
<li>锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</li>
</ul>
<h4 id="10-自旋锁"><a href="#10-自旋锁" class="headerlink" title="10.自旋锁"></a>10.自旋锁</h4><ul>
<li>自旋锁:所谓自就是让线程执行一段无意义的循环，防止不会被立即挂起。看持有锁的线程是否会很快释放锁。优点是避免线程切换带来的开销，缺点是：占用了处理器的时间。在JDK1.6中默认开启。同时自旋的默认次数为10次，可以通过参数-XX:PreBlockSpin来调整；</li>
</ul>
<h4 id="11-适应自旋锁"><a href="#11-适应自旋锁" class="headerlink" title="11.适应自旋锁"></a>11.适应自旋锁</h4><ul>
<li>适应自旋锁：所谓自适应就意味着自旋的次数不再是固定的。而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。线程如果自旋成功了，那么下次自旋的次数会更加多。反之如果自旋很少能成功，那吗在以后获取这个锁时自选次数会减少或者直接忽略掉自旋操作。</li>
</ul>
<h4 id="12-锁消除和锁粗化"><a href="#12-锁消除和锁粗化" class="headerlink" title="12.锁消除和锁粗化"></a>12.锁消除和锁粗化</h4><ul>
<li>锁消除：如果JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除。锁消除的依据是逃逸分析的数据支持。比如StringBuffer的append()方法，Vector的add()方法</li>
<li>锁粗化：就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁</li>
</ul>
<h4 id="13-synchronized的锁升级流程之偏向锁"><a href="#13-synchronized的锁升级流程之偏向锁" class="headerlink" title="13.synchronized的锁升级流程之偏向锁"></a>13.synchronized的锁升级流程之偏向锁</h4><ul>
<li>当一个线程访问同步代码块时，会在对象头和栈帧中的锁记录里存储偏向的线程ID，以后该线程进入和退出同步块时，不需要执行CAS操作来加锁和解锁，只需要简单的测试下对象头的Mark-Word是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已获取到锁</li>
<li>如果测试失败，则需要在测试下Mark-Word中偏向锁的表示是否设置为1（表示当前是偏向锁）；如果没有设置，则使用CAS竞争；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</li>
<li>偏向锁使用了一种等到竞争出现才释放锁的机制，当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁</li>
<li>偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）</li>
<li>它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否存活，如果线程处于不活动状态，则会将对象头设置成无锁状态</li>
<li>如果线程仍然活着，拥有偏向锁的线程会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程</li>
</ul>
<h4 id="14-synchronized的锁升级流程之轻量级锁"><a href="#14-synchronized的锁升级流程之轻量级锁" class="headerlink" title="14.synchronized的锁升级流程之轻量级锁"></a>14.synchronized的锁升级流程之轻量级锁</h4><ul>
<li>引入轻量级锁的目的是为了减轻重量级锁使用操作系统的互斥量产生的性能消耗。当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁</li>
<li>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间,并将对象头中的Mark Word复制到锁记录中(官方称为Displaced Mark Word)</li>
<li>然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针</li>
<li>如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁</li>
<li>轻量级解锁时，会使用原子的CAS操作将Displaced-Mark-Word替换回到对象头。如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁</li>
<li>轻量级锁的加锁和释放锁都是使用CAS操作来执行的</li>
</ul>
<h4 id="14-synchronized的锁升级流程之重量级锁"><a href="#14-synchronized的锁升级流程之重量级锁" class="headerlink" title="14.synchronized的锁升级流程之重量级锁"></a>14.synchronized的锁升级流程之重量级锁</h4><ul>
<li>重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。</li>
</ul>
<h4 id="15-偏向锁-轻量锁，重量级锁的优缺点对比"><a href="#15-偏向锁-轻量锁，重量级锁的优缺点对比" class="headerlink" title="15.偏向锁,轻量锁，重量级锁的优缺点对比"></a>15.偏向锁,轻量锁，重量级锁的优缺点对比</h4><ul>
<li>偏向锁： 加锁和解锁不需要额外的消耗，和执行非同步方法只存在纳秒级的差距。缺点是如果线程间存在锁竞争，会带来额外的锁撤销的消耗。适用于只有一个线程访问同步块</li>
<li>轻量级锁：竞争的线程不会阻塞，提高了线程的响应速度。缺点是如果始终得不到锁竞争的线程，使用自旋会消耗CPU。适用于追求响应时间，同步块执行速度非常快</li>
<li>重量级锁：线程竞争不使用自旋，不会消耗CPU。缺点是线程阻塞，响应时间慢。适用追求吞吐量，同步块执行时间过长。</li>
</ul>
<h4 id="彻底搞懂synchronized-从偏向锁到重量级锁"><a href="#彻底搞懂synchronized-从偏向锁到重量级锁" class="headerlink" title="彻底搞懂synchronized(从偏向锁到重量级锁)"></a>彻底搞懂synchronized(从偏向锁到重量级锁)</h4><ul>
<li>java对象在内存中的存储结构主要有一下三个部分：对象头,实例数据,填充数据.对象头中存储的事hashCode,GC分代年龄，锁信息。</li>
<li>对象被创建出来的那一刻，就有了偏向锁的标志位，偏向锁的标志位是“01”，状态是“0”。偏向锁默认是开启的，但是创建对象时初始化状态是没生效的。</li>
<li>线程执行到临界区时，此时会利用CAS操作，将线程ID插入到Markword中，同时修改偏向锁的标志位为1。所谓临界区，就是只允许一个线程进去执行操作的区域，即同步代码块</li>
<li>这个锁会偏向于第一个获得它的线程，在接下来的执行过程中，假如该锁没有被其他线程所获取，没有其他线程来竞争该锁，那么持有偏向锁的线程将永远不需要进行同步操作。而是简单判断一下当前线程id是否与Markword当中的线程id是否一致.一致则继续执行下面代码</li>
<li>不一致，则要检查一下对象是否还是可偏向。如果还未偏向，则利用CAS操作来竞争锁，也即是第一次获取锁时的操作。</li>
<li>如果此对象已经偏向了，并且不是偏向自己，则说明存在了竞争。此时可能就要根据另外线程的情况，可能是重新偏向，也有可能是做偏向撤销，但大部分情况下就是升级成轻量级锁了。</li>
<li>由于偏向锁失效了，那么接下来就得把该锁撤销，在一个安全点停止拥有锁的线程，遍历线程栈，如果存在锁记录的话，需要修复锁记录和Markword，使其变成无锁状态。唤醒当前线程，将当前锁升级成轻量级锁。</li>
<li>锁撤销升级为轻量级锁之后，那么对象的Markword也会进行相应的的变化。线程在自己的栈桢中创建锁记录LockRecord。将锁对象的对象头中的MarkWord复制到线程的刚刚创建的锁记录中。将锁记录中的Owner指针指向锁对象。将锁对象的对象头的MarkWord替换为指向锁记录的指针。</li>
<li>轻量级锁主要有两种：自旋锁，自适应自旋锁。所谓自旋，就是指当有另外一个线程来竞争锁时，这个线程会在原地循环等待，而不是把该线程给阻塞，直到那个获得锁的线程释放锁之后，这个线程就可以马上获得锁的。</li>
<li>默认情况下，自旋的次数为10次。当线程超过了这个次数，我们就认为，继续使用自旋锁就不适合了，此时锁会再次膨胀，升级为重量级锁。</li>
<li>重量级锁是依赖对象内部的monitor锁来实现的，而monitor又依赖操作系统的MutexLock(互斥锁)来实现的，所以重量级锁也被成为互斥锁。</li>
</ul>
<h4 id="16-原子操作的实现原理"><a href="#16-原子操作的实现原理" class="headerlink" title="16.原子操作的实现原理"></a>16.原子操作的实现原理</h4><ul>
<li>原子操作意为不可被中断的一个或一系列操作</li>
<li>处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。</li>
<li>总线锁：所谓总线锁就是使用处理器提供的一个LOCK#信号，当一个处理器在总线锁输出此信号时，其它处理器就会被阻塞，该处理器将独占内存。</li>
<li>缓存锁：所谓 “缓存锁定“是指内存区域如果被锁定在缓存处理器缓存行中，并且Lock操作期间被锁定,那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK#信号，而是修改内存的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会是缓存行无效。</li>
<li>java如何实现原子操作： 使用循环CAS和锁的方式实现原子操作</li>
</ul>
<h4 id="17-CAS实现原子操作的三大问题"><a href="#17-CAS实现原子操作的三大问题" class="headerlink" title="17.CAS实现原子操作的三大问题"></a>17.CAS实现原子操作的三大问题</h4><ul>
<li>JVM中的CAS是利用处理的cmpxchg（汇编指令，比较并交换操作数）来实现的</li>
<li>ABA问题（CAS操作时需要先检查值是否变化，但是一个值是A接着被改为B 后面又修改为A，CAS操作就会认为他们没有变化。ABA的解决思路是利用版本号）</li>
<li>循环时长开销大（自旋CAS长时间不成功会增大CPU的开销）</li>
<li>只能保证一个共享变量的原子操作。解决思路把多个变量合并为一个变量操作。JDK1.5开始提供了AtomicReference保证对象引用之间的原子性，就可以把多个变量放在同一个对象里进行CAS操作</li>
</ul>
<h4 id="18-线程有哪些状态？"><a href="#18-线程有哪些状态？" class="headerlink" title="18.线程有哪些状态？"></a>18.线程有哪些状态？</h4><ul>
<li>新建(NEW)：新创建了一个线程对象。</li>
<li>可运行(RUNNABLE)：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权 。</li>
<li>运行(RUNNING)：可运行状态(runnable)的线程获得了cpu时间片（timeslice） ，执行程序代码。</li>
<li>阻塞(BLOCKED)：阻塞状态是指线程因为某种原因放弃了cpu使用权，暂时停止运行。阻塞的情况分三种：等待阻塞（wait方法）， 同步阻塞（线程在获取对象的同步锁时）， 其他阻塞（Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时）</li>
</ul>
<h4 id="19-sleep-和-wait-有什么区别？"><a href="#19-sleep-和-wait-有什么区别？" class="headerlink" title="19.sleep() 和 wait() 有什么区别？"></a>19.sleep() 和 wait() 有什么区别？</h4><ul>
<li>sleep()方法是Thread的静态方法，而wait是Object实例方法</li>
<li>wait()方法必须要在同步方法或者同步块中调用，也就是必须已经获得对象锁。而sleep()方法没有这个限制可以在任何地方种使用</li>
<li>wait()方法会释放占有的对象锁，使得该线程进入等待池中，等待下一次获取资源。而sleep()方法只是会让出CPU并不会释放掉对象锁；</li>
<li>sleep()方法在休眠时间达到后如果再次获得CPU时间片就会继续执行，而wait()方法必须等待Object.notift/Object.notifyAll通知后，才会离开等待池，并且再次获得CPU时间片才会继续执行。</li>
</ul>
<h4 id="20-notify-和-notifyAll-有什么区别？"><a href="#20-notify-和-notifyAll-有什么区别？" class="headerlink" title="20.notify()和 notifyAll()有什么区别？"></a>20.notify()和 notifyAll()有什么区别？</h4><ul>
<li>notify只会随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会；由JVM确定唤醒哪个线程，而且不是按优先级</li>
<li>notifyAll会让所有处于等待池的线程全部进入锁池去竞争获取锁的机会；</li>
</ul>
<h4 id="21-线程的-run-和-start-有什么区别？"><a href="#21-线程的-run-和-start-有什么区别？" class="headerlink" title="21.线程的 run()和 start()有什么区别？"></a>21.线程的 run()和 start()有什么区别？</h4><ul>
<li>run()是在主线程中执行方法，和调用普通方法一样；（按顺序执行，同步执行）</li>
<li>start()方法：是创建了新的线程，在新的线程中执行；（异步执行）</li>
<li>启动一个线程，当然要调用strat()</li>
</ul>
<h4 id="22-创建线程池有哪几种方式？"><a href="#22-创建线程池有哪几种方式？" class="headerlink" title="22.创建线程池有哪几种方式？"></a>22.创建线程池有哪几种方式？</h4><ul>
<li>newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务</li>
<li>newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小</li>
<li>newCachedThreadPool：创建一个可缓存的线程池。此线程池不会对线程池大小做限制。线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小</li>
<li>newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</li>
</ul>
<h4 id="22-线程池ThreadPoolExecutor的工作流程？"><a href="#22-线程池ThreadPoolExecutor的工作流程？" class="headerlink" title="22.线程池ThreadPoolExecutor的工作流程？"></a>22.线程池ThreadPoolExecutor的工作流程？</h4><ul>
<li>当提交一个新任务到线程池后，线程池首先会判断核心线程池(corePoolSize）里的线程是否都在执行任务，如果不是则创建一个新的工作线程来执行任务。</li>
<li>如果核心线程池corePoolSize的线程都被占用在执行任务，线程池判断工作队列是否已满，如果工作队列没有满：则将新提交的任务存储到工作队列中，</li>
<li>如果工作队列已满：判断线程池（maximumPoolSize）的线程是否处于工作状态，如果没有，则创建一个新的工作线程来执行任务。</li>
<li>如果线程池已满，则交给饱和策略处理这个任务</li>
</ul>
<h4 id="23-线程池都有哪些状态？"><a href="#23-线程池都有哪些状态？" class="headerlink" title="23.线程池都有哪些状态？"></a>23.线程池都有哪些状态？</h4><ul>
<li>RUNNING(运行中)：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理。线程池的初始化状态是RUNNING。</li>
<li>SHUTDOWN(关掉)：调用线程池的shutdown()接口时，线程池由RUNNING -&gt; SHUTDOWN。处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。</li>
<li>STOP(停止):调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -&gt; STOP。处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。 </li>
<li>tidying：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -&gt; TIDYING。 当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -&gt; TIDYING。</li>
<li>terminated(终止)：线程池彻底终止，就变成terminated状态。 线程池处在tidying状态时，执行完terminated()之后，就会由 tidying -&gt; terminated。</li>
</ul>
<h4 id="24-线程池中-execute-和-submit-方法有什么区别？"><a href="#24-线程池中-execute-和-submit-方法有什么区别？" class="headerlink" title="24.线程池中 execute() 和 submit() 方法有什么区别？"></a>24.线程池中 execute() 和 submit() 方法有什么区别？</h4><ul>
<li>两个方法都可以向线程池提交任务</li>
<li>execute()方法的返回类型是void，它定义在Executor接口中</li>
<li>submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中</li>
</ul>
<h4 id="25-在java-程序中怎么保证多线程的运行安全？"><a href="#25-在java-程序中怎么保证多线程的运行安全？" class="headerlink" title="25.在java 程序中怎么保证多线程的运行安全？"></a>25.在java 程序中怎么保证多线程的运行安全？</h4><ul>
<li>原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作</li>
<li>可见性：一个线程对主内存的修改可以及时地被其他线程看到</li>
<li>有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序</li>
</ul>
<h4 id="26-什么是死锁？如何避免死锁？"><a href="#26-什么是死锁？如何避免死锁？" class="headerlink" title="26.什么是死锁？如何避免死锁？"></a>26.什么是死锁？如何避免死锁？</h4><ul>
<li>线程死锁是指由于两个或者多个线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行，就是死锁</li>
<li>按顺序加锁,每个获取锁的时候加上个时限,按线程间获取锁的关系检测线程间是否发生死锁，如果发生死锁就执行一定的策略，如终断线程或回滚操作等。</li>
</ul>
<h4 id="27-说一下-atomic-的原理？"><a href="#27-说一下-atomic-的原理？" class="headerlink" title="27.说一下 atomic 的原理？"></a>27.说一下 atomic 的原理？</h4><ul>
<li>在Atomic包里一共有12个类，四种原子更新方式，分别是原子更新基本类型，原子更新数组，原子更新引用和原子更新字段。</li>
<li>Atomic包里的类基本都是使用Unsafe实现的包装类。</li>
<li>Atomic包下的类是通过CAS操作来实现原子性的。jdk8直接使用了Unsafe的getAndAddInt方法</li>
</ul>
<h4 id="28-说一下-volatile的实现原理？"><a href="#28-说一下-volatile的实现原理？" class="headerlink" title="28.说一下 volatile的实现原理？"></a>28.说一下 volatile的实现原理？</h4><ul>
<li><code>volatile</code>修饰的变量可以禁止指令重排序和保证了内存可见性和单一操作的原子性，类似<code>i++</code>这样的复合操作的原子性保证不了</li>
<li>有<code>volatile</code>关键字修饰的共享变量进行写操作的一瞬间，底层执行汇编指令会多出一个<code>lock</code>前缀指令进行加锁。<code>lock</code>前缀指令其实就相当于一个内存屏障。在多处理器下，会将当前处理器工作内存的数据回写到主内存中，并且这个回写操作会使其它线程中缓存该内存地址的数据无效。相当于会在写操作后，发出一个信号给缓存了这个数的线程，告诉它们值更新了，需要从主内存中从新获取</li>
<li>在<code>JVM</code>底层<code>volatile</code>是采用“<code>内存屏障</code>”来实现</li>
<li><code>volatile</code>经常用于两个两个场景：状态标记、单列模式中的<code>DCL</code>。</li>
</ul>
<h4 id="29-volataile的内存语义及其实现？"><a href="#29-volataile的内存语义及其实现？" class="headerlink" title="29.volataile的内存语义及其实现？"></a>29.volataile的内存语义及其实现？</h4><ul>
<li>如果第一个操作为volatile读，则不管第二个操作是啥，都不能重排序。这个操作确保volatile读之后的操作不会被编译器重排序到volatile读之前；</li>
<li>当第二个操作为volatile写是，则不管第一个操作是啥，都不能重排序。这个操作确保volatile写之前的操作不会被编译器重排序到volatile写之后；</li>
<li>当第一个操作volatile写，第二操作为volatile读时，不能重排序。</li>
</ul>
<h4 id="29-说一下happens-before的理解？"><a href="#29-说一下happens-before的理解？" class="headerlink" title="29.说一下happens-before的理解？"></a>29.说一下happens-before的理解？</h4><ul>
<li>在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。</li>
<li>两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法</li>
<li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前</li>
<li>happen-before原则是JMM中非常重要的原则，它是判断数据是否存在竞争、线程是否安全的主要依据，保证了多线程环境下的可见性</li>
</ul>
<h4 id="30-说一下happens-before八种规则？"><a href="#30-说一下happens-before八种规则？" class="headerlink" title="30.说一下happens-before八种规则？"></a>30.说一下happens-before八种规则？</h4><ul>
<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；</li>
<li>锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作</li>
<li>volatile变量规则：如果一个线程先去写一个volatile变量，然后一个线程去读这个变量，那么这个写操作一定是happens-before读操作的。</li>
<li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；</li>
<li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；</li>
<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</li>
<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；</li>
<li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；</li>
</ul>
<h4 id="31-什么是AQS？"><a href="#31-什么是AQS？" class="headerlink" title="31.什么是AQS？"></a>31.什么是AQS？</h4><ul>
<li>AQS抽象的队列式同步器，是实现JUC核心基础组件。</li>
<li>AQS是将每一条请求共享资源的线程封装成一个同步队列（CLH）的一个结点（Node），来实现锁的分配。</li>
<li>AQS就是基于CLH队列，用volatile修饰共享变量state，线程通过CAS去改变状态符，成功则获取锁成功，失败则进入等待队列，等待被唤醒。</li>
<li>实现了AQS的锁有：自旋锁、互斥锁、读锁写锁、条件产量、信号量、栅栏都是AQS的衍生物</li>
<li>AQS提供两种同步状态的获取与释放：独占式（该方法对中断不敏感，获取同步状态失败加入到CLH同步队列中，后续对线程进行中断操作时，线程不会从同步队列中移除）和共享式（在同一时刻可以有多个线程获取同步状态）</li>
<li>总结：在AQS中维护着一个FIFO的同步队列，当线程获取同步状态失败后，则会加入到这个CLH同步队列的队尾并一直保持着自旋。在CLH同步队列中的线程在自旋时会判断其前驱节点是否为首节点，如果为首节点则不断尝试获取同步状态，获取成功则退出CLH同步队列。当线程执行完逻辑后，会释放同步状态，释放后会唤醒其后继节点。</li>
</ul>
<h4 id="32-ReentrantLock与synchronized的区别"><a href="#32-ReentrantLock与synchronized的区别" class="headerlink" title="32.ReentrantLock与synchronized的区别"></a>32.ReentrantLock与synchronized的区别</h4><ul>
<li>两者实现方式不同一个基于JVM层面，一个基于JDK源码实现</li>
<li>synchronized是隐式的获取锁和释放，ReentrantLock是显示的获取或释放锁，并且有锁超时，锁中断等功能</li>
<li>ReentrantLock提供了可轮询的锁请求。它会尝试着去获取锁，如果成功则继续，否则可以等到下次运行时处理，而synchronized则一旦进入锁请求要么成功要么阻塞，所以相比synchronized而言，ReentrantLock不容易产生死锁。</li>
</ul>
<h4 id="33-如何确保N个线程可以访问N个资源同时又不导致死锁"><a href="#33-如何确保N个线程可以访问N个资源同时又不导致死锁" class="headerlink" title="33.如何确保N个线程可以访问N个资源同时又不导致死锁"></a>33.如何确保N个线程可以访问N个资源同时又不导致死锁</h4><ul>
<li>指定获取锁的顺序，并强制线程按照指定的顺序获取锁。</li>
</ul>
<h4 id="34-yield-方法有什么用？"><a href="#34-yield-方法有什么用？" class="headerlink" title="34.yield()方法有什么用？"></a>34.yield()方法有什么用？</h4><ul>
<li><p>yield() 是一个静态方法.</p>
</li>
<li><p>yield() 方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。</p>
</li>
<li><p>只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行</p>
</li>
</ul>
<h4 id="35-CyclicBarrier和CountDownLatch的区别？"><a href="#35-CyclicBarrier和CountDownLatch的区别？" class="headerlink" title="35.CyclicBarrier和CountDownLatch的区别？"></a>35.CyclicBarrier和CountDownLatch的区别？</h4><ul>
<li>CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；是通过调用await()方法计数加1，若加1后的值不等于构造方法的值，则线程阻塞。通俗的将；让一组线程到达一个屏障时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活</li>
<li>CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行，调用countDown()方法计数减一，调用await()方法只进行阻塞，对计数没任何影响</li>
<li>CountDownLatch内部通过共享锁实现。在创建CountDownLatch实例时，需要传递一个int型的参数：count，该参数为计数器的初始值，也可以理解为该共享锁可以获取的总次数。当某个线程调用await()方法，程序首先判断count的值是否为0，如果不会0的话则会一直等待直到为0为止。当其他线程调用countDown()方法时，则执行释放共享锁状态，使count值 – 1。当在创建CountDownLatch时初始化的count参数，必须要有count线程调用countDown方法才会使计数器count等于0，锁才会释放，前面等待的线程才会继续运行。注意CountDownLatch不能回滚重置。</li>
<li>CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务</li>
<li>CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了</li>
</ul>
<h4 id="36-Semaphore有什么作用以及实现原理？"><a href="#36-Semaphore有什么作用以及实现原理？" class="headerlink" title="36.Semaphore有什么作用以及实现原理？"></a>36.Semaphore有什么作用以及实现原理？</h4><ul>
<li>Semaphore就是一个信号量，它的作用是限制某段代码块的并发数</li>
<li>Semaphore有非公平和公平模式，默认是非公平的。当Semaphore设置为1时，可以排它锁使用，同一个时刻，只能限制一个线程访问。和CountDownLatch一样的，内部都有一个Sync内部类，基于AQS实现同步状态的释放和获取。</li>
</ul>
<h4 id="37-说一说对ReentrantReadWriteLock的理解？"><a href="#37-说一说对ReentrantReadWriteLock的理解？" class="headerlink" title="37.说一说对ReentrantReadWriteLock的理解？"></a>37.说一说对ReentrantReadWriteLock的理解？</h4><ul>
<li>ReentrantReadWriteLock内部维护了一对锁，读锁和写锁。支持重入和公平以及平非公平模式。读锁是共享式的，它能够被多个线程同时获取，在没有其他写线程访问（或者写状态为0）时，读锁总会被成功地获取，而所做的也只是（线程安全的）增加读状态。如果当前线程已经获取了读锁，则增加读状态。如果当前线程在获取读锁时，写锁已被其他线程获取，则进入等待状态。</li>
<li>写锁是一个支持重进入的排它锁。如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取写锁时(还未获到)，读锁已经被获取或者该线程不是已经获取写锁的线程，则当前线程进入等待状态。</li>
<li>写锁要确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。</li>
<li>锁降级：遵循获取写锁，获取读锁在释放写锁的次序，写锁可以降级为读锁</li>
<li>锁降级中读锁的获取是否必要呢？答案是必要的。主要是为了保证数据的可见性，如果当前线程不获取读锁而是直接释放写锁，获取了写锁并修改了数据，那么当前线程无法感知线程T的数据更新</li>
</ul>
<h4 id="38-说一说Condition的理解？"><a href="#38-说一说Condition的理解？" class="headerlink" title="38 说一说Condition的理解？"></a>38 说一说Condition的理解？</h4><ul>
<li><code>Condition</code>是一个接口，与<code>Lock</code>配合可以实现的等待通知模式，类似<code>Object</code>的<code>wait</code>和<code>notify</code>。获取一个<code>Condition</code>对象需要调用Lock的<code>newCondition</code>方法或得<code>ConditionObject</code>,是AQS的一个内部类。Condition操作需要获取想关联的锁</li>
<li>一个线程获取锁后，通过调用Condition的<code>await()</code>方法，会释放锁，然后构造成节点并将节点从尾部加入等待队列,并进入等待状态。</li>
<li>当线程调用<code>signal()</code>方法后，程序首先检查当前线程是否获取了锁，然后通过<code>doSignal(Node first)</code>方法唤醒同步队列的等待时间最长的节点（首节点)。在唤醒节点之前，会将节点移动到同步队列中，被唤醒的线程，将从await()方法中的while循环中退出来，然后调用acquireQueued()方法竞争同步状态。</li>
</ul>
<h4 id="39-说一说你对exchanger的理解？"><a href="#39-说一说你对exchanger的理解？" class="headerlink" title="39.说一说你对exchanger的理解？"></a>39.说一说你对exchanger的理解？</h4><ul>
<li>Exchanger类允许在两个线程之间定义同步点。当两个线程都到达同步点时，他们交换数据结构，因此第一个线程的数据结构进入到第二个线程中，第二个线程的数据结构进入到第一个线程中</li>
<li>Exchanger算法的核心是通过一个可交换数据的slot，以及一个可以带有数据item的参与者。</li>
<li>在Exchanger中，如果一个线程已经到达了exchanger节点时，如果它的伙伴节点在该线程到达之前已经调用了exchanger方法，则它会唤醒它的伙伴然后进行数据交换，得到各自数据返回。如果它的伙伴节点还没有到达交换点，则该线程将会被挂起，等待它的伙伴节点到达被唤醒，完成数据交换。如果当前线程被中断了则抛出异常，或者等待超时了，则抛出超时异常。</li>
</ul>
<h4 id="说一说对ConcurrentHashMap的理解？"><a href="#说一说对ConcurrentHashMap的理解？" class="headerlink" title="说一说对ConcurrentHashMap的理解？"></a>说一说对ConcurrentHashMap的理解？</h4><ul>
<li>在多线程环境下，HashMap的put方法会引起死循环,是因为并发执行put方法会造成<code>Entry</code>链表形成环形数据结构，导致next指向一直不为空，就会产生死循换获取Entry。</li>
<li><code>ConcurrentHashMap</code>是一种线程安全的HashMap。相对于HashTable和Collections.synchronizedMap()，ConcurrentHashMap具有更好的性能和伸缩性。</li>
<li>JDK1.8以前采用的是分段锁机制（<code>Segment</code>+<code>HashEntry</code>）,将数据分成一段一段存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一段数据时，其它段的数据能被其它线程访问。其中Segment在实现上继承了ReentrantLock，这样就自带了锁的功能</li>
<li><code>put实现</code>：当执行put方法插入数据时，根据key的hash值，在Segment数组中找到相应的位置，如果相应位置的Segment还未初始化，则通过CAS进行赋值，接着执行Segment对象的put方法通过加锁机制插入数据</li>
<li><code>size实现</code>:因为ConcurrentHashMap是可以并发插入数据的，所以在准确计算元素时存在一定的难度,一般的思路是统计每个Segment对象中的元素个数，然后进行累加，但是这种方式计算出来的结果并不一样的准确的，因为在计算后面几个Segment的元素个数时，已经计算过的Segment同时可能有数据的插入或则删除。jdk1.8以前中是先采用不加锁的方式，连续计算元素的个数，最多计算3次，如果前后两次计算结果相同，则说明计算出来的元素个数是准确的；如果前后两次计算结果都不同，则给每个Segment进行加锁，再计算一次元素的个数；</li>
<li>1.8 中使用<code>CAS+synchronized+Node+红黑树</code>的实现方式。当链表长度达到8时，将链表转化为红黑树，当链表长度小于6时，将红黑树转化为链表。</li>
<li>详细分析：<a href="https://www.jianshu.com/p/e694f1e868ec">https://www.jianshu.com/p/e694f1e868ec</a></li>
</ul>
<h4 id="说一下CoucurrentLinkedQueue的理解？"><a href="#说一下CoucurrentLinkedQueue的理解？" class="headerlink" title="说一下CoucurrentLinkedQueue的理解？"></a>说一下CoucurrentLinkedQueue的理解？</h4><ul>
<li><code>ConcurrentLinkedQueue</code>是一个基于链接节点的无边界的线程安全队列，它采用先进先出原则对元素进行排序，插入元素放入队列尾部，出队时从队列头部返回元素，利用CAS方式实现的</li>
<li><code>CoucurrentLinkedQueue</code>的结构由头节点和尾节点组成的，都是使用<code>volatile</code>修饰的。每个节点由节点元素<code>item</code>和指向下一个节点的<code>next</code>引用组成.<br>*入队:</li>
</ul>
<h4 id="CopyOnWrite思想是什么-CopyOnWriteArrayList如何实现"><a href="#CopyOnWrite思想是什么-CopyOnWriteArrayList如何实现" class="headerlink" title="CopyOnWrite思想是什么?CopyOnWriteArrayList如何实现"></a>CopyOnWrite思想是什么?CopyOnWriteArrayList如何实现</h4><ul>
<li>CopyOnWrite大概就是“写数据的时候利用拷贝的副本来执行。我们知道ArrayList是线程不安全，会有并发问题，一般要保证线程的首先想到是加锁，或者是用ReadWriteLock读写锁的方式来控制</li>
<li>如果使用读写锁去控制，这样多个读请求可以同时执行从ArrayList里读取数据，但是读请求和写请求之间互斥，写请求和写请求也是互斥的。</li>
<li>最大的问题，其实就在于写锁和读锁的互斥。假设写操作频率很低，读操作频率很高，是写少读多的场景。那么偶尔执行一个写操作的时候，是不是会加上写锁，此时大量的读操作过来是不是就会被阻塞住，无法执行，这个就是读写锁可能遇到的最大的问题。</li>
<li>CopyOnWriteArrayList的思想就是，在写入时通过复制一个数组的副本来进行写操作，并且这个数组是volatile修饰的，写完后通过volatile变量赋值的方式，把修改好的数组副本给更新回去，立马让其他线程可见的，同时内部加入了lock锁的机制，也就是同一时间只有一个线程可以更新防止产生多个副本</li>
<li>因为读操作就是非常简单的对那个数组进行读而已，不涉及任何的锁</li>
<li>CopyOnWriteArrayList，就是用空间换时间，更新的时候基于副本更新，避免锁，然后最后用volatile变量来赋值保证可见性，更新的时候对读线程没有任何的影响！</li>
</ul>
<h4 id="CopyOnWrite-思想在Kafka源码中的运用"><a href="#CopyOnWrite-思想在Kafka源码中的运用" class="headerlink" title="CopyOnWrite 思想在Kafka源码中的运用"></a>CopyOnWrite 思想在Kafka源码中的运用</h4><ul>
<li>在Kafka的内核源码中，有这么一个场景，客户端在向Kafka写数据的时候，会把消息先写入客户端本地的内存缓冲，然后在内存缓冲里形成一个Batch之后再一次性发送到Kafka服务器上去，这样有助于提升吞吐量。</li>
</ul>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><blockquote>
<p><a href="%5Bhttps://blog.qinxuewu.club/interview-docs/#/2019/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%5D(https://blog.qinxuewu.club/interview-docs/#/2019/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM)">深入理解Java虚拟机笔记</a></p>
</blockquote>
<h4 id="JAVA内存模型与JVM内存模型的区别"><a href="#JAVA内存模型与JVM内存模型的区别" class="headerlink" title="JAVA内存模型与JVM内存模型的区别"></a>JAVA内存模型与JVM内存模型的区别</h4><ul>
<li>JAVA内存模型：Java内存模型规定所有的变量都是存在主存中，每个线程都有自己的工作内存。线程堆变量的操作都必须在工作内存进行，不能直接堆主存进行操作，并且每个线程不能访问其他线程的工作内存</li>
<li>JVM内存模型</li>
</ul>
<h4 id="jvm线上问题排查思路"><a href="#jvm线上问题排查思路" class="headerlink" title="jvm线上问题排查思路"></a>jvm线上问题排查思路</h4><ul>
<li>思路：首先找到 CPU 飚高的那个 Java 进程，因为你的服务器会有多个 JVM 进程。然后找到那个进程中的 “问题线程”，最后根据线程堆栈信息找到问题代码。最后对代码进行排查</li>
<li>通过 top命令找到CPU消耗最高的进程，并记住进程 ID。</li>
<li>再次通过 top -Hp [进程 ID]找到CPU 消耗最高的线程 ID，并记住线程 ID.</li>
<li>通过 JDK 提供的 jstack 工具dump 线程堆栈信息到指定文件中。具体命令jstack -l [进程 ID] &gt;jstack.log。</li>
<li>由于刚刚的线程ID是十进制的，而堆栈信息中的线程ID是16进制的，因此我们需要将10进制的转换成16进制的，并用这个线程 ID 在堆栈中查找。使用 printf “%x\n”[十进制数字]，可以将10进制转换成16进制。</li>
<li>通过刚刚转换的16进制数字从堆栈信息里找到对应的线程堆栈。就可以从该堆栈中看出端倪</li>
</ul>
<h4 id="说下一Java的内存模型"><a href="#说下一Java的内存模型" class="headerlink" title="说下一Java的内存模型"></a>说下一Java的内存模型</h4><ul>
<li>Java内存模型是JVM的抽象模型,就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。</li>
<li>目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。目的是保证并发编程场景中的原子性、可见性和有序性。</li>
<li>Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存,线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存.不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。</li>
</ul>
<h4 id="说一下jvm-的主要组成部分？及其作用？"><a href="#说一下jvm-的主要组成部分？及其作用？" class="headerlink" title="说一下jvm 的主要组成部分？及其作用？"></a>说一下jvm 的主要组成部分？及其作用？</h4><ul>
<li>JVM基本上由三部分组成：类加载器，执行引擎，运行时数据区</li>
<li>类加载器：在JVM启动时以及程序运行时将需要加载的class文件加载到JVM中</li>
<li>执行引擎：负责执行class文件中包含的字节码指令，相当于物理机器上的CPU</li>
<li>运行时数据区：将划分给Java程序的内存划分成几个区来模拟物理机器上的存储、记录和调度功能</li>
</ul>
<h4 id="说一下-jvm-运行时数据区？"><a href="#说一下-jvm-运行时数据区？" class="headerlink" title="说一下 jvm 运行时数据区？"></a>说一下 jvm 运行时数据区？</h4><p><img src="http://wx1.sinaimg.cn/large/006b7Nxngy1g1bbk4bc68j30g20anab3.jpg" alt="运行时数据区"></p>
<ul>
<li>线程私有的：虚拟机栈，本地方法栈，程序计数器</li>
<li>线程共享的 方法区，堆</li>
<li>程序计数器可以看作是当前线程所执行的字节码行号指示器。通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支,循环,跳转,异常处理,线程恢复等基础功能都需要这个计数器来完成</li>
<li>虚拟机栈：每个方法被执行的时候都会创建一个栈帧用于存储局部变量表，操作栈，动态链接，方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机中从入栈到出栈的过程</li>
<li>本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。</li>
<li>方法区主要用于存放已经被虚拟机加载的类信息，如常量，静态变量，即时编译器编译后的代码等。和Java堆一样不需要连续的内存，并且可以动态扩展</li>
<li>Java 堆是整个虚拟机所管理的最大内存区域，所有的对象创建都是在这个区域进行内存分配。堆内存也分为 新生代、老年代。</li>
</ul>
<h4 id="说一下堆栈的区别？"><a href="#说一下堆栈的区别？" class="headerlink" title="说一下堆栈的区别？"></a>说一下堆栈的区别？</h4><ul>
<li>栈内存:栈内存首先是一片内存区域，存储的都是方法的局部变量，凡是定义在方法中的都是局部变量（方法外的是全局变量），for循环内部定义的也是局部变量，是先加载函数才能进行局部变量的定义，所以方法先进栈，然后再定义变量，变量有自己的作用域，一旦离开作用域，变量就会被释放。栈内存的更新速度很快，因为局部变量的生命周期都很短。</li>
<li>堆内存:存储的是数组和对象（其实数组就是对象），凡是new建立的都是在堆中，堆中存放的都是实体（对象），实体用于封装数据，而且是封装多个（实体的多个属性），如果一个数据消失，这个实体也没有消失，还可以用，所以堆是不会随时释放的，但是栈不一样，栈里存放的都是单个变量，变量被释放了，那就没有了。堆里的实体虽然不会被释放，但是会被当成垃圾，Java有垃圾回收机制不定时的收取。</li>
</ul>
<h4 id="队列和栈是什么？有什么区别？"><a href="#队列和栈是什么？有什么区别？" class="headerlink" title="队列和栈是什么？有什么区别？"></a>队列和栈是什么？有什么区别？</h4><ul>
<li>队列(Queue)：是限定只能在表的一端进行插入和在另一端进行删除操作的线性表;</li>
<li>栈(Stack)：是限定只能在表的一端进行插入和删除操作的线性表。</li>
<li>队列是先进先出，栈是先进后出</li>
<li>队列：基于地址指针进行遍历，而且可以从头部或者尾部进行遍历，但不能同时遍历，无需开辟空间，因为在遍历的过程中不影响数据结构，所以遍历速度要快;</li>
<li>栈：只能从顶部取数据，也就是说最先进入栈底的，需要遍历整个栈才能取出来，而且在遍历数据的同时需要为数据开辟临时空间，保持数据在遍历前的一致性。</li>
</ul>
<h4 id="什么是双亲委派模型？"><a href="#什么是双亲委派模型？" class="headerlink" title="什么是双亲委派模型？"></a>什么是双亲委派模型？</h4><ul>
<li>如果一个类收到加载请求时，它不会先自己去尝试加载这个类，而是委派给父类加载器去加载，只有当父类加载器在自己的搜索范围找不到这个类时，才会委派给子类加载器去执行加载。</li>
<li>优点：加载的类是同一个，保证内库更安全，缺点效率低</li>
</ul>
<h4 id="说一下类加载的执行过程？"><a href="#说一下类加载的执行过程？" class="headerlink" title="说一下类加载的执行过程？"></a>说一下类加载的执行过程？</h4><ul>
<li>类的加载过程分为加载，验证，准备，解析，初始化，使用，卸载七个阶段。其中主准备，解析和初始化统称为链接阶段。其中类加载工作由ClassLoader及其子类负责。</li>
<li>加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定</li>
<li>类装载包括了加载，连接（验证、准备、解析（可选）），初始化</li>
<li>加载指的是把class字节码文件从各个来源通过类加载器装载入内存中</li>
<li>验证是为了保证加载进来的字节流符合虚拟机规范，不会造成安全错误</li>
<li>主要是为类变量（注意，不是实例变量）分配内存，并且赋予初值</li>
<li>解析是将常量池内的符号引用替换为直接引用的过程</li>
<li>初始化，这个阶段主要是对类变量初始化，是执行类构造器的过程。</li>
<li>使用阶段包括主动引用和被动引用</li>
<li>卸载，类所有的实例都已经被回收，加载该类的ClassLoader已经被回收，该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法，jvm就会在方法区垃圾回收的时候对类进行卸载</li>
</ul>
<h4 id="说一下类加载器有哪些？"><a href="#说一下类加载器有哪些？" class="headerlink" title="说一下类加载器有哪些？"></a>说一下类加载器有哪些？</h4><p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201105184829.jpeg" alt="双亲委派模型.png"></p>
<ul>
<li>启动类加载器：负责加载JRE的核心类库，如jre目标下的rt.jar,charsets.jar等.</li>
<li>扩展类加载器：负责加载JRE扩展目录ext中JAR类包</li>
<li>系统类加载器：负责加载ClassPath路径下的类包</li>
<li>用户自定义加载器：负责加载用户自定义路径下的类包</li>
</ul>
<h4 id="怎么判断对象是否可以被存活？"><a href="#怎么判断对象是否可以被存活？" class="headerlink" title="怎么判断对象是否可以被存活？"></a>怎么判断对象是否可以被存活？</h4><ul>
<li>java是使用根搜索算法判断对象是否存活的</li>
<li>通过一系列的名为“GC-roots”的对象作为起点，从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象的GC-roots没有任何引用链相连时，则证明此对象是不可用的</li>
<li>可以作为GC-Roots对象有虚拟机栈中的引用对象,方法区中的类静态属性引用对象,方法区中的常量引用的对象,本地方法中JNI（即一般说的native方法）的引用的对象。</li>
</ul>
<h4 id="java-中都有哪些引用类型？"><a href="#java-中都有哪些引用类型？" class="headerlink" title="java 中都有哪些引用类型？"></a>java 中都有哪些引用类型？</h4><ul>
<li>四种：强引用，软引用，弱引用，虚引用</li>
<li>只要强引用还存在，垃圾回收期永远不会回收掉被引用的对象</li>
<li>软引用：用来描述一些还有用，但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出前，将会把这些对象列进回收范围之内并进行第二次回收，如果这此次回收还是没有足够的内存，才会抛出内存溢出</li>
<li>弱引用：用来描述非必须的对象，但是它的强度比软引用更弱一下，被弱引用关联的对象，只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，只会回收被弱引用关联的对象</li>
<li>虚引用：被称为幽灵引用或幻引用，是最弱的一种引用关系。为一个对象设置虚引用的目的就是在对象被回收时收到一个系统通知。</li>
</ul>
<h4 id="说一下-jvm-有哪些垃圾回收算法？"><a href="#说一下-jvm-有哪些垃圾回收算法？" class="headerlink" title="说一下 jvm 有哪些垃圾回收算法？"></a>说一下 jvm 有哪些垃圾回收算法？</h4><ul>
<li>标记-清除算法：算法分为标记和清除两个阶段。首先先标记所有要被回收的对象，标记完成后再统一清除被标记的对象。效率低，会产生大量不连续的内存碎片</li>
<li>复制算法：将可用内存按容量划分为大小相等的两块，每次只用其中的一块，当这一块内存用完，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉</li>
<li>标记-整理算法：标记过程仍然与标记-清楚算法一样。但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存</li>
<li>分代收集算法：根据对象的存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高，没有额外空间对它进行分配担保，就必须使用标记-清理或标记-整理算法来进行回收</li>
</ul>
<h4 id="说一下-jvm-有哪些垃圾回收器？"><a href="#说一下-jvm-有哪些垃圾回收器？" class="headerlink" title="说一下 jvm 有哪些垃圾回收器？"></a>说一下 jvm 有哪些垃圾回收器？</h4><p><img src="http://wx4.sinaimg.cn/large/0068QeGHgy1g4auzcw1bnj30dn0920tb.jpg" alt="垃圾回收器"></p>
<blockquote>
<p>Serial,ParNew,Parallel Scavenge都是新生代回收器，新生代使用复制回收算法</p>
</blockquote>
<blockquote>
<p>老年代垃圾回收器除了CMS是使用标记清除算法外(减少回收停顿时间)，其余都是使用标记整理算法。</p>
</blockquote>
<ul>
<li><code>Serial</code>收集器：一个单线程的收集器，只会使用一个CPU或一条收集线程去完成垃圾收集工作。在进行垃圾收集时必须暂停其它所有的工作线程，直接到结束。是虚拟机运行在Client模式下的默认新手代收集器，简单而高效</li>
<li><code>ParNew</code>收集器：Serial收集器的多线程版本，使用多条线程收集。是许多运行在Server模式下的虚拟机首选新生代收集器。且目前除了Serial收集器，只有它可以与CMS收集器配合工作</li>
<li><code>Parallel Scavenge</code>收集器：它是一款新生代收集器。使用复制算法收集，又是并行的多线程收集器</li>
<li><code>Serial Old</code>收集器：它是Serial收集器的老年代版本，是一个单线程收集器，使用标记-整理算法收集</li>
<li><code>Parallel Old</code>收集器：它是<code>Parallel-Scavenge</code>收集器的老年代版本，使用多线程和标记-整理算法。JDK1.6才开始提供。</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/0068QeGHgy1g7dvc1ftmtj30jz08q750.jpg" alt="CMS垃圾收集器.png"></p>
<ul>
<li><code>CMS</code>收集器：是一种以获取最短回收停顿时间的为目标的收集器。基于标记-清楚算法实现。运作过程分为四个阶段。初始标记,并发标记,重新标记,并发清除。初始标只会标记出所有GC Roots直接应用的对象,虽说会造成<code>Stop the World</code>但影响不大,因为他的速度很快。并发标记阶段会让系统线程随意创建各种新对象，在这个过程中，垃圾回收线程会尽可能的对已有的对象进行GC Roots追踪，这个过程系统会不停的工作和创建对象，这个阶段也是最耗时的，但是因为是和系统程序并发允许的，所以其实不会对系统运行造成影响。重新标记阶段会再次进入<code>Stop the World</code>,然后重新标记下在第二阶段里新创建的对象和已有对象可能失去引用变成垃圾的情况，这个速度是很快的，他其实就是对第二阶段中被系统程序运行变动过的少数对象进行标记，所以运行速度很快。并发清理阶段让系统程序随意运行，然后他来清理掉之前标记为垃圾的对象即可，这个阶段其实也是最耗时的，但他也是和系统程序并发运行，不影响系统程序执行。</li>
</ul>
<p><img src="http://ws1.sinaimg.cn/large/0068QeGHgy1g7goxrqtjhj30ia08n3zy.jpg" alt="G1垃圾收集器"></p>
<ul>
<li><code>G1</code>收集器：将整个Java堆分为多个大小相等的独立区域。虽然保留新生代和老年代，但它们不再是物理隔离，都是一部分不需要连续的集合。特点是并行与并发充分利用CPU缩短停顿时间。分代收集，空间整合不会产生内存空间碎片，可预测的停顿。有计划的避免回收整个Java堆。</li>
<li><code>XX:G1NewSizePercent</code>参数设置新生代初始占比，维持默认值即可。系统运行中JVM其实会不停的给新生代代增加更多的Region，但是新生代占比不会超过60%，可以通过<code>XX:G1MaxNewSizePercent</code></li>
<li>G1中新生代也有<code>Eden区</code>和<code>Survivor</code>概念，之前的参数<code>-XX:SurvivorRatio=8</code>就可以区分，比如100个Region,按照默认<code>8:1:1</code>那么可能80个Region就是Eden，两个<code>Survivor</code>各占10个</li>
<li>G1的垃圾回收触发机制：随着系统不停的分配内存，一旦新生代到达设定的最大大小60%,比如1200个Region,里面Eden占据1000,每个Survivor是100,而且Eden区还占满对象，这个时候就会触发新生代GC,使用之前的复制算法进行垃圾回收，进入stop the world状态</li>
</ul>
<h4 id="新生代与复制算法"><a href="#新生代与复制算法" class="headerlink" title="新生代与复制算法"></a>新生代与复制算法</h4><ul>
<li>目前大部分 JVM的GC对于新生代都采取Copying算法，因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少，但通常并不是按照1：1来划分新生代。一般将新生代划分为一块较大的 Eden空间和两个较小的Survivor空间(FromSpace, To Space)，每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将该两块空间中还存活的对象复制到另一块 Survivor 空间中。</li>
<li>这样做最大的好处是之浪费少数的内存空间，内存空间利用率可达到90%</li>
</ul>
<h4 id="老年代与标记整理算法-Mark-Compact"><a href="#老年代与标记整理算法-Mark-Compact" class="headerlink" title="老年代与标记整理算法(Mark-Compact )"></a>老年代与标记整理算法(Mark-Compact )</h4><ul>
<li>对象的内存分配主要在新生代的 Eden Space 和 Survivor Space 的 From Space(Survivor 目前存放对象的那一块)，少数情况会直接分配到老生代。</li>
<li>当新生代的 Eden Space 和 From Space 空间不足时就会发生一次 GC，进行 GC 后， Eden Space 和 From Space 区的存活对象会被挪到 To Space，然后将 Eden Space 和 From Space 进行清理</li>
<li>如果 To Space 无法足够存储某个对象，则将这个对象存储到老生代。</li>
<li>在进行 GC 后，使用的便是 Eden Space 和 To Space 了，如此反复循环</li>
<li>当对象在 Survivor 区躲过一次 GC 后，其年龄就会+1。 默认情况下年龄到达 15 的对象会被移到老生代中</li>
</ul>
<h4 id="常用的-jvm-调优的参数都有哪些？"><a href="#常用的-jvm-调优的参数都有哪些？" class="headerlink" title="常用的 jvm 调优的参数都有哪些？"></a>常用的 jvm 调优的参数都有哪些？</h4><ul>
<li>-Xms20M:表示设置JVM启动内存的最小值为20M，必须以M为单位</li>
<li>-Xmx20M:表示设置JVM启动内存的最大值为20M</li>
<li>-verbose:gc:表示输出虚拟机中GC的详细情况</li>
<li>-Xss128k:表示可以设置虚拟机栈的大小为128k</li>
<li>-Xoss128k:表示设置本地方法栈的大小为128k</li>
<li>-XX:PermSize=10M:表示JVM初始分配的永久代（方法区）的容量，必须以M为单位</li>
</ul>
<h4 id="java内存泄漏常见5种情况总结"><a href="#java内存泄漏常见5种情况总结" class="headerlink" title="java内存泄漏常见5种情况总结"></a>java内存泄漏常见5种情况总结</h4><ul>
<li>静态集合类，如HashMap、LinkedList等等引起。如果这些容器为静态的，那么它们的生命周期与程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。</li>
<li>简单而言，长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收。</li>
<li>各种连接，如数据库连接、网络连接和IO连接等，使用完后没释放，将会造成大量的对象无法被回收，从而引起内存泄漏。</li>
<li>对变量设置了不合理的作用域，一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏。另一方面，如果没有及时地把对象设置为null，很有可能导致内存泄漏的发生。</li>
<li>static关键字的使用问题：它的生命周期是很长的，如果他用来引用一下资源耗费过多的实例 (全局生存期)</li>
<li>对象内存过大：保存了多个耗用内存过大的对象，造成内存超出限制</li>
<li>如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。</li>
</ul>
<h4 id="MESI缓存一致性协议和总线锁"><a href="#MESI缓存一致性协议和总线锁" class="headerlink" title="MESI缓存一致性协议和总线锁"></a>MESI缓存一致性协议和总线锁</h4><ul>
<li>总线锁：CPU从主内存读取数据到高速缓存，会在总线对这个数据加锁，这样其它CPU没法去读或写这个数据，直到这个CPU使用完数据释放锁之后其它CPU才能读取数据</li>
<li>缓存一致性协议：多个CPU从内存读取同一个数据到各自的高速缓存，当其中某个CPU修改 了缓存里的数据，该数据会马上同步回主内存，其它CPU通过总线嗅探机制可以感知到数据的变化从而将自己的缓存里的数据失效</li>
</ul>
<h4 id="tomcat需要破坏双亲委派模型的原因"><a href="#tomcat需要破坏双亲委派模型的原因" class="headerlink" title="tomcat需要破坏双亲委派模型的原因"></a>tomcat需要破坏双亲委派模型的原因</h4><ul>
<li>tomcat中的需要支持不同web应用依赖同一个第三方类库的不同版本，jar类库需要保证相互隔离；</li>
<li>同一个第三方类库的相同版本在不同web应用可以共享</li>
<li>tomcat自身依赖的类库需要与应用依赖的类库隔离</li>
<li>jsp需要支持修改后不用重启tomcat即可生效 为了上面类加载隔离和类更新不用重启，定制开发各种的类加载器</li>
</ul>
<h4 id="JVM参数设置"><a href="#JVM参数设置" class="headerlink" title="JVM参数设置"></a>JVM参数设置</h4><p><img src="http://ww1.sinaimg.cn/large/0068QeGHgy1g7bogbbuepj30hy09gdg7.jpg" alt="JVM参数设置.png"></p>
<ul>
<li><code>-Xms</code>:Java堆内存大小</li>
<li><code>-Xmx</code>:Java堆内存最大大小</li>
<li><code>-Xmn</code>:Java堆内存中的新生代大小，扣除新生代剩下的就是老年代的内存大小了</li>
<li><code>-XX:PermSize</code>:永久代大小</li>
<li><code>-XX:MaxPermSize</code>:永久代最大大小</li>
<li><code>-Xss</code>：每个线程的栈内存大小</li>
<li><code>java -Xms512M -Xmx512M -Xmn256M -Xss1M -XX:PermSize=128M -XX:MaxPermSize=128M -jar App.jar</code></li>
</ul>
<h4 id="JVM常见配置汇总"><a href="#JVM常见配置汇总" class="headerlink" title="JVM常见配置汇总"></a>JVM常见配置汇总</h4><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//堆设置 </span></span><br><span class="line">-<span class="attr">Xms:</span>初始堆大小 </span><br><span class="line">-<span class="attr">Xmx:</span>最大堆大小 </span><br><span class="line">-<span class="attr">XX:</span>NewSize=<span class="attr">n:</span>设置年轻代大小 </span><br><span class="line">-<span class="attr">XX:</span>NewRatio=<span class="attr">n:</span>设置年轻代和年老代的比值.如:为<span class="number">3</span>,表示年轻代与年老代比值为<span class="number">1</span>:<span class="number">3</span>,年轻代占整个年轻代年老代和的<span class="number">1</span>/<span class="number">4</span> </span><br><span class="line">-<span class="attr">XX:</span>SurvivorRatio=<span class="attr">n:</span>年轻代中Eden区与两个Survivor区的比值.注意Survivor区有两个.如:<span class="number">3</span>,表示<span class="attr">Eden:</span>Survivor=<span class="number">3</span>:<span class="number">2</span>,一个Survivor区占整个年轻代的<span class="number">1</span>/<span class="number">5</span> </span><br><span class="line">-<span class="attr">XX:</span>MaxPermSize=<span class="attr">n:</span>设置持久代大小</span><br><span class="line"><span class="comment">//收集器设置 </span></span><br><span class="line">-<span class="attr">XX:</span>+<span class="attr">UseSerialGC:</span>设置串行收集器 </span><br><span class="line">-<span class="attr">XX:</span>+<span class="attr">UseParallelGC:</span>设置并行收集器 </span><br><span class="line">-<span class="attr">XX:</span>+<span class="attr">UseParalledlOldGC:</span>设置并行年老代收集器 </span><br><span class="line">-<span class="attr">XX:</span>+<span class="attr">UseConcMarkSweepGC:</span>设置并发收集器</span><br><span class="line"></span><br><span class="line"><span class="comment">//垃圾回收统计信息 </span></span><br><span class="line">-<span class="attr">XX:</span>+PrintGC </span><br><span class="line">-<span class="attr">XX:</span>+PrintGCDetails </span><br><span class="line">-<span class="attr">XX:</span>+PrintGCTimeStamps </span><br><span class="line">-<span class="attr">Xloggc:</span>filename</span><br><span class="line">-<span class="attr">XX:</span>+DisableExplicitGC来禁用JVM对显示GC的响应</span><br><span class="line"><span class="comment">//并行收集器设置 </span></span><br><span class="line">-<span class="attr">XX:</span>ParallelGCThreads=<span class="attr">n:</span>设置并行收集器收集时使用的CPU数.并行收集<span class="comment">//线程数. </span></span><br><span class="line">-<span class="attr">XX:</span>MaxGCPauseMillis=<span class="attr">n:</span>设置并行收集最大暂停时间 </span><br><span class="line">-<span class="attr">XX:</span>GCTimeRatio=<span class="attr">n:</span>设置垃圾回收时间占程序运行时间的百分比.公式为<span class="number">1</span>/(<span class="number">1</span>+n)</span><br><span class="line"><span class="comment">//并发收集器设置 </span></span><br><span class="line">-<span class="attr">XX:</span>+<span class="attr">CMSIncrementalMode:</span>设置为增量模式.适用于单CPU情况. </span><br><span class="line">-<span class="attr">XX:</span>CMSInitiatingOccupancyFaction  设置CMS收集器老年代占用多少比例的时候触发CMS垃圾回收，JDK <span class="number">1.6</span>里面默认的值是<span class="number">92</span>%。</span><br><span class="line">-<span class="attr">XX:</span>ParallelGCThreads=<span class="attr">n:</span>设置并发收集器年轻代收集方式为并行收集时,使用的CPU数.并行收集线程数.</span><br><span class="line">-<span class="attr">XX:</span>+UseCMSCompactAtFullCollection  在Full GC之后要再次进行“Stop the World”，停止工作线程，然后进行碎片整理，就是把存活对象挪到一起，空出来大片连续内存空间，避免内存碎片。</span><br><span class="line">-<span class="attr">XX:</span>CMSFullGCsBeforeCompaction  意思是执行多少次Full GC之后再执行一次内存碎片整理的工作，默认是<span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// JVM参数参考模板,根据系统情况设置不同参数即可</span></span><br><span class="line">-Xms4096M -Xmx4096M -Xmn3072M -Xss1M  </span><br><span class="line">-<span class="attr">XX:</span>MetaspaceSize=<span class="number">256</span>M </span><br><span class="line">-<span class="attr">XX:</span>MaxMetaspaceSize=<span class="number">256</span>M </span><br><span class="line">-<span class="attr">XX:</span>+UseParNewGC </span><br><span class="line">-<span class="attr">XX:</span>+UseConcMarkSweepGC </span><br><span class="line">-<span class="attr">XX:</span>CMSInitiatingOccupancyFraction=<span class="number">92</span> </span><br><span class="line">-<span class="attr">XX:</span>+UseCMSCompactAtFullCollection </span><br><span class="line">-<span class="attr">XX:</span>CMSFullGCsBeforeCompaction=<span class="number">0</span> </span><br><span class="line">-<span class="attr">XX:</span>+CMSParallelInitialMarkEnabled </span><br><span class="line">-<span class="attr">XX:</span>+CMSScavengeBeforeRemark </span><br><span class="line">-<span class="attr">XX:</span>+DisableExplicitGC </span><br><span class="line">-<span class="attr">XX:</span>+PrintGCDetails </span><br><span class="line">-<span class="attr">Xloggc:</span>gc.log </span><br><span class="line">-<span class="attr">XX:</span>+HeapDumpOnOutOfMemoryError  </span><br><span class="line">-<span class="attr">XX:</span>HeapDumpPath=<span class="regexp">/usr/</span>local<span class="regexp">/app/</span>oom</span><br></pre></td></tr></table></figure>


<h4 id="GC的详细执行流程"><a href="#GC的详细执行流程" class="headerlink" title="GC的详细执行流程"></a>GC的详细执行流程</h4><p><img src="http://ws3.sinaimg.cn/large/0068QeGHgy1g7cahzc4cxj30ij0gp417.jpg" alt="GC执行流程"></p>
<ul>
<li>开始执行GC，首先检查老年代可用空间是否大于新生代全部对象</li>
<li>如果大于则执行Minor GC。否则检查<code>-XX:HandlePromotionFaulure</code>参数是否开启，</li>
<li>如果开启上述参数，则判断老年代可用空间收费大于历次Minor GC过后进入老年代的对象平均大小</li>
<li>如果大于 则放心执行Minor GC</li>
<li>如果小于则执行Full GC,然后执行Minor GC</li>
<li>如果Full GC,然后执行Minor GC过后 内存还是不够则抛出OOM</li>
</ul>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><blockquote>
<p>编写线程A，A线程中循环执行一个任务，外部线程可以中断A线程</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">volatile</span>  <span class="keyword">boolean</span> falg=<span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">doTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doTask..........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  Exception </span>&#123;</span><br><span class="line">        Thread a=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!falg)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程被终止。。。。&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    doTask();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        a.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    falg=<span class="keyword">false</span>;</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果保证A,B,C三个线程顺序执行打印</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">       Thread a=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;aaaaaaaaa&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       Thread b=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;bbbbbbbbbbbbbb&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       Thread c=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;cccccccccccc&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       a.start();</span><br><span class="line">       a.join();</span><br><span class="line">       b.start();</span><br><span class="line">       b.join();</span><br><span class="line">       c.start();</span><br><span class="line">       c.join();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM</title>
    <url>/2020/10/14/0000.%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/</url>
    <content><![CDATA[<h1 id="一、JVM概述"><a href="#一、JVM概述" class="headerlink" title="一、JVM概述"></a>一、JVM概述</h1><h2 id="0-JVM作用："><a href="#0-JVM作用：" class="headerlink" title="0.JVM作用："></a>0.JVM作用：</h2><p> ①：将.class字节码文件生成为操作系统指令，传递给操作系统后通过计算机运行。 </p>
<h2 id="1-jvm的位置"><a href="#1-jvm的位置" class="headerlink" title="1.jvm的位置"></a>1.jvm的位置</h2><p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096238270_1594978982297-5b94a27f-24c0-4fc2-9743-9202639164db.png" alt="219fc992d2a1c658983097f4874dd06.png"> </p>
<h2 id="2-Jvm的整体结构（HotSpot虚拟机）"><a href="#2-Jvm的整体结构（HotSpot虚拟机）" class="headerlink" title="2.Jvm的整体结构（HotSpot虚拟机）"></a>2.Jvm的整体结构（HotSpot虚拟机）</h2><p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096238161_1595165056570-83f37444-0a7f-4456-8823-c1de088bde3c.png" alt="fb4daaaad358812f41e46fbb30fb049.png"> </p>
<h2 id="3-Java代码的执行流程"><a href="#3-Java代码的执行流程" class="headerlink" title="3.Java代码的执行流程"></a>3.Java代码的执行流程</h2><p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096238156_1594981518143-13b0c554-60fa-49c1-b1ae-6839750466bc.png" alt="8dc485e46117f2b68cf768d1650be8f.png"> </p>
<p> ①：首先java程序经过<a href="">前端</a>编译器生成.class字节码文件； </p>
<p> ②：虚拟机将字节码文件生成为对应的操作系统指令 </p>
<p> ③：操作系统处理成计算机能够运行的指令 </p>
<h2 id="4-jvm的运行周期"><a href="#4-jvm的运行周期" class="headerlink" title="4.jvm的运行周期"></a>4.jvm的运行周期</h2><p> ①启动:通过类引导加载器创建一个初始类来完成； </p>
<p> ②执行：程序开始执行的时候，Jvm启动，程序执行结束的时候，Jvm就停止； </p>
<p> 执行一个java程序的时候，真真正正执行的是一个java虚拟机的进程 </p>
<p> ③停止： </p>
<p> a.程序正常执行结束； </p>
<p> b.程序因为异常终止； </p>
<p> c.程序因为操作系统的异常而终止； </p>
<p> d.自己调用了System类中的exit(）方法使程序退出； </p>
<h1 id="二、类加载子系统-☆"><a href="#二、类加载子系统-☆" class="headerlink" title="二、类加载子系统(☆)"></a>二、类加载子系统(☆)</h1><h2 id="1-作用："><a href="#1-作用：" class="headerlink" title="1.作用："></a>1.作用：</h2><p> 将.class文件加载到内存，并对数据进行检验、解析及初始化，最终形成虚拟机能够直接使用的java类型，加载的类信息存放在方法区中。 </p>
<p> 注：只负责加载，能不能运行，由执行引擎决定。 </p>
<h2 id="2-类加载分为哪些过程："><a href="#2-类加载分为哪些过程：" class="headerlink" title="2.类加载分为哪些过程："></a>2.类加载分为哪些过程：</h2><p> ①加载 </p>
<p> ②连接：验证、准备及解析 </p>
<p> ③初始化 </p>
<h2 id="3-类加载各阶段的作用："><a href="#3-类加载各阶段的作用：" class="headerlink" title="3.类加载各阶段的作用："></a>3.类加载各阶段的作用：</h2><p> ①加载： </p>
<p> a.通过一个类的全限定名来获取此类的二进制字节流； </p>
<p> b.将该二进制字节流所代表的的<strong>静态存储结构</strong>转化为方法区的<strong>运行时数据结构</strong>； </p>
<p> c.在内存中<strong>生成</strong>一个代表该类的<strong>java.lang.Class对象</strong>，作为方法区这个类的数据访问入口。 </p>
<p> ②连接： </p>
<p> a.验证：确保Class文件的字节流（二进制）中包含的信息符合规范，保证这些信息被当做代码运行后不会对虚拟机造成危害。分为：文件格式验证、元数据验证、字节码验证。符号引用验证四个方面。 </p>
<p> b.准备：正式为类的静态变量分配内存并设置初始值（隐式初始化）。 </p>
<p>  <strong>特例</strong>：被final修饰的静态变量在准备阶段会被显式初始化。 </p>
<p> c.解析：Java虚拟机将常量池中的符号引用替换为直接引用。分为：类或接口的解析、字段解析及方法解析、接口方法解析 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096238657_1595297974543-61b880b6-8d89-4325-b88d-c492e1b2356b.png" alt="c5a38f83bd46ecf79801399430030e5.png"> </p>
<p> 如图所示：中间部分即为符号引用；//后面即为直接引用。 </p>
<p> ③初始化：在准备阶段，静态变量已经赋过一次系统要求的初始零值，而在初始化阶段，会根据程序员通过程序编码指定的主观计划去初始化静态变量和其他资源。 </p>
<h2 id="4-简单描述一下-方法"><a href="#4-简单描述一下-方法" class="headerlink" title="4.简单描述一下()方法?"></a>4.简单描述一下<clinit>()方法?</h2><p>  <strong>①定义：<clinit>()方法是由编译器自动收集类中的所有的静态变量的赋值和静态代码块语句合并产生的，没有的话则不会产生。</strong> </p>
<p>  ②顺序：编译器收集的顺序是由语句在源文件中出现的顺序决定，<strong>静态语句块中只能访问到定义在静态语句块之前的静态变量。</strong> </p>
<p>  ③其他： </p>
<p>  <strong>a.java虚拟机会保证在子类的**</strong><clinit>()执行前，父类的**<strong><clinit>()方法已经执行完毕。</strong> </p>
<p>  b.接口中不能使用静态代码块，但是仍然有赋值初始化操作，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法。 </p>
<p>  <strong>c.Java虚拟机必须保证一个类的</strong><clinit>()方法<strong>在多线程的环境中被同步加锁。如果多个线程同时去初始化一个类，必须只能其中一个去执行这个类</strong><clinit>()方法。 </p>
<h2 id="5-类加载器是什么？"><a href="#5-类加载器是什么？" class="headerlink" title="5.类加载器是什么？"></a>5.类加载器是什么？</h2><p>  在类的加载阶段中“通过一个类的全限定名来获取类的二进制字节流”实现这个动作的代码称为类加载器。 </p>
<h2 id="6-类加载器的分类："><a href="#6-类加载器的分类：" class="headerlink" title="6.类加载器的分类："></a>6.类加载器的分类：</h2><p> ①启动类加载器（引导类加载器） </p>
<p> ②扩展类加载器 </p>
<p> ③应有程序类加载器（系统类加载器） </p>
<p> ④自定义类加载器 </p>
<h2 id="7-双亲委派模型"><a href="#7-双亲委派模型" class="headerlink" title="7.双亲委派模型"></a>7.双亲委派模型</h2><p> <strong>1.双亲委派模型的工作过程：</strong> </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096238252_1595230547411-5e0691e3-d438-426a-9f0a-7c5842458afc.png" alt="image.png"> </p>
<p>  <strong>①：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委托给父类的加载器去执行；</strong> </p>
<p>  <strong>②：如果父类加载器还存在父类加载器，则会继续向上委托，请求最终达到顶层的引导类加载器；</strong> </p>
<p>  <strong>③：如果父类引导器可以完成加载任务，则成功返回；否则子加载器会尝试自己执行，这就是双亲委派机制。</strong> </p>
<p> 2.双签委派模型的优势： </p>
<p>  <strong>①：避免类的重复加载；</strong> </p>
<p>  <strong>②：沙箱安全机制：保护程序安全，防止核心类库被随意更改（举例：自定义一个java.lang.String类）</strong> </p>
<h2 id="8-破坏双亲委派模型"><a href="#8-破坏双亲委派模型" class="headerlink" title="8.破坏双亲委派模型"></a>8.破坏双亲委派模型</h2><p> ①第一次“破坏” </p>
<p> 双亲委派机制是在jdk1.2时出现的，因此在jdk1.2之前不满足双亲委派机制，即java.lang.ClassLoader抽象类，用户编写子类，然后能够重写loadClass()方法，这样就破坏了双亲委派机制； </p>
<p> 解决：在ClassLoader中添加了protected的findClass()方法，引导用户重写loadClass()方法时，尽可能重新给这个方法，而不是在loadClass()方法中进行修改。 </p>
<p> ②第二次“破坏” </p>
<p> 缺陷：越基础的类由越上层的类加载器进行加载，但是越基础的类型又需要去调用用户的代码，用户的代码一般由系统类加载器进行加载，这样引导类加载器无法调。 </p>
<p> 解决：线程上下文类加载器，启动类加载器想要调用我们的用户代码时，首先委托给线程上下文类加载器，然后线程上下文类加载器再去调用用户的程序代码。 </p>
<h1 id="三、运行时数据区（☆）"><a href="#三、运行时数据区（☆）" class="headerlink" title="三、运行时数据区（☆）"></a>三、运行时数据区（☆）</h1><h2 id="1-概述："><a href="#1-概述：" class="headerlink" title="1.概述："></a>1.概述：</h2><p> 运行时数据区的结构 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096238192_1595235271575-f488a9a8-7c71-4c2e-b254-96042bd2060e.png" alt="142facffd9e630571232c0e48b7dae6.png"> </p>
<p> 其中：<strong>方法区</strong>和<strong>堆</strong>是线程共享的；程序计数器和本地方法栈及<strong>虚拟机栈</strong>都是每个线程一份 </p>
<h2 id="2-程序计数器"><a href="#2-程序计数器" class="headerlink" title="2.程序计数器"></a>2.程序计数器</h2><p> 2.1程序计数器作用：用于存储下一条字节码指令的地址，<strong>执行引擎</strong>执行完当前指令，根据程序计数器的地址执行下一条指令。 </p>
<p> 2.2程序技术器的特点？ </p>
<p> ①线程私有：每个线程都有自己的程序计数器； </p>
<p> ②当前方法：任何时间一个线程都只有一个方法在执行，程序计数器会存储线程当前执行方法的Jvm指令的地址。 </p>
<p> ③程序计数器的特点：唯一一个没有OOM的内存区域。 </p>
<p>  <strong>2.3为什么需要使用程序计数器来记录当前线程的地址？<br> ①：CPU需要不断切换不同的线程，切换回来需要知道从哪条指令开始。</strong> </p>
<p>  <strong>②：字节码解释器需要知道下一条执行的执行地址。</strong>  </p>
<p>  <strong>2.4为什么要将程序计数器设计为线程私有的？</strong> </p>
<p>  <strong>为了能够准确记录各个线程的当前正在执行的指令地址，最好的办法就是为每一个线程设置一个程序计数器</strong> </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096238248_1595240269784-8cbde4d3-3cb8-4487-89eb-b35dddae6b4a.png" alt="80e5487f0309611166f3944d5681797.png"></strong> </p>
<h2 id="3-Java虚拟机栈"><a href="#3-Java虚拟机栈" class="headerlink" title="3.Java虚拟机栈"></a>3.Java虚拟机栈</h2><h3 id="3-1内存中的堆和栈"><a href="#3-1内存中的堆和栈" class="headerlink" title="3.1内存中的堆和栈"></a>3.1内存中的堆和栈</h3><p> 栈解决<strong>程序</strong>的<strong>运行</strong>问题，<a href="">如程</a>序如何执行，如何处理数据；堆解决<strong>数据存储</strong>问题，数据怎么放，放在哪儿等 </p>
<h3 id="3-2虚拟机栈的作用"><a href="#3-2虚拟机栈的作用" class="headerlink" title="3.2虚拟机栈的作用"></a>3.2虚拟机栈的作用</h3><p>  <strong>①每个线程在创建时都会创建一个虚拟机栈，内存存储一个一个栈帧，正在执行的方法对应着一个一个栈帧。</strong> </p>
<p>  <strong>②主管java程序的运行，保存方法的局部变量（8种基本数据类型及对象的引用地址）、部分结果参与方法的调用及返回。</strong> </p>
<h3 id="3-3虚拟机栈的声明周期"><a href="#3-3虚拟机栈的声明周期" class="headerlink" title="3.3虚拟机栈的声明周期"></a>3.3虚拟机栈的声明周期</h3><p> 与线程一致 </p>
<h3 id="3-4特点："><a href="#3-4特点：" class="headerlink" title="3.4特点："></a>3.4特点：</h3><p> 不存在垃圾回收；但是存在OOM </p>
<h3 id="3-5JVM对虚拟机栈的操作有什么？"><a href="#3-5JVM对虚拟机栈的操作有什么？" class="headerlink" title="3.5JVM对虚拟机栈的操作有什么？"></a>3.5JVM对虚拟机栈的操作有什么？</h3><p>  <strong>①每个方法执行，伴随着入栈。</strong> </p>
<p>  <strong>②方法执行结束出栈。</strong> </p>
<h3 id="3-6虚拟机栈常见两个异常"><a href="#3-6虚拟机栈常见两个异常" class="headerlink" title="3.6虚拟机栈常见两个异常"></a>3.6虚拟机栈常见两个异常</h3><p> ①：stackOverFlow:JVM允许用户自己设置虚拟机栈的大小为固定值，当方法数过多，致使栈帧数量超过虚拟机栈的大小时，就会报stackOverFlow; </p>
<p> ②：OutOfMemoryError：Java虚拟机栈容量允许扩展，当无法申请到足够的内存时，会报OOM异常。 </p>
<h3 id="3-7虚拟机栈运行的原理："><a href="#3-7虚拟机栈运行的原理：" class="headerlink" title="3.7虚拟机栈运行的原理："></a>3.7虚拟机栈运行的原理：</h3><p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096238316_1595249982615-bb92aec8-8688-40af-bc5e-e1c29e31dea3.png" alt="277ca12c3d36fad05eaed7b567d9439.png"> </p>
<p> 如果在当前方法中调用了其他方法，对应新的栈帧会被创建出来，放在栈的顶端，称为当前栈帧 </p>
<h3 id="3-8栈帧的结构"><a href="#3-8栈帧的结构" class="headerlink" title="3.8栈帧的结构"></a>3.8栈帧的结构</h3><p> 局部变量表、操作数栈、动态链接、方法返回地址及一些附加信息； </p>
<h3 id="3-9局部变量表"><a href="#3-9局部变量表" class="headerlink" title="3.9局部变量表"></a>3.9局部变量表</h3><p>  <strong>①：作用</strong> </p>
<p> 局部变量表为定义一个数字数组，<strong>存储方法参数和定义在方法内部的局部变量</strong>。<strong>数字数组中，如果是基本数据类型变量，则存储的是变量值，如果是引用数据类型，则存储的是堆内对象的地址值。</strong> </p>
<p> ②：安全性 </p>
<p> 由于是线程私有的，因此不存在安全问题。 </p>
<p> ③：大小 </p>
<p> 局部变量表的大小是在编译期就确定的，一旦确定，无法修改。 </p>
<p>  <strong>④：声明周期</strong> </p>
<p>  <strong>局部变量表中的变量只在当前的方法调用中有效，一旦方法调用结束，则随着栈帧的出栈，局部变量表随之销毁</strong>。 </p>
<p>  <strong>⑤：与垃圾回收的关系</strong> </p>
<p> 局部变量表中的变量也是垃圾回收的根结点，因为局部变量表中存在指向堆内存的对象的引用地址，一旦栈帧被弹出虚拟机栈，则相应的对象需要被回收，反之，被局部变量表中直接或者间接引用的对象都不会被回收。 </p>
<h3 id="3-10-操作数栈"><a href="#3-10-操作数栈" class="headerlink" title="3.10.操作数栈"></a>3.10.操作数栈</h3><p>  <strong>①**</strong>作用** </p>
<p>  <strong>用于保存计算过程中的中间结果，同时作为变量计算过程中的临时存储空间（可能存在逃逸分析）。</strong> </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096238191_1595295362818-a446a1ba-b6d6-44bf-bc44-b75ea6a6dbcb.png" alt="f980e127c377c44088d9845c59523a8.png"></strong> </p>
<p>  <strong>代码的具体执行过程：</strong> </p>
<p>  <strong>①首先程序计算器中的字节码指令地址为0，然后创建操作数栈，首先将局部变量i的值压入操作数栈，然后此时局部变量表中为空，然后程序计算器中的地址更改为2，执行istore_1指令，即将变量i存储到局部变量表中，然后操作数栈中的15被弹出到局部变量表中，然后继续执行下一条指令。</strong> </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096238566_1595296791418-e4b0c050-4045-44bf-b973-dcbe3f0b782c.png" alt="adc0f74643612cce39bf120aa2aa8f9.png"></strong> </p>
<h3 id="3-11操作数栈的数据结构"><a href="#3-11操作数栈的数据结构" class="headerlink" title="3.11操作数栈的数据结构"></a>3.11操作数栈的数据结构</h3><p>  <strong>底层是由数组来实现的栈，不能通过索引来操作具体的数据，只能是由栈的操作，即出栈和入栈操作。</strong> </p>
<h3 id="3-12操作数栈的创建"><a href="#3-12操作数栈的创建" class="headerlink" title="3.12操作数栈的创建"></a>3.12操作数栈的创建</h3><p> 当一个方法被执行的时候，相应的栈帧也就被创建出来，此时的操作数栈的底层数组时空的，在编译期数组的长度及操作数栈的深度也就被确定了。（<strong>因为数组的长度一旦确认，就不能更改了，只有集合类才存在动态扩容机制</strong>） </p>
<h3 id="4-动态链接"><a href="#4-动态链接" class="headerlink" title="4.动态链接"></a>4.动态链接</h3><p>  <strong>①作用：在Java源文件被编译到字节码文件时，所有的**</strong>变量和方法引用**<strong>都作为符号引用保存在字节码文件的常量池中，动态链接的作用就是转换为调用方法的直接引用（记录在方法区的运行时常量池中的方法的地址）。</strong> </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096238577_1595308822414-9cc80051-12c1-4bf1-93e5-8cf0b25b8ab0.png" alt="7848da45f9123a96fc0954916396bf1.png"></strong> </p>
<p>  <strong>②四种方法调用指令及区分虚方法与非虚方法</strong> </p>
<p>  <strong>③方法重写的本质与虚方法的使用</strong> </p>
<h3 id="5-方法的返回地址"><a href="#5-方法的返回地址" class="headerlink" title="5.方法的返回地址"></a>5.方法的返回地址</h3><p>  <strong>①作用：存放调用该方法的程序计算器的值即调用该方法的下一条指令的地址值。</strong> </p>
<p> ②正常完成出口与异常完成出口 </p>
<p> 正常完成出口:执行引擎遇到任何一个方法返回的字节码指令时，会有返回值传递给上层的方法调用者。 </p>
<p> 异常完成出口：在方法的执行过程中遇到了异常，且没有在本方法内部进行处理，就会退出。 </p>
<p> <strong>6.虚拟机栈面试题</strong> </p>
<p>  <strong>①举例虚拟机栈溢出的情况（StackOverFlow情况）</strong> </p>
<p>  <strong>答：当通过-Xss设置虚拟机栈为固定大小后，当实际运行的栈帧数量超过虚拟机栈的最大深度的时候，就会爆出stackOverFlow错误。</strong> </p>
<p>  <strong>此外还可能存在OOM异常。</strong> </p>
<p>  <strong>②调整虚拟栈的大小能够保证不溢出吗？</strong> </p>
<p>  <strong>答：不能保证，比如说出现不会停止的递归过程，调整虚拟栈的大小也没有什么用，只会让溢出的时间晚一些而已。</strong> </p>
<p>  <strong>③虚拟机栈的大小是越大越好吗？</strong> </p>
<p>  <strong>答：肯定不是的，挤占其他的内存空间。</strong> </p>
<p>  <strong>④垃圾回收是否涉及到虚拟机栈？</strong> </p>
<p>  <strong>不会</strong> </p>
<p>  <strong>⑤方法中定义的局部变量是否是线程安全的？</strong> </p>
<p>  <strong>具体问题具体分析：</strong> </p>
<p>  <strong>线程安全的情况：如果是单个线程或者说在方法内部创建内部消亡的话，则是线程安全的，</strong> </p>
<p>  <strong>线程不安全的情况：多个线程共享这个局部变量时有可能存在线程安全问题。</strong> </p>
<h2 id="4-本地方法栈"><a href="#4-本地方法栈" class="headerlink" title="4.本地方法栈"></a>4.本地方法栈</h2><p>  <strong>①虚拟机栈与本地方法栈的区别：</strong> </p>
<p>  <strong>虚拟机栈用于管理Java方法的调用，而本地方法栈用于本地方法的调用。</strong> </p>
<p>  <strong>②本地方法</strong> </p>
<p>  <strong>本地方法是有C、C++等语言编写的，是Java的拓展方法库。</strong> </p>
<p> ③其他 </p>
<p> 本地方法栈是线程私有的，Hot Spot虚拟机中将其和虚拟机栈合二为一。 </p>
<h2 id="5-堆"><a href="#5-堆" class="headerlink" title="5.堆"></a>5.堆</h2><h3 id="1-堆空间的概述"><a href="#1-堆空间的概述" class="headerlink" title="1.堆空间的概述"></a>1.堆空间的概述</h3><p>  <strong>①一个JVM实例对应着一个堆内存；</strong> </p>
<p>  <strong>②堆是进程私有的，是线程共享的；</strong> </p>
<p>  <strong>③堆随着JVM的启动而创建，堆大小一旦创建完成就不能更改；</strong> </p>
<p>  ④堆内存的大小是可以调节的。 </p>
<p>  ⑤堆在物理上是不连续的，但是在逻辑上连续的； </p>
<p> <strong>2.TLAB（Thread Local Allocation Buffer）</strong> </p>
<p> 堆是线程共享的，但是在堆中存在线程私有的缓冲区。 </p>
<p> <strong>3.作用：几乎所有的对象实例及数组都在堆分配内存</strong> </p>
<p>  <strong>数组和对象可能永远不会存储在虚拟机栈上，因为栈帧中保存的是指向堆空间的对象或者数组的地址值。</strong> </p>
<p> <strong>4.与垃圾回收的关系</strong> </p>
<p> 是垃圾回收的重点区域； </p>
<p> 在方法结束后，堆中的对象不会马上被清除，需要GC进行判断。 </p>
<p> 5.堆内存细分 </p>
<p> jdk1.7之前将堆分为：新生代+老年代+永久代；jdk1.8之后将堆从逻辑上分为：新生代+老年代+元空间 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096238519_1595490148979-ef7ad32e-cd7e-4187-a771-289177ec348c.png" alt="ed0d5bba47d31cbb470884da08e9522.png"> </p>
<p> 6.堆空间的内部结构 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096238526_1595491986858-f7e25c8a-1e34-4bb6-854a-e03581ca1a83.png" alt="1423f4c548f9718044745337328c3af.png"> </p>
<p> 注：永久代/元空间其实是归于方法区管理，堆实际上只负责前两部分（新生代+老年代） </p>
<h3 id="2-设置堆内存的大小及OOM问题"><a href="#2-设置堆内存的大小及OOM问题" class="headerlink" title="2.设置堆内存的大小及OOM问题"></a>2.设置堆内存的大小及OOM问题</h3><p>  <strong>①：设置堆内存大小</strong> </p>
<p>  <strong>a.-Xms：设置堆空间（新生代+老年代）的起始内存大小</strong>  </p>
<p>  <strong>b.-Xmx：设置堆空间（新生代+老年代）的最大内存大小</strong> </p>
<p> 补充：-X是虚拟机的运行参数；ms:memory size的意思 </p>
<p> c.默认的堆空间的起始内存大小：电脑运行内存的大小/64；默认的堆空间的最大内存大小：电脑运行内存的大小/4； </p>
<p> ②OOM问题 </p>
<p> 当堆内存使用超过设置的最大堆内存时，会出现OOM异常 </p>
<p> OOM举例： </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096238793_1595494302236-9eb265ce-5e0b-49ae-b3ec-534f6bd13b51.png" alt="22ce6927f98dbeaa86ce47926fabca8.png"> </p>
<p> 过程：创建了一个List数组，然后不断向数组中添加Picture对象，然后逐渐内存就被占满了后，会出现OOM异常 </p>
<h3 id="3-新生代与老年代"><a href="#3-新生代与老年代" class="headerlink" title="3.新生代与老年代"></a>3.新生代与老年代</h3><p>  <strong>①什么是年轻代？什么是老年代？</strong> </p>
<p>  <strong>存储在堆中的Java对象可以分类两类，一类是新生代，一类是老年代；</strong> </p>
<p>  <strong>新生代：一类是声明周期较短的瞬时对象，这类对象从创建到消亡时间较短暂；新生代包括伊甸园区，两个幸存区</strong> </p>
<p>  <strong>老年代：一类对象的声明周期比较长，在极端情况下还可能与JVM的声明周期一致；</strong> </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096238635_1595495493822-2a498574-fa89-4520-a13d-c4a271bc371c.png" alt="2d29b29a4f6252d1f150f376dc54507.png"></strong> </p>
<p> ②新生代与老年代的默认内存比例 </p>
<p> 默认的新生代与老年代的比例是1：2 </p>
<p> ③HotSpot虚拟机中，新生代与Sur<a href="">vivo</a>r的比例是多少？ </p>
<p> 通过-XX:Sur<a href="">vivo</a>rRatio的值进行调节；<strong>默认的是8：1：1；实际使用时不为8：1：1，因为存在自适应内存分配策略（默认开启）</strong> </p>
<p> ④<strong>几乎所有的</strong>Java对象都是在Eden区被new出来（如果对象查过Eden大小，则直接进入老年代）；绝大部分的java对象销毁都发生在新生代； </p>
<h3 id="4-对象内存分配的一般过程（垃圾回收的一般过程）"><a href="#4-对象内存分配的一般过程（垃圾回收的一般过程）" class="headerlink" title="4.对象内存分配的一般过程（垃圾回收的一般过程）"></a>4.对象内存分配的一般过程（垃圾回收的一般过程）</h3><p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096238902_1595497907218-66a96095-0fac-43c2-83ed-93d695988e13.png" alt="5aaac71ce942af6b38055595bbb8b1c.png"> </p>
<p>  <strong>a.：new出来的对象会被存储在伊甸园区，然后当伊甸园区的空间被占满后，此时会YGC，将没有被其他对象所引用的对象进行回收，然后将伊甸园区剩余对象加载到Sur<a href="">vivo</a>r0区（from区），并将年龄标记为1，再加载新的对象放在伊甸园区。</strong> </p>
<p>  <strong>b.：如果再次触发YGC垃圾回收，上次放在幸存者0区的对象会放在幸存者1区，年龄标记+1.然后伊甸园区幸存下来的对象会被放到幸存者1区，年龄标记为1，然后幸存者1区变为from区，幸存者0区变为to区；</strong> </p>
<p>  <strong>c.：如果再次发生YGC，则会重复此过程，当from区的幸存对象的标记年龄超过15后，则会移动到老年代中；如果存在着大于伊甸园区的对象，则会直接进入到老年代中；当老年代内存不足时，会触发GC，进行老年代回收；</strong> </p>
<p> 总结：对幸存者1区2区：<strong>复制后交换</strong>，谁空谁为to区；频繁在新生代收集，较少在老年代收集，几乎不在永久代/元空间收集 </p>
<h3 id="5-对象内存分配特殊情况（当出现超大对象的情况时）："><a href="#5-对象内存分配特殊情况（当出现超大对象的情况时）：" class="headerlink" title="5.对象内存分配特殊情况（当出现超大对象的情况时）："></a>5.对象内存分配特殊情况（当出现超大对象的情况时）：</h3><p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096238742_1595506311836-59ce7019-0c1a-480b-ab04-0b73e16c2e78.png" alt="c2c08a7c182ca524de7232e7f06153a.png"></strong> </p>
<h3 id="6-Minor-GC和Major-GC和Full-GC"><a href="#6-Minor-GC和Major-GC和Full-GC" class="headerlink" title="6.Minor GC和Major GC和Full GC"></a>6.Minor GC和Major GC和Full GC</h3><p>  <strong>1.三者的区别</strong> </p>
<p>  <strong>部分收集(Partial GC)：不是完整收集整个java堆的垃圾收集</strong> </p>
<p>  <strong>①：新生代收集（Minor GC/Young GC）:只是新生代的垃圾收集</strong> </p>
<p>  <strong>②：老年代收集（Major GC/Old GC）:只是老年代的垃圾收集</strong> </p>
<p>  <strong>目前只有**</strong>CMS**<strong>垃圾收集器**</strong>才有单独的老年代的收集** </p>
<p>  <strong>③：混合收集：收集整个新生代和部分老年代的垃圾收集</strong> </p>
<p> 目前只有G1垃圾收集器具备混合收集（因为它是基于region的垃圾收集） </p>
<p>  <strong>整堆收集（Full GC）：完整收集java堆及方法区的垃圾收集</strong> </p>
<p>  <strong>2.Minor GC</strong> </p>
<p>  <strong>①触发条件：当伊甸园区满了，就会触发Minor GC,回收整个年轻代的垃圾（s0和s1区满不会触发Minor GC）</strong> </p>
<p>  <strong>②触发后果：当进行Minor GC时，会造成STW（Stop The World）,会停止运行用户其他线程。</strong> </p>
<p>  <strong>3.Major GC</strong> </p>
<p>  <strong>①触发条件：当老年代的内存空间不足时，会优先触发Minor GC,如果之后还不足，则会触发Major GC</strong> </p>
<p>  <strong>②触发后果：Major GC比Minor GC的速度要慢十倍以上，造成更长时间的STW。</strong> </p>
<p>  <strong>4.Full GC</strong> </p>
<p>  <strong>①：触发条件：</strong> </p>
<p>  <strong>a.调用System.gc()时，系统建议执行Full GC；</strong> </p>
<p>  <strong>b.老年代的空间不足；</strong> </p>
<p>  <strong>c.方法区的空间不足时。</strong> </p>
<h3 id="7-堆空间的分代思想"><a href="#7-堆空间的分代思想" class="headerlink" title="7.堆空间的分代思想"></a>7.堆空间的分代思想</h3><p>  <strong>1.为什么分为新生代和老年代（面试重点）</strong> </p>
<p>  <strong>不同对象的生命周期是不同的，70%-90%的对象的生命周期是短暂的，在新生代主要存放生命周期短暂的对象，在老年代存放新生代中经过多次垃圾回收之后依然没有没有被回收的对象，这样做主要是为了优化GC的性能，如果不分新生代和老年代，而是将对象都放在一起，则每次GC的时候都要遍历整个堆空间，会造成STW的时间较长，影响用户性能体验。</strong> </p>
<h3 id="8-内存分配策略"><a href="#8-内存分配策略" class="headerlink" title="8.内存分配策略"></a>8.内存分配策略</h3><p>  <strong>a.优先分配到新生代</strong> </p>
<p>  <strong>b.大对象直接分配到老年代；</strong> </p>
<p>  <strong>c.长期存活的对象（s0，s1区中年龄计算器值超过设定阈值或默认阈值15）分配到老年代；</strong> </p>
<p>  <strong>d.动态对象年龄判断：如果Sur<a href="">vivo</a>r区中相同年龄的对象的总和大于等于Sur<a href="">vivo</a>r区的一半，则大于等于该年龄的对象直接进入到老年代中。</strong> </p>
<p>  <strong>补充：大对象直接进入到老年代代码（创建大小为20M的数组，设定堆空间的初始内存和最大内存都为60M，然后设置新生代与老年代的比例为1：2，即老年代40M，新生代20M，然后设定伊甸园区与幸存者区比例为8：1：1，则伊甸园区16M，不足以放下20M的数组）</strong> </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096239094_1595556640996-2e0e9eaa-7064-4fc6-99bd-c6696a898ed9.png" alt="82589a5000c758b289c0737e92395cb.png"></strong> </p>
<h3 id="9-TLAB（Thread-Local-Allocation-Buffer-线程私有缓存区）"><a href="#9-TLAB（Thread-Local-Allocation-Buffer-线程私有缓存区）" class="headerlink" title="9.TLAB（Thread Local Allocation Buffer:线程私有缓存区）"></a>9.TLAB（Thread Local Allocation Buffer:线程私有缓存区）</h3><p>  <strong>1.什么是TLAB？</strong> </p>
<p>  <strong>jvm在伊甸园区为每一个线程开辟了一块私有的缓存区，每个TLAB只占伊甸园区的1%，JVM将TLAB作为内存分配的首选</strong> </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096238863_1595557782607-7be773a5-4b43-46e7-80d2-24642905da8e.png" alt="975488eb886480bbd9dd1e537a074c9.png"></strong> </p>
<p>  <strong>2.为什么要有TLAB?</strong> </p>
<p>  <strong>因为堆空间是线程共享的，如果存在多个线程同时访问堆空间的某个对象，则可能会造成线程安全问题，可以采用加锁机制实现同步处理，但是会影响分配速度，因此采用TLAB的方式解决。</strong> </p>
<p> 3.TLAB补充 </p>
<p> a.尽管不是所有的对象都在TLAB分配内存，但是JVM会优先在TLAB为对象分配内存； </p>
<p> b.当TLAB内存空间不足时，会采用同步加锁机制在伊甸园其他区域分配内存，确保数据操作的原子性。 </p>
<p> 10.堆空间的参数设置(后期补充) </p>
<h3 id="11-堆是分配对象存储的唯一选择吗？"><a href="#11-堆是分配对象存储的唯一选择吗？" class="headerlink" title="11.堆是分配对象存储的唯一选择吗？"></a>11.堆是分配对象存储的唯一选择吗？</h3><p> 1.该问题 </p>
<p> 随着即时编译器的发展与逃逸分析技术的不断成熟，虚拟机<strong>栈上分配</strong>等技术的出现，使得对象分配在堆上就没有那么绝对了。 </p>
<p>  <strong>如果经过逃逸分析后发现，一个对象并没有逃逸出方法的话，则有可能会被优化成栈上分配。</strong> </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096238945_1595560039247-2cc3146c-22ef-439a-9f07-94c9c085b1bb.png" alt="15168d871b56754cd098b11727f722d.png"></strong> </p>
<p> 2.简述逃逸分析（只知道什么逃逸分析即可）？ </p>
<p>  <strong>①什么是逃逸分析？</strong> </p>
<p>  <strong>如果将堆上的对象分配到栈的话，需要使用逃逸分析技术。</strong> </p>
<p>  <strong>虚拟机能够通过分析来判断对象的引用范围是否在方法内部，从而决定是否将对象份分配到堆上。</strong> </p>
<p>  <strong>②如何判断是否发生了逃逸？</strong> </p>
<p>  <strong>如果一个对象在方法中被定义后，对象只在方法内部进行使用，则认为没有发生逃逸。</strong> </p>
<p>  <strong>如果一个对象在方法内被定义后，对象被外部方法所引用，则认为发生了逃逸。</strong> </p>
<h2 id="6-方法区"><a href="#6-方法区" class="headerlink" title="6.方法区"></a>6.方法区</h2><h3 id="1-堆、栈和方法区的交互关系"><a href="#1-堆、栈和方法区的交互关系" class="headerlink" title="1.堆、栈和方法区的交互关系"></a>1.堆、栈和方法区的交互关系</h3><p> ①内存层面 </p>
<p>  <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096239226_1595564024898-a68373ed-edbc-434a-a81a-755bcc1e9ba7.png" alt="b8cae0b5fe97f06a7f71ba3a407f565.png">  </p>
<p>  运行时数据区（Runtime Data Region）主要包括虚拟机栈、堆及方法区（jdk1.8后称为元空间）、程序技术器及本地方法栈。 </p>
<p> ②线程共享层面 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096239011_1595564191837-dbc6a07a-fc20-4177-a96f-11a49f49247c.png" alt="07b2006e0f6d411a73bfae16720d85a.png"> </p>
<p> 线程共享：堆和方法区 </p>
<p> 堆：GC的重点回收区，如果内存不足会报出OOM </p>
<p> 方法区：GC也会对此部分进行回收，回收的频率极低；内存不足时也会报出OOM </p>
<p> 线程私有：程序计数器、虚拟机栈及本地方法栈 </p>
<p> 程序奇数器：无GC、无异常； </p>
<p> 虚拟机栈：无GC，存在异常：StackOverFlow(栈溢出) </p>
<p> 本地方法栈：无GC，存在异常：StackOverFlow(栈溢出) </p>
<p>  <strong>③创建对象层面</strong> </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096239412_1595564454971-0b4da657-7ef5-48d1-9864-2885c195a9ac.png" alt="92e185030600f9f18c3bad3412bd303.png"></strong> </p>
<p>  如上图所示：Person类信息会存储在方法区当中，而person变量如果定义在方法内，则会存储在虚拟机栈的栈帧的局部变量表中，而右侧的new出来的对象则会存放在堆中； </p>
<p>  下面这个图为：虚拟机栈中存储着对象的引用地址，指向位于堆空间对象的实例，而堆空间中对象实例数据中包含指向存储在方法区的对象类型数据的指针。 </p>
<h3 id="2-方法区的理解"><a href="#2-方法区的理解" class="headerlink" title="2.方法区的理解"></a>2.方法区的理解</h3><p> <strong>1.jdk1.8前后的不同</strong> </p>
<p>  <strong>①：jdk1.8之前为永久代；jdk1.8之后称为元空间（MetaSpace）</strong> </p>
<p>  <strong>②：永久代处于虚拟机中的内存中，而元空间不在虚拟机设置的内存中，使用本地内存</strong> </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096239149_1595574759693-c43c17c1-309d-469d-a6ab-3a23699b05e3.png" alt="71afdd02df8339be856dbc88a9f8103.png"></strong> </p>
<p> <strong>2.补充知识点</strong> </p>
<p>  <strong>a.作用：保存类信息相关信息；</strong> </p>
<p>  b.声明周期：随着JVM的创建而创建，随着JVM的关闭而死亡； </p>
<p>  c.异常：方法区的大小决定了系统可以创建多少个类，如果创建过多的类，导致方法区溢出，就会出现OOM； </p>
<p> d.线程：是多个线程共享的区域； </p>
<h3 id="3-调节方法区的大小和OOM"><a href="#3-调节方法区的大小和OOM" class="headerlink" title="3.调节方法区的大小和OOM"></a>3.调节方法区的大小和OOM</h3><p>  <strong>1.元空间的默认大小和设置方式</strong> </p>
<p>  <strong>a.默认大小：**</strong>初始默认大小为**<strong>：21M**</strong>；**<strong>最大显示为**</strong>-1**<strong>，即**</strong>没有限制** </p>
<p>  <strong>b.设置：初始内存大小：-XX:MetaspaceSize=想设置的值；最大内存大小：MaxMetaspaceSize=设置值；</strong> </p>
<p>  <strong>2.如何解决OOM问题（后期补充）：</strong> </p>
<p> ①：内存泄露与内存溢出？ </p>
<p> ②如何解决OOM？ </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096239528_1595577955946-1cf61529-bdf7-448a-9291-347ab050c141.png" alt="b474220dab442458f16ea55353556bd.png"> </p>
<h3 id="4-方法区的内部结构"><a href="#4-方法区的内部结构" class="headerlink" title="4.方法区的内部结构"></a>4.方法区的内部结构</h3><p> <strong>1.方法区中都存储哪些信息？</strong> </p>
<p>  <strong>a.类信息</strong> </p>
<p>  <strong>①：类的名称（包名.类名）</strong> </p>
<p>  <strong>②：父类名称</strong> </p>
<p>  <strong>③：修饰符信息</strong> </p>
<p> ④：接口的有序列表 </p>
<p> ⑤：… </p>
<p>  <strong>b.常量</strong> </p>
<p>  <strong>c.静态变量（存在问题）</strong> </p>
<p>  <strong>被static修饰的变量或者静态代码块（jdk1.7之后，静态变量存储在堆空间中）</strong> </p>
<p>  <strong>d.即时编译器代码缓存</strong> </p>
<p>  <strong>将热点代码存储在方法区中，解释为机器指令后并不执行，以做备用</strong> </p>
<p>  <strong>e.域信息（属性等）</strong> </p>
<p>  <strong>域的修饰符、类型及域的名称等信息</strong> </p>
<p>  <strong>f.方法信息（方法的）</strong> </p>
<p>  <strong>方法的名称、修饰符、返回值类型、参数的类型及个数、异常表信息及字节码信息等</strong> </p>
<p>  <strong>示例代码：</strong> </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096239222_1595579280305-7661c404-cb8d-4123-abb6-cb3e7ce3c871.png" alt="ef4c97c1aa47a5150189a848001fb0b.png"></strong> </p>
<p>  <strong>方法区的存储信息（示例中）：</strong> </p>
<p> ①类型信息 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096239291_1595579583771-8127ee7f-52d3-495f-907e-f81033fa4281.png" alt="d3787e45ade1c7a0bf2b99f640c2062.png"> </p>
<p> ②域信息 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096239378_1595579601684-0fbde0af-2272-47b1-a88f-4e795c478205.png" alt="5a045b3d9e2356185adeb0fd30b3e37.png"> </p>
<p> ③方法信息 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096239517_1595579618769-9c8ecb53-213a-4ce5-86c6-434c4055a961.png" alt="a913ead9a97cd623c2b7f7c3d8acb29.png"> </p>
<p> 2.反编译字节码文件的方法 </p>
<p> ①：找到字节码所在的文件位置，然后调用javap -v -p 类名.class </p>
<p> ②：通过jclasslib插件 </p>
<p> <strong>3.运行时常量池</strong> </p>
<p>  <strong>a.什么是运行时常量池？</strong> </p>
<p>  <strong>.class字节码文件中的常量池用于存放编译后的各种字面量及符号引用，在加载类和接口到虚拟机后，这部分内容就转为了运行时常量池。</strong> </p>
<p>  <strong>b.为什么需要常量池？</strong> </p>
<p>  <strong>常量池中包含了类中各种字面量及对类型、方法及域的各种符号引用，这样可以有效减少字节码文件的大小。</strong> </p>
<p> 4.举例说明方法区的使用过程 </p>
<p> 代码： </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096239479_1595585471775-d759def1-1188-4fa3-b3b5-ed80a3837038.png" alt="461419283deb47bed84469caa83ab56.png"> </p>
<p> 字节码文件中的常量池： </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240135_1595586298053-96f2f45d-5293-497e-a989-3938ed6e1b0f.png" alt="af5f95c46a761cccab9293160938bdc.png"> </p>
<p> 程序实现的具体方法区及虚拟机栈的过程 </p>
<h3 id="5-方法区在jdk6和jdk7及jdk8的不同（重点）？"><a href="#5-方法区在jdk6和jdk7及jdk8的不同（重点）？" class="headerlink" title="5.方法区在jdk6和jdk7及jdk8的不同（重点）？"></a>5.方法区在jdk6和jdk7及jdk8的不同（重点）？</h3><p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096239553_1595585938024-f7150ec1-bff4-4e11-9256-f2d5d65fbd34.png" alt="d37808d57c2b4ac5d1abca5d2afcba4.png"></strong> </p>
<p> jdk1.6：静态变量存放在永久代上，字符串常量池存放在运行时常量池中 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096239700_1595586016957-3e16f958-69c8-4e55-af9e-022b49081fef.png" alt="9ef9a72533903bd4455ba8ed01b51f0.png"> </p>
<p> jdk1.7：逐渐已经放弃“永久代”，<strong>静态变量</strong>和<strong>字符串常量池</strong>存放在<strong>堆</strong>上 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096239758_1595586113088-73e4b170-34dc-4442-a8c2-2de8d8b4b5b3.png" alt="45abfbf4ab92d7b3fe515afa9d74f02.png"> </p>
<p> jdk1.8及以后，永久代被元空间取代，整体从JVM设置内存中移动到本地内存中，但是静态变量和字符串常量池依然保存在堆中。（在jdk1.7的基础上将方法区拿到本地内存中为元空间）。 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096239665_1595586264023-6dd6201c-24d2-4180-9b32-251dac620973.png" alt="b873b5a6ba3f00e6084800ae34b3a88.png"> </p>
<p> 6.永久代替换为元空间的好处有哪些？ </p>
<p> ①：永久代的大小比较有限，而元空间是基于本地内存，相对更大，因此OOM的发生的几率就越小； </p>
<p> ②：对永久代的调优更加困难，因此当方法区空间不足时，会引起Full GC,类型的卸载条件相当苛刻，因此尽量保证不发生Full GC。 </p>
<p> <strong>5.方法区的垃圾回收</strong> </p>
<p>  <strong>1.回收的主要对象（内容）是什么？</strong> </p>
<p> 常量池中<strong>废弃的常量</strong>（包括字面量和符号引用）及<strong>不再使用的类型</strong>； </p>
<p> 2.常量的回收策略？ </p>
<p>  <strong>常量池中的常量没有被任何对象所引用，则会被回收</strong> </p>
<p>  <strong>3.判定类不再被使用的条件？</strong> </p>
<p>  <strong>a.该类的所有实例都已经被回收</strong> </p>
<p> b.加载该类的类加载器已经被回收 </p>
<p> c.该类对应的大的Class对象没有被引用。 </p>
<h3 id="6-对象的实例化与访问"><a href="#6-对象的实例化与访问" class="headerlink" title="6.对象的实例化与访问"></a>6.对象的实例化与访问</h3><p> 1.对象的实例化 </p>
<p> ①：<strong>对象的创建方式</strong>： </p>
<p> <img src="https://uploadfiles.nowcoder.com/images/20201111/849965361_1605098533143_4DAA5E86F28EC78A300E16A0EFA13752" alt="img"> </p>
<p> <strong>②：对象的创建/实例化的步骤（Object obj=new Object()的整个过程）（面试重点）**</strong>：** </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096239773_1595642846333-844eae5b-20de-4c1d-a30f-890698d97363.png" alt="73acdcb8de4c60fde69ab1d074a7788.png"></strong> </p>
<p>  <strong>a.加载对象的类型信息</strong> </p>
<p>  <strong>b.为对象分配内存</strong> </p>
<p> 分配策略： </p>
<p> 指针碰撞： </p>
<p> 空闲列表： </p>
<p>  <strong>c.处理并发安全问题</strong> </p>
<p> CAS<a href="">算法</a>和加锁机制 </p>
<p>  <strong>d.属性的默认初始化</strong> </p>
<p> 非静态变量 </p>
<p>  <strong>e.设置对象头信息</strong> </p>
<p> 对象头中的信息包含指向方法区类型等信息的指针 </p>
<p>  <strong>f.执行init方法进行初始化</strong> </p>
<p> 属性的显式初始化 </p>
<p> 代码块的初始化 </p>
<p> 构造器中的初始化 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096239768_1595642929467-9d5bdbaa-88d2-47d7-8584-6963d7c7c775.png" alt="233d64d2cf31330548a6d3faf51fb48.png"> </p>
<h3 id="2-对象的内存布局"><a href="#2-对象的内存布局" class="headerlink" title="2.对象的内存布局"></a>2.对象的内存布局</h3><p> ①：对象的内存布局包含哪些？每部分的作用展开叙述 </p>
<p>  <strong>a.对象头（面试重点）</strong> </p>
<p>  <strong>运行时元数据：主要包含对象的哈希值、GC分代年龄（from区向to区移动，分代年龄+1）、锁信息等</strong> </p>
<p> 类型指针：指向方法区（元空间）的类元数据，确定对象所属的类 </p>
<p>  <strong>数组长度（如果为数组对象）</strong> </p>
<p> b.实例数据 </p>
<p> 它是对象真正存储的有效信息，包括程序中定义的各种字段（包括从父类继承下来的和自己拥有的字段） </p>
<p> c.对齐填充 </p>
<p> 任何对象的大小都是8字节的整数倍，如果实例数据不满足，采用对齐填充进行补齐 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096239955_1595644982536-f2acfafc-b1a1-4e2b-a904-8f0ee555fa15.png" alt="f4338c7a1776bab3540b77c14477ca4.png"> </p>
<p> ②举例子说明该过程（定义一个Customer类，然后里面有属性，代码块，调用另外一个类来创建类实例，然后创建该类的对象/实例） </p>
<p> 代码如下： </p>
<p> 创建类： </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096239912_1595645223504-4bdd33d9-fe3e-4d1f-8a3c-797313662605.png" alt="6e1fc1a3a23f08b97355da3531f0748.png"> </p>
<p> 创建类的对象/实例： </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096239895_1595645315840-34641235-01d0-4e4a-9910-8daf0409987d.png" alt="c2a54bc8d4b0fe37e196ec3bf04ef47.png"> </p>
<p> 整个内存情况： </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240039_1595645370085-bc66bb68-63fb-49c8-b549-ae0ce38c9d0a.png" alt="de8568ea309f04ddd600f6cfad44b55.png">过程： </p>
<h3 id="3-对象的访问定位"><a href="#3-对象的访问定位" class="headerlink" title="3.对象的访问定位"></a>3.对象的访问定位</h3><p> ①：对象的访问定位方式有几种（<strong>JVM是如何通过虚拟机栈中的栈帧中的局部变量表中的地址值访问到对象的实例数的呢？</strong>），两种方式的优缺点？ </p>
<p> a.句柄方式 </p>
<p> 通过局部变量表中的地址值找到堆空间中的句柄池，句柄池中存在两个指针，一个指针指向堆空间的对象实例数据；另一个指针指向方法区（元空间）中对象的类元信息。 </p>
<p>  <strong>优点：在GC环节，from区到to区对象会频繁移动，此时只需改变句柄池中的指针即可，虚拟栈中的地址不需改动;</strong> </p>
<p>  <strong>缺点：句柄池占用堆空间；对象的访问效率相对降低</strong> </p>
<p> b.直接指针（Hotspot虚拟机采用） </p>
<p> 通过局部变量表中的引用地址值找到位于堆空间的对象的实例数据，实例数据中的对象头中包含指向方法区（元空间）的类元信息的<strong>类型指针。</strong> </p>
<p> 优点和缺点与句柄访问相反。 </p>
<h1 id="四、执行引擎（☆）"><a href="#四、执行引擎（☆）" class="headerlink" title="四、执行引擎（☆）"></a>四、执行引擎（☆）</h1><h2 id="1-执行引擎概述"><a href="#1-执行引擎概述" class="headerlink" title="1.执行引擎概述"></a>1.执行引擎概述</h2><p>  <strong>①.作用：</strong> </p>
<p> 将字节码指令解释/编译为对应平台上的本地机器指令。（因为本地机器指令无法识别字节码指令） </p>
<p>  <strong>②.结构：</strong> </p>
<p>  <strong>a.解释器</strong> </p>
<p>  <strong>b.即时编译器</strong> </p>
<p>  <strong>c.GC</strong> </p>
<p>  <strong>③.执行过程：</strong> </p>
<p> a.首先通过程序计数器找到需要执行的字节码指令 </p>
<p> b.然后通过虚拟栈的栈帧中的局部变量表中的地址找到堆空间中的对象的实例数据，然后通过实例数据中的对象头中的对象的类型指针找到方法区的类元信息。 </p>
<h2 id="2-java代码的编译和执行的过程"><a href="#2-java代码的编译和执行的过程" class="headerlink" title="2.java代码的编译和执行的过程"></a>2.java代码的编译和执行的过程</h2><p> ①：java代码编译和执行的过程 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096239982_1595650138598-20800a9f-5a7e-4a12-8a46-0c5cda3447ab.png" alt="1ee7fcab6c3235a2cd85857262a1ae6.png"> </p>
<p> 橙色部分：即<a href="">前端</a>编译器将.java源文件编译为字节码文件 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240049_1595650311733-8b386688-bff6-437b-ae02-95112cced3b2.png" alt="42f588c79388fd6100fc5a530015037.png"> </p>
<p> 绿色部分：解释器将字节码文件解释为本地机器指令，并进行执行； </p>
<p> 蓝色部分：将字节码指令解释为本地机器指令，但是并不执行（解释热点代码，以备用） </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240195_1595650341470-bff04124-94e4-4802-8584-6d7d3174a802.png" alt="6444e09b44f356f605df265a70aaeae.png"> </p>
<p> ②：为什么说java语言半编译半解释型语言？ </p>
<p> 因为java虚拟中的执行引擎同时存在解释器和即时编译器 </p>
<p> 举例子： </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240264_1595651329997-7ef978e6-5ea6-4d10-baf4-d6a2a66ad9cc.png" alt="4833fc4769b5f2122a0c7df0655b2a7.png"> </p>
<h2 id="3-解释器"><a href="#3-解释器" class="headerlink" title="3.解释器"></a>3.解释器</h2><p> ①：为什么需要字节码文件 </p>
<p> 可以实现跨语言，使其他的语言生成自己码指令,JVM也能执行。 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240209_1595651657984-8a286a9e-b5cb-4741-af09-efcd8cbb8c1e.png" alt="a9ca89d0a6ebcb01a1e762399e9579c.png"> </p>
<p>  <strong>②：解释器作用：</strong> </p>
<p> 根据程序计数器的指令地址，逐条将字节码指令“翻译”为本地机器指令，以便程序能够运行。 </p>
<h2 id="4-即时编译器（JIT）"><a href="#4-即时编译器（JIT）" class="headerlink" title="4.即时编译器（JIT）"></a>4.即时编译器（JIT）</h2><p>  <strong>①：作用：</strong> </p>
<p>  <strong>将整个函数体编译成机器码，每次函数执行时，只编译机器码即可，还可以将常用的机器码进行缓存在方法区（元空间）中，从而提高效率。</strong> </p>
<h2 id="5-解释器与即时编译器的优缺点"><a href="#5-解释器与即时编译器的优缺点" class="headerlink" title="5.解释器与即时编译器的优缺点"></a>5.解释器与即时编译器的优缺点</h2><p> 解释器： </p>
<p> 优点：程序一开始执行的时候，解释器就能够逐条执行，省去编译的时间。 </p>
<p> 缺点：相对于即时编译器而言，逐条进行翻译效率较低 </p>
<p> 即时编译器 </p>
<p> 优点：因为是提前编译好的机器指令，因此效率更高； </p>
<p> 缺点：程序一开始执行的时候，需要事先对字节码指令进行编译，需要一定的时间。 </p>
<p>  <strong>综上：HotSpot虚拟机采用两者兼容的方式，虚拟机开始启动后，解释器可以立即发挥作用，不需要等到即时编译器编译完后再去执行，节省不必要的编译时间，随着时间的推移，即时编译器编译完成之后，采用即时编译器效率更高。</strong> </p>
<h2 id="6-StringTable-字符串"><a href="#6-StringTable-字符串" class="headerlink" title="6.StringTable(字符串)"></a>6.StringTable(字符串)</h2><p>  <strong>①String基本特性</strong> </p>
<p>  <strong>a.存储结构的变更</strong> </p>
<p> jdk1.8时采用char[]进行存储；jdk1.9之后采用byte[]进行存储； </p>
<p>  <strong>b.不可变特性</strong> </p>
<p> 通过字面量的方式给一个字符串赋值，此时的字符串位于堆空间的常量池中， </p>
<p>  <strong>当对字符串进行赋值时，需要重写指定内存区域进行赋值，不能使用原有的value进行赋值；</strong> </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240228_1595663886079-fb77c233-8e69-4b85-9e74-5d42e0bcea9f.png" alt="ef7ab5333645c9d8265d19b65498cf6.png"> </p>
<p> 解释：因为ex.str已经确定为了good,然后再直接赋值的话，就不会改变 </p>
<p>  <strong>c.字符串常量池中不会存储相同的字符串</strong> </p>
<p>  常量池中的字符串均是唯一的，如果两个字符串变量相等，则两个变量指向字符串常量池中的同一个地址。 </p>
<p>  <strong>String Pool（常量池）底层是一个固定大小的HashTable</strong>，默认长度为1009，可通过-XX：StringTableSize设置 </p>
<p>  <strong>②String内存分配</strong> </p>
<p>  <strong>jdk1.6时，字符串常量池位于永久代内</strong> </p>
<p>  <strong>jdk1.7之后，字符串常量池位于堆空间；</strong> </p>
<p>  <strong>移动的原因/好处：</strong> </p>
<p>  <strong>永久代几乎不进行来及回收，将其移动到堆空间后，更方便进行垃圾回收。</strong> </p>
<p>  <strong>③String基本操作</strong> </p>
<p>  <strong>a.java语言规范指出完全相同的字符串字面量，必须是指向同一个String实例。</strong> </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240281_1595666395441-3e5cec92-d5b3-4152-b192-c6125cf8e4c4.png" alt="2c28db80fb54c6785df6e409470ddf0.png"></strong> </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240403_1595666408438-62f99cb6-6d11-4473-b768-d922f51b906a.png" alt="1716e6179d02d1e650de2c3f5d3f4a8.png"></strong> </p>
<p> ④字符串的拼接 </p>
<p>  <strong>a.常量与常量拼接结果存放在常量池中</strong> </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240331_1595669832346-02cc1655-5578-49c4-a66c-71694883305c.png" alt="0d5c1278dcd928e231513c235289094.png"> </p>
<p> 首先==号判断的是两者的地址值是否相等，则两者指向的是字符串常量池中的同一个字符串，地址值相等； </p>
<p> 其次equals判断的是两个字符串序列是否相等，则也是相等的。 </p>
<p>  <strong>b.常量池中不会存在相同内容的常量。</strong> </p>
<p>  <strong>c.如果在拼接前后出现变量，则连接的结果存放在堆中字符串常量池外（相当于new一个对象），原理是StringBuilder;</strong> </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240467_1595670609119-3cf1c740-89a9-468e-bc93-8407e1c79c41.png" alt="24f1bbb42d687c2b9b259c27a36b876.png"></strong> </p>
<p>  <strong>d.如果拼接的结果调用了intern()方法，则主动将常量池中还没有的字符串常量对象放入池中，并返回地址</strong> </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240568_1595670625620-0c121ae8-b220-44a6-a7c4-da0dd5a2af75.png" alt="75ce06b75080dcf3ef18c99343c523b.png"></strong> </p>
<p> ⑤字符串拼接底层原理（后面补充） </p>
<p> ⑥intern()方法（后面补充） </p>
<h1 id="五、垃圾回收（☆）"><a href="#五、垃圾回收（☆）" class="headerlink" title="五、垃圾回收（☆）"></a>五、垃圾回收（☆）</h1><h2 id="1-垃圾回收概述"><a href="#1-垃圾回收概述" class="headerlink" title="1.垃圾回收概述"></a>1.垃圾回收概述</h2><p>  <strong>①什么是垃圾？</strong> </p>
<p> 垃圾指的是在运行程序中没有任何指针指向的对象。 </p>
<p>  <strong>②为什么需要GC？</strong> </p>
<p>  a.如果不断进行内存分配而不进行垃圾回收，内存迟早会被消耗完； </p>
<p>  b.GC可以解决内存中的碎片化问题，从而能够为较大的对象分配足够的内存空间； </p>
<p>  c.随着应用程序的不断完善，用户越来越多，更需要GC来进行性能优化。 </p>
<p>  ③垃圾回收的主要区域 </p>
<p>  a.方法区：主要回收常量池中废弃的常量（字面量及符号引用）及不再使用的类型 </p>
<p>  b.堆空间：回收垃圾（没有任何指针指向的对象） </p>
<h2 id="2-垃圾回收相关算法"><a href="#2-垃圾回收相关算法" class="headerlink" title="2.垃圾回收相关算法"></a>2.垃圾回收相关<a href="">算法</a></h2><p> 判断对象存活方式：<strong>引用计数</strong><a href="">算法</a>和<strong>可达性分析</strong><a href="">算法</a> </p>
<h3 id="①：标记阶段（表明什么对象需要回收）"><a href="#①：标记阶段（表明什么对象需要回收）" class="headerlink" title="①：标记阶段（表明什么对象需要回收）"></a>①：标记阶段（表明什么对象需要回收）</h3><p> a.引用计数<a href="">算法</a> </p>
<p>  <strong>原理：每个对象都有一个引用计数器，来记录对象被引用的次数，每增加一次引用计数器+1；每减少一次引用计数器-1，当引用计数器记录值为0时，就表名该对象没有被任何对象引用，则表名该对象为垃圾。</strong> </p>
<p> 优缺点： </p>
<p> 优点：<strong>实现简单</strong>，垃圾对象便于识别；<strong>回收效率高</strong>； </p>
<p> 缺点： </p>
<p>  <strong>①：无法处理**</strong>循环引用**<strong>的情况；从而造成内存泄露；</strong> </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240483_1595728008989-fb53f3b9-fe0d-4d89-b601-5d01b286cba9.png" alt="1081170840f3c095db45d58f6c50c01.png"></strong> </p>
<p> ②：<strong>空间</strong>：因为需要计数器，所以造成额外的空间开销； </p>
<p> ③：<strong>时间</strong>：需要频繁的加1或者减1操作，造成一定的时间开销； </p>
<p> 代码举例： </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240519_1595728600583-3a7d7e95-c52e-43f6-8eb6-1de87d7948b7.png" alt="bc79c3d75c46c47b0dcee8340e9e235.png"><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240549_1595728642091-2214436c-583b-42f8-bdd8-a0a0ad2693e8.png" alt="a95d6769dd2274680f0f51972c6007a.png"> </p>
<p>  <strong>b.可达性分析<a href="">算法</a>（根搜索<a href="">算法</a>）</strong> </p>
<p> GC Roots:<strong>一组活跃引用的根对象集合</strong> </p>
<p>  <strong>基本原理：以跟对象为起始点，从上到下搜索被根对象所连接的目标是否可以到达，内存中的存活对象都直接或者间接地与根对象集合相连，搜索所走过的路径被称为引用链，如果目标对象没有被任何引用链相连，则为不可到达，即为内存中的垃圾。</strong> </p>
<p> 优点：可以<strong>解决循环引用</strong>的问题； </p>
<p> 缺点：相较于引用计数<a href="">算法</a>来说，回收效率稍慢一些。 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240582_1595730382833-244e346f-9f7f-48bb-9b5e-08a53a985cf7.png" alt="aeb85652010215edb3b2b9b18bf6d3a.png"> </p>
<p>  <strong>c.可以被当做GC Roots的元素有哪些？（重点是堆外保存堆内对象的地址的那些区域）</strong> </p>
<p> ①：<strong>虚拟机栈中引用的对象</strong>；如：各个线程中被调用的方法的局部变量等 </p>
<p> ②：<strong>本地方法栈中引用的对象</strong>； </p>
<p> ③：<strong>方法区（元空间）静态属性引用的对象</strong>：如<strong>静态变量</strong> </p>
<p> ④：<strong>方法区（元空间）中常量引用的对象</strong>。如<strong>字符串常量池中引用的对象</strong> </p>
<p> ⑤：<strong>所有被synchronized持有的对象；</strong> </p>
<p> ⑥：基本数据类型对应的Class对象、异常类对象及系统类加载器 </p>
<p> ⑦：还需要一些<strong>“临时性”对象加入GC Roots</strong>结合中，如只针对新生代回收，则堆中新生代以外的引用对象也需要加入GC Roots集合中。 </p>
<h3 id="②：对象的finalization机制"><a href="#②：对象的finalization机制" class="headerlink" title="②：对象的finalization机制"></a>②：对象的finalization机制</h3><p>  <strong>a.什么是对象的finalization机制</strong> </p>
<p>  <strong>在gc 回收某个对象之前，会先调用对象的finalize()方法。Object类中的finalize()方法没有任何方法体，对象类可以重写这个方法。</strong> </p>
<p> b.虚拟机中的对象有哪几种可能的状态（生存还是死亡）？ </p>
<p> ①：可触及的：能够与引用连相连接的对象； </p>
<p> ②：可复活的：没有任何引用的对象，但是可以在finalize()中被复活的对象； </p>
<p> ③：不可触及的：对象的finalize()被调用，但是没有被复活的对象。<strong>finalize()方法只能被调用一次。</strong> </p>
<p>  <strong>c.判断一个对象是否可以被回收所经历的两次标记过程（如何判断一个对象是否可以被回收？）（面试重点）</strong> </p>
<p>  <strong>①：如果对象到GC Root没有引用链连接，则进行第一次标记；</strong> </p>
<p>  <strong>②：进行筛选，判断是否有必要调用对象的finalize()方法</strong> </p>
<p>  1.对象类没有重写finalize()方法或者已经调用过了finalize（）方法，则为不可触及的； </p>
<p>  2.对象重写了该方法但是还没调用过该方法，则回收前会先调用此方法； </p>
<p>  ③：<strong>执行二次标记</strong>：如果执行finalize()方法后，该对象与引用链上的任何一个对象建立连接，则为复活状态，否则判定为不可达状态。**<br>**  </p>
<h3 id="④：清除阶段-如何回收垃圾"><a href="#④：清除阶段-如何回收垃圾" class="headerlink" title="④：清除阶段(如何回收垃圾)"></a>④：清除阶段(如何回收垃圾)</h3><p> a.标记-清除<a href="">算法</a> </p>
<p>  <strong>1.原理：当需要进行GC时，会停止整个程序（STW），然后整个GC过程分为标记阶段和清除阶段</strong> </p>
<p>  <strong>标记：从引用根对象开始遍历，标记所有**</strong>被引用**<strong>的对象，一般在对象头中记录为可达对象。</strong> </p>
<p>  <strong>清除：对堆内存进行从头到尾的遍历，如果发现某个对象的对象头没有被标记为可达对象，则进行回收</strong> </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240675_1595739453595-f93ecf82-9c3d-47a0-a681-8d15ff492dcf.png" alt="c9a21a81fc7f27cc95007ebd6e9ecf8.png"></strong> </p>
<p>  <strong>2.优点</strong>：最基本的垃圾回收<a href="">算法</a> </p>
<p>  <strong>3.缺点</strong>：①：因为需要遍历，所以<strong>执行效率不高</strong>； </p>
<p> ②：在进行GC时，需要STW，效率不高的话，会<strong>影响用户体验</strong>； </p>
<p> ③：产生<strong>内存碎片化</strong>问题 </p>
<p> b.<strong>复制</strong> </p>
<p>  <strong>1.原理：将内存空间分为大小相等的两块，每次只使用其中的一块，垃圾收集时，将正在使用的内存中的存活的对象复制到另一块内存中，然后将正在使用的内存清空。交换两个内存的角色，完成垃圾回收</strong> </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240674_1595739479153-f7a3ba9e-a669-4eae-bf62-6fd26fae715f.png" alt="687a8a1bc58920ecad9f67bc2abbebf.png"></strong> </p>
<p>  <strong>2.优点：</strong> </p>
<p>  <strong>①：执行效率高，省去了清除中的遍历问题；</strong> </p>
<p>  <strong>②：解决了内存碎片化的问题</strong> </p>
<p>  <strong>3.缺点：</strong> </p>
<p>  <strong>①：空间浪费较明显，始终有一块内存无法使用；</strong> </p>
<p>  <strong>②：对于G1这种分成很多region的垃圾回收器来说，复制意味着需要维持region之间对象的引用关系，空间和时间的开销比较大。</strong> </p>
<p>  <strong>4.适用场景：</strong> </p>
<p>  <strong>比较适合于垃圾对象较多，存活对象较少的区域，如新生代中的Sur<a href="">vivo</a>r0区和Sur<a href="">vivo</a>r1区。</strong>  </p>
<p>  <strong>不适合老年代中垃圾回收。</strong>  </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240919_1595739493765-05008c3b-0016-48c1-9536-b5378d23c4bc.png" alt="dac5e4393b0782d236d092cc09f7d5b.png"></strong> </p>
<p> <strong>c.标记-整理（压缩）</strong> </p>
<p>  <strong>1.原理：</strong> </p>
<p>  <strong>第一阶段和标记-清除<a href="">算法</a>的标记阶段一样，从根结点开始标记所有被引用的对象；</strong> </p>
<p>  <strong>第二阶段将所有存活的对象压缩到内存的一端，按顺序排放，然后清除边界以外的内存空间</strong> </p>
<p>  <strong>2.优点：</strong> </p>
<p>  <strong>①：解决了标记-清除内存碎片化的问题</strong> </p>
<p>  <strong>②：解决了标记-复制空间浪费一半的问题</strong> </p>
<p>  <strong>3.缺点：</strong> </p>
<p>  <strong>①：整理过程中需要移动对象，如果对象被其他对象所引用，则需要不断调整引用的地址；</strong> </p>
<p>  <strong>②：效率相对另外两种<a href="">算法</a>较低；</strong> </p>
<p>  <strong>4.适用场景：适合于老年代中的垃圾收集</strong> </p>
<p> <strong>d.三种垃圾回收<a href="">算法</a>对比</strong> </p>
<table>
<thead>
<tr>
<th><a href="">算法</a>：</th>
<th>标记-清除</th>
<th>复制</th>
<th>标记-压缩（整理）</th>
</tr>
</thead>
<tbody><tr>
<td>执行效率</td>
<td>中等</td>
<td>最快</td>
<td>最慢</td>
</tr>
<tr>
<td>空间开销</td>
<td>少（存在内存碎片化）</td>
<td>大（浪费一半空间）</td>
<td>小（不会产生内存碎片化）</td>
</tr>
<tr>
<td>移动对象</td>
<td>不</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<p> <strong>e.分代收集理论</strong> </p>
<p>  <strong>目的：不同声明周期的对象可以采用不用的回收<a href="">算法</a>，以提高整体的回收效率。</strong> </p>
<p> HotSpot虚拟机中的回收策略： </p>
<p> ①新生代： </p>
<p>  <strong>新生代特点：区域相对老年代小，对象声明周期短，回收频繁</strong> </p>
<p>  <strong>针对这种情况应当采用复制<a href="">算法</a>，回收效率高，针对于空间利用率不高的问题，采用两个Sur<a href="">vivo</a>r区得以缓解；</strong> </p>
<p> ②老年代： </p>
<p> 老年代特点：相对于新生代大，对象的声明周期长，回收不频繁。 </p>
<p> 针对这种情况采用标记-清除+标记-整理相结合的方法，首先标记阶段还是采用两者中的标记方法，即从根对象开始，依次标记所有的存活对象，然后采用清除<a href="">算法</a>，暂时容忍碎片化问题，等到碎片化问题影响到内存分配时，再采用整理<a href="">算法</a>，整理碎片化内存。 </p>
<p> f.增量收集<a href="">算法</a> </p>
<p> 如果一次性将所有垃圾进行回收，需要造成系统长时间的停顿，影响用户体验，可以让垃圾收集线程和用户线程交替执行，每次垃圾收集线程只收集一部分的内存空间，接着切换到应用程序，依次反复，直到垃圾收集完成。 </p>
<p> 优点：低延迟，用户体验更优；缺点：吞吐量下降 </p>
<p> <strong>g.分区收集<a href="">算法</a></strong> </p>
<p> <strong>将整个堆空间划分为连续不等的小区间，根据目标的停顿时间，每次合理的回收若干个小区间，而不是整个堆空间。每一个小区间都独立使用，独立回收。</strong> </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240800_1595751084301-658eedf5-4a0a-4840-91a7-c5833ce4e50d.png" alt="2457ccd314d0dd6b07d3d68efdc5bef.png"></strong> </p>
<h2 id="3-垃圾回收相关概念"><a href="#3-垃圾回收相关概念" class="headerlink" title="3.垃圾回收相关概念"></a>3.垃圾回收相关概念</h2><h3 id="①-System-gc"><a href="#①-System-gc" class="headerlink" title="①  System.gc()"></a>①  System.gc()</h3><p> 会显示触发<strong>Full GC</strong>,但是<strong>无法保证对垃圾收集器的调用</strong>；底层调用Runtime.getRuntime().gc(）； </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240826_1595754647048-a98b157f-0f19-4268-9c11-a79c3d20a2ef.png" alt="3e948d137245d7ef6992b5004e61c83.png"> </p>
<p> 举例子：不太理解方法3和方法4（需要补充关于虚拟机栈Slot槽部分的内容） </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096241232_1595756139900-d838628b-c7db-40ad-8bb8-13a2c1470744.png" alt="573829485ec7aa301af326258a3c4e5.png"> </p>
<h3 id="②-内存溢出与内存泄露"><a href="#②-内存溢出与内存泄露" class="headerlink" title="②  内存溢出与内存泄露"></a>②  内存溢出与内存泄露</h3><p> a.内存溢出（OOM）：<strong>没有空闲内存，并且垃圾收集器也无法提供更多内存</strong>。 </p>
<p> b.没有空闲内存的原因： </p>
<p> ①：设置的堆内存太小，此时可以通过-Xms:和-Xmx来设置堆空间的起始大小和最大大小； </p>
<p> ②：代码中创建了大对象，并且长时间不能被垃圾回收器所收集； </p>
<p>  <strong>举出OOM的例子</strong>： </p>
<p>  <strong>c.内存泄露</strong>：（非常重要） </p>
<p>  <strong>①严格意义：对象不会被程序用到，但是GC又没有办法回收掉该对象，此时就称为发生了内存泄露；</strong> </p>
<p>  <strong>②宽泛意义：实际情况中，一些不好的编程实践造成了对象的声明周期变得很长甚至导致OOM，（如本来可以定义为方法内部的局部变量，定义为类的成员变量甚至定义为静态变量（随着类的加载而加载，随着类的消亡而消亡）造成变量的声明周期加长，本来方法弹栈后可能就会被释放（没有发生逃逸））。</strong> </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096241002_1595759119542-327dff3f-c48b-4787-9507-58e1ca8bd19d.png" alt="edda5dfe6bf8d2ae2093d4066e98f36.png"></strong> </p>
<p> <strong>③：举例说明内存泄露（举出关于内存泄露的例子）</strong> </p>
<p>  <strong>1.单例的生命周期和程序一样长，单例程序中如果存在对外部对象的引用，则外部对象是没有办法被回收的，会造成内存泄露</strong> </p>
<p>  <strong>2.一些提供close()的资源未关闭而导致内存泄露（如数据库的连接必须手动close,否则不能被回收）。</strong> </p>
<h3 id="③-STW"><a href="#③-STW" class="headerlink" title="③ STW"></a>③ STW</h3><p> 如论那种垃圾收集器，在进行垃圾收集的过程中，都会使程序停顿，这称为STW，被STW中断的程序在完成GC后会自动恢复。 </p>
<p> 目的：为了保证数据的一致性（不能统计垃圾的时候还一边造垃圾） </p>
<h3 id="④-垃圾回收并行与并发"><a href="#④-垃圾回收并行与并发" class="headerlink" title="④ 垃圾回收并行与并发"></a>④ 垃圾回收并行与并发</h3><p> a.程序的并行与并发 </p>
<p> 并发：从一段时间来看，有多个任务在执行，从单一的时间点上来看，只有一个任务在执行，时间上是Cpu在快速切换任务交替执行； </p>
<p> 并行：当系统有多个CPU时，一个cpu可以执行一个进程，另一个cpu可以执行另一个进程，两个进程不会互相抢cpu资源，可以同时进行，此称为并行。 </p>
<p> 对比：并发指的是同一个时间段，多个任务发生了，且抢占cpu资源； </p>
<p> 并行指的是在用一个时间点，多个任务发生了，不抢占cpu资源； </p>
<p> <strong>b.垃圾回收的并行与并发</strong> </p>
<p>  <strong>并行：**</strong>多条垃圾回收线程并行执行**<strong>，此时需要停顿用户线程</strong> </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240867_1595761521311-c4ff54ec-6b9e-4f7a-98e9-8b78de2204a5.png" alt="0aa5a774f97604365f4a1a7a134ccbb.png"></strong> </p>
<p>  <strong>串行：只有一条垃圾回收线程，当内存不够时，程序暂停，启动垃圾回收，回收完，再启动程序的线程。</strong> </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240951_1595762176553-c26533d4-711f-42b8-9963-6a2553890e3b.png" alt="3048456c12d156275562237731199e8.png"></strong> </p>
<p>  <strong>并发：用户线程与垃圾回收线程同时执行，垃圾回收线程在执行时，不会停顿用户程序的执行。(？？)</strong> </p>
<p>  <strong>用户程序在继续进行，而垃圾收集线程运行在另一个CPU，如：CMS和G1。</strong> </p>
<h3 id="⑤-安全点与安全区域-后期补充"><a href="#⑤-安全点与安全区域-后期补充" class="headerlink" title="⑤ 安全点与安全区域**(后期补充)**"></a>⑤ 安全点与安全区域**(后期补充)**</h3><h3 id="⑥-强引用（Strong-Reference）"><a href="#⑥-强引用（Strong-Reference）" class="headerlink" title="⑥ 强引用（Strong Reference）"></a>⑥ 强引用（Strong Reference）</h3><p>  <strong>a.定义：在java程序中通过new创建了一个对象，并将其赋值给一个变量，该变量就称为指向该对象的一个强引用</strong> </p>
<p>  <strong>b.适用场景</strong>：99%以上的都是强引用。 </p>
<p>  <strong>c.垃圾回收</strong>：强引用的对象都是可触及的，GC不会回收掉被强引用的对象（<strong>强引用，不回收</strong>）。 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240983_1595818842584-44aba881-26dd-4276-9aec-d0e0e3b779c2.png" alt="fb8867da1f480b45b38a5a953492d91.png"> </p>
<h3 id="⑦-软引用-Soft-Reference"><a href="#⑦-软引用-Soft-Reference" class="headerlink" title="⑦ 软引用(Soft Reference)"></a>⑦ 软引用(Soft Reference)</h3><p> a.定义：<strong>描述的是一些还在用，但是非必须的对象</strong>。 </p>
<p> b.适用场景：通常用来实现内存敏感的缓存，如高速缓存就用到软引用。 </p>
<p> c.垃圾回收：<strong>内存不足即回收</strong> </p>
<p> <strong><img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096240953_1595825486805-f0cde15d-8227-4ea6-9877-c68fbc9678eb.png" alt="319c2e165351273dff2f12c48d8a81f.png"></strong> </p>
<h3 id="⑧-弱引用-Weak-Reference"><a href="#⑧-弱引用-Weak-Reference" class="headerlink" title="⑧ 弱引用(Weak Reference)"></a>⑧ 弱引用(Weak Reference)</h3><p> a.定义：<strong>弱引用也是描述那些非必须的对象，与软引用的区别在于GC时，对于软引用来说需要判断当前内存是否不足，不足的话才进行回收，而对于弱引用不需要进行判断直接回收。</strong> </p>
<p> b.适用场景：保存那些可有可无的缓存数据。 </p>
<p> c.垃圾回收：发现即回收 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096241104_1595825502743-bc232bb6-bda0-4f0d-a272-183b00bed29d.png" alt="2d4a74df4cde830a229d8c8e944d581.png"> </p>
<p> 补充面试题：<strong>你用过weakHashMap吗</strong>？ </p>
<p> 采用weakHashMap进行存储后，当内存不足时，能够对该部分进行回收，因为内存的Entry&lt;k,v&gt;类继承了弱引用类。 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096241181_1595825700924-cee01a4d-63d4-4c7b-91b5-2b04ee0e5f52.png" alt="5f96175ed1b08c259f9798921d22811.png"> </p>
<h3 id="⑨-虚引用-Phantom-Reference"><a href="#⑨-虚引用-Phantom-Reference" class="headerlink" title="⑨ 虚引用(Phantom Reference)"></a>⑨ 虚引用(Phantom Reference)</h3><p> a.定义：<strong>所有引用中最弱的一个，为一个对象设置虚引用关联的目的是跟踪垃圾回收的过程,被回收后可以发出相应的通知。</strong> </p>
<p> b.适用场景：实现跟踪对象的垃圾回收过程 </p>
<p> c.垃圾回收：跟踪对象回收过程 </p>
<h2 id="4-垃圾回收器"><a href="#4-垃圾回收器" class="headerlink" title="4.垃圾回收器"></a>4.垃圾回收器</h2><h3 id="①垃圾回收主要性能指标"><a href="#①垃圾回收主要性能指标" class="headerlink" title="①垃圾回收主要性能指标"></a>①垃圾回收主要性能指标</h3><p> a.吞吐量：用户程序运行时间/用户程序运行时间+垃圾回收时间 </p>
<p> 吞吐量越高越好，这样会提升用户体验，认为只有应用程序在执行。 </p>
<p> b.暂停时间：执行垃圾收集时，程序被暂停的时间。 </p>
<p> 暂停时间越低越好，对于交互式应用程序，暂停时间越长，越容易出现卡顿现象，影响用户体验。 </p>
<p> c.<strong>现在标准：在最大吞吐量优先的情况下，降低停顿时间。</strong> </p>
<h3 id="②垃圾回收器概述（分类）"><a href="#②垃圾回收器概述（分类）" class="headerlink" title="②垃圾回收器概述（分类）"></a>②垃圾回收器概述（分类）</h3><p> 串行(STW时只有一个垃圾回收线程)：Serial 及Serial Old </p>
<p> 并行（STW时有多个垃圾回收线程）：ParNew、Parallel Scavenge及Parallel Old </p>
<p> 并发（垃圾回收线程和用户线程并发执行）：CMS及G1 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096241511_1595840882697-367b4ac4-b3c4-4b54-8fc9-ae6b8b8bf584.png" alt="1595840867(1).png"> </p>
<h3 id="③垃圾回收器的组合关系"><a href="#③垃圾回收器的组合关系" class="headerlink" title="③垃圾回收器的组合关系"></a>③垃圾回收器的组合关系</h3><p> 新生代：Serial ParNew Parallel Scavenge </p>
<p> 老年代：Serial Old  Parallel Old和CMS </p>
<p> 新生代和老年代：G1 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096241232_1595842219886-502f4f93-ac2c-4ed8-8a1b-e8f3ad97dd69.png" alt="29f7408242b6eaa3554dda7d1a548a7.png"> </p>
<p> 组合关系： </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096241322_1595842411433-68100b26-15bf-4b80-b852-bf2cc5653ed0.png" alt="4f1260ebe1fc7b087c38f8f024e788c.png"> </p>
<p> 补充：jdk9中移除了Serial+CMS和ParNew+Serial Old这两种组合 </p>
<p> jdk14中，删除了CMS垃圾回收器。 </p>
<p> 目前的组合：Serial +Serial Old； Parallel Scavenge+Parallel Old和G1 </p>
<h3 id="④Serial垃圾回收器（串行回收）"><a href="#④Serial垃圾回收器（串行回收）" class="headerlink" title="④Serial垃圾回收器（串行回收）"></a>④Serial垃圾回收器（串行回收）</h3><p> a.Serial垃圾回收器 </p>
<p> 采用复制<a href="">算法</a>、串行收集和Stop The World的方式来对新生代进行垃圾收集。是HotSpot虚拟机在<a href="">客户端</a>模式下默认的新生代垃圾回收器。 </p>
<p> b.Serial Old垃圾回收器 </p>
<p> 采用标记-整理<a href="">算法</a>、串行收集和Stop The World的方式来对老年代进行垃圾收集。是HotSpot虚拟机在<a href="">客户端</a>模式下默认的老年代垃圾回收器。 </p>
<p> c.回收过程 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096241308_1595843687990-e4d8fff4-2f0c-4fcb-a591-dfa0f08953ef.png" alt="9265b78a446251f6f9272d95ebf09d7.png"> </p>
<p> d.回收优势：因为是单线程，因此没有线程交换的开销，相对于其他垃圾收集器的单线程相比，简单而高效。 </p>
<p> e.参数设置：-XX:useSerialGC/useSerialOldGC设置 </p>
<h3 id="⑤ParNew垃圾回收器（并行回收）"><a href="#⑤ParNew垃圾回收器（并行回收）" class="headerlink" title="⑤ParNew垃圾回收器（并行回收）"></a>⑤ParNew垃圾回收器（并行回收）</h3><p> a**.**回收模式：采用复制<a href="">算法</a>、并行回收和STW的机制进行垃圾回收,是JVM在服务端下的默认新生代垃圾回收器。 </p>
<p> b组合搭配：可以和Serial Old搭配使用（JDK9中移除）；可以和CMS配合使用（JDK14中删除） </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096241334_1595844540740-8cf49062-0ef1-4702-888f-2a64419c5958.png" alt="18d52dde30c0ee4e38b6746e277094d.png"> </p>
<p> c.优势：对于新生代，回收次数频繁，因此采用并行方式更加高效。 </p>
<p> d.参数设置：**-XX:useParNewGC** </p>
<h3 id="⑥Parallel垃圾回收器（吞吐量优先）"><a href="#⑥Parallel垃圾回收器（吞吐量优先）" class="headerlink" title="⑥Parallel垃圾回收器（吞吐量优先）"></a>⑥Parallel垃圾回收器（吞吐量优先）</h3><p> a.Parallel Scavenge垃圾回收器 </p>
<p>  <strong>采用复制<a href="">算法</a>、并行回收及STW的机制进行垃圾收集。</strong> </p>
<p> b.Parallel Scavenge垃圾回收器与ParNew的区别： </p>
<p>  Parallel Scavenge的<strong>目标是达到一个可控吞吐量</strong>，而且具备自适应调节策略。 </p>
<p> c.Parallel Old垃圾回收器 </p>
<p>  <strong>采用标记-整理、并行回收及STW的机制进行垃圾收集，在JDK8中，默认**</strong>Parallel Scavenge+<strong>**Parallel Old</strong>为垃圾回收器。 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096241334_1595845902568-32911b65-779d-49b6-a9e1-51dbf4d2862e.png" alt="678148c114fe84d0504b6b4fb1fd576.png"> </p>
<p> d.适用场景：高吞吐量则可以高效的利用cpu的时间，来快速实现计算。主要适合<strong>在后台运行而不需要太多交互</strong>的任务 </p>
<h3 id="⑦CMS-Concurrent-Mark-Sweep-垃圾回收器（低延时）"><a href="#⑦CMS-Concurrent-Mark-Sweep-垃圾回收器（低延时）" class="headerlink" title="⑦CMS(Concurrent Mark Sweep)垃圾回收器（低延时）"></a>⑦CMS(Concurrent Mark Sweep)垃圾回收器（低延时）</h3><p> a.概念：CMS(Concurrent Mark Sweep)垃圾回收器是HotSpot虚拟机第一款并发垃圾回收器，实<strong>现了垃圾收集线程和用户线程同时工作</strong>。是<strong>基于标记-清除<a href="">算法</a>，并发回收的老年代垃圾收集器</strong>，只搭配ParNew和Serial使用，在jdk14时，CMS垃圾回收器被删除。 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096241351_1595901760026-72069930-c030-41b0-b184-7c18a5b05908.png" alt="155ee4a9f4599f5f182fce2f1fa054c.png"> </p>
<p> b.工作原理： </p>
<p> 1.初始标记:<strong>仅仅只是标记出GC Roots能够直接关联到的对象</strong>，存在<strong>STW</strong>机制。 </p>
<p> 2.并发标记:<strong>从GC Root直接关联到的对象开始，遍历整个对象图的过程</strong>，该阶段不需要停顿用户线程。 </p>
<p> 3.重新标记:<strong>修正并发标记阶段**</strong>，因用户线程运行而导致标记产生变动的那一部分对象的标记记录，存在STW机制。** </p>
<p> 4.并发清除:<strong>清除标记为已经死亡的对象，释</strong>放内存空间。 </p>
<p> c.优缺点： </p>
<p> 1.优点：并发收集；低延迟； </p>
<p> 2.缺点： </p>
<p> ①：<strong>会产生内存碎片</strong>，当老年代需要为大对象分配内存时，不得不提前触发Full GC; </p>
<p> ②：**无法处理”浮动垃圾”,可能导致”并发失败”**，从而引发Full GC </p>
<p> 浮动垃圾：因为在并发清理阶段，垃圾收集线程和用户线程在并发执行，用户线程运行过程中，会产生新的垃圾，而这部分垃圾是发生在标记阶段之后的，所以只能等到下一次GC时，才能够进行回收，这时候需要预留出一定的内存空间。 </p>
<p> ③：<strong>对CPU资源比较敏感</strong>：CMS默认的<strong>垃圾回收线程数</strong>为**(处理器核心数+3)/4**,对于处理器核心数比较少的情况，垃圾回收线程就占比较大，影响执行速度。 </p>
<p> d.使用场景：适用于<strong>强交互</strong>的应用。 </p>
<p> e.参数设置： </p>
<p> 1.-XX:+UseConcMarkSweepGC:设置使用CMS垃圾收集器； </p>
<p> 2.-XX:CMSinitialingOccupanyFraction:设置堆内存使用率阈值；jdk5,默认为68%；jdk6.默认为92%。 </p>
<p> 3.-XX:ParallelCMSThreads：设置CMS的线程数量 </p>
<p> f.面试题： </p>
<p>  <strong>1.为什么说CMS是一款低延时的垃圾回收器？</strong> </p>
<p> 因为在初始标记阶段和重新标记阶段，会发生STW，但是此部分时间很短，而在并发标记和并发清除阶段，虽然占据的时间比较长，但是在此期间，垃圾回收线程和用户线程并发执行，因此为低延时垃圾回收器 </p>
<p>  <strong>2.CMS会产生内存碎片化问题，为什么不用标记整理<a href="">算法</a>呢？</strong> </p>
<p> 因为CMS在并发标记和并发清除阶段，用户线程和垃圾回收线程并发执行，而标记整理<a href="">算法</a>中存在对象在内存中的定向移动，用户线程在执行过程中，如果发生移动，会造成安全问题。因此无法采用标记-整理<a href="">算法</a>。 </p>
<h3 id="⑧G1垃圾回收器"><a href="#⑧G1垃圾回收器" class="headerlink" title="⑧G1垃圾回收器"></a>⑧G1垃圾回收器</h3><p> a.概述： </p>
<p> 1.目标是在停顿时间可控的情况下尽可能的提高吞吐量的垃圾收集器 </p>
<p>  <strong>2.将整个堆内存分为多个region区，跟踪各个Region区的垃圾堆积的价值大小，然后后台维护一个优先级列表，每次根据允许的收集时间，优先回收价值大的region.</strong> </p>
<p>  <strong>3.基于复制<a href="">算法</a>和标记-整理<a href="">算法</a>的并行垃圾回收器，为jdk9之后默认的垃圾回收器。</strong> </p>
<p> b.回收过程（整体）： </p>
<p> 整体分为：年轻代GC（Young GC）,并发标记老年代，混合回收过程，如果G1失效，Full GC作为后备机制 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096241530_1595925903146-5f2453e5-cacf-4d99-97f5-30eeeec2896d.png" alt="39b257487f171a62cb0b2a902437910.png">当伊甸园区满之后，开始进行年轻代回收，移动存活对象到Sur<a href="">vivo</a>r区或者Old区； </p>
<p> 当堆内存到达一定阈值（默认45%）时，启动并发标记老年代； </p>
<p> 并发标记结束后，进行混合回收，收集老年代时，一次只需回收一部分老年代对象，（因为存在时间限制）。 </p>
<p> c.优缺点： </p>
<p> 优点： </p>
<p>  <strong>1.并发与并行</strong> </p>
<p>  <strong>并行性</strong>：在G1垃圾回收期间，可以有多条垃圾回收线程同时进行回收，有效利用多核计算能力。 </p>
<p>  <strong>并发性</strong>：在G1并发标记阶段，允许垃圾收集线程和用户线程并发执行。 </p>
<p>  <strong>2.分代收集</strong> </p>
<p>  <strong>G1同时兼顾了年轻代和老年代</strong>。因为G1垃圾收集器将堆空间分为不同的Region区，这些区域包含了逻辑上的新生代和老年代。 </p>
<p>  <strong>3.不存在内存碎片化问题</strong> </p>
<p>  因为G1垃圾回收器以Region为基本内存回收单元，Region之间采用复制<a href="">算法</a>，但是从整体上来说，是采用标记-整理<a href="">算法</a>，因此可以避免内存碎片问题。 </p>
<p>  <strong>4.可预测的停顿时间模型（软实时）</strong> </p>
<p>  <strong>使使用者明确在一个长度为M的时间片段内，用于垃圾回收的时间不超过N</strong> </p>
<p> 主要是因为G1跟踪各个Region的垃圾堆积价值的大小，然后后台维护一个优先级列表，在有限的时间内，优先收集价值大的Region。 </p>
<p> 缺点：由于垃圾收集产生的内存占用相对大，小内存应用上性能不如CMS。 </p>
<p> d.适用场景：面向服务端的垃圾收集器，主要针对配备多核CPU和大容量内存的机器（<strong>低延时，大内存</strong>）。 </p>
<p> <strong>e.**</strong>Region相关介绍** </p>
<p> 1.大小：G1将整个堆大小分为约2048个Region，每个Region大小相同，且为2的n次幂(一般在1M-32M之间)，且在JVM的生命周期内不会改变。 </p>
<p> 2.分布：一个Region有可能属于伊甸园区，S区或者Old区。G1还在堆内存中存放了一个Humogous区,简称H区，当对象大小超过1.5倍的Region区时，将其称为大对象，放在H区。（<strong>问题：如果是1.2倍Region大的对象放在哪儿？</strong>） </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096241660_1595924574582-ef42127c-4b3e-4680-abcc-ca68b394870c.png" alt="82c8716df791031ba5fc7615a6c3612.png"> </p>
<p> 3.设置H区的原因？ </p>
<p> 原因在于，如果不设置H区，那么大的对象则会直接进入到老年代，但是如果这个对象的声明周期比较短，则会长时间存在，并且占据着较大内存，所以将其存放在H区，如果对象大于一个H区大小，则会存在在连续的H区中。如果整个H区都装不下，则会触发Full GC. </p>
<p> 4.内存分配 </p>
<p> Region区采用<strong>指针碰撞</strong>的方式进行内存分配，并且每个Region内部存在<strong>TLAB</strong>(线程本地分配缓冲区)。 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096241680_1595924916288-70f9d0c7-52e9-47d8-99f5-70dfe0a5c53b.png" alt="cd99478dc4eb68428f8c94fc37ae4bb.png"> </p>
<p> f.Remembered Set(记忆集) </p>
<p> 1.存在必要性：因为存在跨Region引用的存在，判断存活时，如果挨个遍历每个Region的话，势必造成效率降低，于是引进了记忆集。 </p>
<p> 2.原理：每个Region都有一个记忆集，当进行引用数据写入时，先判断是否存在其他Region的引用关系，如果存在的话，则将该引用关系对应的对象写入记忆集的卡表（CardTable）中，然后在GC过程中将Rset加入到GC Roots中。 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096241709_1595926767353-bfcba122-575e-429c-86bc-8c38d5b5bfaf.png" alt="f8d46f61a7e678d5c923ba5471bc5ef.png"> </p>
<p> g.回收过程（具体） </p>
<p> 1.年轻代GC（与之前讲的一样，只不过是基于分区思想） </p>
<p> JVM优先分配对象到伊甸园区，当伊甸园区满了之后，开始进行年轻代GC，然后，存活下来的对象进入到S区，当S区的对象分代年龄达到阈值后，进入到老年代中，清理过程中的<a href="">算法</a>采用复制<a href="">算法</a>。 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096241685_1595931307451-9fb33e57-fa59-412b-96ac-1bb4a9ed2067.png" alt="f1f522537de43b21e70c00dacd794fd.png"> </p>
<p> 2.标记老年代（<strong>深入理解java虚拟机中此部分为G1的收集过程</strong>） </p>
<p> ①：<strong>初始标记</strong>：只标记GC Roots直接关联到的对象，此过程需要STW； </p>
<p> ②：<strong>并发标记</strong>：从GC Root关联到的对象开始，递归遍历整个对象图，此时垃圾收集线程和用户线程并发执行 </p>
<p> ③：<strong>最终标记</strong>：由于在并发标记阶段，用户线程在执行，需要对标记结果进行修正，此时需要STW. </p>
<p> ④：<strong>筛选回收</strong>：根据用户设置停顿时间，采用复制<a href="">算法</a>进行清理（将决定回收的Region中的存活对象复制到空的Region中，然后清空旧的Region空间），此过程需要STW。 </p>
<p> 3.混合回收： </p>
<p> ⑨垃圾回收器总结 </p>
<p> <img src="https://uploadfiles.nowcoder.com/files/20201111/849965361_1605096242007_1595929229402-e808dabf-7309-4aea-883a-a386efeeb271.png" alt="5155a2a511700fe398f8aded4ce4b40.png"> </p>
<p> ⑩如何选择垃圾回收器 </p>
<p>  <strong>a.优先调整堆的大小，让JVM能够适应；</strong> </p>
<p>  <strong>b.如果是内存比较小，选择Serial +Serial Old垃圾回收器；</strong> </p>
<p>  <strong>c.如果是单核，没有停顿时间要求，**</strong>选择Serial +Serial Old垃圾回收器；** </p>
<p>  <strong>d.如果是多核CPU,需要高吞吐量，并且停顿时间不长，选择Parallel+Parallel Old垃圾回收器；</strong> </p>
<p>  <strong>e.如果是多核CPU,低停顿时间</strong> </p>
<p>  <strong>如果是jdk14以前，则可以选用ParNew+CMS或者G1;jdk14后，选择G1；</strong> </p>
<h1 id="六、补充面试题总结"><a href="#六、补充面试题总结" class="headerlink" title="六、补充面试题总结"></a>六、补充面试题总结</h1><h2 id="1-JVM调优"><a href="#1-JVM调优" class="headerlink" title="1.JVM调优"></a>1.JVM调优</h2><p> 1.调优参数 </p>
<p>  <strong>1.**</strong>设置堆区的大小** </p>
<p>  -Xms:设置初始堆大小； </p>
<p>  -Xmx:设置最大堆大小； </p>
<p>  <strong>2.**</strong>设置新生代和老年代的比例** </p>
<p>  -XX:NewRatio:设置年轻代和老年代的比例； </p>
<p>  <strong>3.设置伊甸园区和幸存者区的比例</strong> </p>
<p>  -XX：Sur<a href="">vivo</a>rRatio=n; </p>
<p>  <strong>4.**</strong>设置永久代/元空间的大小** </p>
<p>  -XX：permSize；-XX：permMax; </p>
<p>  -XX：metaSpaceSize；-XX：metaSpaceMax； </p>
<p>  <strong>5.**</strong>设置垃圾回收器** </p>
<p>  -XX：useG1GC； </p>
<p>  -XX：useCMSGC; </p>
<p>  <strong>6.打印相关日志</strong> </p>
<p>  -XX：+printGC:打印垃圾回收 </p>
<p>  -XX：+printGCDetails:打印垃圾回收细节信息； </p>
<p> 2.调优目的 </p>
<p>  减少GC的频次和Full GC的次数 </p>
<p> 3.调优过程 </p>
<p>  a.首选需要监控GC的状态,查看当前的堆内存快照及gc日志，根据实际的各区域划分和GC执行时间，判断是否需要优化。 </p>
<p>  b.生成堆的dump文件 </p>
<p>  c.分析dump文件 </p>
<p>  可以通过eclipse的工具Memory Analyzer </p>
<p>  d.分析结果，判断是否需要优化 </p>
<p>  e.调整GC的类型和内存分配 </p>
<p>  -XX:use+垃圾回收器+GC； </p>
<p>  f.不断分析和调整参数 </p>
<h2 id="2-OOM及其解决？"><a href="#2-OOM及其解决？" class="headerlink" title="2.OOM及其解决？"></a>2.OOM及其解决？</h2><p> 1.OOM场景有哪些？ </p>
<p>  a.java堆内存溢出 </p>
<p>  原因：堆内存设置小或者内存泄露问题 </p>
<p>  解决：对于内存泄露的话，可以使用内存监控查找程序中的内存泄露的地方           加以更正； </p>
<p>​    对于堆内存设置问题，可以通过-Xms或者-Xmx来进行设置； </p>
<p>  b.方法区溢出： </p>
<p>  原因:出现大量的Class或者jsp页面，过多的常量等会导致方法区溢出; </p>
<p>  解决：可以通过设置方法区的大小来调节 </p>
<p>  -XX:Permsize；-XX：MaxPermSize设置永久代的大小； </p>
<p>  -XX：metaSpaceSize;-XX:MaxmetaSpace设置元空间的大小； </p>
<p> 2.OOM的解决方法 </p>
<p>  a.首先采用内存映像分析工具如（MAT）对dump出来的堆转储快照进行分析，确认内存中的对象是否是必要的，查明到底是内存泄露还是内存溢出 </p>
<p>  b.如果是内存泄露，可进一步通过工具查看泄露对象到GC Roots的引用链，准确定位到泄漏代码的位置； </p>
<p>  c.如果不存在泄漏的话，分析是堆内存溢出还是方法区溢出； </p>
<p>  如果是堆内存溢出，则适当调整堆的大小：通过-Xms或者-Xmx来进行设置； </p>
<p>  如果是方法区溢出，适当调整方法区的大小：通过-XX:Permsize；-XX：MaxPermSize设置永久代的大小；-XX：metaSpaceSize;-XX:MaxmetaSpace设置元空间的大小； </p>
<h2 id="3-jdk1-7和jdk1-8比较？"><a href="#3-jdk1-7和jdk1-8比较？" class="headerlink" title="3.jdk1.7和jdk1.8比较？"></a>3.jdk1.7和jdk1.8比较？</h2><p> 1.字符串放在什么位置？ </p>
<p>  均放在堆空间的字符串常量池中； </p>
<p> 2.默认的垃圾回收器？ </p>
<p>  是一样的，都是Parallel scavenge+parallel old垃圾回收器。jdk1.9之后是G1垃圾回收器。 </p>
<h2 id="4-Full-GC与Minor-GC"><a href="#4-Full-GC与Minor-GC" class="headerlink" title="4.Full GC与Minor GC"></a>4.Full GC与Minor GC</h2><p> ①Full GC触发条件 </p>
<p>  a.老年代内存被占满; </p>
<p>  b.永久代/元空间内存被占满; </p>
<p>  c.System.gc()时会显式调用Full GC; </p>
<p>  d.空间担保失败 </p>
<p>  当老年代的剩余空间小于等于S区的平均对象大小时，表示空间担保失败； </p>
<p> ②Full GC定义 </p>
<p>  完整收集整个堆和方法区的垃圾 </p>
<p> ③Minor GC </p>
<p>  定义：只发生在新生代的垃圾回收 </p>
<p> ④Minor GC触发条件 </p>
<p>  当新生代的伊甸园区满了之后，就会触发Minor GC，回收整个年轻代的垃圾； </p>
<p> ⑤Minor GC出发结果 </p>
<p>  当进行Minor GC时，会产生STW，存活的对象移动到幸存者区；</p>
<h2 id="5-垃圾回收相关"><a href="#5-垃圾回收相关" class="headerlink" title="5.垃圾回收相关"></a>5.垃圾回收相关</h2><h3 id="1-CMS和G1垃圾回收器比较"><a href="#1-CMS和G1垃圾回收器比较" class="headerlink" title="1.CMS和G1垃圾回收器比较"></a>1.CMS和G1垃圾回收器比较</h3><p>  ①CMS垃圾回收器（主打低延时） </p>
<p>  a.介绍 </p>
<p>  是hotspot虚拟机第一款并发的垃圾回收器，垃圾回收线程和用户线程可以并发执行，不需要STW，因此能够提升用户体验，降低延迟性，适合于频繁交互的场景。 </p>
<p>  b.执行过程 </p>
<p>  初始标记：仅仅标记被GC Roots直接关联到的对象，存在STW。 </p>
<p>  并发标记：从GC Roots直接关联的对象开始，遍历整个对象图的过程。此过程不需要停顿用户线程； </p>
<p>  重新标记：重新标记那些在并发标记阶段，由于用户线程的执行标记记录产生变动的对象； </p>
<p>  并发回收：采用标记-清除<a href="">算法</a>，并发清除垃圾对象  </p>
<p>  c.缺点： </p>
<p>  ①内存碎片化 </p>
<p>  产生<strong>内存碎片化</strong>问题，当老年代需要为大对象分配内存时，不得不提前触发Full GC; </p>
<p>  ②浮动垃圾 </p>
<p>  无法处理”<strong>浮动垃圾</strong>“，可能导致并发失败，从而引发Full GC </p>
<p>  浮动垃圾：因为在并发清理阶段，垃圾回收线程和用户线程并发执行，因此该  过程会产生新的垃  圾，这部分垃圾是再标记阶段之后产生的，因此这部分垃圾只能等到下一次垃圾回收时才能被回收，这个时候需要预留出一部分的内存空间。 </p>
<p>  ③对Cpu比较敏感：（核心数+3）/4 </p>
<p>  CMS默认的垃圾回收线程的数量是：（处理器核数+3）/4，对于处理器核心数较少的情况，垃圾回收线程所占的比较较大，影响运行效率。 </p>
<p>  d.使用场景 </p>
<p>  主打低延时，用于频繁交互的场景； </p>
<p>  ②G1垃圾回收器 </p>
<p>  a.概述 </p>
<p>  1.目标是在停顿时间可控的情况下，尽可能提高吞吐量的垃圾回收器 </p>
<p>  2.将整个堆内存分为多个region区域，跟踪每个Region区的垃圾堆积的价值大小，然后后台维护一个优先级列表，每次根据允许的收集时间，优先回收价值大的region； </p>
<p>  3.基于复制<a href="">算法</a>和标记整理的<a href="">算法</a>的并行垃圾回收器，为jdk1.9默认的垃圾回收器； </p>
<p>  b.G1的回收过程 </p>
<p>  ①初始标记：只标记GC Roots直接关联到的对象，此过程需要STW； </p>
<p>  ②并发标记：从GC Root直接关联到的对象开始，递归遍历整个对象图，此时垃圾回收线程和用户线程交替执行； </p>
<p>  ③最终标记：由于并发标记阶段，用于线程在执行，需要对标记结果进行修正，此时需要STW； </p>
<p>  ④<strong>筛选回收</strong>：根据用户设置停顿时间，采用复制<a href="">算法</a>进行清理（将决定回收的Region中的存活对象复制到空的region中，然后清空旧的Region空间），因为涉及到引用的变更，因此需要STW； </p>
<p>  c.G1的优点 </p>
<p>  <strong>1.并行和并发</strong> </p>
<p>  <strong>并行性</strong>：在G1垃圾回收期间，可以允许多条垃圾回收线程同时进行回收，有效利用多核计算能力； </p>
<p> 并发性：在G1并发标记阶段，允许垃圾收集线程和用户线程并发执行； </p>
<p>  <strong>2.**</strong>分代收集** </p>
<p> G1同时兼顾了老年代和新生代。因为G1垃圾收集器将堆空间分为不同的region区，这些区域包含了逻辑上的新生代和老年代。 </p>
<p>  <strong>3.**</strong>不存在内存碎片化的问题** </p>
<p> 因为G1垃圾回收器以Region为基本单元进行回收，Region之间采用的是复制<a href="">算法</a>，但是从整体上看是基于标记整理<a href="">算法</a>，因此可以避免内存碎片化的问题。 </p>
<p>  <strong>4.**</strong>可预测的停顿时间模型** </p>
<p> 使得使用者明确在一个长度为M的时间片段内，用于垃圾回收的时间不超过N；<strong>原因在于G1垃圾回收器跟踪每个region区垃圾堆积的大小，然后后台维护一个优先级列表，在规定的时间内，优先回收价值大的region区。</strong> </p>
<p>  **d.**缺点： </p>
<p>  由于<strong>垃圾收集产生的内存占用大</strong>，小内存上性能不如CMS； </p>
<p>  f.应用场景： </p>
<p>  <strong>面向服务端的垃圾收集器，适用于配备多核CPU和大容量内存的机器。</strong> </p>
<p>  <strong>③什么是垃圾</strong> </p>
<p>  <strong>对于那些没有任何引用指向的对象称之为垃圾</strong> </p>
<h3 id="2-其他垃圾回收器"><a href="#2-其他垃圾回收器" class="headerlink" title="2.其他垃圾回收器"></a>2.其他垃圾回收器</h3><p> ①serial及serial old垃圾回收器（串行回收） </p>
<p>  serial是复制<a href="">算法</a>、串行的，需要STW的针对新生代的垃圾回收器，是hs在<a href="">客户端</a>模式下默认的新生代垃圾回收器 </p>
<p> serial old是标记-整理<a href="">算法</a>，串行的，需要STW的针对老年代的垃圾回收器，是hs在<a href="">客户端</a>默认的老年代垃圾回收器 </p>
<p> 优点：因为是单线程，因此没有线程交换的开销，相对于其他垃圾回收器的单线程相比，简单而且高效 </p>
<p> ②parNew垃圾回收器（并行回收） </p>
<p> parNew是复制<a href="">算法</a>，并行回收，需要STW的针对新生代的垃圾回收器，是hs在服务端默认的新生代垃圾回收器； </p>
<p>  优点：对于新生代，回收次数频繁，比较高效； </p>
<p> ③parallel scavenge和parallel old垃圾回收器(吞吐量优先) </p>
<p>  parallel scavenge采用复制<a href="">算法</a>、并行回收，需要STW的针对新生代的垃圾回收器，注重吞吐量优先； </p>
<p>  parallel old垃圾回收器是标记整理、并行回收，需要STW的针对老年代的垃圾回收器； </p>
<p>  使用场景：高吞吐量则可以高效利用cpu的时间，来实现快速计算，主要适合于在后台运行而不需要进行太多交互的场景。 </p>
<p>  以上两种组合是jdk1.7和1.8中默认的垃圾回收器，适用于后台大量计算而不需要太多交互的场景；</p>
<h3 id="3-为什么要分代？"><a href="#3-为什么要分代？" class="headerlink" title="3.为什么要分代？"></a>3.为什么要分代？</h3><p>  因为java对象的生命周期是不同的，大部分对象的声明周期是比较短暂的，少部分对象的声明周期是比较长的，甚至是伴随着JVM的消亡而消亡，通过分为新生代和老年代两种内存区域，将声明周期短暂的对象放在新生代，将声明周期较长的对象放在老年代，在进行垃圾回收的时候，能够提高效率；如果不采用分代的话，在进行垃圾回收的时候，需要遍历整个堆空间，造成STW时间过长，影响用户体验。 </p>
<h2 id="6-内存泄漏与内存溢出问题及解决方式"><a href="#6-内存泄漏与内存溢出问题及解决方式" class="headerlink" title="6.内存泄漏与内存溢出问题及解决方式"></a>6.内存泄漏与内存溢出问题及解决方式</h2><p> 内存泄漏场景： </p>
<p> ①单例模式中，存在对其他对象的引用，这个对象已经用不到了，但是因为单例的存在没法释放该对象。 </p>
<p> ②将某些对象添加到集合中，集合中的某些对象可能已经用不到了，但是因为集合对该对象还存在引用关系，导致无法被及时回收； </p>
<h2 id="7-JVM内存结构"><a href="#7-JVM内存结构" class="headerlink" title="7.JVM内存结构"></a>7.JVM内存结构</h2><p> ①类加载子系统 </p>
<p> ②运行时数据区 </p>
<p>  a.程序计数器 </p>
<p>  1.作用：记录虚拟机字节码指令的下一条地址，当一个线程再次获得CPU执行权的时候，能够保证下一条执行从哪儿继续； </p>
<p>  b.虚拟机栈 </p>
<p>  1.作用：主管java程序的运行，虚拟机栈中存储着栈帧，对应着一个一个执行的方法，当方法执行的时候，会进行压栈操作，方法执行完后进行弹栈。 </p>
<p>  2.组成： </p>
<p>  ①局部变量表 </p>
<p>  存储方法的参数及局部变量，如果是基本数据类型，则会存储变量值，如果是引用数据类型的话，则存储的是引用地址值。 </p>
<p>  ②操作数栈 </p>
<p>  临时存储变量，作为变量计算的中间结果的临时存储区域 </p>
<p>  ③动态链接 </p>
<p>  将虚拟机栈中的符号引用转为方法区中的方法的直接引用； </p>
<p>  ④方法返回地址 </p>
<p>  存储方法的返回地址，方便调用者能够获取到方法的返回值。 </p>
<p>  3.与本地方法栈的区别： </p>
<p>  虚拟机栈负责java程序的执行；本地方法栈作用类似于虚拟机栈，负责本地方法的执行，本地方法指的的用C/C++编写的程序，作为方法的扩展库；hotSpot虚拟机将两者合二为一。 </p>
<p>  c.堆 </p>
<p>  1.作用：绝大多数的创建的对象将会存储在堆中；jdk1.7之后静态变量及字符串常量存储在堆空间中 </p>
<p>  d.方法区 </p>
<p>  1.作用：存储类信息，域信息，方法信息，常量，即时编译器的代码缓存，jdk1.6及之前存储静态变量。 </p>
<p>  e.本地方法栈 </p>
<p>  1.作用:负责本地方法的运行，本地方法指的是用C/C++编写的程序，作为方法的扩展库。 </p>
<p> ③执行引擎 </p>
<p> ④本地方法接口/本地方法库 </p>
<h2 id="8-JVM类加载过程"><a href="#8-JVM类加载过程" class="headerlink" title="8.JVM类加载过程"></a>8.JVM类加载过程</h2><p> a.加载阶段 </p>
<p>  作用： </p>
<p>  ①根据类的全限定名获取类的二进制字节流； </p>
<p>  ②将该二进制字节流所代表的静态存储结构转换为方法区的运行时的数据结构； </p>
<p>  ③在内存中生成一个代表该类的大的Class对象，作为方法区这个类的数据访问入口。 </p>
<p> b.链接阶段： </p>
<p>  1.验证： </p>
<p>  验证该二进制字节码文件是否符合虚拟机规范，确保在运行过程中不会对虚拟机造成伤害； </p>
<p>  2.准备： </p>
<p>  对类的静态变量及静态代码块进行隐式的初始化，但是有final修饰的变量会进行过显示初始化 </p>
<p>  3.解析： </p>
<p>  将常量池中的符号引用转换为直接引用 </p>
<p> c.初始化： </p>
<p>  根据程序显示初始化类的静态变量及其他资源。 </p>
<h2 id="9-类加载如何保证线程安全"><a href="#9-类加载如何保证线程安全" class="headerlink" title="9.类加载如何保证线程安全"></a>9.类加载如何保证线程安全</h2><p>  类加载器在加载类时采用的loadClass()方法使用了Synchronized关键字进行修饰。 </p>
<h2 id="10-双亲委派机制"><a href="#10-双亲委派机制" class="headerlink" title="10.双亲委派机制"></a>10.双亲委派机制</h2><p> 1.定义： </p>
<p>  当一个类需要加载时，负责加载此类的加载器不会立即对其进行加载，而是递归的委托给其父类加载，父类收到这个加载任务后也会向上进行委托，直到引导类加载器，如果引导类加载器能够加载此类，则会进行加载，如果无法实现加载此类，则会返回给其子类进行加载。 </p>
<p> 2.好处 </p>
<p>  ①：这样做可以有效地防止类被重复加载 </p>
<p>  ②：能够保护java的核心类库，放置核心的API被随意篡改 </p>
<p> 3.各个类加载器加载的类的文件名 </p>
<p> a,引导类加载器 </p>
<p>  java的<strong>核心类库</strong>都是使用引导类加载器加载的，加载的文件存放在**<JAVA_HOME> /lib**文件夹中； </p>
<p>  b.扩展类加载器 </p>
<p>  扩展类加载器负责加载**<JAVA_HOME>/lib/ext**目录中的jar文件 </p>
<p>  c.应用程序类加载器 </p>
<p>  应用程序类加载器加载的是<strong>用户类路径上的类库</strong> </p>
<h2 id="11-垃圾回收算法"><a href="#11-垃圾回收算法" class="headerlink" title="11.垃圾回收算法"></a>11.垃圾回收<a href="">算法</a></h2><p> 1.标记-清除<a href="">算法</a> </p>
<p>  a.<a href="">算法</a>概述 </p>
<p>  当进行垃圾回收时，会停止整个程序（stw）,然后整个过程分为标记阶段和清除阶段 </p>
<p>  <strong>标记阶段</strong>：从引用根对象开始遍历，标记所有被引用的对象，一般在对象头中纪录为可达对象； </p>
<p>  <strong>清除阶段</strong>：对堆内存从头到尾遍历，如果发现某个对象的对象头没有被标记为可达对象，则进行回收； </p>
<p>  b.优点： </p>
<p>  最早的比较经典的<a href="">算法</a> </p>
<p>  c.缺点： </p>
<p>  ①无法解决<strong>内存碎片化</strong>的问题 </p>
<p>  ②在进行GC时，<strong>需要STW</strong>，效率不高的话，会影响用户的体验 </p>
<p>  ③因为需要遍历，所以<strong>执行效率</strong>不高 </p>
<p> 2.复制<a href="">算法</a> </p>
<p>  a.<a href="">算法</a>概述： </p>
<p>  将内存分为大小相等的两部分，每次只使用其中的一块，当进行垃圾回收时，将正在使用的内存中的存活对象复制到另一块内存空间中，然后将正在使用的内存清除，交换两内存空间，继续执行上述操作，完成垃圾回收 </p>
<p>  b.优点： </p>
<p>  ①可以解决<strong>内存碎片化</strong>的问题； </p>
<p>  ②执行效率高，<strong>省去了清除阶段的遍历过程</strong>； </p>
<p>  c.缺点： </p>
<p>  ①内存<strong>空间利用率不高</strong>，因为总是需要一块空的内存； </p>
<p>  ②对于G1这种多个region的垃圾回收器来说，复制并且移动意味着需要维持多个region间的引用关系，<strong>时间和空间消耗比较大</strong>。 </p>
<p>  d.适用场景：比较适合于垃圾对象较多，存活对象较少的区域；新生代中得S区；不适合老年代中的垃圾回收 </p>
<p> 3.标记-整理<a href="">算法</a> </p>
<p>  a.<a href="">算法</a>概述 </p>
<p>  标记阶段与标记-清除<a href="">算法</a>中的标记阶段是一样的 </p>
<p>  整理阶段：将所有存活的对象移动到内存一侧，按顺序存放，然后清除边界以外的内存空间。 </p>
<p>  b.优点： </p>
<p>  ①解决内存碎片化的问题； </p>
<p>  ②空间利用率更高 </p>
<p>  c.缺点： </p>
<p>  ①整理过程中需要移动对象，如果对象被其他对象所引用，需要不断调整引用地址； </p>
<p>  ②效率相对另外两种<a href="">算法</a>较低 </p>
<p>  d.适用场景： </p>
<p>  适用于<strong>老年代</strong>的垃圾回收。 </p>
<h2 id="12-如何选择垃圾回收器"><a href="#12-如何选择垃圾回收器" class="headerlink" title="12.如何选择垃圾回收器"></a>12.如何选择垃圾回收器</h2><p>  **a.**优先调整堆的大小，让jvm能够适应；</p>
<p>  **b.**如果是内存比较小，选择serial+serial Old垃圾回收器</p>
<p>  **c.**如果是单核，没有停顿时间要求，选择serial+serial Old垃圾回收器</p>
<p>  **d.**如果是多核CPU,需要高的吞吐量，选择parallel scanvenge+parallel Old垃圾回收器；</p>
<p>  **e.**如果是多核cpu,低停顿时间</p>
<p>  如果是jdk14以前，可以选用CMS+ParNew；jdk14后，G1垃圾回收器 </p>
<h2 id="13-对象的内存分配策略"><a href="#13-对象的内存分配策略" class="headerlink" title="13.对象的内存分配策略"></a>13.对象的内存分配策略</h2><p>  a.优先分配到新生代 </p>
<p>  b.大对象直接分配在老年代 </p>
<p>  c.长期存活的对象（新生代中的S区的对象年龄达到了设定的阈值）分配到老年代； </p>
<p>  d.动态判断对象年龄：如果相同年龄的对象所占的空间大于等于S区的一半，则大于等于该年龄的对象则会被分配到老年代中。 </p>
<h2 id="14-垃圾判定方法"><a href="#14-垃圾判定方法" class="headerlink" title="14.垃圾判定方法"></a>14.垃圾判定方法</h2><p> a.引用计数<a href="">算法</a>（python中采用） </p>
<p>  ①概述 </p>
<p>  每个对象都有一个引用计数器，对象每增加一次引用，计数器的值就增加1，没减少一次引用，则计数器就-1，当引用计数器的值为0时，判定为对象不存在引用，即认为是垃圾。 </p>
<p>  ②<a href="">算法</a>的优/缺点 </p>
<p>  优点：实现简单，执行效率高； </p>
<p>  缺点： </p>
<p>  1.最大的缺点是不能够解决循环引用问题，如果几个对象存在循环引用，但是这几个对象已经没有其他引用指向他们，但是因为其相互引用，则引用计数器的值也不为零，因此会造成内存泄露的问题。 </p>
<p>  2.因为是计数器，所以也占用一定的空间开销。 </p>
<p> b,可达性分析<a href="">算法</a>（java采用） </p>
<p>  ①概述 </p>
<p>  可达性分析<a href="">算法</a>的思想为：首先说一下GC Roots,一组活跃引用的跟对象集合，以跟对象为起始点，从上向下搜索被根对象所连接的目标是否可达，内存中对象都直接或者间接的与根对象相连，搜索所走过的路径称为引用链，没有被引用链所连接的对象即为不可达，即被判定为垃圾。 </p>
<p>  ②<a href="">算法</a>优/缺点 </p>
<p>  优点：可以解决循环引用的问题 </p>
<p>  缺点：相较于引用计数<a href="">算法</a>而言，判定效率低一些。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2020/10/14/0000.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="内核态和用户态"><a href="#内核态和用户态" class="headerlink" title="内核态和用户态"></a>内核态和用户态</h2><p>内核态：运行内核程序，可以执行特权指令</p>
<p>用户态：运行用户程序，只能运行非特权指令</p>
<h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><p>进程：是程序的一次执行，是系统进行资源分配的最小单位，有自己独立的地址空间，包含至少一个线程</p>
<p>线程：是执行CPU调度的最小单位，同一个进程中的线程可以共享进程中的资源</p>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>协程是一个特殊的函数，这个函数可以在某个地方挂起，也可以在挂起处外继续运行。所以说，协程与进程、线程相比并不是一个维度的概念。</p>
<p>协程由程序所控制，在用户态执行，不被操作系统内核所管理。这样带来的好处是性能大幅度的提升，因为不会像线程切换那样消耗资源。</p>
<p>一个进程可以包含多个线程，一个线程也可以包含多个协程。</p>
<p>如果是多核CPU，多个进程或一个进程内的多个线程是可以并行运行的，但是一个线程内协程却绝对是串行的，无论CPU有多少个核。</p>
<p>当一个协程运行时，其它协程必须挂起。</p>
<h2 id="进程、线程、协程的对比"><a href="#进程、线程、协程的对比" class="headerlink" title="进程、线程、协程的对比"></a>进程、线程、协程的对比</h2><ul>
<li>协程既不是进程也不是线程，协程仅仅是一个特殊的函数，协程它进程和进程不是一个维度的。</li>
<li>一个进程可以包含多个线程，一个线程可以包含多个协程。</li>
<li>一个线程内的多个协程虽然可以切换，但是多个协程是串行执行的，只能在一个线程内运行，没法利用CPU多核能力。</li>
<li>协程与进程一样，切换是存在上下文切换问题的。</li>
</ul>
<blockquote>
<p>进程的切换者是操作系统</p>
<p>线程的切换者是操作系统</p>
<p>协程的切换这是用户（编程者或应用程序）</p>
</blockquote>
<h2 id="进程线程的几种状态以及转换"><a href="#进程线程的几种状态以及转换" class="headerlink" title="进程线程的几种状态以及转换"></a>进程线程的几种状态以及转换</h2><p>新建 、运行、死亡、阻塞、等待、限时等待</p>
<h2 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h2><ol>
<li>管道(PIPE)：管道是一种半双工的通信方式，数据只能单向流动，并且只能在具有亲缘关系的进程间使用（亲缘关系一般指：父子进程关系）</li>
<li>命名管道(FIFO)：命名管道也是一种半双工的通信方式，但是允许无亲缘关系进程间的通讯</li>
<li>信号(Signal)：一个进程向另一个进程发送信号，通知 接收线程某个事件已经发生。主要作为不同进程或者同一进程不同线程之间的同步手段</li>
<li>信号量(Semaphore)：信号量是一个计数器，可以控制多个进程对共享资源的访问。通常作为一种锁机制，防止一个进程访问共享资源时，另一个进程也访问该资源</li>
<li>消息队列(MessageQueue)：消息队列是消息的链表，存放在内核中。一个消息队列由标识符（队列ID）来标识。消息队列克服了 信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点</li>
<li>共享内存(Shared Memry)：两个或多个进程共享一个给定的内存区域。每个进程访问内存的时候有一个虚拟内存地址和物理内存地址的映射，一般两个进程的虚拟内存地址可以是一样的，但映射的物理地址内存一般是不一样的。共享内存就是让他们的物理内存地址也是一样的，这样的话两个进程就可以访问相同的物理内存了，借助这块物理内存就可以实现通信了</li>
</ol>
<blockquote>
<p>特点：</p>
<ul>
<li>共享内存是最快的一种，因为进程是直接对内存进行存取的</li>
<li>因为多个进程同时操作，所以需要进行同步</li>
<li>信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问</li>
</ul>
</blockquote>
<ol>
<li><p>套接字(Socket)：可以用于本机内的进程通信，也可以用于不同机器间的进程通信。</p>
</li>
<li><ol>
<li><ol>
<li>本机访问数据库：Linux 底层套接字<ol start="2">
<li>远程访问数据库：TCP 套接字</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><strong>区别：</strong></p>
<ol>
<li>管道：速度慢，容量有限，只有父子进程能通讯</li>
<li>FIFO：速度慢，任何进程间都能通讯</li>
<li>消息队列：容量受系统限制，且要注意第一次读的时候，要考虑上一次有没有读完数据的问题</li>
<li>信号量：只能用来进行同步，不能用来传递复杂消息</li>
<li>共享内存：容量容易控制，速度快，但要保持同步</li>
</ol>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>提供系统性的服务，比如：垃圾回收线程、JIT线程</p>
<h2 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h2><p><strong>概念：</strong>父进程创建一个子进程，子进程退出后，父进程没有调用 <strong>wait</strong> 或 <strong>waitpid</strong> 获取子进程的<strong>状态信息</strong>，那么子进程的<strong>状态描述符</strong>仍然保存在系统中</p>
<p><strong>危害：</strong>不调用 wait 或者 waitpid，保留的信息不会被释放，进程号会被一直占用，但是系统的进程号是有限的，如果有大量的僵尸进程，系统会因为没有进程号而无法创建新的进程</p>
<h2 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h2><p><strong>概念：</strong>父进程退出，而它的子进程仍然在执行，那么子进程就会成为孤儿进程</p>
<p><strong>无危害：</strong>孤儿进程被 init 进程（进程号为1）所收养，并由 init 进程对它们完成状态收集工作</p>
<h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><ul>
<li>先来先服务：按照进程到达的先后顺序进行服务</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1200640/1586009730593-9f07911d-853a-4762-af3f-23248d3d87f6.png" alt="image.png"></p>
<ul>
<li>短作业优先：要求服务时间最短的进程先得到服务</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1200640/1586009834930-b97983d4-b149-48bc-8eb2-64424ff8e27a.png" alt="image.png"></p>
<ul>
<li>高响应比优先：每次调度时先计算各个进程响应比，响应比高的进程优先得到服务</li>
</ul>
<blockquote>
<p>响应比=（等待时间+要求服务时间）/要求服务时间</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1200640/1586010004686-c5ae2b98-91cd-45a5-be2b-2ccccfc2dd85.png" alt="image.png"></p>
<ul>
<li>时间片轮转：按照进程到达就绪队列的顺序，轮流让各个进程执行一个时间片。若进程未在一个时间片内执行完，则剥夺处理机，将进程放入就绪队列的队尾重新排队。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1200640/1586010210447-ce5c646f-358c-43d3-b3de-417e92c93f23.png" alt="image.png"></p>
<ul>
<li>优先级调度算法：调度时选择优先级最高的进程</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1200640/1586010562142-4f368109-f23d-4865-8a9e-0f7afb10334d.png" alt="image.png"></p>
<ul>
<li>多级反馈队列算法</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1200640/1586010596676-76b660ae-8b76-4d47-86a5-860075b0c7a4.png" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1200640/1586010046562-73847f6e-e2a4-47b3-9656-b4c54f3cbdb5.png" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1200640/1586010615274-122c43a9-c69e-489e-b9d7-feecabbb4944.png" alt="image.png"></p>
<p><a href="https://www.yuque.com/office/yuque/0/2020/pdf/1200640/1586011092123-79578b24-8928-4bf8-8b11-3728ae463f5d.pdf?from=https://www.yuque.com/qianyi-cjurz/gihu7p/zvl8gg">2.2_4_调度算法：先来先服务、最短作业优先、最高响应比优先.pdf</a></p>
<p><a href="https://www.yuque.com/office/yuque/0/2020/pdf/1200640/1586011142686-87b26097-3749-4b49-ab13-e54e567f1c41.pdf?from=https://www.yuque.com/qianyi-cjurz/gihu7p/zvl8gg">2.2_5_调度算法：时间片轮转、优先级、多级反馈队列.pdf</a></p>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><blockquote>
<ul>
<li>时间局部性：如果访问了程序的某条指令或者数据，那么在未来一段时间内，这条指令或者数据有可能被再次访问（程序中有大量的循环）</li>
<li>空间局部性：如果程序访问了某个存储单元，那么在未来一段时间内，附近的存储单元也有可能被访问（因为很多数据和指令在内存中是顺序存放的）</li>
</ul>
</blockquote>
<ul>
<li>在程序装入内存时，将未来一段时间内会用到的部分装入内存，暂时用不到的留在外存</li>
<li>在程序执行过程中，若需要的信息不再内存中，就把所需的信息从外存调入内存</li>
<li>若内存空间不够，就将内存中暂时不用的信息换出到外存</li>
</ul>
<p>在用户看来，似乎是一个比实际内存大得多的内存，就叫虚拟内存</p>
<h2 id="缓存的置换方式"><a href="#缓存的置换方式" class="headerlink" title="缓存的置换方式"></a>缓存的置换方式</h2><p>最佳置换（OPT）：每次选择淘汰的页面将是以后永远或者最长时间内不再被访问的页面</p>
<p>先进先出（FIFO）：每次选择淘汰的页面是最早进入内存的页面</p>
<p>最近最久未使用（LRU）：每次淘汰的页面是最近最久未使用的页面</p>
<h2 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h2><p>多个进程，都拥有其它进程需要的资源，又需要别人拥有的资源，但自己不释放资源，同时又申请其它资源，形成了循环等待链，这就是死锁</p>
<h2 id="死锁发生的条件"><a href="#死锁发生的条件" class="headerlink" title="死锁发生的条件"></a>死锁发生的条件</h2><ul>
<li>互斥条件：对互斥资源的抢夺才会导致死锁</li>
<li>请求和保持条件：进程保持着某些资源不释放，同时申请其它资源</li>
<li>不剥夺条件：进程保持的资源只能主动释放，不能强行剥夺</li>
<li>循环等待条件：存在着某种资源的循环等待链</li>
</ul>
<h2 id="死锁的预防、避免和解决"><a href="#死锁的预防、避免和解决" class="headerlink" title="死锁的预防、避免和解决"></a>死锁的预防、避免和解决</h2><ul>
<li><p>死锁的预防：设置某些限制条件，死锁的四个发生条件中，破坏其中之一即可</p>
</li>
<li><p>死锁的避免：在资源的动态分配过程中，用某种方法防止系统进入某种不安全状态（例如：银行家算法）</p>
</li>
<li><p>死锁的解决：</p>
</li>
<li><ul>
<li>资源剥夺法：挂起某些死锁进程并抢夺它的资源，以便让其它进程继续推进<ul>
<li>撤销进程法：强制撤销部分或者全部死锁进程，并剥夺它们的资源</li>
<li>进程回退法：让进程主动释放某些资源，回退到避免死锁的地步</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Linux中的五种IO模型"><a href="#Linux中的五种IO模型" class="headerlink" title="Linux中的五种IO模型"></a>Linux中的五种IO模型</h2><p>BIO</p>
<p>NIO</p>
<p>多路复用IO</p>
<p>信号量</p>
<p>AIO</p>
<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h2><ol>
<li>并发</li>
</ol>
<ul>
<li><ul>
<li>并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。</li>
<li>并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。</li>
<li>操作系统通过引入进程和线程，使得程序能够并发运行。</li>
</ul>
</li>
</ul>
<ol>
<li>共享</li>
</ol>
<ul>
<li><ul>
<li>共享是指系统中的资源可以被多个并发进程共同使用。</li>
<li>有两种共享方式：互斥共享和同时共享。</li>
<li>互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。</li>
</ul>
</li>
</ul>
<ol>
<li>虚拟</li>
</ol>
<ul>
<li><ul>
<li>虚拟技术把一个物理实体转换为多个逻辑实体。</li>
<li>主要有两种虚拟技术：时分复用技术和空分复用技术。</li>
<li>多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</li>
<li><strong>虚拟内存使用了空分复用技术，它**</strong>将物理内存抽象为地址空间**<strong>，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存**</strong>中。**</li>
</ul>
</li>
</ul>
<ol>
<li>异步</li>
</ol>
<ul>
<li><ul>
<li>异步指进程不是一次性执行完毕</li>
</ul>
</li>
</ul>
<h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><ol>
<li>进程管理</li>
</ol>
<ul>
<li><ul>
<li>进程控制、进程同步、进程通信、死锁处理、处理机调度等。</li>
</ul>
</li>
</ul>
<ol>
<li>内存管理</li>
</ol>
<ul>
<li><ul>
<li>内存分配、地址映射、内存保护与共享、虚拟内存等。</li>
</ul>
</li>
</ul>
<ol>
<li>文件管理</li>
</ol>
<ul>
<li><ul>
<li>文件存储空间的管理、目录管理、文件读写管理和保护等。</li>
</ul>
</li>
</ul>
<ol>
<li>设备管理</li>
</ol>
<ul>
<li><ul>
<li>完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。</li>
<li>主要包括缓冲管理、设备分配、设备处理、虛拟设备等。</li>
</ul>
</li>
</ul>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><ul>
<li><p>如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成</p>
</li>
<li><p>凡是与资源有关的操作（存储分配、I/O、管理文件等），都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成</p>
</li>
<li><p>用户程序执行陷入指令（trap指令）发起系统请求，将CPU使用权主动交给操作系统内核，即CPU状态会从用户态进入内核态</p>
</li>
<li><p>操作系统处理完系统调用的请求后，又会把CPU使用权还给用户程序，即CPU状态会从内核态回到用户态</p>
</li>
<li><p>目的：用户程序不能直接执行对系统影响非常大的操作，保证系统的稳定性和安全性，防止用户程序随意更改或访问重要的系统资源，影响其他进程的运行</p>
</li>
<li><p>PS：从用户态到内核态，不仅状态需要切换，而且所用的堆栈也可能需要从用户堆栈切换为系统堆栈（系统堆栈也属于该进程）</p>
</li>
<li><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1599652312538-4fc8bac8-3c3a-44b5-90b0-c8b954c72099.png" alt="image.png"></p>
</li>
<li><p>系统调用可以分为如下几类：</p>
</li>
<li><ul>
<li>设备管理：完成设备的请求和释放，以及设备启动等功能</li>
<li>文件管理：完成文件的读、写、创建及删除等功能</li>
<li>进程控制：完成进程的撞见、撤销、阻塞及唤醒等功能</li>
<li>进程通信：完成进程之间的消息传递或信号传递等功能</li>
<li>内存管理：完成内存的分配、回收以及获取作业占用内存大小及初始地址等功能</li>
</ul>
</li>
<li><p>Linux 的系统调用主要有以下这些：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Task</th>
<th>Commands</th>
</tr>
</thead>
<tbody><tr>
<td>进程控制</td>
<td>fork(); exit(); wait();</td>
</tr>
<tr>
<td>进程通信</td>
<td>pipe(); shmget(); mmap();</td>
</tr>
<tr>
<td>文件操作</td>
<td>open(); read(); write();</td>
</tr>
<tr>
<td>设备操作</td>
<td>ioctl(); read(); write();</td>
</tr>
<tr>
<td>信息维护</td>
<td>getpid(); alarm(); sleep();</td>
</tr>
<tr>
<td>安全</td>
<td>chmod(); umask(); chown();</td>
</tr>
</tbody></table>
<h2 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1599632380372-38516e83-b1a9-4e9e-bdd0-dec85fe803ee.png" alt="image.png"></p>
<ol>
<li><strong>中断(也称外中断)</strong></li>
</ol>
<ul>
<li><ul>
<li>由 CPU 执行指令以外的事件引起,即与处理器运行的程序无关</li>
<li>I/O 中断:表示设备输入/输出处理已经完成，希望处理器能够发送下一个输入/输出请求,同时让完成输入/输出的程序继续运行</li>
<li>时钟中断:表示一个固定的时间片已到,让处理器处理定时运行的任务</li>
</ul>
</li>
</ul>
<ol>
<li><strong>异常(也称内中断)</strong></li>
</ol>
<ul>
<li><ul>
<li>由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等</li>
</ul>
</li>
<li><p>硬中断/软中断</p>
</li>
<li><ul>
<li>Linux 将中断处理过程分成了两个阶段，也就是上半部和下半部</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>上半部用来快速处理中断，它在中断禁止模式下运行，主要处理跟硬件紧密相关的或时间敏感的工作</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>网卡接收到数据包后，会通过硬件中断的方式，通知内核有新的数据到了。这时，内核就应该调用中断处理程序来响应它</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>下半部用来延迟处理上半部未完成的工作，通常以内核线程的方式运行</li>
<li>网卡接收到数据包后，会通过硬件中断的方式，通知内核有新的数据到了。这时，内核就应该调用中断处理程序来响应它</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>上半部:把网卡的数据读到内存中，然后更新一下硬件寄存器的状态（表示数据已经读好了），最后再发送一个软中断信号，通知下半部做进一步的处理</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li><ul>
<li>上半部直接处理硬件请求，也就是我们常说的硬中断，特点是快速执行</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>下半部:下半部被软中断信号唤醒后，需要从内存中找到网络数据，再按照网络协议栈，对数据进行逐层解析和处理，直到把它送给应用程序</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li><ul>
<li>下半部则是由内核触发，也就是我们常说的软中断，特点是延迟执行</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>硬中断：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>硬中断是由硬件产生的，比如，像磁盘，网卡，键盘，时钟等。每个设备或设备集都有它自己的IRQ（中断请求）</li>
<li>当中断产生的时候，CPU会中断当前正在运行的任务，来处理中断。在有多核心的系统上，一个中断通常只能中断一颗CPU</li>
<li>硬中断可以直接中断CPU。它会引起内核中相关的代码被触发。对于那些需要花费一些时间去处理的进程</li>
<li>对于时钟中断，内核调度代码会将当前正在运行的进程挂起，从而让其他的进程来运行。它的存在是为了让调度代码（或称为调度器）可以调度多任务。</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>软中断：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>软中断是利用硬件中断的概念，用软件方式进行模拟，实现宏观上的异步执行效果。很多情况下，软中断和”信号”有些类似，同时，软中断又是和硬中断相对应的，”硬中断是外部设备对CPU的中断”，”软中断通常是硬中断服务程序对内核的中断”，”信号则是由内核（或其他进程）对某个进程的中断”</li>
<li>软中断是实现系统API函数调用的手段</li>
<li>通常，软中断是一些对I/O的请求。这些请求会调用内核中可以调度I/O发生的程序。</li>
<li>软中断仅与内核相联系。而内核主要负责对需要运行的任何其他的进程进行调度</li>
<li>软中断并不会直接中断CPU。也只有当前正在运行的代码（或进程）才会产生软中断。这种中断是一种需要内核为正在运行的进程去做一些事情（通常为I/O）的请求。有一个特殊的软中断是Yield调用，它的作用是请求内核调度器去查看是否有一些其他的进程可以运行。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="中断处理的流程"><a href="#中断处理的流程" class="headerlink" title="中断处理的流程"></a>中断处理的流程</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1599633797251-4db4b86b-e2f1-47d2-820a-8354145a1cf4.png" alt="image.png"></p>
<ul>
<li>1<del>3步在CPU进入中断周期后，由硬件自动完成，4</del>9步由中断服务程序完成</li>
<li>恢复现场指在中断返回前，必须将寄存器的内容恢复到中断处理前的状态，由中断服务程序完成</li>
</ul>
<ol>
<li>关中断</li>
</ol>
<ul>
<li><ul>
<li>CPU关闭响应更高级中断源的中断请求,否则现场保存不完整</li>
</ul>
</li>
</ul>
<ol>
<li>保存断点</li>
</ol>
<ul>
<li><ul>
<li>将原来程序的程序计数器PC保存起来</li>
</ul>
</li>
</ul>
<ol>
<li>引出中断服务程序</li>
</ol>
<ul>
<li><ul>
<li>取出中断服务程序的入口地址，送去程序技术去PC中</li>
</ul>
</li>
</ul>
<ol>
<li>保存线程和屏蔽字</li>
</ol>
<ul>
<li><ul>
<li>进入中断程序后，首先保存现场信息：程序状态字寄存器PSWR和某些通用寄存器内容</li>
</ul>
</li>
</ul>
<ol>
<li>开中断</li>
</ol>
<ul>
<li><ul>
<li>允许更高级别中断请求得到响应</li>
</ul>
</li>
</ul>
<ol>
<li>执行中断服务程序</li>
</ol>
<ul>
<li><ul>
<li>中断请求的目的就是执行中断服务程序</li>
</ul>
</li>
</ul>
<ol>
<li>关中断</li>
</ol>
<ul>
<li><ul>
<li>保证在恢复线程和屏蔽字时不被中断</li>
</ul>
</li>
</ul>
<ol>
<li>恢复现场和屏蔽字</li>
</ol>
<ul>
<li><ul>
<li>将现场和屏蔽字恢复到原来的状态</li>
</ul>
</li>
</ul>
<ol>
<li>开中断、中断返回</li>
</ol>
<ul>
<li><ul>
<li>中断服务程序的最后一条指令通常是中断返回指令，时期返回原程序断点处，以便继续执行原程序</li>
</ul>
</li>
</ul>
<h2 id="用户态-内核态"><a href="#用户态-内核态" class="headerlink" title="用户态/内核态"></a>用户态/内核态</h2><ul>
<li><p>操作系统为什么分为用户态和内核态：</p>
</li>
<li><ul>
<li>在CPU的所有指令中，有一些指令是非常危险的，如果错用，将导致整个系统崩溃，比如：清内存、设置时钟等</li>
<li>CPU将指令分为特权指令和非特权指令，特权指令只能由内核态运行</li>
</ul>
</li>
<li><p>从用户空间到内核空间有两种触发手段</p>
</li>
<li><ul>
<li>用户空间的应用程序，通过<strong>系统调用</strong>，进入内核空间</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>这个时候用户空间的进程要传递很多变量、参数的值给内核，内核态运行的时候也要保存用户进程的一些寄存器值、变量等</li>
<li>所谓的“进程上下文”，可以看作是用户进程传递给内核的这些参数以及内核要保存的那一整套的变量和寄存器值和当时的环境等</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>硬件通过触发信号，导致内核调用<strong>中断</strong>处理程序，进入内核空间</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>这个过程中，硬件的一些变量和参数也要传递给内核，内核通过这些参数进行中断处理</li>
<li>所谓的“中断上下文”，其实也可以看作就是硬件传递过来的这些参数和内核需要保存的一些其他环境（主要是当前被打断执行的进程环境）</li>
</ul>
</li>
</ul>
</li>
<li><p>用户态和内核态的关系：</p>
</li>
<li><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1598182666276-405e7713-ed1d-457b-a7bb-30e93af83ba8.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image.png"></li>
</ul>
</li>
</ul>
<h1 id="二、进程管理"><a href="#二、进程管理" class="headerlink" title="二、进程管理"></a>二、进程管理</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><ul>
<li><p><strong>进程是资源分配的基本单位</strong></p>
</li>
<li><p>进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。</p>
</li>
<li><p>进程的上下文包含的内容：</p>
</li>
<li><ul>
<li>内存中的程序代码和数据、寄存器内容、程序计数器、环境变量、打开文件的描述符集合</li>
</ul>
</li>
<li><p>程序段+相关数据段+PCB构成了进程实体</p>
</li>
<li><p><strong>进程的创建（创建原语）：</strong></p>
</li>
<li><ul>
<li>申请一个空白的PCB，每个进程有唯一的进程标识号</li>
<li>为进程分配资源，为新进程的程序和数据以及用户栈分配必要的内存空间</li>
<li>初始化PCB，包括初始化标志信息、初始化处理器状态信息和初始化处理器控制信息，已经设置进程的优先级等</li>
<li>最后把该进程转入就绪态，插入就绪队列，等待被调度</li>
</ul>
</li>
<li><p><strong>进程的终止（撤销原语）：</strong></p>
</li>
<li><ul>
<li>根据被终止进程的标识符，检索PCB，从中读出该进程的状态</li>
<li>若被终止的进程处于执行状态，立即终止该进程的执行，将处理器资源分配给其他进程</li>
<li>若该进程有子进程，则将所有子进程终止</li>
<li>将该进程所拥有的全部资源，归还给父进程，或归还给操作系统</li>
<li>将该PCB从队列（链表）中删除</li>
</ul>
</li>
<li><p><strong>进程的阻塞和唤醒</strong></p>
</li>
<li><ul>
<li>正在执行的进程，由于请求系统资源失败、等待某种操作等，无新工作可做，则系统自动执行阻塞原语（Block），使自己由运行态变为阻塞态</li>
<li>进程的阻塞是进程自身的主动行为，只有处于运行态的进程才能转为阻塞态</li>
<li>当阻塞进程期待的事件发生后，如I/O操作完成，由有关进程（如，释放该I/O设备的进程，或提供数据的进程）调用唤醒原语（Wakeup），将该进程唤醒</li>
<li><strong>阻塞原语：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>找到要被阻塞进程的标识号对应的PCB</li>
<li>如果该进程为运行态，则保护其现场，将其状态转为阻塞态，停止运行</li>
<li>将该PCB插入相应事件的等待队列，将处理器资源调度给其他就绪进程</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>唤醒原语</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>在该事件的等待队列中找到相应进程的PCB</li>
<li>将其从等待队列中移出，并置为就绪态</li>
<li>将该PCB插入就绪队列，等待调度程序调度</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>进程切换</strong></p>
</li>
<li><ul>
<li>进程切换指处理器从一个进程运行转到另一个进程上，进程的运行环境产生了实质的变化，过程如下</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>保存处理器上下文，包括程序计数器和其他寄存器</li>
<li>保存PCB信息</li>
<li>把进程的PCB移入相应的队列，如就绪队列、在某个事件阻塞队列</li>
<li>选择另一个进程执行，并更新其PCB</li>
<li>更新内存管理的数据结构</li>
<li>恢复处理器上下文</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>进程切换与处理器模式切换不同</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>进程切换：</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>当前运行进程改变了，则当前进程的环境信息也需要改变</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>处理器模式切换：</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>模式切换时，处理器可能还在同一进程中运行</li>
<li>如果进程因中断或异常进入内核态运行，执行完后又回到用户态刚被中断的程序运行</li>
<li>这种情况，操作系统只需要恢复进程进入内核时所保存的CPU现场，无须改变当前进程的环境信息</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>调度和切换的区别：</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>调度：调度决定资源分配给哪个进程的行为，是一种决策行为</li>
<li>切换：切换指实际分配的行为，是执行行为</li>
<li>一般来说，先有资源的调度，然后才有进程的切换</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>进程控制块（PCB）</strong></p>
</li>
<li><ul>
<li>PCB是进程实体的一部分，是进程存在的唯一标志</li>
<li>操作系统通过PCB表管理和控制进程</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>操作系统调度某进程时，会从其PCB中查出其现行状态及优先级，根据PCB中保存的处理器状态信息，设置该进程恢复运行的现场，并根据其PCB中的程序和数据的内存起始地址，找到程序和数据</li>
<li>进程运行时，当需要和合作的进程实现同步、通信或访问文件时，也需要访问PCB</li>
<li>进程由于某种原因而暂停运行时，又需要将其断点的处理器环境保存在PCB中</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>PCB内容：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1599662589459-7e940eb5-67e2-427d-995f-2af27e689057.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image.png"></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>程序段</strong></p>
</li>
<li><ul>
<li>被进程调度程度调度到CPU执行的程序代码段，程序可被多个进程共享，即多个进程可以运行同一个程序</li>
</ul>
</li>
<li><p>数据段</p>
</li>
<li><ul>
<li>一个进程的数据段，可以实原始数据，也可以是程序执行的中间或最终结果</li>
</ul>
</li>
</ul>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul>
<li>线程是基本的CPU执行单元，也是程序执行流的最小单元，系统独立调度和分派的基本单位</li>
<li>线程由线程ID、程序计数器、寄存器集合和堆栈组成</li>
<li>进程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但是可与同属于一个进程的其他线程共享所拥有的全部资源</li>
<li>一个线程可以创建和撤销另一个线程</li>
<li>一个进程中可以有多个线程，它们共享进程资源</li>
<li>引入线程后，进程的内涵发生了改变，进程只作为除CPU外的系统资源的分配单元，而线程则作为处理器的分配单元</li>
<li>引入进程的目的是为了更好的使多程序并发执行，提高资源利用率和系统吞吐量；引入线程的目的是为了减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能</li>
<li>QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件</li>
</ul>
<h2 id="进程和线程的区别-1"><a href="#进程和线程的区别-1" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><ul>
<li><p><strong>拥有资源</strong></p>
</li>
<li><ul>
<li>进程是资源分配的基本单位，但是线程不拥有资源（除了一点必不可少的资源），线程可以访问隶属进程的系统资源</li>
<li>如果线程也拥有资源，则切换线程就需要较大的时空开销，线程的概念就没有意义了</li>
</ul>
</li>
<li><p>调度</p>
</li>
<li><ul>
<li>传统操作系统中拥有资源和独立调度的基本单位都是进程</li>
<li>引入线程后，线程是独立调度的基本单位，进程是拥有资源的基本单位</li>
<li>在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</li>
</ul>
</li>
<li><p><strong>系统开销</strong></p>
</li>
<li><ul>
<li>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。</li>
<li>类似地，在进行<strong>进程切换时</strong>，涉及当前<strong>执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置（即，Context）</strong>，而<strong>线程切换时</strong>只需<strong>保存和设置少量寄存器内容</strong>，开销很小</li>
<li>同一个进程内的多个线程共享进程的地址空间，因此这些线程间同步与通信非常容易，甚至无须操作系统的干预</li>
</ul>
</li>
<li><p>并发性：</p>
</li>
<li><ul>
<li>引入线程后，不仅进程间可以并发执行，而且多个线程之间也可以并发执行，提高了并发性和吞吐量</li>
</ul>
</li>
<li><p><strong>通信方面</strong></p>
</li>
<li><ul>
<li>进程间通信需要进程同步和互斥手段的辅助，以保证数据的一致性，而线程间通信可以直接读/写进程数据段（如全局变量）来进行通信</li>
</ul>
</li>
</ul>
<h2 id="协程-1"><a href="#协程-1" class="headerlink" title="协程"></a>协程</h2><ul>
<li><p>协程，是一种基于线程之上，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，自主开辟的异步任务，具有对内核来说不可见的特性</p>
</li>
<li><p>正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程</p>
</li>
<li><p><strong>协程的目的</strong></p>
</li>
<li><ul>
<li>当出现长时间的I/O操作时，通过让出目前的协程调度，执行下一个任务的方式，<strong>减少ContextSwitch上的开销</strong></li>
<li>传统的是，每个请求占用一个线程完成完整的业务逻辑（包括事务），所以系统的吞吐能力取决于每个线程的操作耗时</li>
<li>如果遇到很耗时的I/O行为，则整个系统的吞吐立刻下降，同时，较多的线程会带来很多的上下文切换的开销</li>
<li>由于协程的暂停完全由程序控制，发生在用户态上；而线程的阻塞状态是由操作系统内核来进行切换，发生在内核态上。因此，协程的开销远远小于线程的开销，也就没有了ContextSwitch上的开销</li>
</ul>
</li>
<li><p><strong>协程的特点</strong></p>
</li>
</ul>
<ol>
<li><ol>
<li><strong>线程的切换由操作系统负责调度，协程由用户自己进行调度，因此减少了上下文切换，提高了**</strong>效率。**</li>
<li><strong>线程的默认Stack大小是1M，而协程更轻量，接近1K。因此可以在相同的内存中开启更多的**</strong>协程。**</li>
<li>由于在同一个线程上，因此可以避免竞争关系而使用锁。</li>
<li>适用于被阻塞的，且需要大量并发的场景。但不适用于大量计算的多线程，遇到此种情况，更好用线程解决。</li>
</ol>
</li>
</ol>
<ul>
<li><p><strong>协程的原理</strong></p>
</li>
<li><ul>
<li>当出现IO阻塞的时候，由协程的调度器进行调度，通过将数据流立刻yield掉（主动让出），并且记录当前栈上的数据</li>
<li>阻塞完后立刻再通过线程恢复栈，并把阻塞的结果放到这个线程上去跑，这样看上去好像跟写同步代码没有任何差别</li>
<li>这整个流程可以称为coroutine，而跑在由coroutine负责调度的线程称为Fiber。比如Golang里的 go关键字其实就是负责开启一个Fiber，让func逻辑跑在上面</li>
</ul>
</li>
</ul>
<h2 id="协程和线程的区别"><a href="#协程和线程的区别" class="headerlink" title="协程和线程的区别"></a>协程和线程的区别</h2><table>
<thead>
<tr>
<th>比较项</th>
<th>线程</th>
<th>协程</th>
</tr>
</thead>
<tbody><tr>
<td>占用资源</td>
<td>初始单位为1MB,固定不可变</td>
<td>初始一般为 2KB，可随需要而增大</td>
</tr>
<tr>
<td>调度所属</td>
<td>由 OS 的内核完成</td>
<td>由用户完成</td>
</tr>
<tr>
<td>切换开销</td>
<td>涉及模式切换(从用户态切换到内核态)、16个寄存器、PC、SP…等寄存器的刷新等</td>
<td>只有三个寄存器的值修改 - PC / SP / DX.</td>
</tr>
<tr>
<td>性能问题</td>
<td>资源占用太高，频繁创建销毁会带来严重的性能问题</td>
<td>资源占用小,不会带来严重的性能问题</td>
</tr>
<tr>
<td>数据同步</td>
<td>需要用锁等机制确保数据的一直性和可见性</td>
<td>不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</td>
</tr>
</tbody></table>
<h2 id="进程状态的切换"><a href="#进程状态的切换" class="headerlink" title="进程状态的切换"></a>进程状态的切换</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1599655539465-7c6412b9-cf1c-41eb-98c2-631439893c16.png" alt="image.png"></p>
<ul>
<li>就绪状态（ready）：进程获取了除处理器以外的一切所需资源，等待被调度，多个处于就绪状态的进程拍成就绪队列</li>
<li>运行状态（running）：进程正在处理器上运行</li>
<li>阻塞状态（waiting）：等待某资源为可用</li>
<li>创建态（created）：进程正在被创建，尚未转到就绪态</li>
<li>结束态（terminated）：进程正从系统消失，可能是进程正常结束或其他原因中断退出运行</li>
</ul>
<p>应该注意以下内容：</p>
<ul>
<li>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li>
<li>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</li>
</ul>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><h3 id="调度与切换"><a href="#调度与切换" class="headerlink" title="调度与切换"></a>调度与切换</h3><ul>
<li><p>调度：从就绪队列中按照一定的算法选择一个进程并将处理器分配给它运行，以实现进程并发执行</p>
</li>
<li><p>处理器的三级调度</p>
</li>
<li><ul>
<li>低级调度（进程调度）</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>最基本的调度，按照某种算法从就绪队列中选取一个进程，并将处理器分配给它</li>
<li>进程调度的频率很高，一般几十毫秒一次</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>中级调度（内存调度）</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>作用：提高内存利用率和系统吞吐量</li>
<li>将暂时不能运行的进程调至外存等待，此时的该进程称为挂起态</li>
<li>当其具备运行条件且内存有空闲时，由中级调度将外存上的就绪进程重新调入内存，并修改其状态为就绪态，挂在就绪队列上等待</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>高级调度（作业调度）</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>按一定的规则从外存上处于后备状态的作业中挑选一个或多个作业，给它们分配内存、输入输出设备必要的资源，并建立相应的进程</li>
<li>多道批处理系统中大多配有作业调度，而其他系统中通常不需要配置作业调度，作业调度执行频率低，通常几分钟一次</li>
</ul>
</li>
</ul>
</li>
<li><p>进程切换</p>
</li>
<li><ul>
<li>进程切换在调度完成后立刻发生</li>
<li>操作系统内核将原进程的现场信息推入当前进程的内核堆栈来保存它们，并更新堆栈指针</li>
<li>内核完成从新进程的内核栈中装入新进程的现场信息、更新当前运行进程空间指针、重设PC寄存器等工作</li>
<li>开始运行新的进程</li>
</ul>
</li>
<li><p>不能马上进行调度与切换的情况：</p>
</li>
<li><ul>
<li>处理中断的过程中：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>中断过程复杂，实现上很难做到进程切换，而中断处理是系统的一部分，逻辑上不属于某一个进程，不应被剥夺处理器资源</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>进程在操作系统内核程序临界区中：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>进入临界区后，需要独占式访问共享数据，解锁前不应切换到其他进程运行</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>需要完全屏蔽中断的原子操作过程中：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>加锁、解锁、中断现场保护、恢复等原子操作，中断都要屏蔽，更不应该进行进程调度和切换</li>
</ul>
</li>
</ul>
</li>
<li><p>进程调度方式</p>
</li>
<li><ul>
<li>非剥夺调度方式（非抢占方式）：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>一旦把CPU分配给一个进程，该进程会保持CPU直到终止或转换到等待态</li>
<li>优点：系统开销小，适合批处理系统</li>
<li>缺点：不能用于分时系统和实时系统</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>剥夺调度方式（抢占方式）：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>当进程正在CPU上执行时，若某个更重要/紧迫的进程需要使用CPU，则立即暂停正在执行的进程，将处理机分配给这个更为重要/紧迫的进程</li>
</ul>
</li>
</ul>
</li>
<li><p>调度的基本准则</p>
</li>
<li><ul>
<li>CPU利用率：尽可能使CPU利用率最高</li>
<li>系统吞吐量：单位时间内CPU完成作业的数量</li>
<li>周转时间：从作业提交到作业完成所经历的时间</li>
<li>等待时间：进程处于等待CPU状态的时间之和</li>
<li>响应时间：从用户提交到系统首次产生响应所用的时间</li>
</ul>
</li>
</ul>
<h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><h4 id="1-批处理系统"><a href="#1-批处理系统" class="headerlink" title="1. 批处理系统"></a>1. 批处理系统</h4><ul>
<li>批处理系统在很老的计算机时使用，没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）</li>
</ul>
<p><strong>1.1 先来先服务 first-come first-serverd（FCFS）</strong></p>
<ul>
<li>非抢占式的调度算法，按照请求的顺序进行调度</li>
<li><strong>有利于长作业，但不利于短作业</strong>，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长</li>
</ul>
<p><strong>1.2 短作业优先 shortest job first（SJF）</strong></p>
<ul>
<li>非抢占式的调度算法，按估计运行时间最短的顺序进行调度</li>
<li><strong>长作业有可能会饿死</strong>，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度</li>
</ul>
<p><strong>1.3 高响应比优先</strong> </p>
<ul>
<li>高响应比优先调度算法是FCFS和SJF的综合平衡，每次进行作业调度时，先计算后备作业队列中每个作业的响应比，从中选出响应比最高的作业投入运行</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1599725265351-ac1b4730-41f4-45af-ab73-a8e3bf6ae880.png" alt="image.png"></li>
<li>要求服务时间短，响应比高，有利于短作业</li>
<li>等待时间长，响应比高，不会出现长作业饿死的情况</li>
</ul>
<h4 id="2-交互式系统"><a href="#2-交互式系统" class="headerlink" title="2. 交互式系统"></a>2. 交互式系统</h4><ul>
<li>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</li>
</ul>
<p><strong>2.1 时间片轮转</strong></p>
<ul>
<li><p>将所有就绪进程按先到先来原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片</p>
</li>
<li><p>当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程</p>
</li>
<li><p>时间片轮转算法的效率和时间片的大小有很大关系：</p>
</li>
<li><ul>
<li>因为进程切换都要保存进程的信息并且载入新进程的信息，<strong>如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间</strong>。</li>
<li>而<strong>如果时间片过长，那么实时性就不能得到保证</strong></li>
</ul>
</li>
<li><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1597059036482-eecf0326-76a1-49dc-9528-a46128edc7dd.png" alt="image.png"></p>
</li>
</ul>
<p><strong>2.2 优先级调度</strong></p>
<ul>
<li>为每个进程分配一个优先级，按优先级进行调度</li>
<li>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级</li>
</ul>
<p><strong>2.3 多级反馈队列</strong></p>
<ul>
<li>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次</li>
<li>多级队列是为这种需要连续执行多个时间片的进程考虑，<strong>设置了多个队列，每个队列时间片大小都不同</strong>，例如 1,2,4,8,..。<strong>进程在第一个队列没执行完，就会被移到下一个队列</strong>。这种方式下，之前的进程只需要交换 7 次</li>
<li><strong>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列中的进程</strong></li>
<li>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1597059054815-90d0949c-b2e6-4976-812f-d707922f2f8e.png" alt="image.png"></p>
<h4 id="3-实时系统"><a href="#3-实时系统" class="headerlink" title="3. 实时系统"></a>3. 实时系统</h4><p>实时系统要求一个请求在一个确定时间内得到响应。</p>
<p>分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><ul>
<li><p><strong>进程间通信(IPC，InterProcess Communication)的目的</strong></p>
</li>
<li><ul>
<li><strong>数据传输：</strong>一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几兆字节之间</li>
<li><strong>共享数据：</strong>多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到</li>
<li><strong>通知事件：</strong>一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）</li>
<li><strong>资源共享：</strong>多个进程之间共享同样的资源。为了作到这一点，需要内核提供锁和同步机制</li>
<li><strong>进程控制：</strong>有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变</li>
</ul>
</li>
<li><p>IPC方式包括：管道、系统IPC（信号量、消息队列、共享内存）和套接字（socket）</p>
</li>
</ul>
<h3 id="管道-pipe"><a href="#管道-pipe" class="headerlink" title="管道(pipe)"></a>管道(pipe)</h3><ul>
<li><p><strong>管道的特点：</strong></p>
</li>
<li><ul>
<li><strong>管道是半双工</strong>，数据只能向一个方向流动；双方需要互相通信时，需要建立起两个管道</li>
<li>只能用于具有亲缘关系的进程（<strong>父子进程或者兄弟进程</strong>）之间</li>
<li>管道对于两端通信的进程来说就只是一种<strong>文件</strong>，一种<strong>不属于文件系统仅存在内存中的“伪文件”</strong></li>
<li>管道的通信方式为：写端每次都将数据写入管道缓冲区的 <strong>末尾</strong> ，而读端每次都从管道缓冲区的 <strong>头部</strong> 读出数据</li>
<li>当一个管道建立时，它会创建两个文件描述符：fd[0]为读而打开，fd[1]为写而打开，要关闭管道只需将这两个文件描述符关闭即可。如下图：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1598175402011-cbc30792-6045-4701-b33c-2222787f89e6.png" alt="image.png"></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>管道的实质</strong></p>
</li>
<li><ul>
<li>管道的实质是一个<strong>内核缓冲区</strong>，进程以先进先出的方式从缓冲区存取数据：管道一端的进程顺序地将进程数据写入缓冲区，另一端的进程则顺序地读取数据</li>
<li>该缓冲区可以看做一个循环队列，读和写的位置都是自动增加的，一个数据只能被读一次，读出以后再缓冲区都不复存在了</li>
<li>当缓冲区读空或者写满时，有一定的规则控制相应的读进程或写进程是否进入等待队列，当空的缓冲区有新数据写入或慢的缓冲区有数据读出时，就唤醒等待队列中的进程继续读写</li>
</ul>
</li>
</ul>
<h3 id="信号-signals"><a href="#信号-signals" class="headerlink" title="信号(signals)"></a>信号(signals)</h3><ul>
<li><p><strong>信号的特点：</strong></p>
</li>
<li><ul>
<li>Unix系统中使用的最古老的进程间通信的方法之一，操作系统通过信号来通知进程系统中发生了某种预先规定好的事件（一组事件中的一个），它也是用户进程之间通信和同步的一种原始机制</li>
<li>一个键盘中断或者一个错误条件（比如进程试图访问它的虚拟内存中不存在的位置等）都有可能产生一个信号</li>
<li>信号可以在任何时候发给某一进程，而无需知道该进程的状态、</li>
<li>对信号的任何处理，包括终止进程，都必须由接收到信号的进程真正执行时才能处理，所以信号处理可能需要延迟一段时间</li>
<li>如果该进程当前并未处于执行状态，则内核保存该信号，直到该进程回复执行并传递给它为止</li>
</ul>
</li>
<li><p><strong>信号的来源：</strong></p>
</li>
<li><ul>
<li><strong>信号是软件层次上对中断机制的一种模拟，是一种异步通信方式（所以信号不是中断，**</strong>信号处理程序在用户态下运行的, 中断程序在核心态下运行的**<strong>）</strong></li>
<li><strong>信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发生了哪些系统事件</strong></li>
<li>信号事件主要有两个来源：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>硬件来源：用户按键输入 <code>Ctrl+C</code> 退出、硬件异常如无效的存储访问等</li>
<li>软件终止：终止进程信号、其他进程调用 <code>kill</code> 函数、软件异常产生信号</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>信号生命周期和处理流程</strong></p>
</li>
</ul>
<ol>
<li><ol>
<li><strong>信号被某个进程产生</strong>，并设置此信号传递的对象（一般为<strong>对应进程的pid</strong>），然后<strong>传递给操作系统</strong></li>
<li>操作系统根据接收进程的设置（是否阻塞）而选择性的发送给接收者，如果接收者阻塞该信号（且该信号是可以阻塞的），操作系统将暂时保留该信号，而不传递，直到该进程解除了对此信号的阻塞（如果对应进程已经退出，则丢弃此信号），<strong>如果对应进程没有阻塞，操作系统将传递此信号</strong></li>
<li><strong>目的进程接收到此信号后</strong>，将根据当前进程对此信号设置的预处理方式，<strong>暂时终止当前代码的执行，**</strong>保护上下文<strong>（主要包括临时寄存器数据，当前程序位置以及当前CPU的状态）、</strong>转而执行中断服务程序**<strong>，执行完成后在回复到中断的位置</strong>。当然，对于抢占式内核，在中断返回时还将引发新的调度</li>
</ol>
</li>
</ol>
<h3 id="消息队列-message"><a href="#消息队列-message" class="headerlink" title="消息队列(message)"></a>消息队列(message)</h3><ul>
<li><p>消息队列的特点：</p>
</li>
<li><ul>
<li>消息队列是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识</li>
<li>消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区受限等特点</li>
<li>消息队列允许一个或多个进程向它写入与读取消息</li>
<li>管道和消息队列的通信数据都是先进先出的原则</li>
<li>与管道相比，管道发送的数据没有类型；消息队列有类型，读端可以根据数据类型读取特定的数据</li>
</ul>
</li>
</ul>
<h3 id="共享内存-share-memory"><a href="#共享内存-share-memory" class="headerlink" title="共享内存(share memory)"></a>共享内存(share memory)</h3><ul>
<li>使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的</li>
<li>为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率</li>
<li>信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问</li>
</ul>
<h3 id="信号量-semaphore"><a href="#信号量-semaphore" class="headerlink" title="信号量(semaphore)"></a>信号量(semaphore)</h3><ul>
<li><p><strong>信号量</strong></p>
</li>
<li><ul>
<li>信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于<strong>进程间同步</strong></li>
</ul>
</li>
<li><p><strong>信号量与普通整型变量的区别：</strong></p>
</li>
<li><ul>
<li>信号量是非负整型变量，除了初始化之外，它只能通过两个标准原子操作：wait(semap) , signal(semap) ; 来进行访问</li>
<li>操作也被成为PV原语，而普通整型变量则可以在任何语句块中被访问</li>
</ul>
</li>
</ul>
<h3 id="套接字-socket"><a href="#套接字-socket" class="headerlink" title="套接字(socket)"></a>套接字(socket)</h3><ul>
<li>适合<strong>同一主机的不同进程间</strong>和<strong>不同主机的进程间</strong>进行全双工网络通信</li>
</ul>
<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="1-临界区"><a href="#1-临界区" class="headerlink" title="1. 临界区"></a>1. 临界区</h3><ul>
<li>对临界资源进行访问的那段代码称为临界区。</li>
<li>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</li>
<li>// entry section</li>
<li>// critical section;</li>
<li>// exit section</li>
</ul>
<h3 id="2-同步与互斥"><a href="#2-同步与互斥" class="headerlink" title="2. 同步与互斥"></a>2. 同步与互斥</h3><ul>
<li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li>
<li>互斥：多个进程在同一时刻只有一个进程能进入临界区。</li>
</ul>
<h3 id="3-信号量"><a href="#3-信号量" class="headerlink" title="3. 信号量"></a>3. 信号量</h3><ul>
<li><p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p>
</li>
<li><ul>
<li><strong>down</strong> : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li>
<li><strong>up</strong> ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</li>
</ul>
</li>
<li><p><strong>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断</strong>。</p>
</li>
<li><p>如果信号量的取值只能为 0 或者 1，那么就成为了 <strong>互斥量（Mutex）</strong> ，0 表示临界区已经加锁，1 表示临界区解锁。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>使用信号量实现生产者-消费者问题</strong></p>
<p>问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。</p>
<p>因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。</p>
<p>为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。</p>
<p>注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。</p>
<figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">#define N 100</span><br><span class="line">typedef int semaphore;</span><br><span class="line">semaphore mutex = 1;</span><br><span class="line">semaphore empty = N;</span><br><span class="line">semaphore full = 0;</span><br><span class="line">void producer() &#123;</span><br><span class="line">    <span class="meta">while</span>(TRUE) &#123;</span><br><span class="line">        int item = produce_item();</span><br><span class="line">        <span class="meta">do</span><span class="meta">wn(</span><span class="variable">&amp;empty</span>);</span><br><span class="line">        <span class="meta">do</span><span class="meta">wn(</span><span class="variable">&amp;mutex</span>);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        up(<span class="variable">&amp;mutex</span>);</span><br><span class="line">        up(<span class="variable">&amp;full</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void consumer() &#123;</span><br><span class="line">    <span class="meta">while</span>(TRUE) &#123;</span><br><span class="line">        <span class="meta">do</span><span class="meta">wn(</span><span class="variable">&amp;full</span>);</span><br><span class="line">        <span class="meta">do</span><span class="meta">wn(</span><span class="variable">&amp;mutex</span>);</span><br><span class="line">        int item = remove_item();</span><br><span class="line">        consume_item(item);</span><br><span class="line">        up(<span class="variable">&amp;mutex</span>);</span><br><span class="line">        up(<span class="variable">&amp;empty</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-管程"><a href="#4-管程" class="headerlink" title="4. 管程"></a>4. 管程</h3><ul>
<li>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</li>
<li>c 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。</li>
</ul>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">monitor ProducerConsumer</span><br><span class="line">    integer i;</span><br><span class="line">    condition c;</span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">()</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">remove</span><span class="params">()</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span> monitor;</span><br></pre></td></tr></table></figure>

<ul>
<li>管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。</li>
<li>管程引入了 <strong>条件变量</strong> 以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</li>
<li><strong>使用管程实现生产者-消费者问题</strong></li>
</ul>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 管程</span></span><br><span class="line">monitor ProducerConsumer</span><br><span class="line">    condition full, <span class="keyword">empty</span>;</span><br><span class="line">    integer count := <span class="number">0</span>;</span><br><span class="line">    condition c;</span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">(item: integer)</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> count = N <span class="keyword">then</span> wait(full);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        count := count + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">1</span> <span class="keyword">then</span> signal(<span class="keyword">empty</span>);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">remove</span>:</span> integer;</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">0</span> <span class="keyword">then</span> wait(<span class="keyword">empty</span>);</span><br><span class="line">        <span class="keyword">remove</span> = remove_item;</span><br><span class="line">        count := count - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = N -<span class="number">1</span> <span class="keyword">then</span> signal(full);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span> monitor;</span><br><span class="line"><span class="comment">// 生产者客户端</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">producer</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="title">true</span> <span class="title">do</span></span></span><br><span class="line"><span class="function">    <span class="title">begin</span></span></span><br><span class="line"><span class="function">        <span class="title">item</span> = <span class="title">produce_item</span>;</span></span><br><span class="line">        ProducerConsumer.insert(item);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">// 消费者客户端</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">consumer</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="title">true</span> <span class="title">do</span></span></span><br><span class="line"><span class="function">    <span class="title">begin</span></span></span><br><span class="line"><span class="function">        <span class="title">item</span> = <span class="title">ProducerConsumer</span>.<span class="title">remove</span>;</span></span><br><span class="line">        consume_item(item);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>

<h1 id="三、死锁"><a href="#三、死锁" class="headerlink" title="三、死锁"></a>三、死锁</h1><h3 id="1、死锁、饥饿、死循环的区别"><a href="#1、死锁、饥饿、死循环的区别" class="headerlink" title="1、死锁、饥饿、死循环的区别"></a>1、死锁、饥饿、死循环的区别</h3><ul>
<li><p>死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。至少有两个进程或以上同时发生死锁。</p>
</li>
<li><p>饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。比如：在短进程优先（SPF）算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生进程饥饿。可能只有一个进程发生饥饿。发生饥饿的进程既可能是阻塞态（如长期得不到I/O设备），也可能是就绪态（长期得不到处理机）</p>
</li>
<li><p>死循环：某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug导致的，有时是程序员故意设计的。死循环的进程可以上处理机运行（可以是运行态）。</p>
</li>
<li><p>总结：死锁和饥饿是管理者（操作系统）的问题，死循环是被管理者的问题。</p>
</li>
</ul>
<h3 id="2、死锁产生的必要条件"><a href="#2、死锁产生的必要条件" class="headerlink" title="2、死锁产生的必要条件"></a>2、死锁产生的必要条件</h3><p>产生死锁必须同时满足以下四个条件，只要其中一个不成立，死锁就不会发生。</p>
<ul>
<li>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁（如哲学家的筷子、打印机设备）。</li>
<li>不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</li>
<li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。（有了一个，还想要另一个，但是自己原来那个不放手。）</li>
<li>循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</li>
</ul>
<p>注意！发生死锁的时候一定又循环等待，但是发生循环等待时未必死锁（循环等待是死锁的必要不充分条件）。</p>
<p>如果同类资源数大于1，则即使有循环等待，也未必发生死锁。</p>
<p>如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件。</p>
<h3 id="3、什么时候会发生死锁"><a href="#3、什么时候会发生死锁" class="headerlink" title="3、什么时候会发生死锁"></a>3、什么时候会发生死锁</h3><p>1、对系统资源的竞争。各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁。</p>
<p>2、进程推进顺序非法。请求和释放资源的顺序不当，同样也会导致死锁。例如，并发执行进程P1、P2分别申请并占有了资源R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又申请R1，两者会因为申请的资源被对方占有而阻塞，从而发生死锁。</p>
<p>3、信号量的使用不当也会造成死锁。如生产者-消费者问题中，如果实现互斥的P操作在实现同步的P操作之前，就有可能导致死锁。（可以把互斥信号量、同步信号量也看做是一种抽象的系统资源）</p>
<p>总之，对不可剥夺资源的不合理分配，就可能导致死锁。第三点要记住。</p>
<h3 id="4、死锁的处理——预防死锁"><a href="#4、死锁的处理——预防死锁" class="headerlink" title="4、死锁的处理——预防死锁"></a>4、死锁的处理——预防死锁</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/png/218528/1575718340782-6dca5998-47bd-490f-bab3-2417f36e8825.png?x-oss-process=image/resize,w_1500" alt="image.png"></p>
<h4 id="4-1-破坏互斥条件"><a href="#4-1-破坏互斥条件" class="headerlink" title="4.1 破坏互斥条件"></a>4.1 破坏互斥条件</h4><p>如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如：SPOOLing技术。操作系统可以采用SPOOLing技术把独占设备在逻辑上改造成共享设备。比如，用SPOOLing技术将打印机改造为共享设备，在各进程看来，自己对打印机资源的使用请求立即就被接收处理了，不需要再阻塞等待。</p>
<p>缺点：并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，很多时候都无法破坏互斥情况。</p>
<h4 id="4-2-破坏不剥夺条件"><a href="#4-2-破坏不剥夺条件" class="headerlink" title="4.2 破坏不剥夺条件"></a>4.2 破坏不剥夺条件</h4><p>1、不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</p>
<p>2、破坏不剥夺条件：</p>
<p>方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。</p>
<p>方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级。（比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用）</p>
<p>3、缺点：</p>
<ul>
<li>实现起来比较复杂</li>
<li>释放已获得的资源可能造成前一段工作的失效。因此这种方法一般只适用于保存和恢复状态的资源，如CPU。</li>
<li>反复地申请和释放资源会增加系统开销，降低系统吞吐量。</li>
<li>若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果一直发生这样的情况，就会导致进程饥饿。</li>
</ul>
<h4 id="4-3-破坏请求和保持条件"><a href="#4-3-破坏请求和保持条件" class="headerlink" title="4.3 破坏请求和保持条件"></a>4.3 破坏请求和保持条件</h4><p>1、请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</p>
<p>2、可采用静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了。</p>
<p>3、缺点：</p>
<ul>
<li>有些资源可能只需要用很短的时间，因此如果进程的整个运行过程都一直保持着所有资源，就会造成严重的资源浪费，资源利用率极低。另外，该策略也有可能导致某些进程饥饿。</li>
</ul>
<p>例子： A进程需要a资源，B进程需要b资源，C进程需要AB两个资源，那么当A进程和B进程源源不断地加入时，根本轮不到C进程。</p>
<h4 id="4-4-破坏循环等待条件"><a href="#4-4-破坏循环等待条件" class="headerlink" title="4.4 破坏循环等待条件"></a>4.4 破坏循环等待条件</h4><p>1、循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</p>
<p>2、可采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序去请求资源，同类资源（即编号相同的资源）一次申请完。</p>
<p>3、原理分析：一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/218528/1575722481617-3d969ddf-1025-4b09-8522-71e5f3b6b16d.png" alt="image.png"></p>
<p>4、缺点：</p>
<ul>
<li>不方便增加新的设备，因为可能需要重新分配所有的编号</li>
<li>进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费（有可能大号的资源是要先使用的，小号资源晚使用，可是由于编号递增规则，只能先申请小号资源）</li>
<li>必须按规定次序申请资源，用户编程麻烦（在不同机器上，编号可能不一样，用户可能要重新编写代码）</li>
</ul>
<h3 id="5、死锁的处理——避免死锁"><a href="#5、死锁的处理——避免死锁" class="headerlink" title="5、死锁的处理——避免死锁"></a>5、死锁的处理——避免死锁</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/png/218528/1575722844700-df890c05-54b7-4217-898b-4cce009af1db.png?x-oss-process=image/resize,w_1500" alt="image.png"></p>
<h4 id="5-1-安全序列、不安全状态、死锁的联系"><a href="#5-1-安全序列、不安全状态、死锁的联系" class="headerlink" title="5.1 安全序列、不安全状态、死锁的联系"></a>5.1 安全序列、不安全状态、死锁的联系</h4><p>1、所谓安全序列，就是指如果系统按照这种序列分配子牙u你，则每个进程都顺利完成。只要能找出一个安全序列，系统就是安全状态。当然，安全序列可能有多个。</p>
<p>2、如果分配了资源之后，系统中找不到任何一个安全序列，系统就进入了不安全状态。这就意味着之后可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态。</p>
<p>3、如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就可能发生死锁（处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态）</p>
<p>4、可以在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。这也是“银行家算法”的核心思想。</p>
<h4 id="5-2-银行家算法"><a href="#5-2-银行家算法" class="headerlink" title="5.2 银行家算法"></a>5.2 银行家算法</h4><p><img src="https://cdn.nlark.com/yuque/0/2019/png/218528/1575723680965-560e06d5-2688-40b9-bede-4f3822bf6237.png?x-oss-process=image/resize,w_1500" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/218528/1575725368390-6e09854f-9422-4228-b3d3-36cb7473d161.png?x-oss-process=image/resize,w_1500" alt="image.png"></p>
<p>银行家算法总结：</p>
<p>用Available向量表示系统当前的可用资源数。</p>
<p>试分配：</p>
<p>在某一时刻，进程提出资源申请，系统首先检查申请的资源数是否超过进程的最大需求量。</p>
<p>不超过，则检查是否超过当前可用的资源数。</p>
<p>如果都不超过，则试着分配给该进程。</p>
<p>然后用安全性算法检查此次分配是否会导致系统进入不安全状态。</p>
<p>安全性算法简单理解：系统当前剩余的资源数超过了某个进程的Need向量，就把该进程加入安全序列，并将Allocation添加到Available，不断循环此过程，看最终能否让所有进程都加入安全序列，如果可以，此次分配时安全的，系统开始分配。</p>
<p>注意：处于安全状态一定不会死锁，死锁一定处于不安全状态，处于不安全状态不一定会死锁。</p>
<h3 id="6、死锁的处理——检测和解除"><a href="#6、死锁的处理——检测和解除" class="headerlink" title="6、死锁的处理——检测和解除"></a>6、死锁的处理——检测和解除</h3><h4 id="6-1-数据结构"><a href="#6-1-数据结构" class="headerlink" title="6.1 数据结构"></a>6.1 数据结构</h4><p>1、用种数据结构来保存资源的请求和分配信息。数据结构定义如下：</p>
<ul>
<li><p>两种结点：</p>
</li>
<li><ul>
<li>进程结点：对应一个进程<ul>
<li>资源结点：对应一类资源，一类资源可能有多个</li>
</ul>
</li>
</ul>
</li>
<li><p>两种边：</p>
</li>
<li><ul>
<li>进程结点-&gt;资源结点：表示进程想申请几个资源（每条边代表一个）<ul>
<li>资源结点-&gt;进程结点：表示进程想申请几个资源（每条边代表一个）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/218528/1575734720016-bc4c28fa-fae9-478a-aed9-816b1286e6f3.png" alt="image.png"></p>
<p>（矩形中的小圆代表资源的数量）</p>
<p>2、提供一种算法，利用上述信息来检测系统是否已进入死锁状态。算法描述如下：</p>
<p>如果系统中剩余的可用资源满足进程的需求，则进程将顺利自行下去，然后将资源归还系统，然后激活正在等待资源的进程，并顺利执行下去，一直这样下去，如果最终能消除所有边，就称这个图是可完全简化的，此时一定没有发生死锁（相当于找一个安全序列）。如果最终不能消除所有边，那么此时就是发生了死锁。最终连着边的那些进程就是处于死锁状态的进程。</p>
<p>算法简单理解：把没有处于阻塞态的进程的边都去掉，循环此过程。</p>
<h4 id="6-2-死锁的解除"><a href="#6-2-死锁的解除" class="headerlink" title="6.2 死锁的解除"></a>6.2 死锁的解除</h4><p>1、一旦检测出死锁的发生，就应该立即解除死锁。</p>
<p>2、并不是系统中所有进程都是死锁状态，用死锁检测算法简化资源分配图后，还连着边的那些进程就是死锁进程。</p>
<p>3、解除死锁的主要方法有：</p>
<ul>
<li>资源剥夺法：挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</li>
<li>撤销进程法（终止进程法）：强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的有点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束，一旦被终止可谓功亏一篑，以后还得从头再来。</li>
<li>进程回退法：让一个或多个死锁进程回退到足以避免死锁的地步。这就是要求系统要记录进程的历史信息，设置还原点。</li>
</ul>
<p>问题：决定对谁动手？</p>
<ul>
<li>进程优先级</li>
<li>已执行了多长时间</li>
<li>还要多久完成</li>
<li>进程已经使用了多少资源（资源分配多的优先）</li>
<li>进程是交互式的还是批处理式的（批处理优先）</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/218528/1575734667024-d54814af-cee6-49d8-8a26-4798efd42280.png?x-oss-process=image/resize,w_746"></p>
<h1 id="四、内存管理"><a href="#四、内存管理" class="headerlink" title="四、内存管理"></a>四、内存管理</h1><h2 id="虚拟内存-1"><a href="#虚拟内存-1" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><ul>
<li><strong>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存</strong>。</li>
<li>为了更好的管理内存，<strong>操作系统将内存抽象成地址空间。**</strong>每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中**。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</li>
<li>从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个<strong>程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能</strong>。<strong>例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序</strong>。</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1597062741056-0b5eeebc-b334-4929-9319-359a8cf9e7cc.png" alt="image.png"></li>
</ul>
<h2 id="分页与分段"><a href="#分页与分段" class="headerlink" title="分页与分段"></a>分页与分段</h2><ul>
<li><strong>分页</strong>管理方式是从计算机的角度考虑设计的，以<strong>提高内存的利用率</strong>，提升计算机的性能, 且分页通过硬件机制实现，对用户完全透明</li>
<li><strong>分段</strong>管理方式的提出则是考虑了用户和程序员，以<strong>满足方便编程、信息保护和共享、动态增长及动态链接</strong>等多方面的需要</li>
</ul>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><ul>
<li><p><strong>内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表</strong>。</p>
</li>
<li><p>一个虚拟地址分成两个部分，一部分存储页号，一部分存储偏移量。</p>
</li>
<li><p>页表：</p>
</li>
<li><ul>
<li>为了便于在内存中找到进程的每个页面所对应的物理块，<strong>系统为每个进程建立一张页表</strong>，记录页面在内存中对应的物理块号，页表一般存放在内存中。在配置了页表后，进程执行时，通过查找该表，即可找到每页在内存中的物理块号。可见，页表的作用是实现从页号到物理块号的地址映射</li>
<li>下图的页表存放着 16 个页，这 16 个页需要用 4 个bit来进行索引定位。</li>
</ul>
</li>
<li><p>例如对于虚拟地址（0010 000000000100），前 4 位是当在虚拟地址对应的存储页号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。那么映射后，这个页（地址空间）对应的页框（物理内存地址）的地址为 （110 000000000100）。</p>
</li>
<li><p><strong>相当于前缀做一个Mapping，前缀决定虚拟地址属于哪个块，后缀决定这个虚拟地址在块中的相对位置</strong></p>
</li>
<li><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1266758/1597064732122-fa391785-bc91-450c-a6db-3284d9ee19ea.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
</li>
</ul>
<h2 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h2><ul>
<li><p>分段式管理方式按照用户进程中的自然段划分逻辑空间</p>
</li>
<li><ul>
<li>例如，用户进程由主程序、两个子程序、栈和一段数据组成，于是可以把这个用户进程划分为5个段，每段从0 开始编址，并分配一段连续的地址空间</li>
<li>段内要求连续，段间不要求连续，因此整个作业的地址空间是二维的，其<strong>逻辑地址</strong>由<strong>段号S</strong>与<strong>段内偏移量W</strong>两部分组成</li>
</ul>
</li>
<li><p>页式系统中，逻辑地址的页号和页内偏移量对用户是透明的，段式系统中，段号和段内偏移量必须由用户显示提供，，在髙级程序设计语言中，这个工作由编译程序完成</p>
</li>
<li><p>段表</p>
</li>
<li><ul>
<li>每个进程都有一张逻辑空间与内存空间映射的段表，其中每一个段表项对应进程的一个段，段表项记录该段在内存中的起始地址和段的长度</li>
<li>在配置了段表后，执行中的进程可通过查找段表，找到每个段所对应的内存区</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1598085231446-c4b4cce0-09de-4296-85a2-7a2021e9f923.png" alt="image.png"></li>
</ul>
</li>
<li><p>段的共享和保护</p>
</li>
<li><ul>
<li>共享：通过两个作业的段表中相应表项指向被共享的段的同一个物理副本来实现的</li>
<li>保护：存取控制保护、地址越界保护</li>
</ul>
</li>
</ul>
<h2 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h2><ul>
<li>分页能有效地提高内存利用率，分段能反映程序的逻辑结构并有利于段的共享，将这两种存储管理方法结合起来，就形成了段页式存储管理方式</li>
<li>程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1598086260778-9d62781d-6da7-4186-af92-ecf9e30b8b47.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image.png"></li>
</ul>
<h2 id="分页与分段的比较"><a href="#分页与分段的比较" class="headerlink" title="分页与分段的比较"></a>分页与分段的比较</h2><ul>
<li>对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段</li>
<li>地址空间的维度：分页是一维地址空间，分段是二维的</li>
<li>大小是否可以改变：页的大小不可变，段的大小可以动态改变</li>
<li>出现的原因：<strong>分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护</strong></li>
</ul>
<h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><ul>
<li>在程序运行过程中，<strong>如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中</strong>。<strong>此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间</strong>。</li>
<li>页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。</li>
<li><strong>页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）</strong></li>
</ul>
<ol>
<li><strong>最佳（OPT, Optimal replacement algorithm）</strong></li>
</ol>
<ul>
<li><ul>
<li>所<strong>选择的被换出的页面在未来最长时间内不再被访问</strong>，通常可以保证获得最低的缺页率。</li>
<li>是一种<strong>理论上的算法</strong>，因为无法知道一个页面多长时间不再被访问。</li>
<li>举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：</li>
<li>7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1</li>
<li>开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。</li>
</ul>
</li>
</ul>
<ol>
<li><strong>最近最久未使用（LRU, Least Recently Used）</strong></li>
</ol>
<ul>
<li><ul>
<li><strong>虽然无法知道未来要使用的页面情况，但是可以知道过去使用页面的情况</strong>。LRU 将最近最久未使用的页面换出。</li>
<li><strong>为了实现 LRU，需要在内存中维护一个所有页面的链**</strong>表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。**</li>
<li><strong>因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。</strong></li>
<li>4，7，0，7，1，0，1，2，1，2，6</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1597061862423-62868c5b-e196-486b-9104-ffc39a540f9f.png" alt="image.png"></li>
</ul>
</li>
</ul>
<ol>
<li><strong>最近未使用（NRU, Not Recently Used）</strong></li>
</ol>
<ul>
<li><ul>
<li>每个页面都有两个状态位：R 与 M，<strong>当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1</strong>。其中 R 位会定时被清零。可以将页面分成以下四类：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>R=0，M=0</li>
<li>R=0，M=1</li>
<li>R=1，M=0</li>
<li>R=1，M=1</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。</li>
<li><strong>NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）</strong>。</li>
</ul>
</li>
</ul>
<ol>
<li><strong>先进先出（FIFO, First In First Out）</strong></li>
</ol>
<ul>
<li><ul>
<li>选择换出的页面是最先进入的页面。</li>
<li><strong>该算法会将那些经常被访问的页面换出，导致缺页率升高</strong>。</li>
</ul>
</li>
</ul>
<ol>
<li><strong>第二次机会算法</strong></li>
</ol>
<ul>
<li><ul>
<li><strong>FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：</strong></li>
<li><strong>当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。</strong></li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1597061941454-03800959-859a-4877-abfd-27c39e401945.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image.png"></li>
</ul>
</li>
</ul>
<ol>
<li><strong>时钟（Clock）</strong></li>
</ol>
<ul>
<li><ul>
<li>第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1597062565754-826091ad-7dc4-4c83-943d-343b7bd7bdac.png" alt="image.png"></li>
</ul>
</li>
</ul>
<h1 id="五、设备管理"><a href="#五、设备管理" class="headerlink" title="五、设备管理"></a>五、设备管理</h1><h2 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h2><ul>
<li>盘面（Platter）：一个磁盘有多个盘面；</li>
<li>磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；</li>
<li>扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小；</li>
<li>磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；</li>
<li>制动手臂（Actuator arm）：用于在磁道之间移动磁头；</li>
<li>主轴（Spindle）：使整个盘面转动。</li>
<li><img src="https://camo.githubusercontent.com/42c8be3472d81b72762c2a88b29fa61b4bdf2409/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30313466626334642d643837332d346131322d623136302d3836376464616564393830372e6a7067?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></li>
</ul>
<h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><ul>
<li><p>读写一个磁盘块的时间的影响因素有：</p>
</li>
<li><ul>
<li>旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）</li>
<li>寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）</li>
<li>实际的数据传输时间</li>
</ul>
</li>
<li><p>其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p>
</li>
</ul>
<ol>
<li>先来先服务（FCFS, First Come First Served）</li>
</ol>
<ul>
<li><ul>
<li>按照磁盘请求的顺序进行调度。</li>
<li>优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。</li>
</ul>
</li>
</ul>
<ol>
<li>最短寻道时间优先（SSTF, Shortest Seek Time First）</li>
</ol>
<ul>
<li><ul>
<li>优先调度与当前磁头所在磁道距离最近的磁道。</li>
<li>虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是<strong>出现饥饿现象</strong>。<strong>具体来说，两端的磁道请求更容易出现饥饿现象。</strong></li>
<li><img src="https://camo.githubusercontent.com/513755459b87116ae3a03bb9c4c6a0b161e7d0ed/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34653234383565342d333462642d343936372d396630322d3063303933623739376161612e706e67" alt="image"></li>
</ul>
</li>
</ul>
<ol>
<li>电梯算法（SCAN）</li>
</ol>
<ul>
<li><ul>
<li>电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</li>
<li>电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。</li>
<li>因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。</li>
<li><img src="https://camo.githubusercontent.com/8187903788bbfb90978169f20fa4fd41e094bf22/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32373163653038662d633132342d343735662d623439302d6265343466656463366432652e706e67" alt="image"></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2020/10/14/0000.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h3 id="1、谈下你对五层网络协议体系结构的理解？"><a href="#1、谈下你对五层网络协议体系结构的理解？" class="headerlink" title="1、谈下你对五层网络协议体系结构的理解？"></a>1、谈下你对五层网络协议体系结构的理解？</h3><p>学习计算机网络时我们一般采用折中的办法，也就是中和 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚。</p>
<ul>
<li><strong>1. 应用层</strong></li>
</ul>
<p>应用层（application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。我们把应用层交互的数据单元称为报文。</p>
<ul>
<li><strong>2. 运输层</strong></li>
</ul>
<p>运输层（transport layer）的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。</p>
<p>由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。</p>
<ul>
<li><strong>3. 网络层</strong></li>
</ul>
<p>在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP / IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报，简称数据报。</p>
<ul>
<li><strong>4. 数据链路层</strong></li>
</ul>
<p>数据链路层（data link layer）通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如：同步信息，地址信息，差错控制等）。</p>
<p>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。控制信息还使接收端能够检测到所收到的帧中有无差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。</p>
<ul>
<li><strong>5. 物理层</strong></li>
</ul>
<p>在物理层上所传送的数据单位是比特。物理层（physical layer）的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p>
<h3 id="2、简单说下每一层对应的网络协议有哪些？"><a href="#2、简单说下每一层对应的网络协议有哪些？" class="headerlink" title="2、简单说下每一层对应的网络协议有哪些？"></a>2、简单说下每一层对应的网络协议有哪些？</h3><p>计算机五层网络体系中涉及的协议非常多，下面就常用的做了列举：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201030090603.webp" alt="img"></p>
<h3 id="3、ARP-协议的工作原理？"><a href="#3、ARP-协议的工作原理？" class="headerlink" title="3、ARP 协议的工作原理？"></a>3、ARP 协议的工作原理？</h3><p>网络层的 ARP 协议完成了 IP 地址与物理地址的映射。首先，每台主机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 IP 地址和 MAC 地址的对应关系。当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP 列表中是否存在该 IP 地址对应的 MAC 地址：如果有，就直接将数据包发送到这个 MAC 地址；如果没有，就向本地网段发起一个 ARP 请求的广播包，查询此目的主机对应的 MAC 地址。</p>
<p>此 ARP 请求数据包里包括源主机的 IP 地址、硬件地址、以及目的主机的 IP 地址。网络中所有的主机收到这个 ARP 请求后，会检查数据包中的目的 IP 是否和自己的 IP 地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的 MAC 地址和 IP 地址添加到自己的 ARP 列表中，如果 ARP 表中已经存在该 IP 的信息，则将其覆盖，然后给源主机发送一个 ARP 响应数据包，告诉对方自己是它需要查找的 MAC 地址；源主机收到这个 ARP 响应数据包后，将得到的目的主机的 IP 地址和 MAC 地址添加到自己的 ARP 列表中，并利用此信息开始数据的传输。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败。</p>
<h3 id="4、谈下你对-IP-地址分类的理解？"><a href="#4、谈下你对-IP-地址分类的理解？" class="headerlink" title="4、谈下你对 IP 地址分类的理解？"></a>4、谈下你对 IP 地址分类的理解？</h3><p> IP 地址是指互联网协议地址，是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP 地址编址方案将 IP 地址空间划分为 A、B、C、D、E 五类，其中 A、B、C 是基本类，D、E 类作为多播和保留使用，为特殊地址。</p>
<p>每个 IP 地址包括两个标识码（ID），即网络 ID 和主机 ID。同一个物理网络上的所有主机都使用同一个网络 ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机 ID 与其对应。A~E 类地址的特点如下：</p>
<p>A 类地址：以 0 开头，第一个字节范围：0~127；</p>
<p>B 类地址：以 10 开头，第一个字节范围：128~191；</p>
<p>C 类地址：以 110 开头，第一个字节范围：192~223；</p>
<p>D 类地址：以 1110 开头，第一个字节范围为 224~239；</p>
<p>E 类地址：以 1111 开头，保留地址</p>
<h3 id="5、TCP-的主要特点是什么？"><a href="#5、TCP-的主要特点是什么？" class="headerlink" title="5、TCP 的主要特点是什么？"></a>5、TCP 的主要特点是什么？</h3><p>\1. TCP 是面向连接的。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；</p>
<p>\2. 每一条 TCP 连接只能有两个端点，每一条 TCP 连接只能是点对点的（一对一）；</p>
<p>\3. TCP 提供可靠交付的服务。通过 TCP 连接传送的数据，无差错、不丢失、不重复、并且按序到达；</p>
<p>\4. TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；</p>
<p>\5. 面向字节流。TCP 中的“流”（Stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。</p>
<h3 id="6、UDP-的主要特点是什么？"><a href="#6、UDP-的主要特点是什么？" class="headerlink" title="6、UDP 的主要特点是什么？"></a>6、UDP 的主要特点是什么？</h3><p>\1. UDP 是无连接的；</p>
<p>\2. UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）；</p>
<p>\3. UDP 是面向报文的；</p>
<p>\4. UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 直播，实时视频会议等）；</p>
<p>\5. UDP 支持一对一、一对多、多对一和多对多的交互通信；</p>
<p>\6. UDP 的首部开销小，只有 8 个字节，比 TCP 的 20 个字节的首部要短。</p>
<h3 id="7、TCP-和-UDP-的区别？"><a href="#7、TCP-和-UDP-的区别？" class="headerlink" title="7、TCP 和 UDP 的区别？"></a>7、TCP 和 UDP 的区别？</h3><p>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的运输服务（TCP 的可靠体现在 TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。</p>
<p> UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如：QQ 语音、 QQ 视频 、直播等等。</p>
<h3 id="8、TCP-和-UDP-分别对应的常见应用层协议有哪些？"><a href="#8、TCP-和-UDP-分别对应的常见应用层协议有哪些？" class="headerlink" title="8、TCP 和 UDP 分别对应的常见应用层协议有哪些？"></a>8、TCP 和 UDP 分别对应的常见应用层协议有哪些？</h3><ul>
<li><strong>1. TCP 对应的应用层协议</strong></li>
</ul>
<p>FTP：定义了文件传输协议，使用 21 端口。常说某某计算机开了 FTP 服务便是启动了文件传输服务。下载文件，上传主页，都要用到 FTP 服务。</p>
<p>Telnet：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于 DOS 模式下的通信服务。如以前的 BBS 是-纯字符界面的，支持 BBS 的服务器将 23 端口打开，对外提供服务。</p>
<p>SMTP：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么 SMTP 端口设置这个栏，服务器开放的是 25 号端口。</p>
<p>POP3：它是和 SMTP 对应，POP3 用于接收邮件。通常情况下，POP3 协议所用的是 110 端口。也是说，只要你有相应的使用 POP3 协议的程序（例如 Fo-xmail 或 Outlook），就可以不以 Web 方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163 邮箱就没有必要先进入网易网站，再进入自己的邮-箱来收信）。</p>
<p>HTTP：从 Web 服务器传输超文本到本地浏览器的传送协议。</p>
<ul>
<li><strong>2. UDP 对应的应用层协议</strong></li>
</ul>
<p>DNS：用于域名解析服务，将域名地址转换为 IP 地址。DNS 用的是 53 号端口。</p>
<p>SNMP：简单网络管理协议，使用 161 号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。</p>
<p>TFTP(Trival File Transfer Protocal)：简单文件传输协议，该协议在熟知端口 69 上使用 UDP 服务。</p>
<h3 id="9、详细说下-TCP-三次握手的过程？"><a href="#9、详细说下-TCP-三次握手的过程？" class="headerlink" title="9、详细说下 TCP 三次握手的过程？"></a>9、详细说下 TCP 三次握手的过程？</h3><ul>
<li><strong>1. 三次握手</strong></li>
</ul>
<p>TCP 建立连接的过程叫做握手，握手需要在客户和服务器之间交换三个 TCP 报文段。</p>
<p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600"></svg>)<img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201030090622.webp" alt="img"></p>
<p>最初客户端和服务端都处于 CLOSED(关闭) 状态。本例中 A（Client） 主动打开连接，B（Server） 被动打开连接。</p>
<p>一开始，B 的 TCP 服务器进程首先创建传输控制块TCB，准备接受客户端进程的连接请求。然后服务端进程就处于 LISTEN(监听) 状态，等待客户端的连接请求。如有，立即作出响应。</p>
<p>第一次握手：A 的 TCP 客户端进程也是首先创建传输控制块 TCB。然后，在打算建立 TCP 连接时，向 B 发出连接请求报文段，这时首部中的同步位 SYN=1，同时选择一个初始序号 seq = x。TCP 规定，SYN 报文段（即 SYN = 1 的报文段）不能携带数据，但要消耗掉一个序号。这时，TCP 客户进程进入 SYN-SENT（同步已发送）状态。</p>
<p>第二次握手：B 收到连接请求报文后，如果同意建立连接，则向 A 发送确认。在确认报文段中应把 SYN 位和 ACK 位都置 1，确认号是 ack = x + 1，同时也为自己选择一个初始序号 seq = y。请注意，这个报文段也不能携带数据，但同样要消耗掉一个序号。这时 TCP 服务端进程进入 SYN-RCVD（同步收到）状态。</p>
<p>第三次握手：TCP 客户进程收到 B 的确认后，还要向 B 给出确认。确认报文段的 ACK 置 1，确认号 ack = y +  1，而自己的序号 seq = x + 1。这时 ACK 报文段可以携带数据。但如果不携带数据则不消耗序号，这种情况下，下一个数据报文段的序号仍是 seq = x + 1。这时，TCP 连接已经建立，A 进入 ESTABLISHED（已建立连接）状态。</p>
<h3 id="10、为什么两次握手不可以呢？"><a href="#10、为什么两次握手不可以呢？" class="headerlink" title="10、为什么两次握手不可以呢？"></a>10、为什么两次握手不可以呢？</h3><p>为了防止已经失效的连接请求报文段突然又传送到了 B，因而产生错误。比如下面这种情况：A 发出的第一个连接请求报文段并没有丢失，而是在网路结点长时间滞留了，以致于延误到连接释放以后的某个时间段才到达 B。本来这是一个早已失效的报文段。但是 B 收到此失效的链接请求报文段后，就误认为 A 又发出一次新的连接请求。于是就向 A 发出确认报文段，同意建立连接。</p>
<p>对于上面这种情况，如果不进行第三次握手，B 发出确认后就认为新的运输连接已经建立了，并一直等待 A 发来数据。B 的许多资源就这样白白浪费了。</p>
<p>如果采用了三次握手，由于 A 实际上并没有发出建立连接请求，所以不会理睬 B 的确认，也不会向 B 发送数据。B 由于收不到确认，就知道 A 并没有要求建立连接。</p>
<h3 id="11、为什么不需要四次握手？"><a href="#11、为什么不需要四次握手？" class="headerlink" title="11、为什么不需要四次握手？"></a>11、为什么不需要四次握手？</h3><p>有人可能会说 A 发出第三次握手的信息后在没有接收到 B 的请求就已经进入了连接状态，那如果 A 的这个确认包丢失或者滞留了怎么办？</p>
<p>我们需要明白一点，完全可靠的通信协议是不存在的。在经过三次握手之后，客户端和服务端已经可以确认之前的通信状况，都收到了确认信息。所以即便再增加握手次数也不能保证后面的通信完全可靠，所以是没有必要的。</p>
<h3 id="12、Server-端收到-Client-端的-SYN-后，为什么还要传回-SYN？"><a href="#12、Server-端收到-Client-端的-SYN-后，为什么还要传回-SYN？" class="headerlink" title="12、Server 端收到 Client 端的 SYN 后，为什么还要传回 SYN？"></a>12、Server 端收到 Client 端的 SYN 后，为什么还要传回 SYN？</h3><p>接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。</p>
<p>SYN 是 TCP / IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement[汉译：确认字符，在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误]）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。</p>
<h3 id="13、传了-SYN，为什么还要传-ACK？"><a href="#13、传了-SYN，为什么还要传-ACK？" class="headerlink" title="13、传了 SYN，为什么还要传 ACK？"></a>13、传了 SYN，为什么还要传 ACK？</h3><p>双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。</p>
<h3 id="14、详细说下-TCP-四次挥手的过程？"><a href="#14、详细说下-TCP-四次挥手的过程？" class="headerlink" title="14、详细说下 TCP 四次挥手的过程？"></a>14、详细说下 TCP 四次挥手的过程？</h3><p>据传输结束后，通信的双方都可以释放连接。现在 A 和 B 都处于 ESTABLISHED 状态。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201030090638.webp" alt="img"></p>
<p>第一次挥手：A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。A 把连接释放报文段首部的终止控制位 FIN 置 1，其序号 seq = u（等于前面已传送过的数据的最后一个字节的序号加 1），这时 A 进入 FIN-WAIT-1（终止等待1）状态，等待 B 的确认。请注意：TCP 规定，FIN 报文段即使不携带数据，也将消耗掉一个序号。</p>
<p>第二次挥手：B 收到连接释放报文段后立即发出确认，确认号是 ack = u + 1，而这个报文段自己的序号是 v（等于 B 前面已经传送过的数据的最后一个字节的序号加1），然后 B 就进入 CLOSE-WAIT（关闭等待）状态。TCP 服务端进程这时应通知高层应用进程，因而从 A 到 B 这个方向的连接就释放了，这时的 TCP 连接处于半关闭（half-close）状态，即 A 已经没有数据要发送了，但 B 若发送数据，A 仍要接收。也就是说，从 B 到 A 这个方向的连接并未关闭，这个状态可能会持续一段时间。A 收到来自 B 的确认后，就进入 FIN-WAIT-2(终止等待2)状态，等待 B 发出的连接释放报文段。</p>
<p>第三次挥手：若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。这时 B 发出的连接释放报文段必须使 FIN = 1。假定 B 的序号为 w（在半关闭状态，B 可能又发送了一些数据）。B 还必须重复上次已发送过的确认号 ack = u + 1。这时 B 就进入 LAST-ACK(最后确认)状态，等待 A 的确认。</p>
<p>第四次挥手：A 在收到 B 的连接释放报文后，必须对此发出确认。在确认报文段中把 ACK 置 1，确认号 ack = w + 1，而自己的序号 seq = u + 1（前面发送的 FIN 报文段要消耗一个序号）。然后进入 TIME-WAIT(时间等待) 状态。请注意，现在 TCP 连接还没有释放掉。必须经过时间等待计时器设置的时间 2MSL（MSL：最长报文段寿命）后，A 才能进入到 CLOSED 状态，然后撤销传输控制块，结束这次 TCP 连接。当然如果 B 一收到 A 的确认就进入 CLOSED 状态，然后撤销传输控制块。所以在释放连接时，B 结束 TCP 连接的时间要早于 A。</p>
<h3 id="15、为什么-TIME-WAIT-状态必须等待-2MSL-的时间呢？"><a href="#15、为什么-TIME-WAIT-状态必须等待-2MSL-的时间呢？" class="headerlink" title="15、为什么 TIME-WAIT 状态必须等待 2MSL 的时间呢？"></a>15、为什么 TIME-WAIT 状态必须等待 2MSL 的时间呢？</h3><p>\1. 为了保证 A 发送的最后一个 ACK 报文段能够到达 B。这个 ACK 报文段有可能丢失，因而使处在 LAST-ACK 状态的 B 收不到对已发送的 FIN + ACK 报文段的确认。B 会超时重传这个 FIN+ACK 报文段，而 A 就能在 2MSL 时间内（超时 + 1MSL 传输）收到这个重传的 FIN+ACK 报文段。接着 A 重传一次确认，重新启动 2MSL 计时器。最后，A 和 B 都正常进入到 CLOSED 状态。如果 A 在 TIME-WAIT 状态不等待一段时间，而是在发送完 ACK 报文段后立即释放连接，那么就无法收到 B 重传的 FIN + ACK 报文段，因而也不会再发送一次确认报文段，这样，B 就无法按照正常步骤进入 CLOSED 状态。</p>
<p>\2. 防止已失效的连接请求报文段出现在本连接中。A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。</p>
<h3 id="16、为什么第二次跟第三次不能合并-第二次和第三次之间的等待是什么"><a href="#16、为什么第二次跟第三次不能合并-第二次和第三次之间的等待是什么" class="headerlink" title="16、为什么第二次跟第三次不能合并, 第二次和第三次之间的等待是什么?"></a>16、为什么第二次跟第三次不能合并, 第二次和第三次之间的等待是什么?</h3><p>当服务器执行第二次挥手之后, 此时证明客户端不会再向服务端请求任何数据, 但是服务端可能还正在给客户端发送数据（可能是客户端上一次请求的资源还没有发送完毕），所以此时服务端会等待把之前未传输完的数据传输完毕之后再发送关闭请求。</p>
<h3 id="17、保活计时器的作用？"><a href="#17、保活计时器的作用？" class="headerlink" title="17、保活计时器的作用？"></a>17、保活计时器的作用？</h3><p>除时间等待计时器外，TCP 还有一个保活计时器（keepalive  timer）。设想这样的场景：客户已主动与服务器建立了 TCP 连接。但后来客户端的主机突然发生故障。显然，服务器以后就不能再收到客户端发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就需要使用保活计时器了。</p>
<p>服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两个小时。若两个小时都没有收到客户端的数据，服务端就发送一个探测报文段，以后则每隔  75 秒钟发送一次。若连续发送 10个 探测报文段后仍然无客户端的响应，服务端就认为客户端出了故障，接着就关闭这个连接。</p>
<h3 id="18、TCP-协议是如何保证可靠传输的？"><a href="#18、TCP-协议是如何保证可靠传输的？" class="headerlink" title="18、TCP 协议是如何保证可靠传输的？"></a>18、TCP 协议是如何保证可靠传输的？</h3><p>\1. 数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时 TCP 发送数据端超时后会重发数据；</p>
<p>\2. 对失序数据包重排序：既然 TCP 报文段作为 IP 数据报来传输，而 IP 数据报的到达可能会失序，因此 TCP 报文段的到达也可能会失序。TCP 将对失序数据进行重新排序，然后才交给应用层；</p>
<p>\3. 丢弃重复数据：对于重复数据，能够丢弃重复数据；</p>
<p>\4. 应答机制：当 TCP 收到发自 TCP 连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；</p>
<p>\5. 超时重发：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；</p>
<p>\6. 流量控制：TCP 连接的每一方都有固定大小的缓冲空间。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP 使用的流量控制协议是可变大小的滑动窗口协议。</p>
<h3 id="19、谈谈你对停止等待协议的理解？"><a href="#19、谈谈你对停止等待协议的理解？" class="headerlink" title="19、谈谈你对停止等待协议的理解？"></a>19、谈谈你对停止等待协议的理解？</h3><p>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组；在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。主要包括以下几种情况：无差错情况、出现差错情况（超时重传）、确认丢失和确认迟到、确认丢失和确认迟到。</p>
<h3 id="20、谈谈你对-ARQ-协议的理解？"><a href="#20、谈谈你对-ARQ-协议的理解？" class="headerlink" title="20、谈谈你对 ARQ 协议的理解？"></a>20、谈谈你对 ARQ 协议的理解？</h3><ul>
<li><strong>自动重传请求 ARQ 协议</strong></li>
</ul>
<p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求 ARQ。</p>
<ul>
<li><strong>连续 ARQ 协议</strong></li>
</ul>
<p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p>
<h3 id="21、谈谈你对滑动窗口的了解？"><a href="#21、谈谈你对滑动窗口的了解？" class="headerlink" title="21、谈谈你对滑动窗口的了解？"></a>21、谈谈你对滑动窗口的了解？</h3><p>TCP 利用滑动窗口实现流量控制的机制。滑动窗口（Sliding window）是一种流量控制技术。早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。</p>
<p>TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。</p>
<h3 id="22、谈下你对流量控制的理解？"><a href="#22、谈下你对流量控制的理解？" class="headerlink" title="22、谈下你对流量控制的理解？"></a>22、谈下你对流量控制的理解？</h3><p>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<h3 id="23、谈下你对-TCP-拥塞控制的理解？使用了哪些算法？"><a href="#23、谈下你对-TCP-拥塞控制的理解？使用了哪些算法？" class="headerlink" title="23、谈下你对 TCP 拥塞控制的理解？使用了哪些算法？"></a>23、谈下你对 TCP 拥塞控制的理解？使用了哪些算法？</h3><p>拥塞控制和流量控制不同，前者是一个全局性的过程，而后者指点对点通信量的控制。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。</p>
<p>拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致于过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>
<p>为了进行拥塞控制，TCP 发送方要维持一个拥塞窗口(cwnd) 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p>
<p>TCP 的拥塞控制采用了四种算法，即：慢开始、拥塞避免、快重传和快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如：主动队列管理 AQM），以减少网络拥塞的发生。</p>
<ul>
<li><strong>慢开始：</strong> </li>
</ul>
<p>慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。</p>
<ul>
<li><strong>拥塞避免：</strong> </li>
</ul>
<p>拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送方的 cwnd 加 1。</p>
<ul>
<li><strong>快重传与快恢复：</strong> </li>
</ul>
<p>在 TCP/IP 中，快速重传和快恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。</p>
<p>没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。</p>
<p>有了 FRR，就不会因为重传时要求的暂停被耽误。当有单独的数据包丢失时，快速重传和快恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</p>
<h3 id="24、什么是粘包？"><a href="#24、什么是粘包？" class="headerlink" title="24、什么是粘包？"></a>24、什么是粘包？</h3><p>在进行 Java NIO 学习时，可能会发现：如果客户端连续不断的向服务端发送数据包时，服务端接收的数据会出现两个数据包粘在一起的情况。</p>
<p>\1. TCP 是基于字节流的，虽然应用层和 TCP 传输层之间的数据交互是大小不等的数据块，但是 TCP 把这些数据块仅仅看成一连串无结构的字节流，没有边界；</p>
<p>\2. 从 TCP 的帧结构也可以看出，在 TCP 的首部没有表示数据长度的字段。</p>
<p>基于上面两点，在使用 TCP 传输数据时，才有粘包或者拆包现象发生的可能。一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。</p>
<p>接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。拆包和粘包的问题导致接收端在处理的时候会非常困难，因为无法区分一个完整的数据包。</p>
<h3 id="25、TCP-黏包是怎么产生的？"><a href="#25、TCP-黏包是怎么产生的？" class="headerlink" title="25、TCP 黏包是怎么产生的？"></a>25、TCP 黏包是怎么产生的？</h3><ul>
<li><strong>发送方产生粘包</strong></li>
</ul>
<p>采用 TCP 协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据。但当发送的数据包过于的小时，那么 TCP 协议默认的会启用 Nagle 算法，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了。</p>
<ul>
<li><strong>接收方产生粘包</strong></li>
</ul>
<p>接收方采用 TCP 协议接收数据时的过程是这样的：数据到接收方，从网络模型的下方传递至传输层，传输层的 TCP 协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C 语言用 recv、read 等函数）；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包。（放数据的速度 &gt; 应用层拿数据速度）</p>
<h3 id="26、怎么解决拆包和粘包？"><a href="#26、怎么解决拆包和粘包？" class="headerlink" title="26、怎么解决拆包和粘包？"></a>26、怎么解决拆包和粘包？</h3><p>分包机制一般有两个通用的解决方法：</p>
<p>\1. 特殊字符控制；</p>
<p>\2. 在包头首都添加数据包的长度。</p>
<p>如果使用 netty 的话，就有专门的编码器和解码器解决拆包和粘包问题了。</p>
<p>tips：UDP 没有粘包问题，但是有丢包和乱序。不完整的包是不会有的，收到的都是完全正确的包。传送的数据单位协议是 UDP 报文或用户数据报，发送的时候既不合并，也不拆分。</p>
<h3 id="27、你对-HTTP-状态码有了解吗？"><a href="#27、你对-HTTP-状态码有了解吗？" class="headerlink" title="27、你对 HTTP 状态码有了解吗？"></a>27、你对 HTTP 状态码有了解吗？</h3><ul>
<li><strong>1XX 信息</strong></li>
</ul>
<p>\1. 100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</p>
<ul>
<li><strong>2XX 成功</strong></li>
</ul>
<p>\1. 200 OK</p>
<p>\2. 204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</p>
<p>\3. 206 Partial Content ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。</p>
<ul>
<li><strong>3XX 重定向</strong></li>
</ul>
<p>\1. 301 Moved Permanently ：永久性重定向；</p>
<p>\2. 302 Found ：临时性重定向；</p>
<p>\3. 303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</p>
<p>\4. 304 Not Modified ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</p>
<p>\5. 307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</p>
<ul>
<li><strong>4XX 客户端错误</strong></li>
</ul>
<p>\1. 400 Bad Request ：请求报文中存在语法错误。</p>
<p>\2. 401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</p>
<p>\3. 403 Forbidden ：请求被拒绝。</p>
<p>\4. 404 Not Found</p>
<ul>
<li><strong>5XX 服务器错误</strong></li>
</ul>
<p>\1. 500 Internal Server Error ：服务器正在执行请求时发生错误；</p>
<p>\2. 503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</p>
<h3 id="28、HTTP-状态码-301-和-302-代表的是什么？有什么区别？"><a href="#28、HTTP-状态码-301-和-302-代表的是什么？有什么区别？" class="headerlink" title="28、HTTP 状态码 301 和 302 代表的是什么？有什么区别？"></a>28、HTTP 状态码 301 和 302 代表的是什么？有什么区别？</h3><p>301，302 都是 HTTP 状态的编码，都代表着某个 URL 发生了转移。</p>
<ul>
<li><strong>区别：</strong> </li>
</ul>
<p>301 redirect: 301 代表永久性转移（Permanently Moved）</p>
<p>302 redirect: 302 代表暂时性转移（Temporarily Moved）</p>
<h3 id="29、forward-和-redirect-的区别？"><a href="#29、forward-和-redirect-的区别？" class="headerlink" title="29、forward 和 redirect 的区别？"></a>29、forward 和 redirect 的区别？</h3><p>Forward 和 Redirect 代表了两种请求转发方式：直接转发和间接转发。</p>
<p>直接转发方式（Forward）：客户端和浏览器只发出一次请求，Servlet、HTML、JSP 或其它信息资源，由第二个信息资源响应该请求，在请求对象 request 中，保存的对象对于每个信息资源是共享的。</p>
<p>间接转发方式（Redirect）：实际是两次 HTTP 请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个 URL 发出请求，从而达到转发的目的。</p>
<ul>
<li>举个通俗的例子：　</li>
</ul>
<p>直接转发就相当于：“A 找 B 借钱，B 说没有，B 去找 C 借，借到借不到都会把消息传递给 A”；</p>
<p>间接转发就相当于：”A 找 B 借钱，B 说没有，让 A 去找 C 借”。</p>
<h3 id="30、HTTP-方法有哪些？"><a href="#30、HTTP-方法有哪些？" class="headerlink" title="30、HTTP 方法有哪些？"></a>30、HTTP 方法有哪些？</h3><p>客户端发送的 请求报文 第一行为请求行，包含了方法字段。</p>
<p>\1. GET：获取资源，当前网络中绝大部分使用的都是 GET；</p>
<p>\2. HEAD：获取报文首部，和 GET 方法类似，但是不返回报文实体主体部分；</p>
<p>\3. POST：传输实体主体</p>
<p>\4. PUT：上传文件，由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。</p>
<p>\5. PATCH：对资源进行部分修改。PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。</p>
<p>\6. OPTIONS：查询指定的 URL 支持的方法；</p>
<p>\7. CONNECT：要求在与代理服务器通信时建立隧道。使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。</p>
<p>\8. TRACE：追踪路径。服务器会将通信路径返回给客户端。发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。</p>
<h3 id="31、说下-GET-和-POST-的区别？"><a href="#31、说下-GET-和-POST-的区别？" class="headerlink" title="31、说下 GET 和 POST 的区别？"></a>31、说下 GET 和 POST 的区别？</h3><p>GET 和 POST 本质都是 HTTP 请求，只不过对它们的作用做了界定和适配，并且让他们适应各自的场景。</p>
<p>本质区别：GET 只是一次 HTTP请求，POST 先发请求头再发请求体，实际上是两次请求。</p>
<p>\1. 从功能上讲，GET 一般用来从服务器上获取资源，POST 一般用来更新服务器上的资源；</p>
<p>\2. 从 REST 服务角度上说，GET 是幂等的，即读取同一个资源，总是得到相同的数据，而 POST 不是幂等的，因为每次请求对资源的改变并不是相同的；进一步地，GET 不会改变服务器上的资源，而 POST 会对服务器资源进行改变；</p>
<p>\3. 从请求参数形式上看，GET 请求的数据会附在 URL 之后，即将请求数据放置在 HTTP 报文的 请求头 中，以 ? 分割 URL 和传输数据，参数之间以 &amp; 相连。特别地，如果数据是英文字母/数字，原样发送；否则，会将其编码为 application/x-www-form-urlencoded MIME 字符串(如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用 BASE64 加密，得出如：%E4%BD%A0%E5%A5%BD，其中 ％XX 中的 XX 为该符号以 16 进制表示的 ASCII)；而 POST 请求会把提交的数据则放置在是 HTTP 请求报文的 请求体 中；</p>
<p>\4. 就安全性而言，POST 的安全性要比 GET 的安全性高，因为 GET 请求提交的数据将明文出现在 URL 上，而且 POST 请求参数则被包装到请求体中，相对更安全；</p>
<p>\5. 从请求的大小看，GET 请求的长度受限于浏览器或服务器对 URL 长度的限制，允许发送的数据量比较小，而 POST 请求则是没有大小限制的。</p>
<h3 id="32、在浏览器中输入-URL-地址到显示主页的过程？"><a href="#32、在浏览器中输入-URL-地址到显示主页的过程？" class="headerlink" title="32、在浏览器中输入 URL 地址到显示主页的过程？"></a>32、在浏览器中输入 URL 地址到显示主页的过程？</h3><p>\1. DNS 解析：浏览器查询 DNS，获取域名对应的 IP 地址：具体过程包括浏览器搜索自身的 DNS 缓存、搜索操作系统的 DNS 缓存、读取本地的 Host 文件和向本地 DNS 服务器进行查询等。对于向本地 DNS 服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地 DNS 服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个 IP 地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；</p>
<p>\2. TCP 连接：浏览器获得域名对应的 IP 地址以后，浏览器向服务器请求建立链接，发起三次握手；</p>
<p>\3. 发送 HTTP 请求：TCP 连接建立起来后，浏览器向服务器发送 HTTP 请求；</p>
<p>\4. 服务器处理请求并返回 HTTP 报文：服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；</p>
<p>\5. 浏览器解析渲染页面：浏览器解析并渲染视图，若遇到对 js 文件、css 文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。</p>
<p>\6. 连接结束。</p>
<h3 id="33、DNS-的解析过程？"><a href="#33、DNS-的解析过程？" class="headerlink" title="33、DNS 的解析过程？"></a>33、DNS 的解析过程？</h3><p>\1. 主机向本地域名服务器的查询一般都是采用递归查询。所谓递归查询就是：如果主机所询问的本地域名服务器不知道被查询的域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的 IP 地址，或者是报错，表示无法查询到所需的 IP 地址。</p>
<p>\2. 本地域名服务器向根域名服务器的查询的迭代查询。迭代查询的特点：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的 IP 地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的 IP 地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。最后，本地域名服务器得到了所要解析的 IP 地址或报错，然后把这个结果返回给发起查询的主机。</p>
<h3 id="34、谈谈你对域名缓存的了解？"><a href="#34、谈谈你对域名缓存的了解？" class="headerlink" title="34、谈谈你对域名缓存的了解？"></a>34、谈谈你对域名缓存的了解？</h3><p>为了提高 DNS 查询效率，并减轻服务器的负荷和减少因特网上的 DNS 查询报文数量，在域名服务器中广泛使用了高速缓存，用来存放最近查询过的域名以及从何处获得域名映射信息的记录。</p>
<p>由于名字到地址的绑定并不经常改变，为保持高速缓存中的内容正确，域名服务器应为每项内容设置计时器并处理超过合理时间的项（例如：每个项目两天）。当域名服务器已从缓存中删去某项信息后又被请求查询该项信息，就必须重新到授权管理该项的域名服务器绑定信息。当权限服务器回答一个查询请求时，在响应中都指明绑定有效存在的时间值。增加此时间值可减少网络开销，而减少此时间值可提高域名解析的正确性。</p>
<p>不仅在本地域名服务器中需要高速缓存，在主机中也需要。许多主机在启动时从本地服务器下载名字和地址的全部数据库，维护存放自己最近使用的域名的高速缓存，并且只在从缓存中找不到名字时才使用域名服务器。维护本地域名服务器数据库的主机应当定期地检查域名服务器以获取新的映射信息，而且主机必须从缓存中删除无效的项。由于域名改动并不频繁，大多数网点不需花精力就能维护数据库的一致性。</p>
<h3 id="35、谈下你对-HTTP-长连接和短连接的理解？分别应用于哪些场景？"><a href="#35、谈下你对-HTTP-长连接和短连接的理解？分别应用于哪些场景？" class="headerlink" title="35、谈下你对 HTTP 长连接和短连接的理解？分别应用于哪些场景？"></a>35、谈下你对 HTTP 长连接和短连接的理解？分别应用于哪些场景？</h3><p>在 HTTP/1.0 中默认使用短连接。也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如：JavaScript 文件、图像文件、CSS 文件等），每遇到这样一个 Web 资源，浏览器就会重新建立一个 HTTP 会话。</p>
<p>而从 HTTP/1.1 起，默认使用长连接，用以保持连接特性。使用长连接的 HTTP 协议，会在响应头加入这行代码</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Connection:</span><span class="meta">keep</span>-alive复制代码</span><br></pre></td></tr></table></figure>

<p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。</p>
<p>Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如：Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p>
<h3 id="36、谈下-HTTP-1-0-和-1-1、1-2-的主要变化？"><a href="#36、谈下-HTTP-1-0-和-1-1、1-2-的主要变化？" class="headerlink" title="36、谈下 HTTP 1.0 和 1.1、1.2 的主要变化？"></a>36、谈下 HTTP 1.0 和 1.1、1.2 的主要变化？</h3><ul>
<li><strong>HTTP1.1 的主要变化：</strong></li>
</ul>
<p>\1. HTTP1.0 经过多年发展，在 1.1 提出了改进。首先是提出了长连接，HTTP 可以在一次 TCP 连接中不断发送请求。</p>
<p>\2. 然后 HTTP1.1 支持只发送 header 而不发送 body。原因是先用 header 判断能否成功，再发数据，节约带宽，事实上，post 请求默认就是这样做的。</p>
<p>\3. HTTP1.1 的 host 字段。由于虚拟主机可以支持多个域名，所以一般将域名解析后得到 host。</p>
<ul>
<li><strong>HTTP2.0 的主要变化：</strong></li>
</ul>
<p>\1. HTTP2.0 支持多路复用，同一个连接可以并发处理多个请求，方法是把 HTTP数据包拆为多个帧，并发有序的发送，根据序号在另一端进行重组，而不需要一个个 HTTP请求顺序到达；</p>
<p>\2. HTTP2.0 支持服务端推送，就是服务端在 HTTP 请求到达后，除了返回数据之外，还推送了额外的内容给客户端；</p>
<p>\3. HTTP2.0 压缩了请求头，同时基本单位是二进制帧流，这样的数据占用空间更少；</p>
<p>\4. HTTP2.0 适用于 HTTPS 场景，因为其在 HTTP和 TCP 中间加了一层 SSL 层。</p>
<h3 id="37、HTTPS-的工作过程？"><a href="#37、HTTPS-的工作过程？" class="headerlink" title="37、HTTPS 的工作过程？"></a>37、HTTPS 的工作过程？</h3><p>\1. 客户端发送自己支持的加密规则给服务器，代表告诉服务器要进行连接了；</p>
<p>\2. 服务器从中选出一套加密算法和 hash 算法以及自己的身份信息（地址等）以证书的形式发送给浏览器，证书中包含服务器信息，加密公钥，证书的办法机构；</p>
<p>\3. 客户端收到网站的证书之后要做下面的事情： </p>
<ul>
<li>3.1 验证证书的合法性；</li>
<li>3.2 果验证通过证书，浏览器会生成一串随机数，并用证书中的公钥进行加密；</li>
<li>3.3 用约定好的 hash 算法计算握手消息，然后用生成的密钥进行加密，然后一起发送给服务器。</li>
</ul>
<p>\4. 服务器接收到客户端传送来的信息，要做下面的事情： </p>
<ul>
<li>4.1 用私钥解析出密码，用密码解析握手消息，验证 hash 值是否和浏览器发来的一致；</li>
<li>4.2 使用密钥加密消息；</li>
</ul>
<p>\5. 如果计算法 hash 值一致，握手成功。</p>
<h3 id="38、HTTP-和-HTTPS-的区别？"><a href="#38、HTTP-和-HTTPS-的区别？" class="headerlink" title="38、HTTP 和 HTTPS 的区别？"></a>38、HTTP 和 HTTPS 的区别？</h3><p>\1. 开销：HTTPS 协议需要到 CA 申请证书，一般免费证书很少，需要交费；</p>
<p>\2. 资源消耗：HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 ssl 加密传输协议，需要消耗更多的 CPU 和内存资源；</p>
<p>\3. 端口不同：HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是  80，后者是 443；</p>
<p>\4. 安全性：HTTP 的连接很简单，是无状态的；HTTPS 协议是由 TSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。</p>
<h3 id="39、HTTPS-的优缺点？"><a href="#39、HTTPS-的优缺点？" class="headerlink" title="39、HTTPS 的优缺点？"></a>39、HTTPS 的优缺点？</h3><ul>
<li><strong>优点：</strong></li>
</ul>
<p>\1. 使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</p>
<p>\2. HTTPS 协议是由 SSL + HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性；</p>
<p>\3. HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</p>
<ul>
<li><strong>缺点：</strong></li>
</ul>
<p>\1. HTTPS 协议握手阶段比较费时，会使页面的加载时间延长近 50%，增加 10% 到 20% 的耗电；</p>
<p>\2. HTTPS 连接缓存不如 HTTP 高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；</p>
<p>\3. SSL 证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用；</p>
<p>\4. SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗；</p>
<p>\5. HTTPS 协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行。</p>
<h3 id="40、什么是数字签名？"><a href="#40、什么是数字签名？" class="headerlink" title="40、什么是数字签名？"></a>40、什么是数字签名？</h3><p>为了避免数据在传输过程中被替换，比如黑客修改了你的报文内容，但是你并不知道，所以我们让发送端做一个数字签名，把数据的摘要消息进行一个加密，比如 MD5，得到一个签名，和数据一起发送。然后接收端把数据摘要进行 MD5 加密，如果和签名一样，则说明数据确实是真的。</p>
<h3 id="41、什么是数字证书？"><a href="#41、什么是数字证书？" class="headerlink" title="41、什么是数字证书？"></a>41、什么是数字证书？</h3><p>对称加密中，双方使用公钥进行解密。虽然数字签名可以保证数据不被替换，但是数据是由公钥加密的，如果公钥也被替换，则仍然可以伪造数据，因为用户不知道对方提供的公钥其实是假的。所以为了保证发送方的公钥是真的，CA 证书机构会负责颁发一个证书，里面的公钥保证是真的，用户请求服务器时，服务器将证书发给用户，这个证书是经由系统内置证书的备案的。</p>
<h3 id="42、什么是对称加密和非对称加密？"><a href="#42、什么是对称加密和非对称加密？" class="headerlink" title="42、什么是对称加密和非对称加密？"></a>42、什么是对称加密和非对称加密？</h3><p>对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方。</p>
<p>非对称加密指使用一对非对称密钥，即：公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。</p>
<p>由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性。但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发</title>
    <url>/2020/10/14/0000.Java%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h2 id="1-Synchronize关键字原理"><a href="#1-Synchronize关键字原理" class="headerlink" title="1. Synchronize关键字原理"></a>1. Synchronize关键字原理</h2><p>众所周知 <code>Synchronize</code> 关键字是解决并发问题常用解决方案，有以下三种使用方式:</p>
<ul>
<li>同步普通方法，锁的是当前对象。</li>
<li>同步静态方法，锁的是当前 <code>Class</code> 对象。</li>
<li>同步块，锁的是 <code>&#123;&#125;</code> 中的对象。</li>
</ul>
<p> <strong>实现原理：</strong><br><code>JVM</code> 是通过进入、退出对象监视器( <code>Monitor</code> )来实现对方法、同步块的同步的。</p>
<p>具体实现是在编译之后在同步方法调用前加入一个 <code>monitor.enter</code> 指令，在退出方法和异常处插入 <code>monitor.exit</code> 的指令。</p>
<p>其本质就是对一个对象监视器( <code>Monitor</code> )进行获取，而这个获取过程具有排他性从而达到了同一时刻只能一个线程访问的目的。</p>
<p>而对于没有获取到锁的线程将会阻塞到方法入口处，直到获取锁的线程 <code>monitor.exit</code> 之后才能尝试继续获取锁。</p>
<p>流程图如下:</p>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/094206_13b9dc67_1478371.jpeg"></p>
<h3 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h3><ul>
<li>Hotspot虚拟机的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。其中Klass Point是是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，Mark Word用于存储对象自身的运行时数据，它是实现轻量级锁和偏向锁的关键</li>
</ul>
<h3 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h3><ul>
<li>Mark Word用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。Java对象头一般占有两个机器码,但是如果对象是数组类型，则需要三个机器码，因为JVM虚拟机可以通过Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据来确认数组的大小，所以用一块来记录数组长度。<br><img src="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/02/222222_2-1.jpg" alt="输入图片说明" title="在这里输入图片标题"></li>
<li>对象头信息是与对象自身定义的数据无关的额外存储成本，但是考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据，它会根据对象的状态复用自己的存储空间，也就是说，Mark Word会随着程序的运行发生变化，变化状态如下（32位虚拟机）：<br><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/094206_09228ac9_1478371.jpeg" alt="输入图片说明" title="在这里输入图片标题"></li>
</ul>
<h3 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h3><ul>
<li>什么是Monitor？我们可以把它理解为一个同步工具，也可以描述为一种同步机制，它通常被描述为一个对象。</li>
<li>与一切皆对象一样，所有的Java对象是天生的Monitor，每一个Java对象都有成为Monitor的潜质，因为在Java的设计中 ，每一个Java对象自打娘胎里出来就带了一把看不见的锁，它叫做内部锁或者Monitor锁。</li>
<li>Monitor 是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。</li>
<li>每一个被锁住的对象都会和一个monitor关联（对象头的MarkWord中的LockWord指向monitor的起始地址），同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/094206_14c72ca4_1478371.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<ol>
<li>Owner：初始时为NULL表示当前没有任何线程拥有该monitor record，当线程成功拥有该锁后保存线程唯一标识，当锁被释放时又设置为NULL；</li>
<li>EntryQ:关联一个系统互斥锁（semaphore），阻塞所有试图锁住monitor record失败的线程</li>
<li>RcThis:表示blocked或waiting在该monitor record上的所有线程的个数。</li>
<li>Nest:用来实现重入锁的计数。</li>
<li>HashCode:保存从对象头拷贝过来的HashCode值（可能还包含GC age）。</li>
<li>Candidate:用来避免不必要的阻塞或等待线程唤醒，因为每一次只有一个线程能够成功拥有锁，如果每次前一个释放锁的线程唤醒所有正在阻塞或等待的线程，会引起不必要的上下文切换（从阻塞到就绪然后因为竞争锁失败又被阻塞）从而导致性能严重下降。Candidate只有两种可能的值0表示没有需要唤醒的线程1表示要唤醒一个继任线程来竞争锁。</li>
</ol>
<h3 id="jdk1-6开始对锁锁优化"><a href="#jdk1-6开始对锁锁优化" class="headerlink" title="jdk1.6开始对锁锁优化"></a>jdk1.6开始对锁锁优化</h3><ul>
<li><code>synchronize</code>  很多都称之为重量锁，<code>JDK1.6</code> 中对 <code>synchronize</code> 进行了各种优化，为了能减少获取和释放锁带来的消耗引入了<code>偏向锁</code>和<code>轻量锁</code>。</li>
<li>锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</li>
</ul>
<h3 id="轻量锁"><a href="#轻量锁" class="headerlink" title="轻量锁"></a>轻量锁</h3><p>当代码进入同步块时，如果同步对象为无锁状态时，当前线程会在栈帧中创建一个锁记录(<code>Lock Record</code>)区域，同时将锁对象的对象头中 <code>Mark Word</code> 拷贝到锁记录中，再尝试使用 <code>CAS</code> 将 <code>Mark Word</code> 更新为指向锁记录的指针。</p>
<p>如果更新<strong>成功</strong>，当前线程就获得了锁。</p>
<p>如果更新<strong>失败</strong> <code>JVM</code> 会先检查锁对象的 <code>Mark Word</code> 是否指向当前线程的锁记录。</p>
<p>如果是则说明当前线程拥有锁对象的锁，可以直接进入同步块。</p>
<p>不是则说明有其他线程抢占了锁，如果存在多个线程同时竞争一把锁，<strong>轻量锁就会膨胀为重量锁</strong>。</p>
<h4 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h4><p>轻量锁的解锁过程也是利用 <code>CAS</code> 来实现的，会尝试锁记录替换回锁对象的 <code>Mark Word</code> 。如果替换成功则说明整个同步操作完成，失败则说明有其他线程尝试获取锁，这时就会唤醒被挂起的线程(此时已经膨胀为<code>重量锁</code>)</p>
<p>轻量锁能提升性能的原因是：</p>
<p>认为大多数锁在整个同步周期都不存在竞争，所以使用 <code>CAS</code> 比使用互斥开销更少。但如果锁竞争激烈，轻量锁就不但有互斥的开销，还有 <code>CAS</code> 的开销，甚至比重量锁更慢。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>为了进一步的降低获取锁的代价，<code>JDK1.6</code> 之后还引入了偏向锁。</p>
<p>偏向锁的特征是:锁不存在多线程竞争，并且应由一个线程多次获得锁。</p>
<p>当线程访问同步块时，会使用 <code>CAS</code> 将线程 ID 更新到锁对象的 <code>Mark Word</code> 中，如果更新成功则获得偏向锁，并且之后每次进入这个对象锁相关的同步块时都不需要再次获取锁了。</p>
<h4 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h4><p>当有另外一个线程获取这个锁时，持有偏向锁的线程就会释放锁，释放时会等待全局安全点(这一时刻没有字节码运行)，接着会暂停拥有偏向锁的线程，根据锁对象目前是否被锁来判定将对象头中的 <code>Mark Word</code> 设置为无锁或者是轻量锁状态。</p>
<p>偏向锁可以提高带有同步却没有竞争的程序性能，但如果程序中大多数锁都存在竞争时，那偏向锁就起不到太大作用。可以使用 <code>-XX:-userBiasedLocking=false</code> 来关闭偏向锁，并默认进入轻量锁。</p>
<h3 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h3><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><ul>
<li><p>线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。同时我们发现在许多应用上面，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的。所以引入自旋锁。</p>
<p><strong>何谓自旋锁？</strong> </p>
</li>
<li><p>所谓自旋锁，就是让该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。怎么等待呢？执行一段无意义的循环即可（自旋）。</p>
</li>
<li><p>自旋等待不能替代阻塞，先不说对处理器数量的要求,虽然它可以避免线程切换带来的开销，但是它占用了处理器的时间。如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好，反之，自旋的线程就会白白消耗掉处理的资源，它不会做任何有意义的工作，典型的占着茅坑不拉屎，这样反而会带来性能上的浪费。所以说，自旋等待的时间（自旋的次数）必须要有一个限度，如果自旋超过了定义的时间仍然没有获取到锁，则应该被挂起。</p>
</li>
<li><p>自旋锁在JDK 1.4.2中引入，默认关闭，但是可以使用-XX:+UseSpinning开开启，在JDK1.6中默认开启。同时自旋的默认次数为10次，可以通过参数-XX:PreBlockSpin来调整；</p>
</li>
<li><p>如果通过参数-XX:preBlockSpin来调整自旋锁的自旋次数，会带来诸多不便。假如我将参数调整为10，但是系统很多线程都是等你刚刚退出的时候就释放了锁（假如你多自旋一两次就可以获取锁），你是不是很尴尬。于是JDK1.6引入自适应的自旋锁，让虚拟机会变得越来越聪明。</p>
</li>
</ul>
<h3 id="适应性自旋（CAS）"><a href="#适应性自旋（CAS）" class="headerlink" title="适应性自旋（CAS）"></a>适应性自旋（CAS）</h3><ul>
<li>在使用 <code>CAS</code> 时，如果操作失败，<code>CAS</code> 会自旋再次尝试。由于自旋是需要消耗 <code>CPU</code> 资源的，所以如果长期自旋就白白浪费了 <code>CPU</code>。<code>JDK1.6</code>加入了适应性自旋:如果某个锁自旋很少成功获得，那么下一次就会减少自旋。</li>
<li>所谓自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定</li>
<li>线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。</li>
</ul>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><ul>
<li>我们知道在使用同步锁的时候，需要让同步块的作用范围尽可能小—仅在共享数据的实际作用域中才进行同步，这样做的目的是为了使需要同步的操作数量尽可能缩小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。</li>
<li>在大多数的情况下，上述观点是正确的，LZ也一直坚持着这个观点。但是如果一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，所以引入锁粗话的概念。</li>
<li>锁粗话概念比较好理解，就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。如：vector每次add的时候都需要加锁操作，JVM检测到对同一个对象（vector）连续加锁、解锁操作，会合并一个更大范围的加锁、解锁操作，即加锁解锁操作会移到for循环之外。</li>
</ul>
<h3 id="不同锁的比较"><a href="#不同锁的比较" class="headerlink" title="不同锁的比较"></a>不同锁的比较</h3><p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/094206_5f316f33_1478371.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<h2 id="2-volatile关键字的理解"><a href="#2-volatile关键字的理解" class="headerlink" title="2. volatile关键字的理解"></a>2. volatile关键字的理解</h2><p> <strong>具有了以下两点特性：</strong> </p>
<ul>
<li>1 . 保证了不同线程对该变量操作的内存可见性;</li>
<li>2 . 禁止指令重排序</li>
</ul>
<h3 id="内存可见性和是重排序"><a href="#内存可见性和是重排序" class="headerlink" title="内存可见性和是重排序"></a>内存可见性和是重排序</h3><p> <strong>java内存模型（JMM）</strong> </p>
<ul>
<li>Java虚拟机规范试图定义一种Java内存模型（JMM）,来屏蔽掉各种硬件和操作系统的内存访问差异，让Java程序在各种平台上都能达到一致的内存访问效果。</li>
<li>简单来说，由于CPU执行指令的速度是很快的，但是内存访问的速度就慢了很多，相差的不是一个数量级，所以搞处理器的那群大佬们又在CPU里加了好几层高速缓存。</li>
<li>在Java内存模型里，对上述的优化又进行了一波抽象。JMM规定所有变量都是存在主存中的，类似于上面提到的普通内存，每个线程又包含自己的工作内存，方便理解就可以看成CPU上的寄存器或者高速缓存。所以线程的操作都是以工作内存为主，它们只能访问自己的工作内存，且工作前后都要把值在同步回主内存。</li>
</ul>
<p>这么说得我自己都有些不清楚了，拿张纸画一下：<br><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/133856_52bf0ac2_1478371.png" alt="输入图片说明" title="clipboard.png"></p>
<p>在线程执行时，首先会从主存中read变量值，再load到工作内存中的副本中，然后再传给处理器执行，执行完毕后再给工作内存中的副本赋值，随后工作内存再把值传回给主存，主存中的值才更新。</p>
<p>使用工作内存和主存，虽然加快的速度，但是也带来了一些问题。比如看下面一个例子：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">i</span> = i + <span class="number">1</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>假设i初值为0，当只有一个线程执行它时，结果肯定得到1，当两个线程执行时，会得到结果2吗？这倒不一定了。可能存在这种情况：</p>
<p><img src="https://gitee.com/uploads/images/2018/0704/134053_43aae32f_1478371.png" alt="输入图片说明" title="clipboard.png"></p>
<ul>
<li>如果两个线程按照上面的执行流程，那么i最后的值居然是1了。如果最后的写回生效的慢，你再读取i的值，都可能是0，这就是缓存不一致问题。</li>
<li>下面就要提到你刚才问到的问题了，JMM主要就是围绕着如何在并发过程中如何处理原子性、可见性和有序性这3个特征来建立的，通过解决这三个问题，可以解除缓存不一致的问题。而volatile跟可见性和有序性都有关。</li>
</ul>
<h3 id="1-原子性-Atomicity-："><a href="#1-原子性-Atomicity-：" class="headerlink" title="1.原子性(Atomicity)："></a>1.原子性(Atomicity)：</h3><p>Java中，对基本数据类型的读取和赋值操作是原子性操作，所谓原子性操作就是指这些操作是不可中断的，要做一定做完，要么就没有执行。 比如：</p>
<p><img src="https://gitee.com/uploads/images/2018/0704/134216_1d4cdf07_1478371.png" alt="输入图片说明" title="clipboard.png"></p>
<ul>
<li>i=2是读取操作，必定是原子性操作，j=i你以为是原子性操作，其实吧，分为两步，一是读取i的值，然后再赋值给j,这就是2步操作了，称不上原子操作，i++和i = i + 1其实是等效的，读取i的值，加1，再写回主存，那就是3步操作了。所以上面的举例中，最后的值可能出现多种情况，就是因为满足不了原子性。只有简单的读取，赋值是原子操作，还只能是用数字赋值，用变量的话还多了一步读取变量值的操作。有个例外是虚拟机规范中允许对64位数据类型(long和double)，分为2次32为的操作来处理，但是最新JDK实现还是实现了原子操作的。</li>
<li>JMM只实现了基本的原子性，像上面i++那样的操作，必须借助于synchronized和Lock来保证整块代码的原子性了。线程在释放锁之前，必然会把i的值刷回到主存的。</li>
</ul>
<h3 id="2-可见性-Visibility-："><a href="#2-可见性-Visibility-：" class="headerlink" title="2.可见性(Visibility)："></a>2.可见性(Visibility)：</h3><ul>
<li>说到可见性，Java就是利用volatile来提供可见性的。 当一个变量被volatile修饰时，那么对它的修改会立刻刷新到主存，当其它线程需要读取该变量时，会去内存中读取新值。而普通变量则不能保证这一点。</li>
<li>其实通过synchronized和Lock也能够保证可见性，线程在释放锁之前，会把共享变量值都刷回主存，但是synchronized和Lock的开销都更大。</li>
</ul>
<h3 id="3-有序性（Ordering）"><a href="#3-有序性（Ordering）" class="headerlink" title="3.有序性（Ordering）"></a>3.有序性（Ordering）</h3><p>JMM是允许编译器和处理器对指令重排序的，但是规定了as-if-serial语义，即不管怎么重排序，程序的执行结果不能改变。比如下面的程序段：</p>
<p><img src="https://gitee.com/uploads/images/2018/0704/134324_6be6a576_1478371.png" alt="输入图片说明" title="clipboard.png"></p>
<ul>
<li>上面的语句，可以按照A-&gt;B-&gt;C执行，结果为3.14,但是也可以按照B-&gt;A-&gt;C的顺序执行，因为A、B是两句独立的语句，而C则依赖于A、B，所以A、B可以重排序，但是C却不能排到A、B的前面。JMM保证了重排序不会影响到单线程的执行，但是在多线程中却容易出问题。</li>
</ul>
<p> <strong>JMM具备一些先天的有序性,即不需要通过任何手段就可以保证的有序性，通常称为happens-before原则</strong> </p>
<ol>
<li>程序顺序规则： 一个线程中的每个操作，happens-before于该线程中的任意后续操作</li>
<li>监视器锁规则：对一个线程的解锁，happens-before于随后对这个线程的加锁</li>
<li>volatile变量规则： 对一个volatile域的写，happens-before于后续对这个volatile域的读</li>
<li>传递性：如果A happens-before B ,且 B happens-before C, 那么 A happens-before C</li>
<li>start()规则： 如果线程A执行操作ThreadB_start()(启动线程B) , 那么A线程的ThreadB_start()happens-before 于B中的任意操作</li>
<li>join()原则： 如果A执行ThreadB.join()并且成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</li>
<li>interrupt()原则： 对线程interrupt()方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测是否有中断发生</li>
<li>finalize()原则：一个对象的初始化完成先行发生于它的finalize()方法的开始</li>
</ol>
<ul>
<li><p>第1条规则程序顺序规则是说在一个线程里，所有的操作都是按顺序的，但是在JMM里其实只要执行结果一样，是允许重排序的，这边的happens-before强调的重点也是单线程执行结果的正确性，但是无法保证多线程也是如此。</p>
</li>
<li><p>第2条规则监视器规则其实也好理解，就是在加锁之前，确定这个锁之前已经被释放了，才能继续加锁。</p>
</li>
<li><p>第3条规则，就适用到所讨论的volatile，如果一个线程先去写一个变量，另外一个线程再去读，那么写入操作一定在读操作之前。</p>
</li>
<li></li>
<li><p>第4条规则，就是happens-before的传递性。</p>
</li>
</ul>
<h3 id="volatile如何满足并发的三大特性"><a href="#volatile如何满足并发的三大特性" class="headerlink" title="volatile如何满足并发的三大特性"></a>volatile如何满足并发的三大特性</h3><ul>
<li><p>如果一个变量声明成是volatile的，那么当我读变量时，总是能读到它的最新值，这里最新值是指不管其它哪个线程对该变量做了写操作，都会立刻被更新到主存里，我也能从主存里读到这个刚写入的值。也就是说volatile关键字可以保证可见性以及有序性。</p>
<p><strong>从内存语义上来看</strong> </p>
</li>
<li><p>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存</p>
</li>
<li><p>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量。</p>
<p><strong>volatile的两点内存语义能保证可见性和有序性，但是能保证原子性吗？</strong> </p>
</li>
</ul>
<p>首先我回答是不能保证原子性，要是说能保证，也只是对单个volatile变量的读/写具有原子性，但是对于类似volatile++这样的复合操作就无能为力了，比如下面的例子：</p>
<p><img src="https://gitee.com/uploads/images/2018/0704/134603_2e750e61_1478371.png" alt="输入图片说明" title="clipboard.png"></p>
<ul>
<li><p>按道理来说结果是10000，但是运行下很可能是个小于10000的值。有人可能会说volatile不是保证了可见性啊，一个线程对inc的修改，另外一个线程应该立刻看到啊！可是这里的操作inc++是个复合操作啊，包括读取inc的值，对其自增，然后再写回主存。</p>
</li>
<li><p>假设线程A，读取了inc的值为10，这时候被阻塞了，因为没有对变量进行修改，触发不了volatile规则。</p>
</li>
<li><p>线程B此时也读读inc的值，主存里inc的值依旧为10，做自增，然后立刻就被写回主存了，为11。</p>
</li>
<li><p>有人说，volatile不是会使缓存行无效的吗？但是这里线程A读取到线程B也进行操作之前，并没有修改inc值，所以线程B读取的时候，还是读的10。</p>
</li>
<li><p>又有人说，线程B将11写回主存，不会把线程A的缓存行设为无效吗？但是线程A的读取操作已经做过了啊，只有在做读取操作时，发现自己缓存行无效，才会去读主存的值，所以这里线程A只能继续做自增了。</p>
</li>
</ul>
<p>综上所述，在这种复合操作的情景下，原子性的功能是维持不了了。但是volatile在上面那种设置flag值的例子里，由于对flag的读/写操作都是单步的，所以还是能保证原子性的。</p>
<p>要想保证原子性，只能借助于synchronized,Lock以及并发包下的atomic的原子操作类了，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。</p>
<h3 id="volatile底层的实现机制"><a href="#volatile底层的实现机制" class="headerlink" title="volatile底层的实现机制"></a>volatile底层的实现机制</h3><ul>
<li><p>如果把加入volatile关键字的代码和未加入volatile关键字的代码都生成汇编代码，会发现加入volatile关键字的代码会多出一个lock前缀指令。</p>
<p><strong>lock前缀指令实际相当于一个内存屏障，内存屏障提供了以下功能：</strong> </p>
</li>
<li><p>1   重排序时不能把后面的指令重排序到内存屏障之前的位置</p>
</li>
<li><p>2 . 使得本CPU的Cache写入内存</p>
</li>
<li><p>3 . 写入动作也会引起别的CPU或者别的内核无效化其Cache，相当于让新写入的值对别的线程可见。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/134745_53217997_1478371.png" alt="输入图片说明" title="clipboard.png"></p>
<h2 id="3-ConcurrentHashMap-实现原理"><a href="#3-ConcurrentHashMap-实现原理" class="headerlink" title="3.  ConcurrentHashMap 实现原理"></a>3.  ConcurrentHashMap 实现原理</h2><p>由于 <code>HashMap</code> 是一个线程不安全的容器，主要体现在容量大于<code>总量*负载因子</code>发生扩容时会出现环形链表从而导致死循环。</p>
<p>因此需要支持线程安全的并发容器 <code>ConcurrentHashMap</code> 。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201015141802.jpeg"></p>
<p>如图所示，是由 <code>Segment</code> 数组、<code>HashEntry</code> 数组组成，和 <code>HashMap</code> 一样，仍然是数组加链表组成。</p>
<p><code>ConcurrentHashMap</code> 采用了分段锁技术，其中 <code>Segment</code> 继承于 <code>ReentrantLock</code>。不会像 <code>HashTable</code> 那样不管是 <code>put</code> 还是 <code>get</code> 操作都需要做同步处理，理论上 ConcurrentHashMap 支持 <code>CurrencyLevel</code> (Segment 数组数量)的线程并发。每当一个线程占用锁访问一个 <code>Segment</code> 时，不会影响到其他的 <code>Segment</code>。</p>
<h3 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h3><p><code>ConcurrentHashMap</code> 的 <code>get</code> 方法是非常高效的，因为整个过程都不需要加锁。</p>
<p>只需要将 <code>Key</code> 通过 <code>Hash</code> 之后定位到具体的 <code>Segment</code> ，再通过一次 <code>Hash</code> 定位到具体的元素上。由于 <code>HashEntry</code> 中的 <code>value</code> 属性是用 <code>volatile</code> 关键词修饰的，保证了内存可见性，所以每次获取时都是最新值(<a href="https://github.com/crossoverJie/Java-Interview/blob/master/MD/Threadcore.md#%E5%8F%AF%E8%A7%81%E6%80%A7">volatile 相关知识点</a>)。</p>
<h3 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h3><p>内部 <code>HashEntry</code> 类 ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V value;</span><br><span class="line">    <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    HashEntry(<span class="keyword">int</span> hash, K key, V value, HashEntry&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然 HashEntry 中的 value 是用 <code>volatile</code> 关键词修饰的，但是并不能保证并发的原子性，所以 put 操作时仍然需要加锁处理。</p>
<p>首先也是通过 Key 的 Hash 定位到具体的 Segment，在 put 之前会进行一次扩容校验。这里比 HashMap 要好的一点是：HashMap 是插入元素之后再看是否需要扩容，有可能扩容之后后续就没有插入就浪费了本次扩容(扩容非常消耗性能)。</p>
<p>而 ConcurrentHashMap 不一样，它是先将数据插入之后再检查是否需要扩容，之后再做插入。</p>
<h3 id="size-方法"><a href="#size-方法" class="headerlink" title="size 方法"></a>size 方法</h3><p>每个 <code>Segment</code> 都有一个 <code>volatile</code> 修饰的全局变量 <code>count</code> ,求整个 <code>ConcurrentHashMap</code> 的 <code>size</code> 时很明显就是将所有的 <code>count</code> 累加即可。但是 <code>volatile</code> 修饰的变量却不能保证多线程的原子性，所有直接累加很容易出现并发问题。</p>
<p>但如果每次调用 <code>size</code> 方法将其余的修改操作加锁效率也很低。所以做法是先尝试两次将 <code>count</code> 累加，如果容器的 <code>count</code> 发生了变化再加锁来统计 <code>size</code>。</p>
<p>至于 <code>ConcurrentHashMap</code> 是如何知道在统计时大小发生了变化呢，每个 <code>Segment</code> 都有一个 <code>modCount</code> 变量，每当进行一次 <code>put remove</code> 等操作，<code>modCount</code> 将会 +1。只要 <code>modCount</code> 发生了变化就认为容器的大小也在发生变化。</p>
<h2 id="4-什么是死锁"><a href="#4-什么是死锁" class="headerlink" title="4. 什么是死锁"></a>4. 什么是死锁</h2><p> <strong>死锁：是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。 由于资源占用是互斥的，当某个进程提出申请资源后，使得有关进程在无外力协助下，永远分配不到必需的资源而无法继续运行，这就产生了一种特殊现象：死锁。”</strong> </p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class MyTestSiSuo &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">Object</span> o1 = <span class="keyword">new</span> <span class="keyword">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">Object</span> o2 = <span class="keyword">new</span> <span class="keyword">Object</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        </span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> run()&#123;</span><br><span class="line">                <span class="comment">//抢占资源 o1</span></span><br><span class="line">                <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.<span class="built_in">println</span>(<span class="string">&quot;t1 ---Get o1&quot;</span>);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//需要资源o2 但是 t2 独占(未释放) --&gt;互相竞争资源--&gt;死锁</span></span><br><span class="line">                    <span class="keyword">synchronized</span>(o2)&#123;</span><br><span class="line">                        System.out.<span class="built_in">println</span>(<span class="string">&quot;t1 ---Get o2&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> run()&#123;</span><br><span class="line">                <span class="comment">//抢占资源o2</span></span><br><span class="line">                <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">                    System.out.<span class="built_in">println</span>(<span class="string">&quot;t2 ---Get o2&quot;</span>);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//需要资源 o1,但是 t1 独占(未释放) --&gt;互相竞争资源--&gt;死锁</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">                        System.out.<span class="built_in">println</span>(<span class="string">&quot;t2 ---Get o1&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">                </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> <strong>实现过程：</strong> </p>
<ul>
<li>有公共资源o1,o2;程序开始，线程t2抢占资源o2,在同步代码块中，o1也被抢占；线程t1睡眠等待1000ms；</li>
<li>t2在需要资源o1时，此时发现被t1独占，而t1此时睡眠醒来，需要资源o2，发现被t2独占；由此，产生 死锁；</li>
</ul>
<h2 id="5-什么是AQS"><a href="#5-什么是AQS" class="headerlink" title="5. 什么是AQS"></a>5. 什么是AQS</h2><p>Java并发包（JUC）中提供了很多并发工具，这其中，很多我们耳熟能详的并发工具，譬如ReentrangLock、Semaphore，它们的实现都用到了一个共同的基类–AbstractQueuedSynchronizer,简称AQS。AQS是一个用来构建锁和同步器的框架</p>
<h3 id="AQS的基本实现原理"><a href="#AQS的基本实现原理" class="headerlink" title="AQS的基本实现原理"></a>AQS的基本实现原理</h3><p>AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">private volatile int <span class="keyword">state</span>;//共享变量，使用volatile修饰保证线程可见性</span><br></pre></td></tr></table></figure>
<p>状态信息通过procted类型的getState，setState，compareAndSetState进行操作</p>
<h3 id="AQS支持两种同步方式"><a href="#AQS支持两种同步方式" class="headerlink" title="AQS支持两种同步方式"></a>AQS支持两种同步方式</h3><ol>
<li>独占式</li>
<li>共享式</li>
</ol>
<ul>
<li><p>独占式如ReentrantLock，共享式如Semaphore，CountDownLatch，组合式的如ReentrantReadWriteLock。总之，AQS为使用提供了底层支撑，如何组装实现，使用者可以自由发挥。</p>
<p><strong>同步器的设计是基于模板方法模式的，一般的使用方式是这样：</strong> </p>
</li>
</ul>
<ol>
<li><p>使用者继承AbstractQueuedSynchronizer并重写指定的方法。（这些重写方法很简单，无非是对于共享资源state的获取和释放）</p>
</li>
<li><p>将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</p>
<p><strong>AQS定义的这些可重写的方法：</strong> </p>
</li>
<li><p><code>protected boolean tryAcquire(int arg)</code> : 独占式获取同步状态，试着获取，成功返回true，反之为false</p>
</li>
<li><p><code> protected boolean tryRelease(int arg)</code> ：独占式释放同步状态，等待中的其他线程此时将有机会获取到同步状态；</p>
</li>
<li><p><code>protected int tryAcquireShared(int arg)</code> ：共享式获取同步状态，返回值大于等于0，代表获取成功；反之获取失败；</p>
</li>
<li><p><code>protected boolean tryReleaseShared(int arg)</code> ：共享式释放同步状态，成功为true，失败为false</p>
</li>
<li><p><code>protected boolean isHeldExclusively()</code> ： 是否在独占模式下被线程占用。</p>
</li>
</ol>
<h3 id="如何使用AQS"><a href="#如何使用AQS" class="headerlink" title="如何使用AQS"></a>如何使用AQS</h3><ul>
<li><p>首先，我们需要去继承AbstractQueuedSynchronizer这个类，然后我们根据我们的需求去重写相应的方法，比如要实现一个独占锁，那就去重写tryAcquire，tryRelease方法，要实现共享锁，就去重写tryAcquireShared，tryReleaseShared；最后，在我们的组件中调用AQS中的模板方法就可以了，而这些模板方法是会调用到我们之前重写的那些方法的。也就是说，我们只需要很小的工作量就可以实现自己的同步组件，重写的那些方法，仅仅是一些简单的对于共享资源state的获取和释放操作，至于像是获取资源失败，线程需要阻塞之类的操作，自然是AQS帮我们完成了。</p>
<p><strong>自定义同步器代码实现</strong> </p>
</li>
</ul>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.AQS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.AbstractQueuedSynchronizer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于AQS 实现自定义同步器&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> qinxuewu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 18/7/14下午1:23</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态内部类 继承AQS</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span>&#123;</span><br><span class="line">        <span class="comment">//是否处于占用状态</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState()==<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当状态为0的时候获取锁，CAS操作成功，则state状态为1，</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                 setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放锁，将同步状态置为0</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">if</span> (getState() == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">                  setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">                   setState(<span class="number">0</span>);</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同步对象完成一系列复杂的操作，我们仅需指向它即可</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line">    <span class="comment">//加锁操作，代理到acquire（模板方法）上就行，acquire会调用我们重写的tryAcquire方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> sync.<span class="title">tryAcquire</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放锁，代理到release（模板方法）上就行，release会调用我们重写的tryRelease方法。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> sync.<span class="title">isHeldExclusively</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.AQS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> qinxuewu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 18/7/14下午1:44</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMutex</span> </span>&#123;</span><br><span class="line">    <span class="comment">//CyclicBarrier是一个同步工具类，它允许一组线程互相等待，直到到达某个公共屏障点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">31</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  Mutex mutex = <span class="keyword">new</span> Mutex();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//说明:我们启用30个线程，每个线程对i自加10000次，同步正常的话，最终结果应为300000；</span></span><br><span class="line">        <span class="comment">//未加锁前</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">30</span>;i++)&#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">                        increment1();<span class="comment">//没有同步措施的a++；</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// barrier的await方法，在所有参与者都已经在此 barrier 上调用 await 方法之前，将一直等待。</span></span><br><span class="line">                        barrier.await();<span class="comment">//等30个线程累加完毕</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">        barrier.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;加锁前，a=&quot;</span>+a);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加锁后</span></span><br><span class="line">        barrier.reset();<span class="comment">//重置CyclicBarrier</span></span><br><span class="line">        a=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">30</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">                        increment2();<span class="comment">//a++采用Mutex进行同步处理</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        barrier.await();<span class="comment">//等30个线程累加完毕</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        barrier.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;加锁后，a=&quot;</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 没有同步措施的a++</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用自定义的Mutex进行同步处理的a++</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mutex.lock();</span><br><span class="line">        a++;</span><br><span class="line">        mutex.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="6-什么是CAS"><a href="#6-什么是CAS" class="headerlink" title="6. 什么是CAS"></a>6. 什么是CAS</h2><ul>
<li>CAS（Compare and Swap），即比较并替换，实现并发算法时常用到的一种技术，Doug lea大神在java同步器中大量使用了CAS技术，鬼斧神工的实现了多线程执行的安全性。</li>
<li>CAS的思想很简单：三个参数，一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。</li>
</ul>
<h3 id="一个n-的问题"><a href="#一个n-的问题" class="headerlink" title="一个n++的问题"></a>一个n++的问题</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Case</span> &#123;</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> n;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过javap -verbose Case看看add方法的字节码指令</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> add();</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0       </span><br><span class="line">         <span class="number">1</span>: dup           </span><br><span class="line">         <span class="number">2</span>: getfield      #<span class="number">2</span>                  <span class="comment">// Field n:I</span></span><br><span class="line">         <span class="number">5</span>: iconst_1      </span><br><span class="line">         <span class="number">6</span>: iadd          </span><br><span class="line">         <span class="number">7</span>: putfield      #<span class="number">2</span>                  <span class="comment">// Field n:I</span></span><br></pre></td></tr></table></figure>

<p>n++被拆分成了几个指令：</p>
<ul>
<li>执行getfield拿到原始n；</li>
<li>执行iadd进行加1操作；</li>
<li>执行putfield写把累加后的值写回n；</li>
</ul>
<p>通过volatile修饰的变量可以保证线程之间的可见性，但并不能保证这3个指令的原子执行，在多线程并发执行下，无法做到线程安全，得到正确的结果，那么应该如何解决呢？在add方法加上synchronized修饰解决，但是性能上差了点，除了低性能的加锁方案，我们还可以使用JDK自带的CAS方案，在CAS中，比较和替换是一组原子操作，不会被外部打断，且在性能上更占有优势。</p>
<p> <strong>在JDK 5之前Java语言是靠synchronized关键字保证同步的，这会导致有锁</strong><br>锁机制存在以下问题：</p>
<p>（1）在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。</p>
<p>（2）一个线程持有锁会导致其它所有需要此锁的线程挂起。</p>
<p>（3）如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。</p>
<p>volatile是不错的机制，但是volatile不能保证原子性。因此对于同步最终还是要回到锁机制上来。</p>
<p>独占锁是一种悲观锁，<code>synchronized</code>就是一种独占锁，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。而另一个更加有效的锁就是乐观锁。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁用到的机制就是CAS，Compare and Swap。</p>
<h3 id="并发之CAS操作"><a href="#并发之CAS操作" class="headerlink" title="并发之CAS操作"></a>并发之CAS操作</h3><ul>
<li>CAS即compare and set的缩写。常见于java.util.concurrent中，是构成concurrent包的基础。</li>
<li>CAS有三个操作数，内存值M，旧的预期(expect)值E和更新(update)值U。在CAS操作中，只有当M==E时，才会更新U。否则什么都不做。这些操作都是原子的。</li>
</ul>
<h3 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h3><ul>
<li>ABA问题。 CAS操作更新的基础是如果值没有变化则更新，若有变化则不更新。但如若有一值刚开始是A，然后变为B，最后又变为A。那么CAS检查时发现它没有变化就更新了，但实际上却是已经发生了变化。</li>
<li>CAS自旋。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。 </li>
<li>只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性。</li>
</ul>
<h3 id="1-偏向锁"><a href="#1-偏向锁" class="headerlink" title="1.偏向锁"></a>1.偏向锁</h3><ul>
<li>大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁</li>
<li>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁</li>
<li>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。</li>
<li>偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正<br>在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的MarkWord要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。</li>
<li>偏向锁在Java 6和Java7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用JVM参数来关闭延迟：-XX:BiasedLockingStartupDelay=0。如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，那么程序默认会进入轻量级锁状态</li>
</ul>
<h3 id="2-轻量级锁"><a href="#2-轻量级锁" class="headerlink" title="2.轻量级锁"></a>2.轻量级锁</h3><ul>
<li><p>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的MarkWord复制到锁记录中然后线程尝试使用CAS将对象头中的MarkWord替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁</p>
</li>
<li><p>轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。</p>
</li>
</ul>
<h3 id="3-锁的优缺点对比"><a href="#3-锁的优缺点对比" class="headerlink" title="3.锁的优缺点对比"></a>3.锁的优缺点对比</h3><table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁</td>
<td>加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距</td>
<td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td>
<td>适用于只有一个线程访问同步场景</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高了程序的响应速度</td>
<td>如果始终得不到锁竞争的线程，适用自旋消耗CPU</td>
<td>追求响应时间，同步块执行速度非常快</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争不使用自旋，不会消耗CPU</td>
<td>线程阻塞，响应时间缓慢</td>
<td>追求吞吐量 同步块执行速度较长</td>
</tr>
</tbody></table>
<h2 id="7-CountDownLatch"><a href="#7-CountDownLatch" class="headerlink" title="7. CountDownLatch"></a>7. CountDownLatch</h2><p>CountDownLatch 允许一个或多个线程等待其他线程完成操作。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>假如有这样一个需求，当我们需要解析一个Excel里多个sheet的数据时，可以考虑使用多线程，每个线程解析一个sheet里的数据，等到所有的sheet都解析完之后，程序需要提示解析完成。在这个需求中，要实现主线程等待所有线程完成sheet的解析操作，最简单的做法是使用join。代码如下：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="literal">void</span> main(<span class="built_in">String</span>[] args) throws InterruptedException &#123;</span><br><span class="line">    Thread t1=<span class="keyword">new</span></span><br><span class="line">            Thread<span class="function"><span class="params">(() -&gt; System.out.println(Thread.currentThread().getName()+<span class="string">&quot; finish&quot;</span>))</span>;</span></span><br><span class="line"><span class="function">    <span class="title">Thread</span> <span class="title">t2</span>=<span class="title">new</span> </span></span><br><span class="line"><span class="function">            <span class="title">Thread</span><span class="params">(() -&gt; System.out.println(Thread.currentThread().getName()+<span class="string">&quot; finish&quot;</span>))</span>;</span></span><br><span class="line"><span class="function">    <span class="title">t1</span>.<span class="title">start</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    <span class="title">t2</span>.<span class="title">start</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    <span class="title">t1</span>.<span class="title">join</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    <span class="title">t2</span>.<span class="title">join</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(<span class="string">&quot;所有线程执行完毕 主线程执行。。。。。。。。。。。。&quot;</span>)</span>;       </span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">输出：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Thread-0</span> <span class="title">finish</span></span></span><br><span class="line"><span class="function"><span class="title">Thread-1</span> <span class="title">finish</span></span></span><br><span class="line"><span class="function">所有线程执行完毕 主线程执行。。。。。。。。。。。。</span></span><br></pre></td></tr></table></figure>
<ul>
<li>join用于让当前执行线程等待join线程执行结束。其实现原理是不停检查join线程是否存活，如果join线程存活则让当前线程永远wait</li>
<li>直到join线程中止后，线程的this.notifyAll会被调用，调用notifyAll是在JVM里实现的，所以JDK里看不到，可以看看JVM源码。JDK不推荐在线程实例上使用wait，notify和notifyAll方法。</li>
</ul>
<p> <strong>JDK1.5之后的并发包中提供的CountDownLatch也可以实现join的这个功能，并且比join的功能更多</strong> </p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> CountDownLatch c=<span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">    public <span class="keyword">static</span> <span class="literal">void</span> main(<span class="built_in">String</span>[] args) throws InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread<span class="function"><span class="params">(() -&gt;&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">             System.out.println(<span class="number">1</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">             c.countDown();</span></span></span><br><span class="line"><span class="function"><span class="params">             System.out.println(<span class="number">2</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">             c.countDown();</span></span></span><br><span class="line"><span class="function"><span class="params">        &#125;)</span>.<span class="title">start</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">         <span class="title">c</span>.<span class="title">await</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">         <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(<span class="string">&quot;3&quot;</span>)</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>CountDownLatch的构造函数接收一个int类型的参数作为计数器，如果你想等待N个点完成，这里就传入N。</p>
<ul>
<li>当我们调用一次<code>CountDownLatch</code>的<code>countDown</code>方法时，<code>N</code>就会减1，CountDownLatch的await会阻塞当前线程，直到N变成零。由于countDown方法可以用在任何地方，所以这里说的N个点，可以是N个线程，也可以是1个线程里的N个执行步骤。用在多个线程时，你只需要把这个CountDownLatch的引用传递到线程里。</li>
</ul>
<h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><p>如果有某个解析sheet的线程处理的比较慢，我们不可能让主线程一直等待，所以我们可以使用另外一个带指定时间的await方法</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">这个方法等待特定时间后，就会不再阻塞当前线程。<span class="keyword">join</span>也有类似的方法。</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span>(<span class="keyword">long</span> time, TimeUnit unit): </span><br></pre></td></tr></table></figure>
<ul>
<li>注意：计数器必须大于等于0，只是等于0时候，计数器就是零，调用await方法时不会阻塞当前线程。CountDownLatch不可能重新初始化或者修改CountDownLatch对象的内部计数器的值。一个线程调用countDown方法 happen-before 另外一个线程调用await方法。</li>
</ul>
<h2 id="8-同步屏障CyclicBarrier"><a href="#8-同步屏障CyclicBarrier" class="headerlink" title="8.  同步屏障CyclicBarrier"></a>8.  同步屏障CyclicBarrier</h2><ul>
<li>CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> CyclicBarrier c=<span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>() &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                     c.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                 System.out.<span class="built_in">println</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             c.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">         System.out.<span class="built_in">println</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：<span class="number">2</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">如果把<span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>)修改成<span class="keyword">new</span> CyclicBarrier(<span class="number">3</span>)则主线程和子线程会永远等待，因为没有第三个线程执行await方法，即没有第三个线程到达屏障，所以之前到达屏障的两个线程都不会继续执行。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>CyclicBarrier的内部是使用重入锁ReentrantLock和Condition。它有两个构造函数：</p>
<ul>
<li>CyclicBarrier(int parties)：创建一个新的 CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，但它不会在启动 barrier 时执行预定义的操作。</li>
<li>CyclicBarrier还提供一个更高级的构造函数CyclicBarrier(int parties, Runnable barrierAction)，用于在线程到达屏障时，优先执行barrierAction，方便处理更复杂的业务场景</li>
</ul>
<p>代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CyclicBarrierTest2</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">A</span> <span class="title">implements</span> <span class="title">Runnable</span>&#123;</span><br><span class="line">        @Override</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">             System.<span class="keyword">out</span>.println(<span class="number">3</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> CyclicBarrier c=<span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>, <span class="keyword">new</span> A());</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    c.<span class="keyword">await</span>();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;                 </span><br><span class="line">                &#125;</span><br><span class="line">                 System.<span class="keyword">out</span>.println(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c.<span class="keyword">await</span>();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;     </span><br><span class="line">        &#125;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：<span class="number">3</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="CyclicBarrier的应用场景"><a href="#CyclicBarrier的应用场景" class="headerlink" title="CyclicBarrier的应用场景"></a>CyclicBarrier的应用场景</h3><ul>
<li>CyclicBarrier可以用于多线程计算数据，最后合并计算结果的应用场景。比如我们用一个Excel保存了用户所有银行流水，每个Sheet保存一个帐户近一年的每笔银行流水，现在需要统计用户的日均银行流水，先用多线程处理每个sheet里的银行流水，都执行完之后，得到每个sheet的日均银行流水，最后，再用barrierAction用这些线程的计算结果，计算出整个Excel的日均银行流水。</li>
</ul>
<p>应用示例 比如我们开会只有等所有的人到齐了才会开会，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  CyclicBarrier试用与多线程结果合并的操作，用于多线程计算数据，最后合并计算结果的应用场景</span></span><br><span class="line"><span class="comment"> *  比如我们需要统计多个Excel中的数据，然后等到一个总结果。我们可以通过多线程处理每一个Excel，执行完成后得到相应的结果，</span></span><br><span class="line"><span class="comment"> *  最后通过barrierAction来计算这些线程的计算结果，得到所有Excel的总和。 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> qxw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> 2018年7月26日下午3:00:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier cyclicBarrier;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;到了&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//应用示例 比如我们开会只有等所有的人到齐了才会开会，如下：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        cyclicBarrier=<span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>, <span class="keyword">new</span> Runnable() &#123;         </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;人到齐了 开会吧....&quot;</span>);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> CyclicBarrierThread().start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/151054_8c6b0b98_1478371.png" alt="输入图片说明" title="屏幕截图.png"></p>
<p>在CyclicBarrier中最重要的方法莫过于await()方法，在所有参与者都已经在此 barrier 上调用 await 方法之前，将一直等待。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/145223_d2deafdc_1478371.png" alt="输入图片说明" title="屏幕截图.png"></p>
<p>await()方法内部调用dowait(boolean timed, long nanos)方法：</p>
<p>其实await()的处理逻辑还是比较简单的：如果该线程不是到达的最后一个线程，则他会一直处于等待状态，除非发生以下情况：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/145317_2332e0eb_1478371.png" alt="输入图片说明" title="屏幕截图.png"></p>
<h3 id="CyclicBarrier和CountDownLatch的区别"><a href="#CyclicBarrier和CountDownLatch的区别" class="headerlink" title="CyclicBarrier和CountDownLatch的区别"></a>CyclicBarrier和CountDownLatch的区别</h3><ul>
<li>CountDownLatch的计数器只能使用一次。而CyclicBarrier的计数器可以使用reset() 方法重置。所以CyclicBarrier能处理更为复杂的业务场景，比如如果计算发生错误，可以重置计数器，并让线程们重新执行一次。</li>
<li>CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得CyclicBarrier阻塞的线程数量。isBroken方法用来知道阻塞的线程是否被中断。</li>
</ul>
<p>比如以下代码执行完之后会返回true。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest4</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> CyclicBarrier c = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>() &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    c.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.interrupt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">             System.out.<span class="built_in">println</span>(c.isBroken());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-并发工具类Exchanger"><a href="#9-并发工具类Exchanger" class="headerlink" title="9. 并发工具类Exchanger"></a>9. 并发工具类Exchanger</h2><p>Exchanger，它允许在并发任务之间交换数据。具体来说，Exchanger类允许在两个线程之间定义同步点。当两个线程都到达同步点时，他们交换数据结构，因此第一个线程的数据结构进入到第二个线程中，第二个线程的数据结构进入到第一个线程中。</p>
<h3 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">     <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="title">implements</span> <span class="title">Runnable</span>&#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//生产者、消费者交换的数据结构</span></span><br><span class="line">         <span class="keyword">private</span> List&lt;<span class="keyword">String</span>&gt; <span class="built_in">buffer</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生产者和消费者的交换对象</span></span><br><span class="line">         <span class="keyword">private</span> Exchanger&lt;List&lt;<span class="keyword">String</span>&gt;&gt; exchanger;</span><br><span class="line">         </span><br><span class="line">         Producer(List&lt;<span class="keyword">String</span>&gt; <span class="built_in">buffer</span>,Exchanger&lt;List&lt;<span class="keyword">String</span>&gt;&gt; exchanger)&#123;</span><br><span class="line">             <span class="keyword">this</span>.<span class="built_in">buffer</span>=<span class="built_in">buffer</span>;</span><br><span class="line">             <span class="keyword">this</span>.exchanger=exchanger;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">        @Override</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.<span class="built_in">println</span>(<span class="string">&quot;生产者第&quot;</span> +i +<span class="string">&quot;次提供&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;=<span class="number">3</span>; j++) &#123;</span><br><span class="line">                    System.out.<span class="built_in">println</span>(<span class="string">&quot;生产者装入&quot;</span>+ i  +  <span class="string">&quot;--&quot;</span> + j);</span><br><span class="line">                    <span class="built_in">buffer</span>.add(<span class="string">&quot;buffer :&quot;</span>+i +<span class="string">&quot;--&quot;</span>+j);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.<span class="built_in">println</span>(<span class="string">&quot;生产者装满,等待与消费者交换....&quot;</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    exchanger.exchange(<span class="built_in">buffer</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="title">implements</span> <span class="title">Runnable</span>&#123;</span></span><br><span class="line">         <span class="keyword">private</span> List&lt;<span class="keyword">String</span>&gt; <span class="built_in">buffer</span>;</span><br><span class="line">         <span class="keyword">private</span> Exchanger&lt;List&lt;<span class="keyword">String</span>&gt;&gt; exchanger;</span><br><span class="line">         </span><br><span class="line">         Consumer(List&lt;<span class="keyword">String</span>&gt; <span class="built_in">buffer</span>,Exchanger&lt;List&lt;<span class="keyword">String</span>&gt;&gt; exchanger)&#123;</span><br><span class="line">             <span class="keyword">this</span>.<span class="built_in">buffer</span>=<span class="built_in">buffer</span>;</span><br><span class="line">             <span class="keyword">this</span>.exchanger=exchanger;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">        @Override</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="comment">//调用exchange()与消费者进行数据交换</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="built_in">buffer</span>=exchanger.exchange(<span class="built_in">buffer</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.<span class="built_in">println</span>(<span class="string">&quot;消费者第&quot;</span> + i + <span class="string">&quot;次提取&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;=<span class="number">3</span>; j++) &#123;</span><br><span class="line">                    System.out.<span class="built_in">println</span>(<span class="string">&quot;消费者： &quot;</span>+<span class="built_in">buffer</span>.<span class="built_in">get</span>(<span class="number">0</span>));</span><br><span class="line">                    <span class="built_in">buffer</span>.<span class="built_in">remove</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;    </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;<span class="keyword">String</span>&gt; buffer1=<span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;();</span><br><span class="line">        List&lt;<span class="keyword">String</span>&gt; buffer2=<span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;();</span><br><span class="line">        Exchanger&lt;List&lt;<span class="keyword">String</span>&gt;&gt; exchanger=<span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span>  Producer(buffer1, exchanger));</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(<span class="keyword">new</span>  Consumer(buffer2, exchanger));</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>首先生产者Producer、消费者Consumer首先都创建一个缓冲列表，通过Exchanger来同步交换数据。消费中通过调用Exchanger与生产者进行同步来获取数据，而生产者则通过for循环向缓存队列存储数据并使用exchanger对象消费者同步。到消费者从exchanger哪里得到数据后，他的缓冲列表中有3个数据，而生产者得到的则是一个空的列表。上面的例子充分展示了消费者-生产者是如何利用Exchanger来完成数据交换的。</li>
</ul>
<p>在Exchanger中，如果一个线程已经到达了exchanger节点时，对于它的伙伴节点的情况有三种:</p>
<ol>
<li>如果它的伙伴节点在该线程到达之前已经调用了exchanger方法，则它会唤醒它的伙伴然后进行数据交换，得到各自数据返回。</li>
</ol>
<ol>
<li>如果它的伙伴节点还没有到达交换点，则该线程将会被挂起，等待它的伙伴节点到达被唤醒，完成数据交换。</li>
<li>如果当前线程被中断了则抛出异常，或者等待超时了，则抛出超时异常。</li>
</ol>
<h2 id="10-控制并发线程数Semaphore"><a href="#10-控制并发线程数Semaphore" class="headerlink" title="10.  控制并发线程数Semaphore"></a>10.  控制并发线程数Semaphore</h2><ul>
<li>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。很多年以来，我都觉得从字面上很难理解Semaphore所表达的含义，只能把它比作是控制流量的红绿灯，比如XX马路要限制流量，只允许同时有一百辆车在这条路上行使，其他的都必须在路口等待，所以前一百辆车会看到绿灯，可以开进这条马路，后面的车会看到红灯，不能驶入XX马路，但是如果前一百辆中有五辆车已经离开了XX马路，那么后面就允许有5辆车驶入马路，这个例子里说的车就是线程，驶入马路就表示线程在执行，离开马路就表示线程执行完成，看见红灯就表示线程被阻塞，不能执行。</li>
</ul>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul>
<li>Semaphore(int permits) ：创建具有给定的许可数和非公平的公平设置的 Semaphore。</li>
<li>Semaphore(int permits, boolean fair) ：创建具有给定的许可数和给定的公平设置的 Semaphore。</li>
</ul>
<p><img src="https://images.gitee.com/uploads/images/2018/0727/133123_0786a3a1_1478371.png" alt="输入图片说明" title="屏幕截图.png"></p>
<p> <strong>Semaphore默认选择非公平锁。</strong> </p>
<p>当信号量Semaphore = 1 时，它可以当作互斥锁使用。其中0、1就相当于它的状态，当=1时表示其他线程可以获取，当=0时，排他，即其他线程必须要等待。</p>
<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>Semaphore可以用于做流量控制，特别公用资源有限的应用场景。比如数据库连接。假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发的读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有十个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。</li>
</ul>
<p>这个时候，我们就可以使用Semaphore来做流控，代码如下：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> SemaphoreTest &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> static final <span class="built_in">int</span> SIZE=<span class="number">5</span>;</span><br><span class="line">    <span class="comment">//创建固定数量的线程池</span></span><br><span class="line">    <span class="keyword">private</span> static  ExecutorService threadPool=<span class="module-access"><span class="module"><span class="identifier">Executors</span>.</span></span><span class="keyword">new</span><span class="constructor">FixedThreadPool(SIZE)</span>;  </span><br><span class="line">    <span class="comment">//允许并发的线程数</span></span><br><span class="line">    <span class="keyword">private</span> static Semaphore s = <span class="keyword">new</span> <span class="constructor">Semaphore(3)</span>;</span><br><span class="line"></span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; SIZE; i++) &#123;</span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> <span class="constructor">Runnable()</span> &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run<span class="literal">()</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//获取取一个许可证</span></span><br><span class="line">                        s.acquire<span class="literal">()</span>;</span><br><span class="line">                        long time=(long)(<span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>random<span class="literal">()</span>*<span class="number">10</span>);</span><br><span class="line"><span class="comment">//                      System.out.println(&quot;此信号量中当前可用的许可证数:  &quot;+s.availablePermits());</span></span><br><span class="line"><span class="comment">//                      System.out.println(&quot;正在等待获取许可证的线程数:  &quot;+s.getQueueLength());</span></span><br><span class="line"><span class="comment">//                      System.out.println(&quot;是否有线程正在等待获取许可证:  &quot;+s.hasQueuedThreads());</span></span><br><span class="line">                        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span>+<span class="string">&quot;  从内存中读取存储到数据库耗时 ：&quot;</span>+time+<span class="string">&quot;秒。。。。&quot;</span>);</span><br><span class="line">                        <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>sleep(time);                     </span><br><span class="line">                        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span>+<span class="string">&quot; 释放数据库链接&quot;</span>);                        </span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">                    &#125;finally&#123;</span><br><span class="line">                        <span class="comment">//使用完之后调用release()归还许可证。还可以用tryAcquire()方法尝试获取许可证。</span></span><br><span class="line">                        s.release<span class="literal">()</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">         threadPool.shutdown<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在代码中，虽然有5个线程在执行，但是只允许3个并发的执行。Semaphore的构造方法Semaphore(int permits) 接受一个整型的数字，表示可用的许可证数量。Semaphore(3)表示允许3个线程获取许可证，也就是最大并发数是3。Semaphore的用法也很简单，首先线程使用Semaphore的acquire()获取一个许可证，使用完之后调用release()归还许可证。还可以用tryAcquire()方法尝试获取许可证。</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Semaphore还提供一些其他方法：</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> available<span class="constructor">Permits()</span> ：返回此信号量中当前可用的许可证数。</span><br><span class="line"><span class="built_in">int</span> get<span class="constructor">QueueLength()</span>：返回正在等待获取许可证的线程数。</span><br><span class="line">boolean has<span class="constructor">QueuedThreads()</span> ：是否有线程正在等待获取许可证。</span><br><span class="line">void reduce<span class="constructor">Permits(<span class="params">int</span> <span class="params">reduction</span>)</span> ：减少reduction个许可证。是个protected方法。</span><br><span class="line">Collection get<span class="constructor">QueuedThreads()</span> ：返回所有等待获取许可证的线程集合。是个protected方法。</span><br></pre></td></tr></table></figure>

<h2 id="11-乐观锁与悲观锁"><a href="#11-乐观锁与悲观锁" class="headerlink" title="11. 乐观锁与悲观锁"></a>11. 乐观锁与悲观锁</h2><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><ul>
<li><p>总是认为不会产生并发问题，每次去取数据的时候总认为不会有其他线程对数据进行修改，因此不会上锁，但是在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用版本号机制或CAS操作实现。</p>
</li>
<li><p>version方式：一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</p>
<p><strong>核心SQL代码：</strong> </p>
</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">update table <span class="builtin-name">set</span> <span class="attribute">x</span>=x+1, <span class="attribute">version</span>=version+1 where <span class="attribute">id</span>=#&#123;id&#125; <span class="keyword">and</span> <span class="attribute">version</span>=#&#123;version&#125;;  </span><br></pre></td></tr></table></figure>
<ul>
<li>CAS操作方式：即compare and swap(比较并交换) 或者 compare and set，涉及到三个操作数，数据所在的内存值，预期值，新值。当需要更新时，判断当前内存值与之前取到的值是否相等，若相等，则用新值更新，若失败则重试，一般情况下是一个自旋操作，即不断的重试。</li>
</ul>
<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><ul>
<li>总是假设最坏的情况，每次取数据时都认为其他线程会修改，所以都会加锁（读锁、写锁、行锁等），当其他线程想要访问数据时，都需要阻塞挂起。可以依靠数据库实现，如行锁、读锁和写锁等，都是在操作之前加锁，在Java中，synchronized的思想也是悲观锁。</li>
</ul>
<h3 id="程序中的乐观锁与悲观锁"><a href="#程序中的乐观锁与悲观锁" class="headerlink" title="程序中的乐观锁与悲观锁"></a>程序中的乐观锁与悲观锁</h3><p> <strong>概念:</strong> </p>
<ol>
<li>这里抛开数据库来谈乐观锁和悲观锁,扯上数据库总会觉得和Java离得很远.</li>
<li>悲观锁:一段执行逻辑加上悲观锁,不同线程同时执行时,只能有一个线程执行,其他的线程在入口处等待,直到锁被释放.</li>
<li>乐观锁:一段执行逻辑加上乐观锁,不同线程同时执行时,可以同时进入执行,在最后更新数据的时候要检查这些数据是否被其他线程修改了(版本和执行初是否相同),没有修改则进行更新,否则放弃本次操作.</li>
</ol>
<p>从解释上可以看出,悲观锁具有很强的独占性,也是最安全的.而乐观锁很开放,效率高,安全性比悲观锁低,因为在乐观锁检查数据版本一致性时也可能被其他线程修改数据.</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">package com.example.<span class="keyword">lock</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 乐观锁实现</span></span><br><span class="line"><span class="comment"> * @author qinxuewu</span></span><br><span class="line"><span class="comment"> * @version 1.00</span></span><br><span class="line"><span class="comment"> * @time 20/7/2018下午 12:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OptimisticLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="keyword">value</span> = <span class="number">0</span>; <span class="comment">// 多线程同时调用的操作对象</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A线程要执行的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invoke</span>(<span class="params"><span class="keyword">int</span> Avalue, String i</span>) throws InterruptedException</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);<span class="comment">//延长执行时间</span></span><br><span class="line">        <span class="keyword">if</span> (Avalue != <span class="keyword">value</span>) &#123;<span class="comment">//判断value版本</span></span><br><span class="line">            System.<span class="keyword">out</span>.println(Avalue + <span class="string">&quot;:&quot;</span> + <span class="keyword">value</span> + <span class="string">&quot;A版本不一致,不执行&quot;</span>);</span><br><span class="line">            <span class="keyword">value</span>--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Avalue++;<span class="comment">//对数据操作</span></span><br><span class="line">            <span class="keyword">value</span> = Avalue;;<span class="comment">//对数据操作</span></span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;invoke:   &quot;</span>+i + <span class="string">&quot;:&quot;</span> + <span class="keyword">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * B线程要执行的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invoke2</span>(<span class="params"><span class="keyword">int</span> Bvalue, String i</span>)</span></span><br><span class="line"><span class="function">            throws InterruptedException</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);<span class="comment">//延长执行时间</span></span><br><span class="line">        <span class="keyword">if</span> (Bvalue != <span class="keyword">value</span>) &#123;<span class="comment">//判断value版本</span></span><br><span class="line">            System.<span class="keyword">out</span>.println(Bvalue + <span class="string">&quot;:&quot;</span> + <span class="keyword">value</span> + <span class="string">&quot;B版本不一致,不执行&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;B:利用value运算,value=&quot;</span>+Bvalue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试,期待结果:B线程执行的时候value数据总是当前最新的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws InterruptedException</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;<span class="comment">//A线程</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                        <span class="keyword">int</span> Avalue = OptimisticLock.<span class="keyword">value</span>;<span class="comment">//A获取的value</span></span><br><span class="line">                        OptimisticLock.invoke(Avalue, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;<span class="comment">//B线程</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                        <span class="keyword">int</span> Bvalue = OptimisticLock.<span class="keyword">value</span>;<span class="comment">//B获取的value</span></span><br><span class="line">                        OptimisticLock.invoke2(Bvalue, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>测试结果:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">A:<span class="number">1</span></span><br><span class="line"><span class="number">0</span>:<span class="number">1</span>B版本不一致,不执行</span><br><span class="line">B:利用value运算,value=<span class="number">1</span></span><br><span class="line">A:<span class="number">2</span></span><br><span class="line">B:利用value运算,value=<span class="number">2</span></span><br><span class="line">A:<span class="number">3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">从结果中看出,B线程在执行的时候最后发现自己的value和执行前不一致,说明被A修改了,那么放弃了本次执行.</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">多运行几次发现了下面的结果:</span><br><span class="line"></span><br><span class="line">A:<span class="number">1</span></span><br><span class="line">B:利用value运算,value=<span class="number">0</span></span><br><span class="line">A:<span class="number">2</span></span><br><span class="line"><span class="number">1</span>:<span class="number">2</span>B版本不一致,不执行</span><br><span class="line">A:<span class="number">3</span></span><br><span class="line">B:利用value运算,value=<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>从结果看A修改了value值,B却没有检查出来,利用错误的value值进行了操作. 为什么会这样呢?</p>
<p>这里就回到前面说的乐观锁是有一定的不安全性的,B在检查版本的时候A还没有修改,在B检查完版本后更新数据前(例子中的输出语句),A更改了value值,这时B执行更新数据(例子中的输出语句)就发生了与现存value不一致的现象.</p>
<p>针对这个问题,我觉得乐观锁要解决这个问题还需要在检查版本与更新数据这个操作的时候能够使用悲观锁,比如加上synchronized,让它在最后一步保证数据的一致性.这样既保证多线程都能同时执行,牺牲最后一点的性能去保证数据的一致.</p>
<p> <strong>有两种方式来保证乐观锁最后同步数据保证它原子性的方法</strong> </p>
<ul>
<li><p>1,CAS方式:Java非公开API类Unsafe实现的CAS(比较-交换),由C++编写的调用硬件操作内存,保证这个操作的原子性,concurrent包下很多乐观锁实现使用到这个类,但这个类不作为公开API使用,随时可能会被更改.我在本地测试了一下,确实不能够直接调用,源码中Unsafe是私有构造函数,只能通过getUnsafe方法获取单例,首先去掉eclipse的检查(非API的调用限制)限制以后,执行发现报 java.lang.SecurityException异常,源码中getUnsafe方法中执行访问检查,看来java不允许应用程序获取Unsafe类. 值得一提的是反射是可以得到这个类对象的.</p>
</li>
<li></li>
<li><p>2,加锁方式:利用Java提供的现有API来实现最后数据同步的原子性(用悲观锁).看似乐观锁最后还是用了悲观锁来保证安全,效率没有提高.实际上针对于大多数只执行不同步数据的情况,效率比悲观加锁整个方法要高.特别注意:针对一个对象的数据同步,悲观锁对这个对象加锁和乐观锁效率差不多,如果是多个需要同步数据的对象,乐观锁就比较方便.</p>
</li>
</ul>
<h2 id="12-ReentrantLock实现原理"><a href="#12-ReentrantLock实现原理" class="headerlink" title="12. ReentrantLock实现原理"></a>12. ReentrantLock实现原理</h2><p><a href="https://blog.csdn.net/yanyan19880509/article/details/52345422/">原理解释</a></p>
<ul>
<li>ReentrantLock支持两种获取锁的方式，一种是公平模型，一种是非公平模型</li>
<li>使用 synchronize 来做同步处理时，锁的获取和释放都是隐式的，实现的原理是通过编译后加上不同的机器指令来实现。</li>
<li>而 ReentrantLock 就是一个普通的类，它是基于 AQS(AbstractQueuedSynchronizer)来实现的。是一个重入锁：一个线程获得了锁之后仍然可以反复的加锁，不会出现自己阻塞自己的情况。</li>
</ul>
<p>什么是AQS</p>
<ul>
<li>AQS即是AbstractQueuedSynchronizer，一个用来构建锁和同步工具的框架，包括常用的ReentrantLock、CountDownLatch、Semaphore等。</li>
<li>AQS没有锁之类的概念，它有个state变量，是个int类型，在不同场合有着不同含义。本文研究的是锁，为了好理解，姑且先把state当成锁。</li>
<li>AQS围绕state提供两种基本操作“获取”和“释放”，有条双向队列存放阻塞的等待线程，并提供一系列判断和处理方法，<br>简单说几点： state是独占的，还是共享的；</li>
</ul>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">state</span>被获取后，其他线程需要等待；</span><br><span class="line"><span class="keyword">state</span>被释放后，唤醒等待线程；</span><br><span class="line">线程等不及时，如何退出等待。</span><br></pre></td></tr></table></figure>


<h3 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认非公平锁</span></span><br><span class="line">  public <span class="constructor">ReentrantLock()</span> &#123;</span><br><span class="line">      sync = <span class="keyword">new</span> <span class="constructor">NonfairSync()</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//公平锁</span></span><br><span class="line">  public <span class="constructor">ReentrantLock(<span class="params">boolean</span> <span class="params">fair</span>)</span> &#123;</span><br><span class="line">      sync = fair ? <span class="keyword">new</span> <span class="constructor">FairSync()</span> : <span class="keyword">new</span> <span class="constructor">NonfairSync()</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>默认一般使用非公平锁，它的效率和吞吐量都比公平锁高的多</li>
<li>ReentrantLock的内部类Sync继承了AQS，分为公平锁FairSync和非公平锁NonfairSync。</li>
<li>公平锁：线程获取锁的顺序和调用lock的顺序一样，FIFO；</li>
<li>非公平锁：线程获取锁的顺序和调用lock的顺序无关，全凭运气。</li>
</ul>
<h3 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认非公平锁，</span></span><br><span class="line"> <span class="keyword">private</span> ReentrantLock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">// private ReentrantLock lock = new ReentrantLock(true); 公平锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//do bussiness</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">lock</span>.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h3 id="公平锁获取锁"><a href="#公平锁获取锁" class="headerlink" title="公平锁获取锁"></a>公平锁获取锁</h3><p>首先看下获取锁的过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到是使用 <code>sync</code>的方法，而这个方法是一个抽象方法，具体是由其子类(<code>FairSync</code>)来实现的，以下是公平锁的实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AbstractQueuedSynchronizer 中的 acquire()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">    acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">    selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一步是尝试获取锁(<code>tryAcquire(arg)</code>),这个也是由其子类实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先会判断 <code>AQS</code> 中的 <code>state</code> 是否等于 0，0 表示目前没有其他线程获得锁，当前线程就可以尝试获取锁。</p>
<p><strong>注意</strong>:尝试之前会利用 <code>hasQueuedPredecessors()</code> 方法来判断 AQS 的队列中中是否有其他线程，如果有则不会尝试获取锁(<strong>这是公平锁特有的情况</strong>)。</p>
<p>如果队列中没有线程就利用 CAS 来将 AQS 中的 state 修改为1，也就是获取锁，获取成功则将当前线程置为获得锁的独占线程(<code>setExclusiveOwnerThread(current)</code>)。</p>
<p>如果 <code>state</code> 大于 0 时，说明锁已经被获取了，则需要判断获取锁的线程是否为当前线程(<code>ReentrantLock</code> 支持重入)，是则需要将 <code>state + 1</code>，并将值更新。</p>
<h3 id="写入队列"><a href="#写入队列" class="headerlink" title="写入队列"></a>写入队列</h3><p>如果 <code>tryAcquire(arg)</code> 获取锁失败，则需要用 <code>addWaiter(Node.EXCLUSIVE)</code> 将当前线程写入队列中。</p>
<p>写入之前需要将当前线程包装为一个 <code>Node</code> 对象(<code>addWaiter(Node.EXCLUSIVE)</code>)。</p>
<blockquote>
<p>AQS 中的队列是由 Node 节点组成的双向链表实现的。</p>
</blockquote>
<p>包装代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先判断队列是否为空，不为空时则将封装好的 <code>Node</code> 利用 <code>CAS</code> 写入队尾，如果出现并发写入失败就需要调用 <code>enq(node);</code> 来写入了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个处理逻辑就相当于<code>自旋</code>加上 <code>CAS</code> 保证一定能写入队列。</p>
<h3 id="挂起等待线程"><a href="#挂起等待线程" class="headerlink" title="挂起等待线程"></a>挂起等待线程</h3><p>写入队列之后需要将当前线程挂起(利用<code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</code>)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先会根据 <code>node.predecessor()</code> 获取到上一个节点是否为头节点，如果是则尝试获取一次锁，获取成功就万事大吉了。</p>
<p>如果不是头节点，或者获取锁失败，则会根据上一个节点的 <code>waitStatus</code> 状态来处理(<code>shouldParkAfterFailedAcquire(p, node)</code>)。</p>
<p><code>waitStatus</code> 用于记录当前节点的状态，如节点取消、节点等待等。</p>
<p><code>shouldParkAfterFailedAcquire(p, node)</code> 返回当前线程是否需要挂起，如果需要则调用 <code>parkAndCheckInterrupt()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>他是利用 <code>LockSupport</code> 的 <code>part</code> 方法来挂起当前线程的，直到被唤醒。</p>
<h3 id="非公平锁获取锁"><a href="#非公平锁获取锁" class="headerlink" title="非公平锁获取锁"></a>非公平锁获取锁</h3><p>公平锁与非公平锁的差异主要在获取锁：</p>
<p>公平锁就相当于买票，后来的人需要排到队尾依次买票，<strong>不能插队</strong>。</p>
<p>而非公平锁则没有这些规则，是<strong>抢占模式</strong>，每来一个人不会去管队列如何，直接尝试获取锁。</p>
<p>非公平锁:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//直接尝试获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>公平锁:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还要一个重要的区别是在尝试获取锁时<code>tryAcquire(arg)</code>，非公平锁是不需要判断队列中是否还有其他线程，也是直接尝试获取锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//没有 !hasQueuedPredecessors() 判断</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="释放锁-1"><a href="#释放锁-1" class="headerlink" title="释放锁"></a>释放锁</h3><p>公平锁和非公平锁的释放流程都是一样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">               <span class="comment">//唤醒被挂起的线程</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试释放锁</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure>

<p>首先会判断当前线程是否为获得锁的线程，由于是重入锁所以需要将 <code>state</code> 减到 0 才认为完全释放锁。</p>
<p>释放之后需要调用 <code>unparkSuccessor(h)</code> 来唤醒被挂起的线程。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>由于公平锁需要关心队列的情况，得按照队列里的先后顺序来获取锁(会造成大量的线程上下文切换)，而非公平锁则没有这个限制。</p>
<p>所以也就能解释非公平锁的效率会被公平锁更高。</p>
<h3 id="羊群效应"><a href="#羊群效应" class="headerlink" title="羊群效应"></a>羊群效应</h3><ul>
<li>这里说一下羊群效应，当有多个线程去竞争同一个锁的时候，假设锁被某个线程占用，那么如果有成千上万个线程在等待锁，有一种做法是同时唤醒这成千上万个线程去去竞争锁，这个时候就发生了羊群效应，海量的竞争必然造成资源的剧增和浪费，因此终究只能有一个线程竞争成功，其他线程还是要老老实实的回去等待。AQS的FIFO的等待队列给解决在锁竞争方面的羊群效应问题提供了一个思路：保持一个FIFO队列，队列每个节点只关心其前一个节点的状态，线程唤醒也只唤醒队头等待线程。其实这个思路已经被应用到了分布式锁的实践中，见：Zookeeper分布式锁的改进实现方案。</li>
</ul>
<h2 id="13-阻塞队列ArrayBlockingQueu"><a href="#13-阻塞队列ArrayBlockingQueu" class="headerlink" title="13. 阻塞队列ArrayBlockingQueu"></a>13. 阻塞队列ArrayBlockingQueu</h2><ul>
<li>ArrayBlockingQueue，一个由数组实现的有界阻塞队列。该队列采用FIFO的原则对元素进行排序添加的。</li>
<li>ArrayBlockingQueue为有界且固定，其大小在构造时由构造函数来决定，确认之后就不能再改变了。</li>
<li>ArrayBlockingQueue支持对等待的生产者线程和使用者线程进行排序的可选公平策略，但是在默认情况下不保证线程公平的访问，在构造时可以选择公平策略（fair = true）。公平性通常会降低吞吐量，但是减少了可变性和避免了“不平衡性”。</li>
</ul>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">ArrayBlockingQueue</span>&lt;<span class="symbol">E</span>&gt; <span class="symbol">extends</span> <span class="symbol">AbstractQueue</span>&lt;<span class="symbol">E</span>&gt; <span class="symbol">implements</span> <span class="symbol">BlockingQueue</span>&lt;<span class="symbol">E</span>&gt;, <span class="symbol">Serializable</span> &#123;</span><br><span class="line">       <span class="keyword">private</span> static <span class="keyword">final</span> long serialVersionUID = <span class="number">-817911632652898426</span>L;</span><br><span class="line">       <span class="keyword">final</span> Object[] items;</span><br><span class="line">       <span class="built_in">int</span> takeIndex;</span><br><span class="line">       <span class="built_in">int</span> putIndex;</span><br><span class="line">       <span class="built_in">int</span> count;</span><br><span class="line">       <span class="comment">// 重入锁</span></span><br><span class="line">       <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line">       <span class="comment">// notEmpty condition</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line">       <span class="comment">// notFull condition</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line">       transient ArrayBlockingQueue.Itrs itrs;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>可以清楚地看到ArrayBlockingQueue继承AbstractQueue，实现BlockingQueue接口。看过java.util包源码的同学应该都认识AbstractQueue，改类在Queue接口中扮演着非常重要的作用，该类提供了对queue操作的骨干实现（具体内容移驾其源码）。BlockingQueue继承java.util.Queue为阻塞队列的核心接口，提供了在多线程环境下的出列、入列操作，作为使用者，则不需要关心队列在什么时候阻塞线程，什么时候唤醒线程，所有一切均由BlockingQueue来完成。</p>
<p><strong>ArrayBlockingQueue内部使用可重入锁ReentrantLock + Condition来完成多线程环境的并发操作。</strong> </p>
</li>
<li><p>items，一个定长数组，维护ArrayBlockingQueue的元素</p>
</li>
<li><p>takeIndex，int，为ArrayBlockingQueue对首位置</p>
</li>
<li><p>putIndex，int，ArrayBlockingQueue对尾位置</p>
</li>
<li><p>count，元素个数</p>
</li>
<li><p>lock，锁，ArrayBlockingQueue出列入列都必须获取该锁，两个步骤公用一个锁</p>
</li>
<li><p>notEmpty，出列条件</p>
</li>
<li><p>notFull，入列条件</p>
<p><strong>入队</strong> </p>
</li>
</ul>
<p>ArrayBlockingQueue提供了诸多方法，可以将元素加入队列尾部。</p>
<ul>
<li>add(E e) ：将指定的元素插入到此队列的尾部（如果立即可行且不会超过该队列的容量），在成功时返回 true，如果此队列已满，则抛出 IllegalStateException</li>
<li>offer(E e) :将指定的元素插入到此队列的尾部（如果立即可行且不会超过该队列的容量），在成功时返回 true，如果此队列已满，则返回 false</li>
<li>offer(E e, long timeout, TimeUnit unit) :将指定的元素插入此队列的尾部，如果该队列已满，则在到达指定的等待时间之前等待可用的空间</li>
<li>put(E e) :将指定的元素插入此队列的尾部，如果该队列已满，则等待可用的空间</li>
</ul>
<h3 id="add-E-e）"><a href="#add-E-e）" class="headerlink" title="add(E e）"></a>add(E e）</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">add</span><span class="params">(e)</span></span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (offer(e))</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Queue full&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>add方法调用offer(E e)，如果返回false，则直接抛出IllegalStateException异常。offer(E e)为ArrayBlockingQueue实现：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">offer</span>(<span class="params">E e</span>)</span> &#123;</span><br><span class="line">       checkNotNull(e);</span><br><span class="line">       final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;</span><br><span class="line">       <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (count == items.length)</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               enqueue(e);</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">lock</span>.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>方法首先检查是否为null，然后获取lock锁。获取锁成功后，如果队列已满则直接返回false，否则调用enqueue(E e)，enqueue(E e)为入列的核心方法，所有入列的方法最终都将调用该方法在队列尾部插入元素：</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> void enqueue(E x) &#123;</span><br><span class="line">       <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">       <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">       final Object[] <span class="built_in">items</span> = this.<span class="built_in">items</span>;</span><br><span class="line">       <span class="built_in">items</span>[putIndex] = x;</span><br><span class="line">       <span class="keyword">if</span> (++putIndex == <span class="built_in">items</span>.length)</span><br><span class="line">           putIndex = <span class="number">0</span>;</span><br><span class="line">       <span class="built_in">count</span>++;</span><br><span class="line">       notEmpty.signal();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>该方法就是在putIndex（对尾）为知处添加元素，最后使用notEmpty的signal()方法通知阻塞在出列的线程（如果队列为空，则进行出列操作是会阻塞）。</p>
<h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><ul>
<li><p>poll() :获取并移除此队列的头，如果此队列为空，则返回 null</p>
</li>
<li><p>poll(long timeout, TimeUnit unit) :获取并移除此队列的头部，在指定的等待时间前等待可用的元素（如果有必要）</p>
</li>
<li><p>remove(Object o) :从此队列中移除指定元素的单个实例（如果存在）</p>
</li>
<li><p>take() :获取并移除此队列的头部，在元素变得可用之前一直等待（如果有必要）</p>
<p><strong>poll()</strong> </p>
</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">       final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;</span><br><span class="line">       <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="literal">null</span> : dequeue();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">lock</span>.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>如果队列为空返回null，否则调用dequeue()获取列头元素：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> E dequeue() &#123;</span><br><span class="line">        <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">        E x = (E) items[takeIndex];</span><br><span class="line">        items[takeIndex] = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">            takeIndex = <span class="number">0</span>;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span> (itrs != <span class="literal">null</span>)</span><br><span class="line">            itrs.elementDequeued();</span><br><span class="line">        notFull.signal();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>该方法主要是从列头（takeIndex 位置）取出元素，同时如果迭代器itrs不为null，则需要维护下该迭代器。最后调用notFull.signal()唤醒入列线程。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span>(<span class="params"></span>) throws InterruptedException</span> &#123;</span><br><span class="line">       final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;</span><br><span class="line">       <span class="keyword">lock</span>.lockInterruptibly();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">               notEmpty.<span class="keyword">await</span>();</span><br><span class="line">           <span class="keyword">return</span> dequeue();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">lock</span>.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>take()与poll()存在一个区别就是count == 0 时的处理，poll()直接返回null，而take()则是在notEmpty上面等待直到被入列的线程唤醒。</p>
<h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueueTest</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//队列中存满20个元素 在添加新的元素 会一直阻塞</span></span><br><span class="line">        ArrayBlockingQueue&lt;<span class="keyword">String</span>&gt; <span class="built_in">queue</span>=<span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">21</span>; i++) &#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(i);</span><br><span class="line">            <span class="built_in">queue</span>.<span class="built_in">put</span>(<span class="string">&quot;put :&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;size:&quot;</span>+<span class="built_in">queue</span>.<span class="built_in">size</span>());</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-同步队列SynchronousQueue"><a href="#13-同步队列SynchronousQueue" class="headerlink" title="13. 同步队列SynchronousQueue"></a>13. 同步队列SynchronousQueue</h2><ul>
<li>SynchronousQueue 内部没有容量，但是由于一个插入操作总是对应一个移除操作，反过来同样需要满足那么一个元素就不会再SynchronousQueue 里面长时间停留，一旦有了插入线程和移除线程，元素很快就从插入线程移交给移除线程。也就是说这更像是一种信道（管道），资源从一个方向快速传递到另一方 向。显然这是一种快速传递元素的方式， 这种情况下元素总是以最快的方式从插入着（生产者）传递给移除着（消费者），这在多任务队列中是最快处理任务的方式</li>
<li>因为没有容量，所以对应 peek, contains, clear, isEmpty … 等方法其实是无效的。例如clear是不执行任何操作的，contains始终返回false,peek始终返回null。</li>
<li>SynchronousQueue分为公平和非公平，默认情况下采用非公平性访问策略，当然也可以通过构造函数来设置为公平性访问策略（为true即可）。</li>
<li>在线程池里的一个典型应用是Executors.newCachedThreadPool()就使用了SynchronousQueue， 这个线程池根据需要（新任务到来时）创建新的线程，如果有空闲线程则会重复使用，线程空闲了60秒后会被回收。</li>
</ul>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">iterator</span><span class="params">()</span></span> 永远返回空，因为里面没东西。 </span><br><span class="line"><span class="function"><span class="title">peek</span><span class="params">()</span></span> 永远返回null。 </span><br><span class="line"><span class="function"><span class="title">put</span><span class="params">()</span></span> 往queue放进去一个element以后就一直wait直到有其他thread进来把这个element取走。 </span><br><span class="line"><span class="function"><span class="title">offer</span><span class="params">()</span></span> 往queue里放一个element后立即返回，如果碰巧这个element被另一个thread取走了，offer方法返回true，认为offer成功；否则返回false。 </span><br><span class="line"><span class="function"><span class="title">offer</span><span class="params">(<span class="number">2000</span>, TimeUnit.SECONDS)</span></span> 往queue里放一个element但是等待指定的时间后才返回，返回的逻辑和offer()方法一样。 </span><br><span class="line"><span class="function"><span class="title">take</span><span class="params">()</span></span> 取出并且remove掉queue里的element（认为是在queue里的。。。），取不到东西他会一直等。 </span><br><span class="line"><span class="function"><span class="title">poll</span><span class="params">()</span></span> 取出并且remove掉queue里的element（认为是在queue里的。。。），只有到碰巧另外一个线程正在往queue里offer数据或者put数据的时候，该方法才会取到东西。否则立即返回null。 </span><br><span class="line"><span class="function"><span class="title">poll</span><span class="params">(<span class="number">2000</span>, TimeUnit.SECONDS)</span></span> 等待指定的时间然后取出并且remove掉queue里的element,其实就是再等其他的thread来往里塞。 </span><br><span class="line"><span class="function"><span class="title">isEmpty</span><span class="params">()</span></span>永远是true。 </span><br><span class="line"><span class="function"><span class="title">remainingCapacity</span><span class="params">()</span></span> 永远是<span class="number">0</span>。 </span><br><span class="line"><span class="function"><span class="title">remove</span><span class="params">()</span></span>和removeAll() 永远是false。 </span><br></pre></td></tr></table></figure>

<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> SynchronousQueueTest &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) throws InterruptedException &#123;</span><br><span class="line">         final SynchronousQueue&lt;String&gt; queue = <span class="keyword">new</span> SynchronousQueue&lt;String&gt;(<span class="literal">true</span>);</span><br><span class="line">         <span class="comment">//put线程</span></span><br><span class="line">          ExecutorService exec=<span class="module-access"><span class="module"><span class="identifier">Executors</span>.</span></span><span class="keyword">new</span><span class="constructor">CachedThreadPool()</span>;</span><br><span class="line">          exec.execute(<span class="keyword">new</span> <span class="constructor">Runnable()</span> &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run<span class="literal">()</span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                         <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span>+<span class="string">&quot;   put 开始&quot;</span>);</span><br><span class="line">                          queue.put(<span class="string">&quot;put:&quot;</span>+i);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">          exec.shutdown<span class="literal">()</span>;</span><br><span class="line">          <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>sleep(<span class="number">1000</span>);</span><br><span class="line">          <span class="comment">//消费线程</span></span><br><span class="line">          ExecutorService exec2=<span class="module-access"><span class="module"><span class="identifier">Executors</span>.</span></span><span class="keyword">new</span><span class="constructor">CachedThreadPool()</span>;</span><br><span class="line">          exec2.execute(<span class="keyword">new</span> <span class="constructor">Runnable()</span> &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run<span class="literal">()</span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;       </span><br><span class="line">                          <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span>+<span class="string">&quot;  take 消费开始&quot;</span>);</span><br><span class="line">                          <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span> +<span class="string">&quot;  take值： : &quot;</span> +queue.take<span class="literal">()</span>);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                     <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span>+<span class="string">&quot;  take 消费结束&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">          exec2.shutdown<span class="literal">()</span>;</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h3><p>与其他BlockingQueue一样，SynchronousQueue同样继承AbstractQueue和实现BlockingQueue接口：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SynchronousQueue&lt;E&gt;</span> <span class="keyword">extends</span> <span class="title">AbstractQueue&lt;E&gt;</span></span></span><br><span class="line"><span class="class">    <span class="title">implements</span> <span class="title">BlockingQueue&lt;E&gt;</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<p> <strong>SynchronousQueue提供了两个构造函数：</strong> </p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(<span class="literal">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 通过 fair 值来决定公平性和非公平性</span></span><br><span class="line">       <span class="comment">// 公平性使用TransferQueue，非公平性采用TransferStack</span></span><br><span class="line">       transferer = fair ? <span class="keyword">new</span> TransferQueue&lt;E&gt;() : <span class="keyword">new</span> TransferStack&lt;E&gt;();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p> <strong>TransferQueue、TransferStack继承Transferer，Transferer为SynchronousQueue的内部类，它提供了一个方法transfer()，该方法定义了转移数据的规范，如下：</strong> </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Transferer</span>&lt;<span class="title">E</span>&gt; &#123;</span><br><span class="line">       <span class="function"><span class="keyword">abstract</span> E <span class="title">transfer</span>(<span class="params">E e, boolean timed, <span class="keyword">long</span> nanos</span>)</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>transfer()方法主要用来完成转移数据的，如果e != null，相当于将一个数据交给消费者，如果e == null，则相当于从一个生产者接收一个消费者交出的数据。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库</title>
    <url>/2020/10/13/0000.%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/1590590509208-c55e311d-4d15-4bd8-8b43-5bec5a1c2193.png" alt="image"></p>
<h2 id="一、MySQL架构"><a href="#一、MySQL架构" class="headerlink" title="一、MySQL架构"></a>一、MySQL架构</h2><p>和其它数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎的架构上，<strong>插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离</strong>。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/1590590539775-66b802ba-2c1c-4c50-9cd0-a41eb54578e5.png" alt="image"></p>
<ul>
<li><strong>连接层</strong>：最上层是一些客户端和连接服务。<strong>主要完成一些类似于连接处理、授权认证、及相关的安全方案</strong>。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</li>
<li><strong>服务层</strong>：第二层服务层，主要完成大部分的核心服务功能， 包括<strong>查询解析、分析、优化、缓存**</strong>、以及所有的内置函数<strong>，所有跨存储引擎的功能也都在这一层实现，包括</strong>触发器、存储过程、视图**等</li>
<li><strong>引擎层</strong>：第三层存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取</li>
<li><strong>存储层</strong>：第四层为数据存储层，主要是将数据存储在运行于该设备的文件系统之上，并完成与存储引擎的交互</li>
</ul>
<p><strong>MySQL 的查询流程</strong></p>
<p>（所有SQL语句都可以称为查询，包括INSERT,DELETE,UPDATE）</p>
<p>—&gt; 客户端请求</p>
<p>—&gt; 连接器（验证用户身份，给予权限）  </p>
<p>—&gt; 查询缓存（存在缓存则直接返回，不存在则执行后续操作）</p>
<p>—&gt; 分析器（对SQL进行词法分析和语法分析操作）  </p>
<p>—&gt; 优化器（主要对执行的sql优化选择最优的执行方案方法）  </p>
<p>—&gt; 执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口）</p>
<p>—&gt; 去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）</p>
<h2 id="二、MySQL-事务"><a href="#二、MySQL-事务" class="headerlink" title="二、MySQL 事务"></a>二、MySQL 事务</h2><blockquote>
<p>❝</p>
<p>事务的隔离级别有哪些？MySQL的默认隔离级别是什么？</p>
<p>什么是幻读，脏读，不可重复读呢？</p>
<p>MySQL事务的四大特性以及实现原理</p>
<p>MVCC熟悉吗，它的底层原理？</p>
</blockquote>
<p>MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！</p>
<h3 id="ACID-—-事务基本要素"><a href="#ACID-—-事务基本要素" class="headerlink" title="ACID — 事务基本要素"></a>ACID — 事务基本要素</h3><p>事务是由一组SQL语句组成的逻辑处理单元，具有4个属性，通常简称为事务的ACID属性。</p>
<ul>
<li><strong>A (Atomicity) 原子性</strong>：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样</li>
<li><strong>C (Consistency) 一致性</strong>：在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。AID是手段，C是目的，即通过种种手段保证数据库在事务执行前后都处于正确的状态（即数据库列上没有限制数据的范围，但是转账业务中不可能出现账户余额为负的情况，所以要保证事务前后要保证数据库在业务上处于正确的状态）</li>
<li><strong>I (Isolation)隔离性</strong>：一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰</li>
<li><strong>D (Durability) 持久性</strong>：在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚</li>
</ul>
<p><strong>（隔离性不够时）**</strong>并发事务处理带来的问题**</p>
<ul>
<li>**更新丢失（Lost Update)**：事务A和事务B选择同一行，并基于最初选定的值更新该行时，由于两个事务都不知道彼此的存在，就会发生丢失更新问题</li>
<li>**脏读(Dirty Reads)**：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</li>
<li>**不可重复读（Non-Repeatable Reads)**：事务 A 多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。</li>
<li>**幻读（Phantom Reads)**：幻读与不可重复读类似。它发生在一个事务A读取了几行数据，接着另一个并发事务B插入了一些数据时。在随后的查询中，事务A就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>
</ul>
<p><strong>幻读和不可重复读的区别：</strong></p>
<ul>
<li><strong>不可重复读的重点是修改</strong>：在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样。（因为中间有其他事务提交了修改）</li>
<li><strong>幻读的重点在于新增或者删除</strong>：在同一事务中，同样的条件,第一次和第二次读出来的记录数不一样。（因为中间有其他事务提交了插入/删除）</li>
</ul>
<p><strong>并发事务处理带来的问题的解决办法：</strong></p>
<ul>
<li><p>“更新丢失”通常是应该完全避免的。但防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决，因此，防止更新丢失应该是应用的责任。</p>
</li>
<li><p><strong>“脏读” 、 “不可重复读”和“幻读” ，其实都是数据库读一致性问题</strong>，必须由数据库提供一定的事务隔离机制来解决：</p>
</li>
<li><ul>
<li>一种是加锁：在读取数据前，对其加锁，阻止其他事务对数据进行修改。</li>
<li>另一种是数据多版本并发控制（MultiVersion Concurrency Control，<strong>MVCC</strong> ）：可以认为是行级锁的变种， 通过一定机制生成一个数据请求时间点的一致性数据快照 （Snapshot)， 并用这个快照来提供一定级别 （语句级或事务级） 的一致性读取。下面会详细介绍MVCC。</li>
</ul>
</li>
</ul>
<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>数据库事务的隔离级别有4种，由低到高分别为</p>
<ul>
<li><strong>READ-UNCOMMITTED(读未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li>
<li><strong>READ-COMMITTED(读已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li>
<li><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li>
<li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li>
</ul>
<p>查看当前数据库的事务隔离级别：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">&#x27;tx_isolation&#x27;</span></span><br></pre></td></tr></table></figure>

<p>下面通过事例一一阐述在事务的并发操作中可能会出现脏读，不可重复读，幻读和事务隔离级别的联系。</p>
<p><strong>数据库的事务隔离越严格，并发副作用越小，但付出的代价就越大</strong>，因为事务隔离实质上就是使事务在一定程度上“串行化”进行，这显然与“并发”是矛盾的。同时，不同的应用对读一致性和事务隔离程度的要求也是不同的，比如许多应用对“不可重复读”和“幻读”并不敏感，可能更关心数据并发访问的能力。</p>
<ul>
<li><strong>Read uncommitted</strong></li>
</ul>
<p><strong>读未提交，就是一个事务可以读取另一个未提交事务的数据</strong>。</p>
<p>事例：老板要给程序员发工资，程序员的工资是3.6万/月。但是发工资时老板不小心按错了数字，按成3.9万/月，该钱已经打到程序员的户口，但是事务还没有提交，就在这时，程序员去查看自己这个月的工资，发现比往常多了3千元，以为涨工资了非常高兴。但是老板及时发现了不对，马上回滚差点就提交了的事务，将数字改成3.6万再提交。</p>
<p>分析：实际程序员这个月的工资还是3.6万，但是程序员看到的是3.9万。他看到的是老板还没提交事务时的数据。这就是脏读。</p>
<p>那怎么解决脏读呢？Read committed！读提交，能解决脏读问题。</p>
<ul>
<li><strong>Read committed</strong></li>
</ul>
<p><strong>读**</strong>提交，顾名思义，就是一个事务要等另一个事务提交后才能读取数据**。</p>
<p>事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（程序员事务开启），收费系统事先检测到他的卡里有3.6万，就在这个时候！！程序员的妻子要把钱全部转出充当家用，并提交。当收费系统准备扣款时，再检测卡里的金额，发现已经没钱了（第二次检测金额当然要等待妻子转出金额事务提交完）。程序员就会很郁闷，明明卡里是有钱的…</p>
<p>分析：这就是读提交，若有事务对数据进行更新（UPDATE）操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。但在这个事例中，<strong>出现了一个事务范围内两个相同的查询却返回了不同数据</strong>，这就是<strong>不可重复读</strong>。</p>
<p>那怎么解决可能的不可重复读问题？Repeatable read ！</p>
<ul>
<li><strong>Repeatable read</strong></li>
</ul>
<p>重复读，就是在开始读取数据（事务开启）时，不再允许修改操作。<strong>MySQL的默认事务隔离级别</strong></p>
<p>事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（事务开启，不允许其他事务的UPDATE修改操作），收费系统事先检测到他的卡里有3.6万。这个时候他的妻子不能转出金额了。接下来收费系统就可以扣款了。</p>
<p>分析：重复读可以解决不可重复读问题。写到这里，应该明白的一点就是，<strong>不可重复读对应的是修改，即UPDATE操作。但是可能还会有幻读问题。因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作</strong>。</p>
<p><strong>什么时候会出现幻读？</strong></p>
<p>事例：程序员某一天去消费，花了2千元，然后他的妻子去查看他今天的消费记录（全表扫描FTS，妻子事务开启），看到确实是花了2千元，就在这个时候，程序员花了1万买了一部电脑，即新增INSERT了一条消费记录，并提交。当妻子打印程序员的消费记录清单时（妻子事务提交），发现花了1.2万元，似乎出现了幻觉，这就是幻读。</p>
<p>那怎么解决幻读问题？Serializable！</p>
<ul>
<li><strong>Serializable</strong></li>
</ul>
<p>Serializable 是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。简单来说，Serializable会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用问题。这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。</p>
<h4 id="隔离级别比较"><a href="#隔离级别比较" class="headerlink" title="隔离级别比较"></a>隔离级别比较</h4><table>
<thead>
<tr>
<th>事务隔离级别</th>
<th>读数据一致性</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交（read-uncommitted）</td>
<td>最低级被，只能保证不读取物理上损坏的数据</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>读已提交（read-committed）</td>
<td>语句级</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>可重复读（repeatable-read）</td>
<td>事务级</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>串行化（serializable）</td>
<td>最高级别，事务级</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
<p>需要说明的是，<strong>事务隔离级别和数据访问的并发性是对立的</strong>，事务隔离级别越高并发性就越差。所以要根据具体的应用来确定合适的事务隔离级别，这个地方没有万能的原则。</p>
<p><strong>这里需要注意的是：</strong>与 SQL 标准不同的地方在于InnoDB 存储引擎在 <strong>REPEATABLE-READ</strong>（可重读）事务隔离级别下使用的是<strong>Next-Key Lock</strong> 算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 <strong>SERIALIZABLE</strong>(可串行化)隔离级别，而且保留了比较好的并发性能。</p>
<p>因为<strong>隔离级别越低，事务请求的锁越少</strong>，所以大部分数据库系统的隔离级别都是<strong>READ-COMMITTED</strong>(读已提交):，但是你要知道的是<strong>InnoDB 存储引擎默认使用 REPEATABLE-READ（可重读）并不会有任何性能损失</strong>。</p>
<h3 id="MVCC-多版本并发控制"><a href="#MVCC-多版本并发控制" class="headerlink" title="MVCC 多版本并发控制"></a>MVCC 多版本并发控制</h3><p>MySQL的大多数<strong>事务型存储引擎实现都不是简单的行级锁**</strong>。基于提升并发性考虑，一般都同时实现了多版本并发控制（MVCC）**，包括Oracle、PostgreSQL。只是实现机制各不相同</p>
<p><strong>可以认为 MVCC 是行级锁的一个变种，但它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只是锁定必要的行</strong></p>
<p>MVCC 的实现是通过保存数据在某个时间点的快照来实现的。也就是说不管事务需要执行多长时间，每个事物看到的数据都是一致的。根据事务开始时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的</p>
<p><strong>MVCC与幻读：</strong></p>
<ul>
<li><p>当前读：读取数据的最新版本，例如update/insert/dalete/select … for update/select … lock in share mode</p>
</li>
<li><ul>
<li>这种MVCC不能防止幻读</li>
</ul>
</li>
<li><p>快照读：读取事务快照，普通的select语句都是快照读</p>
</li>
<li><ul>
<li>这种方式因为读取的是快照（如果发生了insert也不会修改到快照），所以天然解决了幻读</li>
</ul>
</li>
</ul>
<p>典型的MVCC实现方式，分为<strong>乐观并发控制</strong>和<strong>悲观并发控制</strong>。下边通过 InnoDB的简化版行为来说明 MVCC 是如何工作的。</p>
<p><strong>InnoDB 的 MVCC，是通过在每行记录后面保存两个隐藏的列来实现</strong>。<strong>一个保存了行的创建时间，一个保存行的过期时间（删除时间）</strong>。当然存储的并不是真实的时间，而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</p>
<p><strong>REPEATABLE READ（可重读）隔离级别下MVCC如何工作：</strong></p>
<ul>
<li><p><strong>SELECT：</strong></p>
</li>
<li><ul>
<li>InnoDB会根据以下两个条件检查每行记录，只有符合上述两个条件的才会被查询出来</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>只查找版本早于当前事务版本的数据行，这样可以确保事务读取的行，要么是在开始事务之前已经存在要么是事务自身插入或者修改过的</li>
<li>行的删除版本号要么未定义，要么大于当前事务版本号，这样可以确保事务读取到的行在事务开始之前未被删除</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>INSERT：</strong>InnoDB为新插入的每一行保存当前系统版本号作为行版本号</p>
</li>
<li><p><strong>DELETE：</strong>InnoDB为删除的每一行保存当前系统版本号作为行删除标识</p>
</li>
<li><p><strong>UPDATE：**</strong>InnoDB为插入的一行新纪录保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识**</p>
</li>
</ul>
<p>保存这两个额外系统版本号，使大多数操作都不用加锁。使数据操作简单，性能很好，并且也能保证只会读取到符合要求的行。不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作和一些额外的维护工作。</p>
<p>MVCC 只在 COMMITTED READ（读提交）和REPEATABLE READ（可重复读）两种隔离级别下工作。</p>
<blockquote>
<p>❝你知道MySQL 有多少种日志吗？</p>
</blockquote>
<ul>
<li><strong>错误日志</strong>：记录出错信息，也记录一些警告信息或者正确的信息。</li>
<li><strong>查询日志</strong>：记录所有对数据库请求的信息，不论这些请求是否得到了正确的执行。</li>
<li><strong>慢查询日志</strong>：设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询的日志文件中。</li>
<li><strong>二进制日志</strong>：binlog 记录对数据库执行更改的所有操作。</li>
<li><strong>中继日志</strong>：中继日志也是二进制日志，用来给slave 库恢复</li>
<li><strong>事务日志</strong>：重做日志redo和回滚日志undo</li>
</ul>
<h3 id="InnoDB事务日志"><a href="#InnoDB事务日志" class="headerlink" title="InnoDB事务日志"></a>InnoDB事务日志</h3><p><strong>InnoDB 使用日志来减少提交事务时的开销：因为日志中已经记录了事务，就无须在每个事务提交时把缓冲池的脏块刷新(flush)到磁盘中</strong>。</p>
<p><strong>事务修改的数据和索引通常会映射到表空间的随机位置，所以刷新这些变更到磁盘需要很多随机 I/O</strong>。</p>
<p>随机I/O比顺序IO昂贵得多，因为一个I/O请求需要时间把磁头移到正确的位置，然后等待磁盘上读出需要的部分，再转到开始位置。</p>
<p><strong>InnoDB 用日志把随机IO变成顺序IO。一旦日志安全写到磁盘，事务就持久化了，即使断电了，InnoDB可以重放日志并且恢复已经提交的事务</strong>。</p>
<p>InnoDB 使用一个后台线程智能地刷新这些变更到数据文件。这个线程可以批量组合写入，使得数据写入更顺序，以提高效率。</p>
<p>事务日志可以帮助提高事务效率：</p>
<ul>
<li>使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。</li>
<li>事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，所以采用事务日志的方式相对来说要快得多。</li>
<li>事务日志持久以后，内存中被修改的数据在后台可以慢慢刷回到磁盘。</li>
<li>如果数据的修改已经记录到事务日志并持久化，但数据本身没有写回到磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这一部分修改的数据。</li>
</ul>
<p>目前来说，大多数存储引擎都是这样实现的，我们通常称之为<strong>预写式日志</strong>（Write-Ahead Logging），修改数据需要写两次磁盘。</p>
<h3 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h3><p>事务的实现是基于数据库的存储引擎。不同的存储引擎对事务的支持程度不一样。MySQL 中支持事务的存储引擎有 InnoDB 和 NDB。</p>
<p>事务的实现就是如何实现ACID特性。</p>
<p><strong>事务的隔离性是通过锁实现，而**</strong>事务的**<strong>一致性和持久性则是通过事务日志实现</strong> 。</p>
<blockquote>
<p>❝事务是如何通过日志来实现的，说得越深入越好。</p>
</blockquote>
<p>事务日志包括：<strong>重做日志redo</strong>和<strong>回滚日志undo</strong></p>
<ul>
<li><p><strong>redo log（重做日志</strong>）：实现持久化</p>
</li>
<li><ul>
<li>redo log 是<strong>事务中</strong>操作任何数据，都会将最新的数据备份到一个地方</li>
<li>在InnoDB的存储引擎中，事务日志通过重做(redo)日志和InnoDB存储引擎的日志缓冲(InnoDB Log Buffer)实现。事务开启时，<strong>事务中的操作，在**</strong>执行过程中都会先写入存储引擎的日志缓冲中，**<strong>在**</strong>事务提交之前**<strong>，这些缓冲的日志都需要提前刷新到磁盘上持久化</strong>，这就是DBA们口中常说的“日志先行”(Write-Ahead Logging)。</li>
<li>当事务提交之后，在Buffer Pool中映射的数据文件才会慢慢刷新到磁盘。此时如果数据库崩溃或者宕机，那么当系统重启进行恢复时，就可以根据redo log中记录的日志，把数据库恢复到崩溃前的一个状态。未完成的事务，可以继续提交，也可以选择回滚，这基于恢复的策略而定。</li>
<li><strong>在系统启动的时候，就已经为redo log分配了一块连续的存储空间，以顺序追加的方式记录redo log，通过顺序IO来改善性能</strong>。所有的事务共享redo log的存储空间，它们的redo log按语句的执行顺序，依次交替的记录在一起</li>
<li><strong>redo log和存储结构的关系：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>MySQL基本存储结构是页，所以会先将页加载到内存中，对内存中的页进行修改，然后再刷回磁盘（这个过程是随机IO）</li>
<li>但是一个页16KB，不值得每一次都刷入磁盘，所以会异步的刷到磁盘中</li>
<li>同时防止数据库宕机，而内存没有来得及刷入磁盘，引入了redo log（es也有类似的，translog）</li>
<li>redo log也有自己的内存buffer，先写buffer，然后由于redo log在磁盘中是顺序存储，所以可以很快的就写入磁盘</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1596528160059-8e4787a5-7932-43b1-9c53-c01696d8b624.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image.png"></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>undo log（回滚日志）：</strong>原子性</p>
</li>
<li><ul>
<li>undo log 是<strong>事务开始之前</strong>，操作任何数据之前，首先将需要操作的数据备份到一个地方</li>
<li>undo log 提供两个功能：回滚和MVCC（原子性需要要么成功要么回滚，所以undo log帮助实现原子性）</li>
<li><strong>undo log记录了数据在每个操作前的状态，如果事务执行过程中需要回滚，就可以根据undo log进行回滚操作</strong>。单个事务的回滚，只会回滚当前事务做的操作，并不会影响到其他的事务做的操作</li>
<li>undo log记录的是已部分完成并且写入硬盘的未完成的事务，默认情况下回滚日志是记录下表空间中的（共享表空间或者独享表空间）</li>
<li><strong>undo log和MVCC：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>undo log中的数据可以作为数据旧版本快照供其他并发事务进行快照读</li>
<li>当读取被其他事务锁定的行时，可以从undo log中分析出改行记录以前的数据是什么，从而提供该行版本信息，实现非锁定一致性读取</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1596527329634-8360cba5-8e2c-4d0f-8761-168fe59d4286.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>上面二种日志均可以视为一种恢复操作，redo_log是恢复提交事务修改的页操作，而undo_log是回滚行记录到特定版本。二者记录的内容也不同</p>
</li>
<li><p><strong>redo_log是物理日志，记录页的物理修改操作，而undo_log是逻辑日志，根据每行记录进行记录，binlog也是逻辑日志</strong></p>
</li>
<li><p><strong>binlog：实现复制功能</strong></p>
</li>
<li><ul>
<li><strong>因为MySQL可能使用不同的引擎，所以需要在server层记录执行操作的日志，这样可以实现MySQL的主从复制功能以及发送消息队列功能</strong></li>
<li>然而这种情况会导致redo log与binlog的一致性问题，MySQL通过内部XA两阶段提交机制解决这种一致性的问题</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>本来直接提交redo log啥事也没有，但是因为有binlog的存在，就要想办法保证redo log和binlog一致</li>
<li>步骤细节在下面一节</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>redo log 和 binlog都有共同的字段XID(事务ID)，崩溃时的恢复操作：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>恢复时，顺序扫描redo log</li>
<li>如果既prepare，又commit，则直接提交redo log，将redo log中的数据写入真正的页中</li>
<li>如果只有prepare，没有commit，则根据XID检查binlog，如果binlog中有XID，则也将redo log中的数据写入真的的页中</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>为什么这么做？</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>引入binlog保证数据库的主从一致性</li>
<li>防止出现主从不一致，使用了两阶段提交</li>
<li>崩溃恢复时如果binlog中包含了事务，则会提交，因为binlog会复制到其他数据库中，所以binlog中有的事务需要提交</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>只用binlog行不行？</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>binlog记录逻辑日志，没有数据页的更新细节，所以不能恢复</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>只用redo log行不行？</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>不可行，需要binlog屏蔽MySQL底层的引擎</li>
<li>同时，主从复制的时候传播的是逻辑操作，redo log这种物理操作不能应用在主从复制中</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="事务的写入过程"><a href="#事务的写入过程" class="headerlink" title="事务的写入过程"></a>事务的写入过程</h3><ul>
<li><p>一个事务的例子：</p>
</li>
<li><ul>
<li>步骤1:begin;</li>
<li>步骤2:insert into t1 …r</li>
<li>步骤3:insert into t2 …</li>
<li>步骤4:commit;</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/1590590539973-d4b0a609-44be-4018-b989-cc1e2967d8c9.png" alt="image.png"></p>
<ul>
<li><p>MySQL的事务使用两阶段提交(2PC)，事务提交前，将redo log的写入拆成了两个步骤，prepare和commit</p>
</li>
<li><ul>
<li>redo log 和binlog 有一个共同的数据字段，叫 XID,崩溃恢复的时候，会按顺序扫描 redo log</li>
<li>假设在写入binlog前系统崩溃，那么数据库恢复后顺序扫描 redo log，碰到只有 parepare、而没有 commit 的 redo log，就拿着 XID（事务ID） 去 binlog 找对应的事务，而且binlog也没写入，所以事务就直接回滚了</li>
<li>假设在写入binlog之后，事务提交前数据库崩溃，那么数据库恢复后顺序扫描 redo log，碰到既有 prepare、又有 commit 的 redo log，就直接提交，保证主从一致性</li>
</ul>
</li>
</ul>
<h3 id="MySQL对分布式事务的支持"><a href="#MySQL对分布式事务的支持" class="headerlink" title="MySQL对分布式事务的支持"></a>MySQL对分布式事务的支持</h3><p>分布式事务的实现方式有很多，既可以采用 InnoDB 提供的原生的事务支持，也可以采用消息队列来实现分布式事务的最终一致性。这里我们主要聊一下 InnoDB 对分布式事务的支持。</p>
<p>MySQL 从 5.0.3  InnoDB 存储引擎开始支持XA协议的分布式事务。一个分布式事务会涉及多个行动，这些行动本身是事务性的。所有行动都必须一起成功完成，或者一起被回滚。</p>
<p>在MySQL中，使用分布式事务涉及一个或多个资源管理器和一个事务管理器。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/1590590539973-d4b0a609-44be-4018-b989-cc1e2967d8c9.png" alt="image"></p>
<p>如图，MySQL 的分布式事务模型。模型中分三块：应用程序（AP）、资源管理器（RM）、事务管理器（TM）:</p>
<ul>
<li>应用程序：定义了事务的边界，指定需要做哪些事务；</li>
<li>资源管理器：提供了访问事务的方法，通常一个数据库就是一个资源管理器；</li>
<li>事务管理器：协调参与了全局事务中的各个事务。</li>
</ul>
<p>分布式事务采用两段式提交（two-phase commit）的方式：</p>
<ul>
<li>第一阶段所有的事务节点开始准备，告诉事务管理器ready。</li>
<li>第二阶段事务管理器告诉每个节点是commit还是rollback。如果有一个节点失败，就需要全局的节点全部rollback，以此保障事务的原子性。</li>
</ul>
<h2 id="三、MySQL锁机制"><a href="#三、MySQL锁机制" class="headerlink" title="三、MySQL锁机制"></a>三、MySQL锁机制</h2><blockquote>
<p>❝</p>
<p>数据库的乐观锁和悲观锁？</p>
<p>MySQL 中有哪几种锁，列举一下？</p>
<p>MySQL中InnoDB引擎的行锁是怎么实现的？</p>
<p>MySQL 间隙锁有没有了解，死锁有没有了解，写一段会造成死锁的 sql 语句，死锁发生了如何解决，MySQL 有没有提供什么机制去解决死锁</p>
</blockquote>
<h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><p><strong>从对数据操作的类型分类</strong>：</p>
<ul>
<li><strong>读锁</strong>（共享锁）：针对同一份数据，多个读操作可以同时进行，不会互相影响</li>
<li><strong>写锁</strong>（排他锁）：当前写操作没有完成前，它会阻断其他写锁和读锁</li>
</ul>
<p><strong>从对数据操作的粒度分类</strong>：</p>
<p>为了尽可能提高数据库的并发度，每次锁定的数据范围越小越好，理论上每次只锁定当前操作的数据的方案会得到最大的并发度，但是管理锁是很耗资源的事情（涉及获取，检查，释放锁等动作），因此数据库系统需要在高并发响应和系统性能两方面进行平衡，这样就产生了“锁粒度（Lock granularity）”的概念。</p>
<ul>
<li><strong>表级锁</strong>：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低（MyISAM 和 MEMORY 存储引擎采用的是表级锁）；</li>
<li><strong>行级锁</strong>：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高（InnoDB 存储引擎既支持行级锁也支持表级锁，但默认情况下是采用行级锁）；</li>
<li><strong>页面锁</strong>：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</li>
</ul>
<p>适用：从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。</p>
<table>
<thead>
<tr>
<th></th>
<th>行锁</th>
<th>表锁</th>
<th>页锁</th>
</tr>
</thead>
<tbody><tr>
<td>MyISAM</td>
<td></td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>BDB</td>
<td></td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>InnoDB</td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>Memory</td>
<td></td>
<td>√</td>
<td></td>
</tr>
</tbody></table>
<h3 id="MyISAM-表锁"><a href="#MyISAM-表锁" class="headerlink" title="MyISAM 表锁"></a>MyISAM 表锁</h3><p>MyISAM 的表锁有两种模式：</p>
<ul>
<li>表共享读锁 （Table Read Lock）：不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；</li>
<li>表独占写锁 （Table Write Lock）：会阻塞其他用户对同一表的读和写操作；</li>
</ul>
<p>MyISAM 表的读操作与写操作之间，以及写操作之间是串行的。当一个线程获得对一个表的写锁后， 只有持有锁的线程可以对表进行更新操作。其他线程的读、 写操作都会等待，直到锁被释放为止。</p>
<p>默认情况下，写锁比读锁具有更高的优先级：当一个锁释放时，这个锁会优先给写锁队列中等候的获取锁请求，然后再给读锁队列中等候的获取锁请求。</p>
<h3 id="InnoDB-行锁"><a href="#InnoDB-行锁" class="headerlink" title="InnoDB 行锁"></a>InnoDB 行锁</h3><ul>
<li><p>InnoDB 实现了以下两种类型的<strong>行锁</strong>：</p>
</li>
<li><ul>
<li>共享锁（shared lock S锁，又称读锁）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</li>
<li>排他锁（exclusive lock X锁，又称写锁）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。insert ，delete ， <strong>update在事务中都会自动默认加上排它锁</strong>。</li>
</ul>
</li>
<li><p>同时InnoDB还实现了<strong>多粒度锁</strong>：</p>
</li>
</ul>
<p><strong>为了允许行锁和表锁共存，实现多粒度锁机制——意向锁</strong>（Intention Locks）：未来的某个时刻，事务可能要加共享/排它锁了，先提前声明一个意向</p>
<ul>
<li><ul>
<li>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。</li>
<li>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。</li>
</ul>
</li>
<li><p>“冲突—兼容”规则：</p>
</li>
<li><ul>
<li><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/1590745463390-4377c2d2-8ea7-4d04-8a13-a78ec84125eb.png" alt="image"></li>
<li><strong>意向锁是怎么提高检测效率的？</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li><strong>在加表锁的时可立即检测到是否存在意向锁，若存在，则说明有行锁，因此无须遍历整个表即可知道发生冲突</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="加锁机制"><a href="#加锁机制" class="headerlink" title="加锁机制"></a>加锁机制</h4><ul>
<li><p><strong>乐观锁与悲观锁是两种并发控制的思想，可用于解决丢失更新问题</strong></p>
</li>
<li><ul>
<li>乐观锁会“乐观地”假定大概率不会发生并发更新冲突，访问、<strong>处理数据过程中不加锁**</strong>，**<strong>只在更新数据时再根据版本号或时间戳判断是否有冲突</strong>，有则处理，无则提交事务。用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式</li>
<li>悲观锁会“悲观地”假定大概率会发生并发更新冲突，访问、<strong>处理数据前就加排他锁</strong>，<strong>在整个数据处理过程中锁定数据，事务提交或回滚后才释放锁</strong>。另外与乐观锁相对应的，<strong>悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。</strong></li>
</ul>
</li>
<li><p><strong>悲观锁的例子：</strong></p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">//step1: 查出商品状态，使用悲观锁锁定需要修改的数据</span><br><span class="line"><span class="keyword">select</span> quantity <span class="keyword">from</span> items <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">100</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line">//step2: 根据商品信息生成订单</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> orders(<span class="keyword">id</span>,item_id) <span class="keyword">values</span>(<span class="literal">null</span>,<span class="number">100</span>);</span><br><span class="line">//step3: 修改商品的库存</span><br><span class="line"><span class="keyword">update</span> Items <span class="keyword">set</span> quantity=quantity<span class="number">-2</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>乐观锁的例子</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">//step1: 查询出商品信息，普通快照读</span><br><span class="line"><span class="keyword">select</span> (quantity,<span class="keyword">version</span>) <span class="keyword">from</span> items <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">100</span>;</span><br><span class="line">//step2: 根据商品信息生成订单</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> orders(<span class="keyword">id</span>,item_id) <span class="keyword">values</span>(<span class="literal">null</span>,<span class="number">100</span>);</span><br><span class="line">//step3: 修改商品的库存，使用版本号进行判断修改</span><br><span class="line"><span class="keyword">update</span> items <span class="keyword">set</span> quantity=quantity<span class="number">-1</span>,<span class="keyword">version</span>=<span class="keyword">version</span>+<span class="number">1</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">100</span> <span class="keyword">and</span> <span class="keyword">version</span>=<span class="comment">#&#123;version&#125;;</span></span><br></pre></td></tr></table></figure>

<p>**<br>**</p>
<h4 id="锁模式"><a href="#锁模式" class="headerlink" title="锁模式"></a>锁模式</h4><p><strong>上面是各种锁的思想，或者分类，下面是InnoDB实际使用的锁的模式</strong></p>
<ul>
<li><p>**记录锁(Record Locks，也被称为行锁)**：</p>
</li>
<li><ul>
<li>单个行记录上的锁。对索引项加锁，锁定符合条件的索引而不是真正的数据记录，如果表上没有索引，则会使用自动创建的隐藏主键索引</li>
<li>加上记录锁后，其他事务不能再获取排他锁，即不能修改和删除加锁项（但是可以快照读）；</li>
<li>记录锁分为共享锁和排他锁：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>使用共享锁：<code>SELECT ... </code>**<code>LOCK IN SHARE MODE</code>**<code>;</code></li>
<li>使用排他锁（悲观锁）：<code>SELECT ... </code>**<code>FOR UPDATE</code>**`;```</li>
<li>使用了排他锁，如果事务结束前，其他事务不能修改锁定的数据</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>使用记录锁的方法：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><strong>精准确定哪些行需要加锁时会使用记录锁</strong></li>
<li><code>SELECT * FROM table </code><strong><code>WHERE id = 1</code></strong><code> FOR UPDATE;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>它会在 id=1 的记录上加上记录锁，以阻止其他事务插入，更新，删除 id=1 这一行</p>
<p><strong>如果where中不是精准匹配，而是&gt;,&lt;,like等，那么就会转换成临建锁</strong></p>
<ul>
<li><ul>
<li><ul>
<li>在通过 主键索引 与 唯一索引 对数据行进行 UPDATE 操作时，也会对该行数据加记录锁：</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong><code>UPDATE</code></strong><code>SET age = 50</code><strong><code>WHERE id = 1</code></strong><code>;-- id 列为主键列或唯一索引列</code></p>
<ul>
<li><p><strong>间隙锁（Gap Locks）</strong>：</p>
</li>
<li><ul>
<li><strong>当检索数据是范围条件时，即不能精准确定哪些行数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁</strong>。</li>
<li>对索引项之间的“间隙”加锁，锁定记录的范围（对第一条记录前的间隙或最后一条将记录后的间隙加锁），不包含索引项本身。<strong>使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据</strong></li>
<li><strong>间隙锁基于非唯一索引，它锁定一段范围内的索引记录。间隙锁基于下面将会提到的**</strong><code>Next-Key Locking</code>** <strong>算法</strong></li>
<li>其他事务不能在锁范围内插入数据，这样就防止了别的事务新增幻影行（即，隔离级别为可重复读时解决部分幻读）。</li>
<li>如果将事务的隔离级别降级为读提交(Read Committed, RC)，间隙锁则会自动失效。</li>
<li>间隙锁是排他锁，只在UPDATE、DELETE以及特殊的SELECT语句中出现（INSERT语句采用了另外一种锁——插入意向间隙锁）</li>
<li>使用间隙锁：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><code>SELECT * FROM table</code><strong><code> WHERE id BETWEN 1 AND 10</code></strong><code> FOR UPDATE;</code></li>
<li>所有在**<code>（1，10）</code>**区间内的记录行都会被锁住，所有id 为 2-9 的数据行的插入会被阻塞，但是 1 和 10 两条记录行并不会被锁住。</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>间隙锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况</li>
</ul>
</li>
<li><p>**临键锁(Next-key Locks)**：</p>
</li>
<li><ul>
<li><strong>临键锁</strong>，是<strong>记录锁与间隙锁的组合</strong>，它的封锁范围，既包含索引记录，又包含索引区间。<br>Next-Key 可以理解为一种特殊的<strong>间隙锁</strong>，也可以理解为一种特殊的<strong>算法</strong>。</li>
<li><strong>临键锁的索引必须是非唯一索引，如果索引是唯一索引，则临键锁降级为行锁，仅锁住索引本身，而不会锁住范围</strong></li>
<li>通过临键锁可以解决幻读的问题。每个数据行上的非唯一索引列上都会存在一把临键锁，当某个事务持有该数据行的临键锁时，<strong>会锁住一段左开右闭区间的数据</strong>。</li>
<li>如果把事务的隔离级别降级为RC，临键锁则也会失效。</li>
<li>对于非唯一索引的行的查询，都是采用该方法，主要目的是解决幻读的问题。</li>
<li>例子：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>表table(id PK, age KEY, name)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1590748148197-bfa179a3-78e2-4f4f-b304-2f01083a34ca.png" alt="image.png"></p>
<ul>
<li><ul>
<li><ul>
<li>该表中 age 列潜在的临键锁有：-∞, 10], (10, 24], (24, 32], (32, 45], (45, +∞]</li>
<li>在<code>事务 A</code> 中执行如下命令：</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>– 根据非唯一索引列 UPDATE 某条记录</p>
<p>UPDATE table SET name = Vladimir WHERE age = 24;</p>
<p>– 或根据非唯一索引列 锁住某条记录</p>
<p>SELECT * FROM table WHERE age = 24 FOR UPDATE;</p>
<ul>
<li><ul>
<li><ul>
<li>不管执行了上述 SQL 中的哪一句，之后如果在<code>事务 B</code> 中执行以下命令，则该命令会被阻塞：</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>INSERT INTO table VALUES(100, 26, ‘Ezreal’);</p>
<ul>
<li><p><strong>插入意向间隙锁（Insert Intention Gap Lock）:</strong></p>
</li>
<li><ul>
<li>对于数据的修改和删除，必须使用强排他锁，而对于数据的插入不需要这么强的锁</li>
<li>如果多个事务希望对同一个索引间隙插入数据，只要插入的不是同一个位置，则可以直接执行，不用等待其他事务结束，即不会阻塞</li>
<li><strong>使用共享锁提高读读并发，使用插入意向间隙锁提高插入并发</strong></li>
<li>例子：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>表索引：t(id unique PK, name)，列name不是唯一索引</li>
<li>表中数据：</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>10, shenjian</li>
<li>20, zhangsan</li>
<li>30, lisi</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>事务A先执行，在10与20两条记录中插入了一行，还未提交：insert into t values(11, xxx);</li>
<li>事务B后执行，也在10与20两条记录中插入了一行：insert into t values(12, ooo);</li>
<li>这时使用插入意向间隙锁，事务B不会被阻塞</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li><strong>InnoDB</strong> 中的<code>行锁</code>的实现依赖于<code>索引</code>，一旦某个加锁操作没有使用到索引，那么该锁就会退化为<code>表锁</code>。</li>
<li><strong>记录锁</strong>存在于包括<code>主键索引</code>在内的<code>唯一索引</code>中，锁定单条索引记录。</li>
<li><strong>间隙锁</strong>存在于<code>非唯一索引</code>中，锁定<code>开区间</code>范围内的一段间隔，它是基于<strong>临键锁</strong>实现的。</li>
<li><strong>临键锁</strong>存在于<code>非唯一索引</code>中，该类型的每条记录的索引上都存在这种锁，它是一种特殊的<strong>间隙锁</strong>，锁定一段<code>左开右闭</code>的索引区间。</li>
</ol>
<blockquote>
<p>❝MySQL 遇到过死锁问题吗，你是如何解决的？</p>
</blockquote>
<h4 id="读取方式"><a href="#读取方式" class="headerlink" title="读取方式"></a>读取方式</h4><ul>
<li>快照读(Snapshot Read)：基于 MVCC 和 undo log 实现的，普通的select读，读数据记录的快照版本，不加锁</li>
</ul>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> xxx;</span><br></pre></td></tr></table></figure>

<ul>
<li>当前读(Current Read)：基于临键锁（记录锁 + 间隙锁）实现的，特殊的select读。读数据记录的最新版本，且在读取完成前需要保证数据不被其他事务修改，因此要加锁</li>
</ul>
<p>select * from t where xxx <strong>for update</strong>———排他锁</p>
<p>​    select * from t where xxx <strong>lock in share mode</strong>———共享锁</p>
<p>​    <strong>update / insert / delete</strong>———排他锁</p>
<h4 id="索引访问与加锁方式"><a href="#索引访问与加锁方式" class="headerlink" title="索引访问与加锁方式"></a>索引访问与加锁方式</h4><ul>
<li><p><strong>主键访问：</strong></p>
</li>
<li><ul>
<li>RC(Read Commit)模式： </li>
</ul>
</li>
</ul>
<p>只需要给主键上查询对应的记录加锁只需要给主键上查询对应的记录加锁，不存在间隙锁</p>
<ul>
<li><ul>
<li>RR(Repeatable Read)模式：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>等值查询：加Next-key LOCK，如果键值满足条件，Next-key LOCK退化为行锁，如果不满足条件，Next-key LOCK退化为GAP锁</li>
<li>范围查询：加Next-key LOCK，一直遍历到第一个不满足查询条件的键值为止，且锁不退化</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>唯一性二级索引访问：</strong></p>
<p>和主键访问的区别是一个是锁主键索引，一个是锁二级索引+对应的主键记录 </p>
</li>
<li><p><strong>非唯一性二级索引访问：</strong></p>
</li>
<li><ul>
<li>RC模式：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>只需要给二级索引上对应的记录和对应主键索引上的记录加锁只需要给主键上查询对应的记录加锁，不存在间隙锁</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>RR模式：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>等值查询：加Next-key LOCK，一直遍历到第一个不满足查询条件的键值为止，然后把这个Next-key LOCK退化为GAP锁</li>
<li>范围查询：加Next-key LOCK，一直遍历到第一个不满足查询条件的键值为止，且锁不退化</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>无索引访问</strong>(也可以叫做主键索引全扫描、全表扫描)：</p>
</li>
<li><ul>
<li>RC模式：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>主键上所有记录行加锁，返回给Server层，Server层进行过滤，对不满足条件的记录，调用unlock_row方法放锁</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>RR模式：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>主键上所有记录行和GAP加锁，返回给Server层，Server层进行过滤，且事务结束之前不会释放</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><strong>死锁产生</strong>：</p>
<ul>
<li>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环</li>
<li>当事务试图以不同的顺序锁定资源时，就可能产生死锁。多个事务同时锁定同一个资源时也可能会产生死锁</li>
<li>锁的行为和顺序和存储引擎相关。以同样的顺序执行语句，有些存储引擎会产生死锁有些不会——死锁有双重原因：真正的数据冲突；存储引擎的实现方式。</li>
</ul>
<p><strong>检测死锁</strong>：数据库系统实现了各种死锁检测和死锁超时的机制。InnoDB存储引擎能检测到死锁的循环依赖并立即返回一个错误。</p>
<p><strong>死锁恢复</strong>：死锁发生以后，只有部分或完全回滚其中一个事务，才能打破死锁，InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。所以事务型应用程序在设计时必须考虑如何处理死锁，多数情况下只需要重新执行因死锁回滚的事务即可。</p>
<p><strong>外部锁的死锁检测</strong>：发生死锁后，InnoDB 一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及表锁的情况下，InnoDB 并不能完全自动检测到死锁， 这需要通过设置锁等待超时参数 innodb_lock_wait_timeout 来解决</p>
<p><strong>死锁影响性能</strong>：死锁会影响性能而不是会产生严重错误，因为InnoDB会自动检测死锁状况并回滚其中一个受影响的事务。在高并发系统上，当许多线程等待同一个锁时，死锁检测可能导致速度变慢。有时当发生死锁时，禁用死锁检测（使用innodb_deadlock_detect配置选项）可能会更有效，这时可以依赖<code>innodb_lock_wait_timeout</code>设置进行事务回滚。</p>
<p><strong>MyISAM避免死锁</strong>：</p>
<ul>
<li><strong>在自动加锁的情况下，MyISAM 总是一次获得 SQL 语句所需要的全部锁，所以 MyISAM 表不会出现死锁。</strong></li>
</ul>
<p><strong>InnoDB避免死锁</strong>：</p>
<ul>
<li>为了在单个InnoDB表上执行多个并发写入操作时避免死锁，可以在事务开始时通过为预期要修改的每行使用<code>SELECT ... FOR UPDATE</code>语句来获取必要的锁，即使这些行的更改语句是在之后才执行的。</li>
<li>在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应先申请共享锁、更新时再申请排他锁，因为这时候当用户再申请排他锁时，其他事务可能又已经获得了相同记录的共享锁，从而造成锁冲突，甚至死锁</li>
<li>如果事务需要修改或锁定多个表，则应在每个事务中以相同的顺序使用加锁语句。在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会</li>
<li>通过<code>SELECT ... LOCK IN SHARE MODE</code>获取行的读锁后，如果当前事务再需要对该记录进行更新操作，则很有可能造成死锁。</li>
<li>改变事务隔离级别</li>
</ul>
<p>如果出现死锁，可以用 <code>show engine innodb status;</code>命令来确定最后一个死锁产生的原因。返回结果中包括死锁相关事务的详细信息，如引发死锁的 SQL 语句，事务已经获得的锁，正在等待什么锁，以及被回滚的事务等。据此可以分析死锁产生的原因和改进措施。</p>
<h3 id="with-nolock-（SQL-Server）"><a href="#with-nolock-（SQL-Server）" class="headerlink" title="with(nolock)（SQL Server）"></a>with(nolock)（SQL Server）</h3><ul>
<li><p>with(nolock)是表提示（table_hint）中的一种，等同于READUNCOMMITTED，提高并发查询性能的同时可能会导致脏读</p>
</li>
<li><p><strong>特点：</strong></p>
</li>
<li><ul>
<li>允许脏读：不发布共享锁来阻止其他事务修改当前事务读取的数据，其他事务设置的排他锁不会阻碍当前事务读取锁定数据。允许脏读可能产生较多的并发操作，但其代价是读取以后会被其他事务回滚的数据修改。这可能会使您的事务出错，向用户显示从未提交过的数据，或者导致用户两次看到记录（或根本看不到记录）</li>
<li>READUNCOMMITTED 和 NOLOCK 提示仅适用于数据锁。所有查询（包括那些带有 READUNCOMMITTED 和 NOLOCK 提示的查询）都会在编译和执行过程中获取 Sch-S（架构稳定性）锁。因此，当并发事务持有表的 Sch-M（架构修改）锁时，将阻塞查询。例如，数据定义语言 (DDL) 操作在修改表的架构信息之前获取 Sch-M 锁。所有并发查询（包括那些使用 READUNCOMMITTED 或 NOLOCK 提示运行的查询）都会在尝试获取 Sch-S 锁时被阻塞。相反，持有 Sch-S 锁的查询将阻塞尝试获取 Sch-M 锁的并发事务</li>
<li>不能为通过插入、更新或删除操作修改过的表指定 READUNCOMMITTED 和 NOLOCK。SQL Server 查询优化器忽略 FROM 子句中应用于 UPDATE 或 DELETE 语句的目标表的 READUNCOMMITTED 和 NOLOCK 提示</li>
</ul>
</li>
<li><p><strong>使用场景：</strong></p>
</li>
<li><ul>
<li>是否使用要综合考虑性能情况与业务要求来决定，大体来说一般有下面一些场景可以使用WITH(NOLOCK)</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>基础数据表，这些表的数据很少变更</li>
<li>历史数据表，这些表的数据很少变更</li>
<li>业务允许脏读情况出现涉及的表</li>
<li>数据量超大的表，出于性能考虑，而允许脏读</li>
</ul>
</li>
</ul>
</li>
<li><p>如何产生脏读</p>
</li>
<li><ul>
<li>不使用的正常情况</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>会话窗口1，开启事务修改数据但是不提交也不回滚</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li><code>BEGIN TRAN</code></li>
<li><code>UPDATE TEST SET NAME=&#39;Timmy&#39; WHERE OBJECT_ID =1;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>会话窗口2，查询数据，但是被阻塞了（会话2在等待获取共享锁）</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li><code>SELECT * FROM TEST;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>使用的情况</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>会话窗口3，可以查询结果</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li><code>SELECT * FROM TEST WITH(NOLOCK)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>会话窗口1，回滚，出现脏读</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="四、存储引擎"><a href="#四、存储引擎" class="headerlink" title="四、存储引擎"></a>四、存储引擎</h2><p>存储引擎是MySQL的组件，用于处理不同表类型的SQL操作。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以获得特定的功能。</p>
<p>使用哪一种引擎可以灵活选择，<strong>一个数据库中多个表可以使用不同引擎以满足各种性能和实际需求</strong>，使用合适的存储引擎，将会提高整个数据库的性能 。</p>
<p>MySQL服务器使用<strong>可插拔</strong>的存储引擎体系结构，可以从运行中的 MySQL 服务器加载或卸载存储引擎 。</p>
<h3 id="查看存储引擎"><a href="#查看存储引擎" class="headerlink" title="查看存储引擎"></a>查看存储引擎</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看支持的存储引擎</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">ENGINES</span></span><br><span class="line"><span class="comment">-- 查看默认存储引擎</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">&#x27;storage_engine&#x27;</span></span><br><span class="line"><span class="comment">--查看具体某一个表所使用的存储引擎，这个默认存储引擎被修改了！</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> tablename</span><br><span class="line"><span class="comment">--准确查看某个数据库中的某一表所使用的存储引擎</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">&#x27;tablename&#x27;</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> <span class="keyword">status</span> <span class="keyword">from</span> <span class="keyword">database</span> <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">&quot;tablename&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="设置存储引擎"><a href="#设置存储引擎" class="headerlink" title="设置存储引擎"></a>设置存储引擎</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 建表时指定存储引擎。默认的就是INNODB，不需要设置</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (i <span class="built_in">INT</span>) <span class="keyword">ENGINE</span> = <span class="keyword">INNODB</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t2 (i <span class="built_in">INT</span>) <span class="keyword">ENGINE</span> = CSV;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t3 (i <span class="built_in">INT</span>) <span class="keyword">ENGINE</span> = <span class="keyword">MEMORY</span>;</span><br><span class="line"><span class="comment">-- 修改存储引擎</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="comment">-- 修改默认存储引擎，也可以在配置文件my.cnf中修改默认引擎</span></span><br><span class="line"><span class="keyword">SET</span> default_storage_engine=NDBCLUSTER;</span><br></pre></td></tr></table></figure>

<p>默认情况下，每当 <code>CREATE TABLE</code> 或 <code>ALTER TABLE</code> 不能使用默认存储引擎时，都会生成一个警告。为了防止在所需的引擎不可用时出现令人困惑的意外行为，可以启用 <code>NO_ENGINE_SUBSTITUTION SQL</code> 模式。如果所需的引擎不可用，则此设置将产生错误而不是警告，并且不会创建或更改表</p>
<h3 id="存储引擎对比"><a href="#存储引擎对比" class="headerlink" title="存储引擎对比"></a>存储引擎对比</h3><p>常见的存储引擎就 InnoDB、MyISAM、Memory、NDB。</p>
<p>InnoDB 现在是 MySQL 默认的存储引擎，支持<strong>事务、行级锁定和外键</strong></p>
<h4 id="文件存储结构对比"><a href="#文件存储结构对比" class="headerlink" title="文件存储结构对比"></a>文件存储结构对比</h4><p>在 MySQL中建立任何一张数据表，在其数据目录对应的数据库目录下都有对应表的 <code>.frm</code> 文件，<code>.frm</code> 文件是用来保存每个数据表的元数据(meta)信息，包括表结构的定义等，与数据库存储引擎无关，也就是任何存储引擎的数据表都必须有<code>.frm</code>文件，命名方式为 数据表名.frm，如user.frm。</p>
<p>查看MySQL 数据保存在哪里：<code>show variables like &#39;data%&#39;</code></p>
<p><strong>MyISAM 物理文件结构为：</strong></p>
<ul>
<li><code>.frm</code>文件：与表相关的元数据信息都存放在frm文件，包括<strong>表结构的定义信息</strong>等</li>
<li><code>.MYD</code> (<code>MYData</code>) 文件：MyISAM 存储引擎专用，用于存储MyISAM <strong>表的数据</strong></li>
<li><code>.MYI</code> (<code>MYIndex</code>)文件：MyISAM 存储引擎专用，用于存储MyISAM <strong>表的索引相关信息</strong></li>
</ul>
<p><strong>InnoDB 物理文件结构为：</strong></p>
<ul>
<li><code>.frm</code> 文件：与表相关的元数据信息都存放在frm文件，包括<strong>表结构的定义信息</strong>等</li>
<li><code>.ibd</code> 文件或 <code>.ibdata</code> 文件：这两种文件都是存放 InnoDB 数据的文件，之所以有两种文件形式存放 InnoDB 的数据，是因为 InnoDB 的数据存储方式能够通过配置来决定是使用<strong>共享表空间</strong>存放存储数据，还是用<strong>独享表空间</strong>存放存储数据。<br>独享表空间存储方式使用<code>.ibd</code>文件，并且每个表一个<code>.ibd</code>文件 共享表空间存储方式使用<code>.ibdata</code>文件，所有表共同使用一个<code>.ibdata</code>文件（或多个，可自己配置）</li>
</ul>
<h4 id="MyISAM和InnoDB区别"><a href="#MyISAM和InnoDB区别" class="headerlink" title="MyISAM和InnoDB区别"></a>MyISAM和InnoDB区别</h4><ol>
<li>InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</li>
<li>InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；</li>
<li>InnoDB 是聚簇索引，MyISAM 是非聚簇索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是二级索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和二级索引是独立的。</li>
<li>InnoDB 不保存表的具体行数，执行<code>select count(*) from table</code> 时需要全表扫描。而 MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</li>
<li>InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。MyISAM一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</li>
</ol>
<table>
<thead>
<tr>
<th>对比项</th>
<th>MyISAM</th>
<th>InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td>主外键</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>事务</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>行表锁</td>
<td>表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</td>
<td>行锁,操作时只锁某一行，不对其它行有影响，适合高并发的操作</td>
</tr>
<tr>
<td>缓存</td>
<td>只缓存索引，不缓存真实数据</td>
<td>不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响</td>
</tr>
<tr>
<td>表空间</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>关注点</td>
<td>性能</td>
<td>事务</td>
</tr>
<tr>
<td>默认安装</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<blockquote>
<p>❝一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15 ？</p>
</blockquote>
<p>如果表的类型是MyISAM，那么是18。因为MyISAM表会把自增主键的最大ID 记录到数据文件中，重启MySQL自增主键的最大ID也不会丢失；</p>
<p>如果表的类型是InnoDB，那么是15。因为InnoDB 表只是把自增主键的最大ID记录到内存中，所以重启数据库或对表进行OPTION操作，都会导致最大ID丢失。</p>
<blockquote>
<p>❝哪个存储引擎执行 select count(*) 更快，为什么?</p>
</blockquote>
<p>MyISAM更快，因为MyISAM内部维护了一个计数器，可以直接调取。</p>
<ul>
<li>在 MyISAM 存储引擎中，把表的总行数存储在磁盘上，当执行 select count(*) from t 时，直接返回总数据。</li>
<li>在 InnoDB 存储引擎中，跟 MyISAM 不一样，没有将总行数存储在磁盘上，当执行 select count(*) from t 时，会先把数据读出来，一行一行的累加，最后返回总数量。</li>
</ul>
<p>InnoDB 中 count(*) 语句是在执行的时候，全表扫描统计总数量，所以当数据越来越大时，语句就越来越耗时了，为什么 InnoDB 引擎不像 MyISAM 引擎一样，将总行数存储到磁盘上？这跟 InnoDB 的事务特性有关，<strong>由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的</strong>。</p>
<p>❝为什么MyISAM读取速度更快？</p>
<ul>
<li>InnoDB 在做 SELECT 的时候，要维护的东西比 MYISAM 引擎多很多，比如检查和维护MVCC</li>
<li>innodb寻址要映射到块，再到行，MYISAM记录的直接是文件的OFFSET，定位比INNODB要快</li>
</ul>
<h2 id="五、数据类型"><a href="#五、数据类型" class="headerlink" title="五、数据类型"></a>五、数据类型</h2><h3 id="MySQL的数据类型"><a href="#MySQL的数据类型" class="headerlink" title="MySQL的数据类型"></a>MySQL的数据类型</h3><ul>
<li>整数类型：BIT、BOOL、TINY INT、SMALL INT、MEDIUM INT、 INT、 BIG INT</li>
<li>浮点数类型：FLOAT、DOUBLE、DECIMAL</li>
<li>字符串类型：CHAR、VARCHAR、TINY TEXT、TEXT、MEDIUM TEXT、LONG TEXT、TINY BLOB、BLOB、MEDIUM BLOB、LONG BLOB</li>
<li>日期类型：Date、DateTime、TimeStamp、Time、Year</li>
<li>其他数据类型：BINARY、VARBINARY、ENUM、SET、Geometry、Point、MultiPoint、LineString、MultiLineString、Polygon、GeometryCollection等</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/1590590539852-f07a129b-1bfb-4487-af9a-df13273354c2.webp" alt="image"><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539869-222256f7-421d-4ca2-b17c-ab93c141d6aa.webp" alt="image"><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539903-c0a28251-0a32-486e-b3d6-4defbb7768ea.webp?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<blockquote>
<p>❝CHAR 和 VARCHAR 的区别？</p>
</blockquote>
<p>char是固定长度，varchar长度可变：</p>
<p>char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。</p>
<p>存储时，前者不管实际存储数据的长度，直接按 char 规定的长度分配存储空间；而后者会根据实际存储的数据分配最终的存储空间</p>
<p><strong>相同点：</strong></p>
<ol>
<li>char(n)，varchar(n)中的n都代表字符的个数</li>
<li>超过char，varchar最大长度n的限制后，字符串会被截断。</li>
</ol>
<p><strong>不同点：</strong></p>
<ol>
<li>char不论实际存储的字符数都会占用n个字符的空间，而varchar只会占用实际字符应该占用的字节空间加1（实际长度length，0&lt;=length&lt;255）或加2（length&gt;255）。因为varchar保存数据时除了要保存字符串之外还会加一个字节来记录长度（如果列声明长度大于255则使用两个字节来保存长度）。</li>
<li>能存储的最大空间限制不一样：char的存储上限为255字节。</li>
<li>char在存储时会截断尾部的空格，而varchar不会。</li>
</ol>
<p>char是适合存储很短的、一般固定长度的字符串。例如，char非常适合存储密码的MD5值，因为这是一个定长的值。对于非常短的列，char比varchar在存储空间上也更有效率。</p>
<blockquote>
<p>❝列的字符串类型可以是什么？</p>
</blockquote>
<p>字符串类型是：BIT、SET、BLOB、ENUM、CHAR、TEXT、VARCHAR</p>
<p>ENUM：使用枚举代替字符串类型，将不重复的字符串存储到预定义的集合中。列中存储的是整数，这样列表值会非常紧凑，压缩到1-2个字节中。定义好了ENUM的集合后，如果想向其中添加或删除字符串必须使用ALTER TABLE，除非是向集合列表末尾添加元素。</p>
<p>BIT：二进制的多个比特串，MySQL将其作为字符串类型处理</p>
<p>SET：多个BIT合并称的数据类型，有效利用存储空间。</p>
<p>上述三种都可以使用其他数据类型达到同样的功能，而且不容易犯错。</p>
<blockquote>
<p>❝BLOB和TEXT有什么区别？</p>
</blockquote>
<p>BLOB和TEXT都是为存储很大的数据而设计的字符串数据类型，且容纳可变数量的数据。</p>
<p>BLOB存储的是二进制数据，四种类型的BLOB：TINYBLOB、BLOB、MEDIUMBLO和 LONGBLOB</p>
<p>TEXT存储的是字符数据，四种TEXT类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。</p>
<p>数据类型相关还有很多细节，在《高性能MySQL》第四章。</p>
<h3 id="范式与反范式"><a href="#范式与反范式" class="headerlink" title="范式与反范式"></a>范式与反范式</h3><ul>
<li><p>范式化的数据库中，每个事实数据只会出现一次，而反范式化的数据库中，信息是冗余的，可能会存储在多个地方。</p>
</li>
<li><p>范式的优点：</p>
</li>
<li><ul>
<li>范式化修改的数据通常更少，更新操作通常比反范式化更快</li>
<li>范式化的表通常更小，可以更好的放在内存里</li>
<li>范式化很少有多余的数据意味着检索列表数据时可能不需要DISTINCT/GROUP BY语句</li>
</ul>
</li>
<li><p>范式的缺点：</p>
</li>
<li><ul>
<li>通常需要关联，不仅代价高而且可能使得一些索引无效。比如，将列存储在不用的表中，而这些列如果在一个表中则本可以属于同一个索引</li>
</ul>
</li>
<li><p>反范式的优点：</p>
</li>
<li><ul>
<li>避免了很多关联，在没有关联的情况下，反范式执行全表扫描是顺序I/O，可能比关联要快得多</li>
</ul>
</li>
<li><p>反范式优点的例子，查看所有付费用户中最近的10个消息：</p>
</li>
<li><ul>
<li>范式：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>范式需要使用message和user两个表，并关联，SQL语句：</li>
<li>SELECT message_text,user_name</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>FROM message </p>
<p>INNER JOIN user ON <strong>message.user_id=user.id</strong></p>
<p>WHERE <strong>user.account_type</strong>=’VIP’</p>
<p>ORDER BY <strong>message.published</strong> DESC LIMIT 10;</p>
<ul>
<li><ul>
<li><ul>
<li>范式化需要先对message表的published索引进行扫描，并且每一个消息都要去user表找到对应的用户并检查是否为付费用户，如果付费用户少则需要扫面很多数据。</li>
<li>因为关联的存在，使得在索引中查找另一个表并进行过滤，使得消耗了性能</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>反范式：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>将message和user表合并，并且增加索引（account_type,published），这样就不用使用关联，而且索引覆盖：</li>
<li>SELECT message_text,user_name</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>FROM user_message</p>
<p>WHERE account_type=’VIP’</p>
<p>ORDER BY published DESC LIMIT 10;</p>
<h4 id="混合范式化和反范式化"><a href="#混合范式化和反范式化" class="headerlink" title="混合范式化和反范式化"></a>混合范式化和反范式化</h4><ul>
<li><ul>
<li>实际并不会完全的范式化和反范式化，上面完全反范式化的例子user_message的表太大了，而且如果没有消息就会丢失用户信息。可以在user表和message表中都存储account_type字段，可以同时解决前面两个问题。但是新的问题是每次更新都要更新两张表，更新代价提高了。</li>
</ul>
</li>
</ul>
<h4 id="缓存表和汇总表"><a href="#缓存表和汇总表" class="headerlink" title="缓存表和汇总表"></a>缓存表和汇总表</h4><ul>
<li>上面的混合范式化是在同一张表中保存衍生的冗余数据，而有时也需要创建完全独立的缓存表和汇总表</li>
<li>缓存表：保存比较简单的从其他表获取且速度较慢的的数据</li>
<li>汇总表：保存使用GROUP BY语句聚合的数据</li>
</ul>
<h2 id="六、索引"><a href="#六、索引" class="headerlink" title="六、索引"></a>六、索引</h2><blockquote>
<p>❝</p>
<p>说说你对 MySQL 索引的理解？</p>
<p>数据库索引的原理，为什么要用 B+树，为什么不用二叉树？</p>
<p>聚集索引与非聚集索引的区别？</p>
<p>InnoDB引擎中的索引策略，了解过吗？</p>
<p>创建索引的方式有哪些？</p>
<p>聚簇索引/非聚簇索引，mysql索引底层实现，为什么不用B-tree，为什么不用hash，叶子结点存放的是数据还是指向数据的内存地址，使用索引需要注意的几个地方？</p>
</blockquote>
<ul>
<li>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构，所以说<strong>索引的本质是：数据结构</strong></li>
<li>索引的目的在于提高查询效率，可以类比字典、 火车站的车次表、图书的目录等 </li>
<li>可以简单的理解为“排好序的快速查找数据结构”，数据本身之外，<strong>数据库还维护着一个满足特定查找算法的数据结构</strong>，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。下图是一种可能的索引方式示例<img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539862-061bbf2b-9b17-4cb6-9ec2-3c2139bbfbc1.webp?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></li>
<li>左边的数据表，一共有两列七条记录，最左边的是数据记录的物理地址。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值，和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在一定的复杂度内获取到对应的数据，从而快速检索出符合条件的记录。</li>
<li>索引本身也很大，不可能全部存储在内存中，<strong>一般以索引文件的形式存储在磁盘上</strong></li>
<li>平常说的索引，没有特别指明的话，就是B+树（多路搜索树，不一定是二叉树）结构组织的索引。其中聚集索引，次要索引，覆盖索引，符合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。此外还有哈希索引等。</li>
</ul>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ul>
<li><p>创建：</p>
</li>
<li><ul>
<li>创建索引：<code>CREATE [UNIQUE] INDEX indexName ON mytable(username(length));</code><br>如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。</li>
<li>修改表结构(添加索引)：<code>ALTER table tableName ADD [UNIQUE] INDEX indexName(columnName)</code></li>
</ul>
</li>
<li><p>删除：<code>DROP INDEX [indexName] ON mytable;</code></p>
</li>
<li><p>查看：<code>SHOW INDEX FROM table_name\G</code>       –可以通过添加 \G 来格式化输出信息。</p>
</li>
<li><p>使用ALERT命令</p>
</li>
<li><ul>
<li><code>ALTER TABLE tbl_name ADD PRIMARY KEY (column_list):</code> 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。</li>
<li><code>ALTER TABLE tbl_name ADD UNIQUE index_name (column_list</code> 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。</li>
<li><code>ALTER TABLE tbl_name ADD INDEX index_name (column_list)</code> 添加普通索引，索引值可出现多次。</li>
<li><code>ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list)</code>该语句指定了索引为 FULLTEXT ，用于全文索引。</li>
</ul>
</li>
</ul>
<h3 id="索引的优势"><a href="#索引的优势" class="headerlink" title="索引的优势"></a>索引的优势</h3><ul>
<li><strong>大大减少服务器需要扫描的数据量</strong></li>
<li><strong>B+树种按照顺序存储数据，降低执行排序操作ORDER BY/GROUP BY的成本，避免生成临时表</strong></li>
<li><strong>B+树的特点+数据顺序存储，可以将随机I/O变为顺序I/O</strong></li>
</ul>
<h3 id="索引的劣势"><a href="#索引的劣势" class="headerlink" title="索引的劣势"></a>索引的劣势</h3><ul>
<li>索引也是一张表，保存了主键和索引字段，并指向实体表的记录，所以也需要占用内存</li>
<li><strong>虽然索引大大提高了查询速度，同时却会降低更新表的速度</strong>，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要更新索引文件中对应的索引列字段， 因为这三种操作会导致索引信息发生变化</li>
<li>对于非常小的表使用全表扫描更高效，中到大型表适合使用索引，特大型表建立和使用索引代价随之增加，可以使用分区技术</li>
</ul>
<h3 id="MySQL索引分类"><a href="#MySQL索引分类" class="headerlink" title="MySQL索引分类"></a>MySQL索引分类</h3><h4 id="数据结构角度"><a href="#数据结构角度" class="headerlink" title="数据结构角度"></a>数据结构角度</h4><ul>
<li>B+树索引</li>
<li>Hash索引</li>
<li>Full-Text全文索引</li>
<li>R-Tree索引</li>
</ul>
<h4 id="从物理存储角度"><a href="#从物理存储角度" class="headerlink" title="从物理存储角度"></a>从物理存储角度</h4><ul>
<li>聚集索引（clustered index）</li>
<li>非聚集索引（non-clustered index），也叫二级索引（secondary index）<br>聚集索引和非聚集索引都是B+树结构</li>
</ul>
<h4 id="从逻辑角度"><a href="#从逻辑角度" class="headerlink" title="从逻辑角度"></a>从逻辑角度</h4><ul>
<li>主键索引：主键索引是一种特殊的唯一索引，不允许有空值</li>
<li>普通索引或者单列索引：每个索引只包含单个列，一个表可以有多个单列索引</li>
<li>联合索引（复合索引、多列索引）：联合索引指多个字段上创建的索引，使用联合索引时遵循匹配最左前缀，即联合索引必须从左至右依次使用（只有在精准匹配第一列之后才可以使用后面的列，<strong>如果出现了between则不能再使用后面的索引</strong>）</li>
<li>唯一索引或者非唯一索引</li>
<li>空间索引：空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，<strong>空间索引只能在存储引擎为MYISAM的表中创建</strong></li>
</ul>
<blockquote>
<p>❝</p>
<p>为什么MySQL 索引中用B+tree，不用B-tree 或者其他树，为什么不用 Hash 索引</p>
<p>聚簇索引/非聚簇索引，MySQL 索引底层实现，叶子结点存放的是数据还是指向数据的内存地址，使用索引需要注意的几个地方？</p>
<p>使用索引查询一定能提高查询的性能吗？为什么?</p>
</blockquote>
<h3 id="MySQL索引结构"><a href="#MySQL索引结构" class="headerlink" title="MySQL索引结构"></a>MySQL索引结构</h3><p><strong>首先要明白索引（index）是在存储引擎（storage engine）层面实现的，而不是server层面</strong>。不是所有的存储引擎都支持所有的索引类型。即使多个存储引擎支持某一索引类型，它们的实现和行为也可能有所差别。</p>
<h4 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B+Tree索引"></a>B+Tree索引</h4><p>MyISAM 和 InnoDB 存储引擎，都使用 B+Tree的数据结构，它相对与 B-Tree结构，所有的数据都存放在叶子节点上，且把叶子节点通过指针连接到一起，形成了一条数据链表，以加快相邻数据的检索效率</p>
<p><strong>先了解下 B-Tree 和 B+Tree 的区别</strong></p>
<h5 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h5><ul>
<li>B-Tree是为磁盘等外存储设备设计的一种平衡多路查找树（查找路径不止两个）。</li>
<li>系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。</li>
<li>InnoDB 存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB 存储引擎中默认每个页的大小为16KB，可通过参数 <code>innodb_page_size</code> 将页的大小设置为 4K、8K、16K，在 MySQL 中可通过如下命令查看页的大小：<code>show variables like &#39;innodb_page_size&#39;;</code></li>
<li>而系统一个磁盘块的存储空间往往没有这么大，因此 InnoDB 每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小 16KB。InnoDB 在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。</li>
<li>B-Tree 结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述 B-Tree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值，对应表中的主键值，data 为一行记录中除主键外的数据。对于不同的记录，key值互不相同。</li>
<li><strong>m阶的B-Tree的特性：</strong></li>
</ul>
<ol>
<li>每个节点最多有m个子节点</li>
<li>除了根节点和叶子节点外，其它每个节点至少有ceil(m/2)个子节点（ceil()向上取整）。</li>
<li>若根节点不是叶子节点，则至少有2个子节点</li>
<li>所有叶子节点都在同一层，且不包含其它关键字信息</li>
<li>关键字的个数n满足：ceil(m/2)-1 &lt;= n &lt;= m-1</li>
<li>每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn）</li>
<li>ki(i=1,…n)为关键字，且关键字升序排序</li>
<li>Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)</li>
</ol>
<ul>
<li><p>B-Tree 中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个 3 阶的 B-Tree：</p>
</li>
<li><ul>
<li>每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。</li>
<li>模拟查找关键字29的过程：</li>
</ul>
</li>
</ul>
<ol>
<li><ol>
<li><ol>
<li>根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】</li>
<li>比较关键字29在区间（17,35），找到磁盘块1的指针P2。</li>
<li>根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】</li>
<li>比较关键字29在区间（26,30），找到磁盘块3的指针P2。</li>
<li>根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】</li>
<li>在磁盘块8中的关键字列表中找到关键字29。</li>
</ol>
</li>
</ol>
</li>
</ol>
<ul>
<li><ul>
<li>分析上面过程，发现需要3次磁盘I/O操作，和3次内存查找操作。而3次磁盘I/O操作是影响整个B-Tree查找效率的决定因素，所以<strong>B-Tree相对于AVLTree缩减了节点个数</strong>，从而提高了查询效率。</li>
</ul>
</li>
</ul>
<h5 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h5><ul>
<li>B+Tree 是在 B-Tree 基础上的一种优化，使其更适合实现外存储索引结构，InnoDB 存储引擎就是用 B+Tree 实现其索引结构。</li>
<li>B-Tree结构图中每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。在B+Tree中，<strong>所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上**</strong>，而非叶子节点上只存储key值信息**<strong>，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度</strong>。</li>
<li>B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对B+Tree进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。</li>
<li><strong>B+Tree相对于B-Tree有几点不同：</strong></li>
</ul>
<ol>
<li>非叶子节点只存储键值信息；</li>
<li>所有叶子节点之间都有一个链指针；</li>
<li>数据记录都存放在叶子节点中</li>
</ol>
<ul>
<li>假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示：</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539886-ed20e377-d331-41d0-a2f8-1f7273b9442d.webp?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<ul>
<li><p>可能上面例子中只有22条数据记录，看不出B+Tree的优点，下面做一个推算：</p>
</li>
<li><ul>
<li>InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为10^3）。也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录。</li>
</ul>
</li>
<li><p>实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2-4层。MySQL的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。</p>
</li>
<li><p>B+Tree性质</p>
</li>
</ul>
<ol>
<li>通过上面的分析，我们知道IO次数取决于B+树的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有<img src="https://cdn.nlark.com/yuque/__latex/419c87720465f7f5a8523f3cc041af27.svg" alt="img">，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。</li>
<li>当B+树的数据项是复合的数据结构，比如(name,age,sex)的时候，B+树是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，B+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即<strong>索引的最左匹配特性</strong>。</li>
</ol>
<blockquote>
<p>❝B+树是怎么保证平衡的？</p>
</blockquote>
<p><a href="https://www.cnblogs.com/nullzx/p/8729425.html">B树、B+树插入删除过程</a></p>
<h5 id="MyISAM主键索引与二级索引的结构"><a href="#MyISAM主键索引与二级索引的结构" class="headerlink" title="MyISAM主键索引与二级索引的结构"></a>MyISAM主键索引与二级索引的结构</h5><ul>
<li><p>MyISAM引擎的索引文件和数据文件是分离的。<strong>MyISAM引擎索引结构的叶子节点的数据域，存放的并不是实际的数据记录，而是数据记录的地址</strong>。索引文件与数据文件分离，这样的索引称为”非聚簇索引”。MyISAM的主索引与二级索引区别并不大，只是主索引不能有重复的关键字</p>
</li>
<li><p>MyISAM索引</p>
</li>
<li><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590541902-8b1f0c77-6a43-4901-beab-7f3a2f3b0ff5.webp?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></li>
</ul>
</li>
<li><p>在MyISAM中，索引（含叶子节点）存放在单独的.myi文件中，叶子节点存放的是数据的物理地址偏移量</p>
</li>
<li><p>主索引是指主键索引，键值不可能重复；二级索引则是普通索引，键值可能重复。</p>
</li>
<li><p>通过索引查找数据的流程：先从索引文件中查找到索引节点，从中拿到数据的文件指针，再到数据文件中通过文件指针定位了具体的数据。二级索引类似。</p>
</li>
</ul>
<h5 id="InnoDB主键索引与二级索引的结构"><a href="#InnoDB主键索引与二级索引的结构" class="headerlink" title="InnoDB主键索引与二级索引的结构"></a>InnoDB主键索引与二级索引的结构</h5><ul>
<li><strong>InnoDB引擎索引结构的叶子节点的数据域，存放的就是实际的数据记录</strong>（对于主索引，此处会存放表中所有的数据记录；对于二级索引叶子节点存储的是主键，检索的时候通过叶子节点的主键到主键索引中找到对应数据行，即二级索引需要访问两次索引）</li>
<li>或者说，<strong>InnoDB的数据文件本身就是主键索引文件</strong>，这样的索引被称为“聚簇索引”，一个表只能有一个聚簇索引。</li>
<li><strong>向聚簇索引中的页插入新行，如果超出了存储容量则需要执行“页分裂”**</strong>，会导致页与页之间不连续**（分裂的页就不是聚簇的概念，会通过优化表的操作重新完成聚簇）</li>
</ul>
<h6 id="主键索引："><a href="#主键索引：" class="headerlink" title="主键索引："></a>主键索引：</h6><ul>
<li>InnoDB索引是聚集索引，它的索引和数据是存入同一个.idb文件中的，因此它的索引结构是在同一个树节点中同时存放索引和数据，如下图中最底层的叶子节点有三行数据，对应于数据表中的id、stu_id、name数据项。</li>
<li>在Innodb中，索引分叶子节点和非叶子节点，非叶子节点就像新华字典的目录，单独存放在索引段中，叶子节点则是顺序排列的，在数据段中。Innodb的数据文件可以按照表来切分（只需要开启<code>innodb_file_per_table)</code>，切分后存放在<code>xxx.ibd</code>中，默认不切分，存放在<code>xxx.ibdata</code>中。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539905-19dcb659-d0cf-440b-995d-2a62040981f3.webp?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<h6 id="二级（非主键）索引："><a href="#二级（非主键）索引：" class="headerlink" title="二级（非主键）索引："></a>二级（非主键）索引：</h6><ul>
<li>以示例中学生表中的name列建立二级索引，它的索引结构跟主键索引的结构有很大差别，在最底层的叶子结点有两行数据，第一行的字符串是二级索引，按照ASCII码进行排序，第二行的整数是主键的值。</li>
<li>这就意味着，对name列进行条件搜索，需要两个步骤：</li>
</ul>
<ol>
<li>在二级索引上检索name，到达其叶子节点获取对应的主键；</li>
<li>使用主键在主索引上再进行对应的检索操作</li>
</ol>
<p>这也就是所谓的“<strong>回表查询</strong>”</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539900-bb4d422c-e6a4-4b89-a3f0-44deb87c26cf.webp?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<h5 id="InnoDB-索引结构需要注意的点"><a href="#InnoDB-索引结构需要注意的点" class="headerlink" title="InnoDB 索引结构需要注意的点"></a>InnoDB 索引结构需要注意的点</h5><ol>
<li>数据文件本身就是索引文件</li>
<li>聚集索引中叶节点包含了完整的数据记录</li>
<li>InnoDB 表必须要有主键，并且推荐使用整型自增主键</li>
</ol>
<ul>
<li>不管是主键索引还是二级索引，所有的查询都是通过先查找到索引节点才能拿到相对应的数据，所以如果在设计表结构时没有显式指定索引列的话，MySQL 会从表中选择数据不重复的列建立索引，如果没有符合的列，则 MySQL 自动为 InnoDB 表生成一个隐含字段作为主键，并且这个字段长度为6个字节，类型为整型。</li>
</ul>
<blockquote>
<p>❝那为什么推荐使用整型自增主键而不是选择UUID？</p>
</blockquote>
<ul>
<li>UUID是字符串，比整型消耗更多的存储空间；</li>
<li>在B+树中进行查找时需要跟经过的节点值比较大小，整型数据的比较运算比字符串更快速；</li>
<li>自增的整型索引在磁盘中会连续存储，在读取一页数据时也是连续；UUID是随机产生的，读取的上下两行数据存储是分散的，不适合执行where id &gt; 5 &amp;&amp; id &lt; 20的条件查询语句。</li>
<li>在插入或删除数据时，整型自增主键会在叶子结点的末尾建立新的叶子节点，不会破坏左侧子树的结构；UUID主键很容易就破坏了原有树结构，B+树为了维持自身的特性，有可能会进行结构的重构，消耗更多的时间。</li>
</ul>
<blockquote>
<p>❝为什么非主键索引结构叶子节点存储的是主键值？</p>
</blockquote>
<p>保证数据一致性（更新数据的时候只更新主键索引中的数据即可）和节省存储空间，</p>
<h4 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h4><ul>
<li><p>主要就是通过Hash算法，将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。<br>检索算法：在检索查询时，就再次对待查关键字再次执行相同的Hash算法，得到Hash值，到对应Hash表对应位置取出数据即可，如果发生Hash碰撞，则需要在取值时进行筛选。</p>
</li>
<li><p><strong>Hash索引的限制：</strong></p>
</li>
<li><ul>
<li>value存储的是行指针，不能实现覆盖索引</li>
<li>哈希索引不是按照索引值顺序存储的，所以不能用于排序，也就不支持范围查找</li>
<li>联合索引时不支持使用部分索引进行查找，因为hash值是由全部索引列计算得到的</li>
<li>哈希冲突严重的时候相当于遍历链表，反而比不上二叉树</li>
</ul>
</li>
<li><p>MySQL目前有Memory引擎和NDB引擎支持Hash索引。</p>
</li>
<li><p>InnoDB可以创建自定义哈希索引：</p>
</li>
<li><ul>
<li>当需要根据URL进行索引时，可以将URL的hash值作为索引的列，这样可以降低索引值长度，并且是整数比较速度快</li>
<li>即使有大量的哈希冲突，但是索引仍然可以过滤很多数据，而且速度比直接使用URL快</li>
</ul>
</li>
</ul>
<h4 id="full-text全文索引"><a href="#full-text全文索引" class="headerlink" title="full-text全文索引"></a>full-text全文索引</h4><ul>
<li>全文索引也是MyISAM的一种特殊索引类型，主要用于全文索引，InnoDB从MYSQL5.6版本提供对全文索引的支持。</li>
<li>它用于替代效率较低的LIKE模糊匹配操作，而且可以通过多字段组合的全文索引一次性全模糊匹配多个字段。</li>
<li>同样使用B-Tree存放索引数据，但使用的是特定的算法，将字段数据分割后再进行索引（一般每4个字节一次分割），索引文件存储的是分割前的索引字符串集合，与分割后的索引信息，对应B-tree结构的节点存储的是分割后的词信息以及它在分割前的索引字符串集合中的位置。</li>
</ul>
<h4 id="R-Tree空间索引"><a href="#R-Tree空间索引" class="headerlink" title="R-Tree空间索引"></a>R-Tree空间索引</h4><p>空间索引是MyISAM的一种特殊索引类型，主要用于地理空间数据类型</p>
<blockquote>
<p>❝为什么Mysql索引要用B+树不是B树？</p>
</blockquote>
<p>用B+树不用B树考虑的是IO对性能的影响，B树的每个节点都存储数据，而B+树只有叶子节点才存储数据，所以查找相同数据量的情况下，B树的高度更高，IO更频繁。数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。其中在MySQL底层对B+树进行进一步优化：在叶子节点中是双向链表，且在链表的头结点和尾节点也是循环指向的。</p>
<blockquote>
<p>❝面试官：为何不采用Hash方式？</p>
</blockquote>
<p>因为Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。所以，哈希索引只适用于等值查询的场景。而B+Tree是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描。</p>
<p>哈希索引不支持多列联合索引的最左匹配规则，如果有大量重复键值的情况下，哈希索引的效率会很低，因为存在哈希碰撞问题。</p>
<h3 id="哪些情况需要创建索引"><a href="#哪些情况需要创建索引" class="headerlink" title="哪些情况需要创建索引"></a>哪些情况需要创建索引</h3><ol>
<li>主键自动建立唯一索引</li>
<li>频繁作为查询条件的字段</li>
<li>查询中与其他表关联的字段，外键关系建立索引</li>
<li>单键/组合索引的选择问题，高并发下倾向创建组合索引</li>
<li>查询中排序的字段，排序字段通过索引访问大幅提高排序速度</li>
<li>查询中统计或分组字段</li>
</ol>
<h3 id="哪些情况不要创建索引"><a href="#哪些情况不要创建索引" class="headerlink" title="哪些情况不要创建索引"></a>哪些情况不要创建索引</h3><ol>
<li>表记录太少</li>
<li>经常增删改的表</li>
<li>数据重复且分布均匀的表字段，只应该为最经常查询和最经常排序的数据列建立索引（如果某个数据类包含太多的重复数据，建立索引没有太大意义）</li>
<li>频繁更新的字段不适合创建索引（会加重I/O负担）</li>
<li>where条件里用不到的字段不创建索引</li>
</ol>
<h3 id="高性能创建索引"><a href="#高性能创建索引" class="headerlink" title="高性能创建索引"></a>高性能创建索引</h3><p>创建索引的时候有各种细节可以使得索引的使用效率进一步提高**<br>**</p>
<h4 id="列前缀索引"><a href="#列前缀索引" class="headerlink" title="列前缀索引"></a>列前缀索引</h4><ul>
<li><p>有时需要索引很长的字符列，会让索引变得大且慢。一个策略是使用哈希索引，另一种方式是使用列前缀索引，即使用该列前一部分字符建立索引，并查询时也只使用该列的前一部分字符。注意：列前缀索引和匹配最前缀索引不是一回事，前者是一个列，后者是多个列</p>
</li>
<li><ul>
<li>例如</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>建立city列字符串的前3个字符的索引：</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>ALTER TABLE sakila.city_demo ADD KEY (city(7));</p>
<ul>
<li><ul>
<li><ul>
<li>查询city列字符串的前3个字符：</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>SELECT COUNT(*) AS cnt, LEFT(city,3) AS pref</p>
<p>FROM sakila.city_demo GROUP BY pref ORDER BY cnt DESC LIMIT 10;</p>
<ul>
<li><p>查询时究竟选择几个字符需要根据实际列判断索引选择性：</p>
</li>
<li><ul>
<li><ul>
<li>索引选择性：不重复的索引项/数据表的记录总数（即，分支越多索引选择性越大）</li>
<li>选择全部的字符串时索引选择性大</li>
<li>当选择前n个字符的索引选择性接近全字符串的索引选择性时是最佳的列前缀索引</li>
</ul>
</li>
</ul>
</li>
<li><p>使用列前缀索引则不能在该列上使用ORDER BY/GROUP BY，也不能作为覆盖索引</p>
</li>
</ul>
<h4 id="联合索引中索引顺序"><a href="#联合索引中索引顺序" class="headerlink" title="联合索引中索引顺序"></a>联合索引中索引顺序</h4><ul>
<li><p>“三星”索引概念：</p>
</li>
<li><ul>
<li>与查询相关的索引行是相邻的，也就是where后面的等值谓词，可以匹配索引列顺序——where和索引匹配越多，扫描的数据行越少</li>
<li>索引行的顺序与查询语句需求一致，也就是order by 中的排序和索引顺序是否一致——避免排序</li>
<li>索引行包含查询语句中所有的列——避免扫描数据行</li>
</ul>
</li>
<li><p>一个联合索引中的索引列顺序可以影响到一个索引是否是“三星”索引</p>
</li>
<li><p>通用经验是将选择性高的列放在索引最前列，这样仅仅在where进行查找时效果较好，仅仅是一个经验，排序和分组时这样并不一定适合，实践中并不一定这么做</p>
</li>
<li><p>《高性能MySQL》P183 5.4 索引学习中有很好的设计索引的例子，例子中的选择</p>
</li>
<li><ul>
<li>例子：根据用户信息表的多个列筛选出指定的特征的一批用户</li>
<li>country,sex这种列虽然选择性不强但使用这个列进行查询的情况比较多，所以作为联合索引的头两列(sex,country)</li>
<li>如果查新时没有限定性别，则可以在WHERE中新增AND SEX IN(‘m’,’f’)，保证满足匹配最左索引，使得该索引发挥作用</li>
<li>对于age这种一般都设定为范围的列，建立索引时要放在联合索引的最右边(sex,country,…,age)</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>因为基于索引查询需要满足匹配最左前缀，直到遇到第一个范围条件列。即，如果age在第一列，那么使用WHERE AGE BETWEEN 18 AND 24，那么后面的sex,country列就不能作为索引列了，联合索引仅仅只使用了第一列age</li>
<li>当然可以转化为AND AGE IN (18,19,20,21,22,23,24)，但是不是所有的范围查询都可以转换的</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>IN(…)这种技巧不要过于依赖，由于多列IN组合的数量是乘法，所以组合数会快速增加，当组合数达到上千个时就需要小心了</li>
</ul>
</li>
</ul>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p><strong>覆盖索引</strong>（Covering Index）,或者叫索引覆盖， 可以不需要回表操作</p>
<ul>
<li>就是select查询数据列在索引中就已经完全包含，不必读取数据行，利用索引返回select列表中的字段，而不必根据索引再次读取数据文件，换句话说<strong>查询列要被所建的索引覆盖</strong>。</li>
<li>索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据，当能通过读取索引就可以得到想要的数据，那就不需要读取行了。一个索引包含（覆盖）满足查询结果的数据就叫做覆盖索引。</li>
<li><strong>判断标准</strong><br>使用explain，可以通过输出的extra列来判断，对于一个索引覆盖查询，显示为<strong>using index</strong>，MySQL查询优化器在执行查询前会决定是否有索引覆盖查询</li>
</ul>
<h2 id="七、MySQL查询"><a href="#七、MySQL查询" class="headerlink" title="七、MySQL查询"></a>七、MySQL查询</h2><ul>
<li>查询优化、索引优化、库表结构优化需要齐头并进</li>
</ul>
<h3 id="优化慢查询"><a href="#优化慢查询" class="headerlink" title="优化慢查询"></a>优化慢查询</h3><ul>
<li>是否查询了大量的结果，但是仅使用前10条——使用LIMIT</li>
<li>多表关联的时候返回了全部的列（SELECT * FROM actor INNER JOIN film_actor USING(actor_id) WHERE …）——仅返回需要的列</li>
<li>取出不需要的列（SELECT * FROM xxx）</li>
</ul>
<p>取出不需要的列会导致优化器无法使用索引覆盖进行优化，同时还会带来额外的I/O、内存和CPU消耗</p>
<h3 id="索引效果与优化"><a href="#索引效果与优化" class="headerlink" title="索引效果与优化"></a>索引效果与优化</h3><p>使用WHERE条件的三种方式，从好到坏：</p>
<ul>
<li>索引中使用WHERE条件过滤不匹配的记录。在存储引擎层完成</li>
<li>使用索引覆盖扫描返回记录（Explain中Extra列为Using index）。在MySQL服务器层完成，不需要回表查询</li>
<li>从数据表中返回记录，然后根据WHERE过滤不满足条件的记录（Explain中Extra列为Using Where）。在MySQL服务器层完成，需要先从数据表读出记录再过滤</li>
</ul>
<p>发现扫描大量数据，但只返回需要的少量数据，优化方式：</p>
<ul>
<li>从索引角度入手，使用索引覆盖扫描</li>
<li>从库表结构入手，例如使用单独的汇总表（优化count()语句）</li>
<li>从查询语句入手，重写查询语句，下面会介绍</li>
</ul>
<h3 id="重构查询的方式"><a href="#重构查询的方式" class="headerlink" title="重构查询的方式"></a>重构查询的方式</h3><h4 id="切分查询"><a href="#切分查询" class="headerlink" title="切分查询"></a>切分查询</h4><ul>
<li><p>有时候可以将一个大查询切分成小查询</p>
</li>
<li><p>例如，删除旧数据</p>
</li>
<li><ul>
<li>一次删除大量数据可能锁住很多数据，占满整个事务日志、耗尽资源、阻塞很多重要查询</li>
<li>将要删除的数据分为多次小删除对服务器影响较小</li>
<li>原SQL语句一次删除大量数据：DELETE FROM messages WHERE created &lt; DATE_SUB(NOW(),INTERVAL 3 MONTH);</li>
<li>一次只删除10000行数据：rows_affected = 0</li>
</ul>
</li>
</ul>
<p>do {</p>
<p> rows_affected = do_query{</p>
<p>“DELETE FROM messages WHERE created &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH)</p>
<p>LIMIT 10000”)</p>
<p>} while rows_affected &gt; 0</p>
<h4 id="分解关联查询"><a href="#分解关联查询" class="headerlink" title="分解关联查询"></a>分解关联查询</h4><ul>
<li><p><strong>将一条关联查询分解成多个独立的单表查询，可以具有如下优势：</strong></p>
</li>
<li><ul>
<li>缓存的效率更高。缓存单表查询的话重复查询的频率会更高</li>
<li>执行单个查询可以减少锁竞争</li>
<li>持久层分解，应用层关联，可以更容易拆分数据库，提高可伸缩性</li>
</ul>
</li>
</ul>
<h3 id="查询执行的基础"><a href="#查询执行的基础" class="headerlink" title="查询执行的基础"></a>查询执行的基础</h3><ul>
<li><p>客户端向服务器发送请求时的步骤：</p>
</li>
<li><ul>
<li>客户端发送一条查询给服务器</li>
<li>服务器先检查<strong>查询缓存</strong>，如果命中缓存则立即返回缓存中的结果，否则进入下一阶段</li>
<li>服务器端进行SQL<strong>解析、预处理</strong>，再由<strong>优化器</strong>生成对应的<strong>执行计划</strong></li>
<li>根据执行计划调用存储引擎的API来执行查询</li>
<li>将结果返回给客户端</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1590917863447-22c656bd-a4c5-4b08-8c99-7b39215b5f4f.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image.png"></li>
</ul>
</li>
</ul>
<h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><ul>
<li>解析查询语句前MySQL会解析查询是否命中缓存中的数据。检查是通过大小写敏感的哈希查找，即使查询语句有一个字节不同也不会匹配</li>
<li>如果匹配了则检查权限，并直接返回缓存中的结果</li>
<li>如果没有匹配则执行下面的步骤</li>
</ul>
<h4 id="查询优化处理"><a href="#查询优化处理" class="headerlink" title="查询优化处理"></a>查询优化处理</h4><ul>
<li>查询在查询缓存后的下一个生命周期是将SQL转换成一个执行计划，具体步骤包括：<strong>解析SQL、预处理、优化SQL执行计划</strong></li>
</ul>
<h5 id="语法解析器和预处理"><a href="#语法解析器和预处理" class="headerlink" title="语法解析器和预处理"></a>语法解析器和预处理</h5><ul>
<li>解析器根据SQL关键字解析，并生成“解析树”。这个步骤会进行验证和解析查询，例如，验证是否错误的关键字，关键字顺序是否正确</li>
<li>预处理器进一步检查解析树是否合法，例如，查询数据表和数据列是否存在。同时会验证权限。</li>
</ul>
<h5 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h5><ul>
<li><p>优化器将这个合法的语法树转化成执行计划</p>
</li>
<li><p>一条查询语句可以有多种执行方式，返回相同的结果，优化器的作用就是找到其中最好的执行计划</p>
</li>
<li><p>MySQL使用基于成本的优化器，主要是完成查询需要读取数据页的数量。受限于统计信息不准确（MVCC架构），没有考虑并发情况等，最终的执行计划并不一定是最优的</p>
</li>
<li><p>优化策略可以分为两种：</p>
</li>
<li><ul>
<li>静态优化：直接对解析树进行优化，例如通过简单的代数变换将where条件转换成另一种等价形式（下面有例子）</li>
<li>动态优化：与查询的上下文有关，也可能和很多其他因素有关，例如where条件中的取值、索引中条目对应的数据行数。因为不是固定的优化策略，所以每次查询都要重新评估。</li>
</ul>
</li>
<li><p>MySQL能够处理的优化类型：</p>
</li>
<li><ul>
<li><strong>重新定义关联表的顺序：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>下面会说</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>将外连接转化成内连接：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>有些外连接LEFT OUTER JOIN 可以转换成内连接INNER JOIN，这样就可以调整管关联顺序了</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>优化COUNT()、MIN()、MAX()：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>例如最小值可以直接查询B-Tree最左端记录</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>预估并转换为常数表达式：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>检测到表达式可以转化成常数时会将其当作常数进行优化处理</li>
<li>此外，有时候一个查询也可以转化为一个常数，例子：</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>EXPLAIN SELECT film.film_id, film_actor.actor_id</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>FROM sakila.film</p>
<p>INNER JOIN sakila.film_actor USING(film_id)</p>
<p>WHERE film.film_id=1;</p>
<ul>
<li><ul>
<li><ul>
<li><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1590914393242-1ebaea4c-d929-4b6a-820e-b21c8c6de7a9.png" alt="image.png"></li>
<li>上面查询分为两步：</li>
<li>①：先从film表找到需要的行，因为film_id字段上有主键索引，所以MySQL知道只会返回一行数据，所以表的访问类型是const</li>
<li>②：因为第一步返回的film_id列当作已知取值的列，那么对表film_actor的访问类型也是const</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>覆盖索引扫描：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>索引中的列包含所有查询中需要的列时就可以使用索引返回需要的数据，无须查询对应的数据行</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>子查询优化：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>某些情况下会将子查询转换一种形式，从而减少多个查询多次对数据进行访问的次数</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>提前终止查询：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>发现已经满足查询需求时候会立刻终止查询，比如使用LIMIT的时候，或者发现一个不成立的条件时（SELECT  film.film_id FROM sakila.film WHERE film_id = -1）</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>等值传播：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>如果两个列通过等式关联，那么MySQL能够把其中一个列的WHERE条件传递到另一个列上，例如：</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>SELECT film.film_id</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>FROM sakila.film</p>
<p>INNER JOIN sakila.film_actor USING(film_id)</p>
<p>WHERE film.film_id&gt;500;</p>
<ul>
<li><ul>
<li><ul>
<li><ul>
<li>由于WHERE 子句中的film_id字段同样适用于film_actor表，那么MySQL会优化成下面的形式：</li>
<li>… WHERE film.film_id &gt; 500 AND film_actor.film_id &gt; 500</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>列表IN()</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>很多数据库系统中，IN()完全等同于多个OR条件的子句，复杂度O(n)。但是MySQL会将IN()中的数据先排序，然后通过二分查找确定IN()中的值是否满足条件，复杂度O(logn)。IN()中有大量取值时，MySQL处理速度会快一定</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="数据和索引的统计信息"><a href="#数据和索引的统计信息" class="headerlink" title="数据和索引的统计信息"></a>数据和索引的统计信息</h5><ul>
<li><p>统计信息由存储引擎实现</p>
</li>
<li><p>查询优化器在生成查询计划时，需要向存储引擎获取相应的统计信息，包括</p>
</li>
<li><ul>
<li>每个表或索引有多少页</li>
<li>每个表的每个索引的基数是多少（索引选择性）</li>
<li>数据行和索引长度、索引的分布信息等</li>
</ul>
</li>
</ul>
<h5 id="如何执行关联查询"><a href="#如何执行关联查询" class="headerlink" title="如何执行关联查询"></a>如何执行关联查询</h5><ul>
<li><p>MySQL概念中不仅仅是查询需要到两个表才叫关联，，每个查询都是一次关联。</p>
</li>
<li><p>MySQL关联执行的策略：</p>
</li>
<li><ul>
<li>嵌套循环关联：先在一个表中循环取出单条数据，然后再执行嵌套循环到下一个表中匹配的行，依次下去，直到找到所有表中匹配的行。然后根据各表匹配的行，返回查询中需要的各个列。先在最后一个关联表尝试找到所有匹配的行，然后再回溯到上一个表。</li>
<li>即，循环+嵌套获取所有匹配的行，然后回溯返回数据</li>
</ul>
</li>
<li><p>MySQL多表关联示意图：</p>
</li>
<li><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1590918172760-399cd7a4-0411-4da4-8812-47e69bb74014.png" alt="image.png"></li>
</ul>
</li>
<li><p>MySQL关联查询示例图</p>
</li>
<li><ul>
<li>SQL语句：SELECT tbl1.col1, tbl2.col2 FROM tbl1 INNER JOIN tbl2 USING(col3) WHERE tbl1.col1 IN(5,6);</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1590917828821-0399668d-00d1-4c66-8d35-70e18754ede5.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image.png"></li>
</ul>
</li>
</ul>
<h5 id="关联查询优化器"><a href="#关联查询优化器" class="headerlink" title="关联查询优化器"></a>关联查询优化器</h5><ul>
<li><p>MySQL优化器最重要的部分就是关联查询优化，多表关联时可以有多种不同的关联顺序来获取相同的结果，关联查询优化器就是通过评估不同顺序时的成本来选择代价最小的关联顺序</p>
</li>
<li><p>例子：</p>
</li>
<li><ul>
<li>SQL语句：SELECT film_id, film.title, film.release_year, actor.actor_id, actor.first_name, actor.last_name</li>
</ul>
</li>
</ul>
<p>FROM sakila.<strong>film</strong></p>
<p>INNER JOIN sakila.<strong>film_actor</strong> USING(film_id)</p>
<p>INNER JOIN sakila.<strong>actor</strong> USING(actor_id);</p>
<ul>
<li><ul>
<li>MySQL没有按照SQL关联的顺序，而是优化了关联顺序，EXPLAIN结果如下：</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1590918875519-95211bf1-b239-4546-924d-652fd842d47d.png" alt="image.png"></li>
<li>如果让MySQL强行按照SQL顺序执行，在SELECT后加STRAIGHT_JOIN，EXPLAIN结果如下：</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1590919015592-d17f26a1-03b9-416c-966d-b313c527d900.png" alt="image.png"></li>
<li>可以发现修改关联顺序可以减少扫描的行数，让查询进行更少的嵌套循环和回溯操作</li>
<li>如果可以的话，优化器会遍历每一个表然后逐个做嵌套循环计算成本，然后返回最优的执行计划</li>
<li>但是n个表的关联种数是阶乘，所以会使用“启发式”优化策略，并不会遍历计算所有可能的执行计划</li>
<li>（注意：各个查询的顺序不能随意安排，因为后面的表的查询需要依赖于前面表的查询结果。比如左外连接、相关子查询）</li>
</ul>
</li>
</ul>
<h5 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h5><ul>
<li><p>MySQL排序规则：</p>
</li>
<li><ul>
<li>当不能使用索引生成排序结果时，MySQL会使用filesort进行排序</li>
<li><strong>如果数据量小于“排序缓冲区”会在内存中使用快排进行排序。如果数据量大于则会在磁盘中进行排序，先将数据分块，对每个独立的块使用快排，然后将各个块的排序结果存放在磁盘上，然后将各个排好序的块进行合并，最后返回结果</strong></li>
</ul>
</li>
<li><p>MySQL排序算法：</p>
</li>
<li><ul>
<li>两次传输排序：① 读取行指针和需要排序的字段，并对其排序。② 然后根据排序结果读取所需要的数据行</li>
<li>单次传输排序：① 读取查询需要的所有列，然后根据给定列进行排序，最后直接返回排序结果</li>
<li>两种算法各有优劣</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>两次传输排序：因为排序后再读取数据行，会产生大量的随机I/O</li>
<li>顺序读取数据行，不会随机I/O，缺点是如果需要返回的列非常多，会额外占用大量的空间，而这些列对排序本身没有帮助</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="查询执行计划"><a href="#查询执行计划" class="headerlink" title="查询执行计划"></a>查询执行计划</h4><ul>
<li>查询执行引擎根据执行计划调用API完成查询</li>
</ul>
<h4 id="返回结果给客户端"><a href="#返回结果给客户端" class="headerlink" title="返回结果给客户端"></a>返回结果给客户端</h4><ul>
<li>将查询结果返回给客户端，如果缓存开启，则将结果存放到查询缓存中</li>
<li>并不是查询彻底完成后才开始返回的，一旦服务器处理完最后一个关联表，开始生成第一条结果时，就开始向客户端逐步返回结果集</li>
<li>好处：服务器端不用存储太多了结果，客户端可以第一时间获得返回的结果</li>
</ul>
<h3 id="几个查询语句的区别"><a href="#几个查询语句的区别" class="headerlink" title="几个查询语句的区别"></a>几个查询语句的区别</h3><h5 id="count-和count-列名-查询"><a href="#count-和count-列名-查询" class="headerlink" title="count(*)和count(列名)查询"></a>count(*)和count(列名)查询</h5><ul>
<li>count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL</li>
<li>count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数，即某个字段值为NULL时，不统计。</li>
</ul>
<h5 id="in和-exists-的区别？"><a href="#in和-exists-的区别？" class="headerlink" title="in和 exists 的区别？"></a>in和 exists 的区别？</h5><ul>
<li>exists：exists对外表用loop逐条查询，每次查询都会查看exists的条件语句，当exists里的条件语句能够返回记录行时（无论记录行是的多少，只要能返回），条件就为真，返回当前loop到的这条记录；反之，如果exists里的条件语句不能返回记录行，则当前loop到的这条记录被丢弃，exists的条件就像一个bool条件，当能返回结果集则为true，不能返回结果集则为false</li>
<li>in：in查询相当于多个or条件的叠加</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> A.id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> B);</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> * <span class="keyword">from</span> B <span class="keyword">WHERE</span> B.id = A.id);</span><br></pre></td></tr></table></figure>

<ul>
<li>如果查询的两个表大小相当，那么用in和exists差别不大</li>
<li>如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in</li>
</ul>
<h5 id="UNION和UNION-ALL的区别"><a href="#UNION和UNION-ALL的区别" class="headerlink" title="UNION和UNION ALL的区别?"></a>UNION和UNION ALL的区别?</h5><p>UNION和UNION ALL都是将两个结果集合并为一个，<strong>两个要联合的SQL语句 字段个数必须一样，而且字段类型要“相容”（一致）；</strong></p>
<ul>
<li>UNION在进行表连接后会筛选掉重复的数据记录（效率较低），而UNION ALL则不会去掉重复的数据记录；</li>
<li>UNION会按照字段的顺序进行排序，而UNION ALL只是简单的将两个结果合并就返回；</li>
</ul>
<h3 id="SQL执行顺序"><a href="#SQL执行顺序" class="headerlink" title="SQL执行顺序"></a>SQL执行顺序</h3><ul>
<li>手写</li>
</ul>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> &lt;select_list&gt;</span><br><span class="line"><span class="keyword">FROM</span>  &lt;left_table&gt; &lt;join_type&gt;</span><br><span class="line"><span class="keyword">JOIN</span>  &lt;right_table&gt; <span class="keyword">ON</span> &lt;join_condition&gt;</span><br><span class="line"><span class="keyword">WHERE</span>  &lt;where_condition&gt;</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span>  &lt;group_by_list&gt;</span><br><span class="line"><span class="keyword">HAVING</span> &lt;having_condition&gt;</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;order_by_condition&gt;</span><br><span class="line"><span class="keyword">LIMIT</span> &lt;limit_number&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>机读</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span>  &lt;left_table&gt;</span><br><span class="line"><span class="keyword">ON</span> &lt;join_condition&gt;</span><br><span class="line">&lt;join_type&gt; <span class="keyword">JOIN</span>  &lt;right_table&gt;</span><br><span class="line"><span class="keyword">WHERE</span>  &lt;where_condition&gt;</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span>  &lt;group_by_list&gt;</span><br><span class="line"><span class="keyword">HAVING</span> &lt;having_condition&gt;</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">DISTINCT</span> &lt;select_list&gt;</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;order_by_condition&gt;</span><br><span class="line"><span class="keyword">LIMIT</span> &lt;limit_number&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>总结</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539949-2595b2b5-7eac-4a9f-a6ca-016a37625d12.webp" alt="image"></p>
<blockquote>
<p>❝</p>
<p>mysql 的内连接、左连接、右连接有什么区别？</p>
<p>什么是内连接、外连接、交叉连接、笛卡尔积呢？</p>
</blockquote>
<h3 id="Join图"><a href="#Join图" class="headerlink" title="Join图"></a>Join图</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539969-2ac4a686-05ba-4792-baa4-251a6c5bd854.webp?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<h2 id="八、MySQL调优"><a href="#八、MySQL调优" class="headerlink" title="八、MySQL调优"></a>八、MySQL调优</h2><blockquote>
<p>❝</p>
<p>日常工作中你是怎么优化SQL的？</p>
<p>SQL优化的一般步骤是什么，怎么看执行计划（explain），如何理解其中各个字段的含义？</p>
<p>如何写sql能够有效的使用到复合索引？</p>
<p>一条sql执行过长的时间，你如何优化，从哪些方面入手？</p>
<p>什么是最左前缀原则？什么是最左匹配原则？</p>
</blockquote>
<h3 id="影响mysql的性能因素"><a href="#影响mysql的性能因素" class="headerlink" title="影响mysql的性能因素"></a>影响mysql的性能因素</h3><ul>
<li><p>业务需求对MySQL的影响(合适合度)</p>
</li>
<li><p>存储定位对MySQL的影响</p>
</li>
<li><ul>
<li>系统各种配置及规则数据</li>
<li>活跃用户的基本信息数据</li>
<li>活跃用户的个性化定制信息数据</li>
<li>准实时的统计信息数据</li>
<li>其他一些访问频繁但变更较少的数据</li>
<li>二进制多媒体数据</li>
<li>流水队列数据</li>
<li>超大文本数据</li>
<li>不适合放进MySQL的数据</li>
<li>需要放进缓存的数据</li>
</ul>
</li>
<li><p>Schema设计对系统的性能影响</p>
</li>
<li><ul>
<li>尽量减少对数据库访问的请求</li>
<li>尽量减少无用数据的查询请求</li>
</ul>
</li>
<li><p>硬件环境对系统性能的影响</p>
</li>
</ul>
<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><h4 id="MySQL-Query-Optimizer"><a href="#MySQL-Query-Optimizer" class="headerlink" title="MySQL Query Optimizer"></a>MySQL Query Optimizer</h4><ol>
<li>MySQL 中有专门负责优化 SELECT 语句的优化器模块，主要功能：通过计算分析系统中收集到的统计信息，为客户端请求的 Query 提供他认为最优的执行计划（他认为最优的数据检索方式，但不见得是 DBA 认为是最优的，这部分最耗费时间）</li>
<li>当客户端向 MySQL 请求一条 Query，命令解析器模块完成请求分类，区别出是 SELECT 并转发给 MySQL Query Optimize r时，MySQL Query Optimizer 首先会对整条 Query 进行优化，处理掉一些常量表达式的预算，直接换算成常量值。并对 Query 中的查询条件进行简化和转换，如去掉一些无用或显而易见的条件、结构调整等。然后分析 Query 中的 Hint 信息（如果有），看显示 Hint 信息是否可以完全确定该 Query 的执行计划。如果没有 Hint 或 Hint 信息还不足以完全确定执行计划，则会读取所涉及对象的统计信息，根据 Query 进行写相应的计算分析，然后再得出最后的执行计划。</li>
</ol>
<h4 id="MySQL常见瓶颈"><a href="#MySQL常见瓶颈" class="headerlink" title="MySQL常见瓶颈"></a>MySQL常见瓶颈</h4><ul>
<li>CPU：CPU在饱和的时候一般发生在数据装入内存或从磁盘上读取数据时候</li>
<li>IO：磁盘I/O瓶颈发生在装入数据远大于内存容量的时候</li>
<li>服务器硬件的性能瓶颈：top，free，iostat 和 vmstat来查看系统的性能状态</li>
</ul>
<h4 id="性能下降SQL慢-执行时间长-等待时间长-原因分析"><a href="#性能下降SQL慢-执行时间长-等待时间长-原因分析" class="headerlink" title="性能下降SQL慢 执行时间长 等待时间长 原因分析"></a>性能下降SQL慢 执行时间长 等待时间长 原因分析</h4><ul>
<li>查询语句写的烂</li>
<li>索引失效（单值、复合）</li>
<li>关联查询太多join（设计缺陷或不得已的需求）</li>
<li>服务器调优及各个参数设置（缓冲、线程数等）</li>
</ul>
<h4 id="MySQL常见性能分析手段"><a href="#MySQL常见性能分析手段" class="headerlink" title="MySQL常见性能分析手段"></a>MySQL常见性能分析手段</h4><p>在优化MySQL时，通常需要对数据库进行分析，常见的分析手段有<strong>慢查询日志</strong>，<strong>EXPLAIN 分析查询</strong>，<strong>profiling分析</strong>以及<strong>show命令查询系统状态及系统变量</strong>，通过定位分析性能的瓶颈，才能更好的优化数据库系统的性能。</p>
<h5 id="性能瓶颈定位"><a href="#性能瓶颈定位" class="headerlink" title="性能瓶颈定位"></a>性能瓶颈定位</h5><p>我们可以通过 show 命令查看 MySQL 状态及变量，找到系统的瓶颈：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">Mysql&gt; <span class="keyword">show</span> status ——显示状态信息（扩展<span class="keyword">show</span> status <span class="keyword">like</span> ‘XXX’）</span><br><span class="line">Mysql&gt; <span class="keyword">show</span> variables ——显示系统变量（扩展<span class="keyword">show</span> variables <span class="keyword">like</span> ‘XXX’）</span><br><span class="line">Mysql&gt; <span class="keyword">show</span> innodb status ——显示InnoDB存储引擎的状态</span><br><span class="line">Mysql&gt; <span class="keyword">show</span> processlist ——查看当前<span class="keyword">SQL</span>执行，包括执行状态、是否锁表等</span><br><span class="line">Shell&gt; mysqladmin variables -u username -p <span class="keyword">password</span>——显示系统变量</span><br><span class="line">Shell&gt; mysqladmin extended-status -u username -p <span class="keyword">password</span>——显示状态信息</span><br></pre></td></tr></table></figure>

<h5 id="Explain-执行计划"><a href="#Explain-执行计划" class="headerlink" title="Explain(执行计划)"></a>Explain(执行计划)</h5><p>是什么：使用 <strong>Explain</strong> 关键字可以模拟优化器执行SQL查询语句，从而知道 MySQL 是如何处理你的 SQL 语句的。分析你的查询语句或是表结构的性能瓶颈</p>
<p>能干什么：</p>
<ul>
<li>表的读取顺序</li>
<li>数据读取操作的操作类型</li>
<li>哪些索引可以使用</li>
<li>哪些索引被实际使用</li>
<li>表之间的引用</li>
<li>每张表有多少行被优化器查询</li>
</ul>
<p>怎么玩：</p>
<ul>
<li>Explain + SQL语句</li>
<li>执行计划包含的信息（如果有分区表的话还会有<strong>partitions</strong>）</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539945-f25d6d79-1cb8-42b6-a6fa-b57a1ba9b5c9.webp" alt="image">expalin</p>
<p>各字段解释</p>
<ul>
<li><p><strong>id</strong>（select 查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序）</p>
</li>
<li><ul>
<li>id相同，执行顺序从上往下</li>
<li>id全不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</li>
<li>id部分相同，执行顺序是先按照数字大的先执行，然后数字相同的按照从上往下的顺序执行</li>
</ul>
</li>
<li><p><strong>select_type</strong>（查询类型，用于区别普通查询、联合查询、子查询等复杂查询）</p>
</li>
<li><ul>
<li><strong>SIMPLE</strong> ：简单的select查询，查询中不包含子查询或UNION</li>
<li><strong>PRIMARY</strong>：查询中若包含任何复杂的子部分，最外层查询被标记为PRIMARY</li>
<li><strong>SUBQUERY</strong>：在select或where列表中包含了子查询</li>
<li><strong>DERIVED</strong>：在from列表中包含的子查询被标记为DERIVED，MySQL会递归执行这些子查询，把结果放在临时表里</li>
<li><strong>UNION</strong>：若第二个select出现在UNION之后，则被标记为UNION，若UNION包含在from子句的子查询中，外层select将被标记为DERIVED</li>
<li><strong>UNION RESULT</strong>：从UNION表获取结果的select</li>
</ul>
</li>
<li><p><strong>table</strong>（显示这一行的数据是关于哪张表的）</p>
</li>
<li><p><strong>type</strong>（显示查询使用了那种类型，从最好到最差依次排列 <strong>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</strong> ）<br>tip: 一般来说，得保证查询至少达到range级别，最好到达ref</p>
</li>
<li><ul>
<li>system：表只有一行记录（等于系统表），是 const 类型的特例，平时不会出现</li>
<li>const：表示通过索引一次就找到了，const 用于比较 primary key 或 unique 索引，因为只要匹配一行数据，所以很快，如将主键置于 where 列表中，mysql 就能将该查询转换为一个常量</li>
<li>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常见于主键或唯一索引扫描</li>
<li>ref：非唯一性索引扫描，范围匹配某个单独值得所有行。本质上也是一种索引访问，他返回所有匹配某个单独值的行，然而，它可能也会找到多个符合条件的行，多以他应该属于查找和扫描的混合体</li>
<li>range：只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引，一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询，这种范围扫描索引比全表扫描要好，因为它只需开始于索引的某一点，而结束于另一点，不用扫描全部索引</li>
<li>index：Full Index Scan，index于ALL区别为index类型只遍历索引树。通常比ALL快，因为索引文件通常比数据文件小。（<strong>也就是说虽然all和index都是读全表，但index是从索引中读取的，而all是从硬盘中读的</strong>）</li>
<li>ALL：Full Table Scan，将遍历全表找到匹配的行</li>
</ul>
</li>
<li><p><strong>possible_keys</strong>（显示可能应用在这张表中的索引，一个或多个，查询涉及到的字段若存在索引，则该索引将被列出，但不一定被查询实际使用）</p>
</li>
<li><p><strong>key</strong></p>
</li>
<li><ul>
<li>实际使用的索引，如果为NULL，则没有使用索引</li>
<li><strong>查询中若使用了覆盖索引，则该索引和查询的 select 字段重叠，仅出现在key列表中</strong></li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539958-bcf79915-a194-4c29-9bb0-f8a828626624.webp" alt="image">explain-key</p>
<ul>
<li><p><strong>key_len</strong></p>
</li>
<li><ul>
<li>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好</li>
<li>key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的</li>
</ul>
</li>
<li><p><strong>ref</strong>（显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值）</p>
</li>
<li><p><strong>rows</strong>（根据表统计信息及索引选用情况，大致估算找到所需的记录所需要读取的行数）</p>
</li>
<li><p><strong>Extra</strong>（包含不适合在其他列中显示但十分重要的额外信息）</p>
</li>
</ul>
<ol>
<li><ol>
<li>using filesort: 说明mysql会对数据使用一个外部的索引排序，不是按照表内的索引顺序进行读取。mysql中无法利用索引完成的排序操作称为“文件排序”。常见于order by和group by语句中</li>
<li>Using temporary：使用了临时表保存中间结果，mysql在对查询结果排序时使用临时表。常见于排序order by和分组查询group by。</li>
<li>using index：表示相应的select操作中使用了覆盖索引，避免访问了表的数据行，效率不错，如果同时出现using where，表明索引被用来执行索引键值的查找；否则索引被用来读取数据而非执行查找操作</li>
<li>using where：使用了where过滤</li>
<li>using join buffer：使用了连接缓存</li>
<li>impossible where：where子句的值总是false，不能用来获取任何元祖</li>
<li>select tables optimized away：在没有group by子句的情况下，基于索引优化操作或对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化</li>
<li>distinct：优化distinct操作，在找到第一匹配的元祖后即停止找同样值的动作</li>
</ol>
</li>
</ol>
<p><strong>case</strong>:</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539975-a8ae7858-047b-4816-a2d7-c5b3cab09fab.webp" alt="image">explain-demo</p>
<ol>
<li>第一行（执行顺序4）：id列为1，表示是union里的第一个select，select_type列的primary表示该查询为外层查询，table列被标记为，表示查询结果来自一个衍生表，其中derived3中3代表该查询衍生自第三个select查询，即id为3的select。【select d1.name……】</li>
<li>第二行（执行顺序2）：id为3，是整个查询中第三个select的一部分。因查询包含在from中，所以为derived。【select id,name from t1 where other_column=’’】</li>
<li>第三行（执行顺序3）：select列表中的子查询select_type为subquery，为整个查询中的第二个select。【select id from t3】</li>
<li>第四行（执行顺序1）：select_type为union，说明第四个select是union里的第二个select，最先执行【select name,id from t2】</li>
<li>第五行（执行顺序5）：代表从union的临时表中读取行的阶段，table列的&lt;union1,4&gt;表示用第一个和第四个select的结果进行union操作。【两个结果union操作】</li>
</ol>
<h5 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h5><p>MySQL 的慢查询日志是 MySQL 提供的一种日志记录，它用来记录在 MySQL 中响应时间超过阈值的语句，具体指运行时间超过 <code>long_query_time</code> 值的 SQL，则会被记录到慢查询日志中。</p>
<ul>
<li><code>long_query_time</code> 的默认值为10，意思是运行10秒以上的语句</li>
<li>默认情况下，MySQL数据库没有开启慢查询日志，需要手动设置参数开启</li>
</ul>
<p><strong>查看开启状态</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">&#x27;%slow_query_log%&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>开启慢查询日志</strong></p>
<ul>
<li>临时配置：</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">mysql&gt; <span class="builtin-name">set</span> global <span class="attribute">slow_query_log</span>=<span class="string">&#x27;ON&#x27;</span>;</span><br><span class="line">mysql&gt; <span class="builtin-name">set</span> global <span class="attribute">slow_query_log_file</span>=<span class="string">&#x27;/var/lib/mysql/hostname-slow.log&#x27;</span>;</span><br><span class="line">mysql&gt; <span class="builtin-name">set</span> global <span class="attribute">long_query_time</span>=2;</span><br></pre></td></tr></table></figure>

<p>也可set文件位置，系统会默认给一个缺省文件host_name-slow.log</p>
<p>使用set操作开启慢查询日志只对当前数据库生效，如果MySQL重启则会失效。</p>
<ul>
<li>永久配置<br>修改配置文件my.cnf或my.ini，在[mysqld]一行下面加入两个配置参数</li>
</ul>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">slow_query_log</span> = <span class="literal">ON</span></span><br><span class="line"><span class="attr">slow_query_log_file</span> = /var/lib/mysql/hostname-slow.log</span><br><span class="line"><span class="attr">long_query_time</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>注：log-slow-queries 参数为慢查询日志存放的位置，一般这个目录要有 MySQL 的运行帐号的可写权限，一般都将这个目录设置为 MySQL 的数据存放目录；long_query_time=2 中的 2 表示查询超过两秒才记录；在my.cnf或者 my.ini 中添加 log-queries-not-using-indexes 参数，表示记录下没有使用索引的查询。</p>
<p>可以用 <code>select sleep(4)</code> 验证是否成功开启。</p>
<p>在生产环境中，如果手工分析日志，查找、分析SQL，还是比较费劲的，所以MySQL提供了日志分析工具<strong>mysqldumpslow</strong>。</p>
<p>通过 mysqldumpslow –help 查看操作帮助信息</p>
<ul>
<li>得到返回记录集最多的10个SQL<br><code>mysqldumpslow -s r -t 10 /var/lib/mysql/hostname-slow.log</code></li>
<li>得到访问次数最多的10个SQL<br><code>mysqldumpslow -s c -t 10 /var/lib/mysql/hostname-slow.log</code></li>
<li>得到按照时间排序的前10条里面含有左连接的查询语句<br><code>mysqldumpslow -s t -t 10 -g &quot;left join&quot; /var/lib/mysql/hostname-slow.log</code></li>
<li>也可以和管道配合使用<br><code>mysqldumpslow -s r -t 10 /var/lib/mysql/hostname-slow.log | more</code></li>
</ul>
<p><strong>也可使用 pt-query-digest 分析 RDS MySQL 慢查询日志</strong></p>
<h5 id="Show-Profile-分析查询"><a href="#Show-Profile-分析查询" class="headerlink" title="Show Profile 分析查询"></a>Show Profile 分析查询</h5><p>通过慢日志查询可以知道哪些 SQL 语句执行效率低下，通过 explain 我们可以得知 SQL 语句的具体执行情况，索引使用等，还可以结合<code>Show Profile</code>命令查看执行状态。</p>
<ul>
<li><p>Show Profile 是 MySQL 提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于SQL的调优的测量</p>
</li>
<li><p>默认情况下，参数处于关闭状态，并保存最近15次的运行结果</p>
</li>
<li><p>分析步骤<br>mysql&gt; show profiles; +———-+————+———————————+ | Query_ID | Duration  | Query              | +———-+————+———————————+ |     1 | 0.00385450 | show variables like “profiling” | |     2 | 0.00170050 | show variables like “profiling” | |     3 | 0.00038025 | select * from t_base_user    | +———-+————+———————————+</p>
</li>
<li><ul>
<li>converting HEAP to MyISAM 查询结果太大，内存都不够用了往磁盘上搬了。</li>
<li>create tmp table 创建临时表，这个要注意</li>
<li>Copying to tmp table on disk  把内存临时表复制到磁盘</li>
<li>locked</li>
</ul>
</li>
</ul>
<ol>
<li><ol>
<li>诊断SQL，show profile cpu,block io for query  id(上一步前面的问题SQL数字号码)</li>
<li>日常开发需要注意的结论</li>
<li>是否支持，看看当前的mysql版本是否支持</li>
</ol>
</li>
</ol>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">mysql&gt;Show  <span class="keyword">variables</span> like <span class="comment">&#x27;profiling&#x27;</span>;  --默认是关闭，使用前需要开启</span><br></pre></td></tr></table></figure>

<ol>
<li><ol>
<li>开启功能，默认是关闭，使用前需要开启</li>
</ol>
</li>
</ol>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">mysql&gt;<span class="builtin-name">set</span> <span class="attribute">profiling</span>=1;</span><br></pre></td></tr></table></figure>

<ol>
<li><ol>
<li>运行SQL</li>
<li>查看结果</li>
</ol>
</li>
</ol>
<blockquote>
<p>❝查询中哪些情况不会使用索引？</p>
</blockquote>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><h4 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h4><ol>
<li>全值匹配我最爱</li>
<li>最佳左前缀法则，比如建立了一个联合索引(a,b,c)，那么其实我们可利用的索引就有(a), (a,b), (a,b,c)</li>
<li>不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描</li>
<li>存储引擎不能使用索引中范围条件右边的列</li>
<li>尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致))，减少select</li>
<li>is null ,is not null 也无法使用索引</li>
<li>like “xxxx%” 是可以用到索引的，like “%xxxx” 则不行(like “%xxx%” 同理)。like以通配符开头(‘%abc…’)索引失效会变成全表扫描的操作，</li>
<li>字符串不加单引号索引失效</li>
<li>少用or，用它来连接时会索引失效</li>
<li>&lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN 可用到索引，&lt;&gt;，not in ，!= 则不行，会导致全表扫描</li>
</ol>
<p><strong>一般性建议</strong></p>
<ul>
<li>对于单键索引，尽量选择针对当前query过滤性更好的索引</li>
<li>在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。</li>
<li>在选择组合索引的时候，尽量选择可以能够包含当前query中的where字句中更多字段的索引</li>
<li>尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的</li>
<li>少用Hint强制索引</li>
</ul>
<h4 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h4><p><strong>永远小表驱动大表（小的数据集驱动大的数据集）</strong></p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">slect * <span class="keyword">from</span> A <span class="keyword">where</span> <span class="built_in">id</span> <span class="keyword">in</span> (select <span class="built_in">id</span> <span class="keyword">from</span> B)`等价于</span><br><span class="line"><span class="comment">#等价于</span></span><br><span class="line">select <span class="built_in">id</span> <span class="keyword">from</span> B</span><br><span class="line">select * <span class="keyword">from</span> A <span class="keyword">where</span> A.<span class="built_in">id</span>=B.<span class="built_in">id</span></span><br></pre></td></tr></table></figure>

<p>当 B 表的数据集必须小于 A 表的数据集时，用 in 优于 exists</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> B <span class="keyword">where</span> B.id=A.id)</span><br><span class="line"><span class="comment">#等价于</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> B <span class="keyword">where</span> B.id = A.id<span class="string">`</span></span><br></pre></td></tr></table></figure>

<p>当 A 表的数据集小于B表的数据集时，用 exists优于用 in</p>
<p>注意：A表与B表的ID字段应建立索引。</p>
<p><strong>order by关键字优化</strong></p>
<ul>
<li><p>order by子句，尽量使用 Index 方式排序，避免使用 FileSort 方式排序</p>
</li>
<li><p>MySQL 支持两种方式的排序，FileSort 和 Index，Index效率高，它指 MySQL 扫描索引本身完成排序，FileSort 效率较低；</p>
</li>
<li><p>ORDER BY 满足两种情况，会使用Index方式排序；①ORDER BY语句使用索引最左前列 ②使用where子句与ORDER BY子句条件列组合满足索引最左前列</p>
</li>
<li><p>尽可能在索引列上完成排序操作，遵照索引建的最佳最前缀</p>
</li>
<li><p>如果不在索引列上，filesort 有两种算法，mysql就要启动双路排序和单路排序</p>
</li>
<li><ul>
<li>双路排序：MySQL 4.1之前是使用双路排序,字面意思就是两次扫描磁盘，最终得到数据</li>
<li>单路排序：从磁盘读取查询需要的所有列，按照order by 列在 buffer对它们进行排序，然后扫描排序后的列表进行输出，效率高于双路排序</li>
</ul>
</li>
<li><p>优化策略</p>
</li>
<li><ul>
<li>增大sort_buffer_size参数的设置</li>
<li>增大max_lencth_for_sort_data参数的设置</li>
</ul>
</li>
</ul>
<p><strong>GROUP BY关键字优化</strong></p>
<ul>
<li>group by实质是先排序后进行分组，遵照索引建的最佳左前缀</li>
<li>当无法使用索引列，增大 <code>max_length_for_sort_data</code> 参数的设置，增大<code>sort_buffer_size</code>参数的设置</li>
<li>where高于having，能写在where限定的条件就不要去having限定了</li>
</ul>
<h4 id="数据类型优化"><a href="#数据类型优化" class="headerlink" title="数据类型优化"></a>数据类型优化</h4><p>MySQL 支持的数据类型非常多，选择正确的数据类型对于获取高性能至关重要。不管存储哪种类型的数据，下面几个简单的原则都有助于做出更好的选择。</p>
<ul>
<li>更小的通常更好：一般情况下，应该尽量使用可以正确存储数据的最小数据类型。<br>简单就好：简单的数据类型通常需要更少的CPU周期。例如，整数比字符操作代价更低，因为字符集和校对规则（排序规则）使字符比较比整型比较复杂。</li>
<li>尽量避免NULL：通常情况下最好指定列为NOT NULL</li>
</ul>
<h2 id="九、分区、分表、分库"><a href="#九、分区、分表、分库" class="headerlink" title="九、分区、分表、分库"></a>九、分区、分表、分库</h2><h3 id="MySQL分区"><a href="#MySQL分区" class="headerlink" title="MySQL分区"></a>MySQL分区</h3><p>一般情况下我们创建的表对应一组存储文件，使用<code>MyISAM</code>存储引擎时是一个<code>.MYI</code>和<code>.MYD</code>文件，使用<code>Innodb</code>存储引擎时是一个<code>.ibd</code>和<code>.frm</code>（表结构）文件。</p>
<p>当数据量较大时（一般千万条记录级别以上），MySQL的性能就会开始下降，这时我们就需要将数据分散到多组存储文件，保证其单个文件的执行效率</p>
<p><strong>能干嘛</strong></p>
<ul>
<li>逻辑数据分割</li>
<li>提高单一的写和读应用速度</li>
<li>提高分区范围读查询的速度</li>
<li>分割数据能够有多个不同的物理文件路径</li>
<li>高效的保存历史数据</li>
</ul>
<p><strong>怎么玩</strong></p>
<p>首先查看当前数据库是否支持分区</p>
<ul>
<li>MySQL5.6以及之前版本：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">&#x27;%partition%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>MySQL5.6：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> plugins;</span><br></pre></td></tr></table></figure>

<p><strong>分区类型及操作</strong></p>
<ul>
<li><strong>RANGE分区</strong>：基于属于一个给定连续区间的列值，把多行分配给分区。mysql将会根据指定的拆分策略，,把数据放在不同的表文件上。相当于在文件上,被拆成了小块.但是,对外给客户的感觉还是一张表，透明的。<br>按照 range 来分，就是每个库一段连续的数据，这个一般是按比如<strong>时间范围</strong>来的，比如交易表啊，销售表啊等，可以根据年月来存放数据。可能会产生热点问题，大量的流量都打在最新的数据上了。<br>range 来分，好处在于说，扩容的时候很简单。</li>
<li><strong>LIST分区</strong>：类似于按RANGE分区，每个分区必须明确定义。它们的主要区别在于，LIST分区中每个分区的定义和选择是基于某列的值从属于一个值列表集中的一个值，而RANGE分区是从属于一个连续区间值的集合。</li>
<li><strong>HASH分区</strong>：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL 中有效的、产生非负整数值的任何表达式。<br>hash 分发，好处在于说，可以平均分配每个库的数据量和请求压力；坏处在于说扩容起来比较麻烦，会有一个数据迁移的过程，之前的数据需要重新计算 hash 值重新分配到不同的库或表</li>
<li><strong>KEY分区</strong>：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL服务器提供其自身的哈希函数。必须有一列或多列包含整数值。</li>
</ul>
<p><strong>看上去分区表很帅气，为什么大部分互联网还是更多的选择自己分库分表来水平扩展咧？</strong></p>
<ul>
<li>分区表，分区键设计不太灵活，如果不走分区键，很容易出现全表锁</li>
<li>一旦数据并发量上来，如果在分区表实施关联，就是一个灾难</li>
<li>自己分库分表，自己掌控业务场景与访问模式，可控。分区表，研发写了一个sql，都不确定mysql是怎么玩的，不太可控</li>
</ul>
<blockquote>
<p>❝</p>
<p>随着业务的发展，业务越来越复杂，应用的模块越来越多，总的数据量很大，高并发读写操作均超过单个数据库服务器的处理能力怎么办？</p>
</blockquote>
<p>这个时候就出现了<strong>数据分片</strong>，数据分片指按照某个维度将存放在单一数据库中的数据分散地存放至多个数据库或表中。数据分片的有效手段就是对关系型数据库进行分库和分表。</p>
<p>区别于分区的是，分区一般都是放在单机里的，用的比较多的是时间范围分区，方便归档。只不过分库分表需要代码实现，分区则是mysql内部实现。分库分表和分区并不冲突，可以结合使用。</p>
<blockquote>
<p>❝</p>
<p>说说分库与分表的设计</p>
</blockquote>
<h3 id="MySQL分表"><a href="#MySQL分表" class="headerlink" title="MySQL分表"></a>MySQL分表</h3><p>分表有两种分割方式，一种垂直拆分，另一种水平拆分。</p>
<ul>
<li><p><strong>垂直拆分</strong><br>垂直分表，通常是按照业务功能的使用频次，把主要的、热门的字段放在一起做为主要表。然后把不常用的，按照各自的业务属性进行聚集，拆分到不同的次要表中；主要表和次要表的关系一般都是一对一的。</p>
</li>
<li><p><strong>水平拆分(数据分片)</strong><br>单表的容量不超过500W，否则建议水平拆分。是把一个表复制成同样表结构的不同表，然后把数据按照一定的规则划分，分别存储到这些表中，从而保证单表的容量不会太大，提升性能；当然这些结构一样的表，可以放在一个或多个数据库中。<br>水平分割的几种方法：</p>
</li>
<li><ul>
<li>使用MD5哈希，做法是对UID进行md5加密，然后取前几位（我们这里取前两位），然后就可以将不同的UID哈希到不同的用户表（user_xx）中了。</li>
<li>还可根据时间放入不同的表，比如：article_201601，article_201602。</li>
<li>按热度拆分，高点击率的词条生成各自的一张表，低热度的词条都放在一张大表里，待低热度的词条达到一定的贴数后，再把低热度的表单独拆分成一张表。</li>
<li>根据ID的值放入对应的表，第一个表user_0000，第二个100万的用户数据放在第二 个表user_0001中，随用户增加，直接添加用户表就行了。</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539957-9e85fd78-eebe-4644-a408-80ff3dfc87cd.webp?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<h3 id="MySQL分库"><a href="#MySQL分库" class="headerlink" title="MySQL分库"></a>MySQL分库</h3><blockquote>
<p>❝为什么要分库?</p>
</blockquote>
<p>数据库集群环境后都是多台 slave，基本满足了读取操作;  但是写入或者说大数据、频繁的写入操作对master性能影响就比较大，这个时候，单库并不能解决大规模并发写入的问题，所以就会考虑分库。</p>
<blockquote>
<p>❝分库是什么？</p>
</blockquote>
<p>一个库里表太多了，导致了海量数据，系统性能下降，把原本存储于一个库的表拆分存储到多个库上， 通常是将表按照功能模块、关系密切程度划分出来，部署到不同库上。</p>
<p>优点：</p>
<ul>
<li>减少增量数据写入时的锁对查询的影响</li>
<li>由于单表数量下降，常见的查询操作由于减少了需要扫描的记录，使得单表单次查询所需的检索行数变少，减少了磁盘IO，时延变短</li>
</ul>
<p>但是它无法解决单表数据量太大的问题</p>
<p><strong>分库分表后的难题</strong></p>
<p>分布式事务的问题，数据的完整性和一致性问题。</p>
<p>数据操作维度问题：用户、交易、订单各个不同的维度，用户查询维度、产品数据分析维度的不同对比分析角度。跨库联合查询的问题，可能需要两次查询 跨节点的count、order by、group by以及聚合函数问题，可能需要分别在各个节点上得到结果后在应用程序端进行合并 额外的数据管理负担，如：访问数据表的导航定位 额外的数据运算压力，如：需要在多个节点执行，然后再合并计算程序编码开发难度提升，没有太好的框架解决，更多依赖业务看如何分，如何合，是个难题。</p>
<blockquote>
<p>❝配主从，正经公司的话，也不会让 Javaer 去搞的，但还是要知道</p>
</blockquote>
<h2 id="十、主从复制"><a href="#十、主从复制" class="headerlink" title="十、主从复制"></a>十、主从复制</h2><h3 id="复制的基本原理"><a href="#复制的基本原理" class="headerlink" title="复制的基本原理"></a>复制的基本原理</h3><ul>
<li>slave 会从 master 读取 binlog 来进行数据同步</li>
<li>三个步骤<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590540019-3b79bd00-05a5-47a9-a4bb-c594e451c33c.webp?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image">img</li>
</ul>
<ol>
<li><ol>
<li>master将改变记录到二进制日志（binary log）。这些记录过程叫做二进制日志事件，binary log events；</li>
<li>salve 将 master 的 binary log events 拷贝到它的中继日志（relay log）;</li>
<li>slave 重做中继日志中的事件，将改变应用到自己的数据库中。MySQL 复制是异步且是串行化的。</li>
</ol>
</li>
</ol>
<h3 id="复制的基本原则"><a href="#复制的基本原则" class="headerlink" title="复制的基本原则"></a>复制的基本原则</h3><ul>
<li>每个 slave只有一个 master</li>
<li>每个 salve只能有一个唯一的服务器 ID</li>
<li>每个master可以有多个salve</li>
</ul>
<h3 id="复制的最大问题"><a href="#复制的最大问题" class="headerlink" title="复制的最大问题"></a>复制的最大问题</h3><ul>
<li>延时</li>
</ul>
<h2 id="十一、其他问题"><a href="#十一、其他问题" class="headerlink" title="十一、其他问题"></a>十一、其他问题</h2><h3 id="说一说三个范式"><a href="#说一说三个范式" class="headerlink" title="说一说三个范式"></a>说一说三个范式</h3><ul>
<li>第一范式（1NF）：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。</li>
<li>第二范式（2NF）：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。</li>
<li>第三范式（3NF）：在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。所谓传递函数依赖，指的是如 果存在”A → B → C”的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系：关键字段 → 非关键字段 x → 非关键字段y</li>
</ul>
<h3 id="百万级别或以上的数据如何删除"><a href="#百万级别或以上的数据如何删除" class="headerlink" title="百万级别或以上的数据如何删除"></a>百万级别或以上的数据如何删除</h3><p>关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。</p>
<ol>
<li>所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）</li>
<li>然后删除其中无用数据（此过程需要不到两分钟）</li>
<li>删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。</li>
<li>与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合</title>
    <url>/2020/10/18/JAVA%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><ul>
<li>Collection：List（列表）、Queue（队列）、Set（集）</li>
<li>Iterator（迭代器）</li>
</ul>
<a id="more"></a>

<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/JAVA-283.jpg"></p>
<h2 id="1-ArrayList和LinkedList的区别？"><a href="#1-ArrayList和LinkedList的区别？" class="headerlink" title="1 ArrayList和LinkedList的区别？"></a>1 ArrayList和LinkedList的区别？</h2><ul>
<li><strong>是否线程安全：</strong>ArrayList和LinkedList都不是线程安全的；</li>
<li><strong>底层数据结构：</strong>ArrayList底层使用数组，LinkedList底层使用双向链表；</li>
<li><strong>快速随机访问：</strong>ArrayList支持，LinkedList不支持；</li>
<li><strong>随机位置插入删除的时间复杂度：</strong>ArrayList为O(n)，LinkedList为O(1);</li>
<li><strong>内存占用：</strong>ArrayList会在列表结尾预留一定容量空间，LinkedList的每个元素都要额外存储直接前驱和直接后继。</li>
</ul>
<h2 id="2-ArrayList和Vector的区别？"><a href="#2-ArrayList和Vector的区别？" class="headerlink" title="2 ArrayList和Vector的区别？"></a>2 ArrayList和Vector的区别？</h2><ul>
<li>ArrayList不是线程安全的；</li>
<li>Vector是线程安全的，但是在同步操作上会耗费大量时间。</li>
</ul>
<h2 id="3-ArrayList的扩容机制？"><a href="#3-ArrayList的扩容机制？" class="headerlink" title="3 ArrayList的扩容机制？"></a>3 ArrayList的扩容机制？</h2><ul>
<li><p>默认初始大小为10；</p>
</li>
<li><p>底层其实是调用Arrays.copyOf`方法来进行扩充数组容量。</p>
</li>
<li><p>默认情况下，新的容量会是原容量的1.5倍，这里用了位运算提高效率。一般情况下，如果扩容1.5倍后就大于期望容量，那就返回这个1.5倍旧容量的值。而如果小于期望容量，那就返回期望容量。</p>
</li>
<li><p>使用1.5倍这个数值而不是直接使用期望容量，是为了防止频繁扩容影响性能。试想如果每次add操作都要扩容一次，那性能将会非常低下。</p>
</li>
<li><p>可以手动扩容，没有缩容。</p>
</li>
</ul>
<h2 id="4-HashMap和HashTable的区别？"><a href="#4-HashMap和HashTable的区别？" class="headerlink" title="4 HashMap和HashTable的区别？"></a>4 HashMap和HashTable的区别？</h2><ul>
<li><strong>线程是否安全：</strong>HashMap是非线程安全的，HashTable使用synchronized修饰，是线程安全的；</li>
<li><strong>效率：</strong>HashTable的效率低，已被淘汰；</li>
<li><strong>Null值：</strong>HashMap的Key和Value可以为null，HashTab的Key如果为null，则会跑出NullPointerException。</li>
<li><strong>初始容量和扩容：</strong>HashMap的初始大小为16，扩容因子为0.75，每次扩容变为2倍，HashTable的初始大小为11，每次扩容变为原来的2n+1;</li>
<li><strong>底层实现不同。</strong></li>
</ul>
<h2 id="5-HashMap和HashSet的区别？"><a href="#5-HashMap和HashSet的区别？" class="headerlink" title="5 HashMap和HashSet的区别？"></a>5 HashMap和HashSet的区别？</h2><ul>
<li>HashSet的底层是基于HashMap实现的；</li>
</ul>
<table>
<thead>
<tr>
<th align="center">HashMap</th>
<th align="center">HashSet</th>
</tr>
</thead>
<tbody><tr>
<td align="center">实现Map接口</td>
<td align="center">实现Set接口</td>
</tr>
<tr>
<td align="center">存储键值对</td>
<td align="center">仅存储值</td>
</tr>
<tr>
<td align="center">使用put()添加元素</td>
<td align="center">使用add()添加元素</td>
</tr>
<tr>
<td align="center">使用key计算hashCode</td>
<td align="center">使用value计算hashCode</td>
</tr>
</tbody></table>
<h2 id="6-HashSet如何检查重复？"><a href="#6-HashSet如何检查重复？" class="headerlink" title="6 HashSet如何检查重复？"></a>6 HashSet如何检查重复？</h2><p>向HashSet添加元素时，HashSet会计算元素的hashCode判断元素加入的位置，同时与其他已添加的元素的hashCode作比较，如果没有hashCode相同的元素，则添加，否则会调用equals()方法检查hashCode相同的元素是否真的相同。</p>
<h3 id="6-1-hashCode-和equals"><a href="#6-1-hashCode-和equals" class="headerlink" title="6.1 hashCode()和equals()"></a>6.1 hashCode()和equals()</h3><ul>
<li>如果两个对象相等，则hashCode相等，equals()为true；</li>
<li>两个对象即使hashCode相等，也不一定相等；</li>
<li>覆盖equals()必须覆盖hashCode()；</li>
<li>如果没有重写hashCode()，则两个对象绝对不相等。</li>
</ul>
<h3 id="6-2-和equals-的区别？"><a href="#6-2-和equals-的区别？" class="headerlink" title="6.2 ==和equals()的区别？"></a>6.2 ==和equals()的区别？</h3><ul>
<li>对于基本类型的变量来说（如 <code>short</code>、 <code>int</code>、 <code>long</code>、 <code>float</code>、 <code>double</code>），只能使用 == ，因为这些基本类型的变量没有 equals 方法。对于基本类型变量的比较，使用 == 比较， <strong>一般比较的是它们的值</strong>。</li>
<li>对于引用类型的变量来说（例如 String 类）才有 equals 方法。对于该类型对象的比较，默认情况下，也就是没有复写 Object 类的 equals 方法，使用 == 和 equals 比较是一样效果的，都是<strong>比较的是它们在内存中的存放地址</strong>。<strong>String 类存在 equals 方法被复写的情况，使用 equals 方法会比较它们的值</strong>；</li>
</ul>
<h2 id="7-HashMap的底层实现"><a href="#7-HashMap的底层实现" class="headerlink" title="7 HashMap的底层实现"></a>7 HashMap的底层实现</h2><ul>
<li>JDK1.8以前，HashMap的底层是数组和链表组合在一起。HashMap计算key的hashCode经过扰动函数处理后得到hash值，然后通过 (n-1) &amp; hash判断当前元素存放的位置，如果当前位置存在元素，则判断该元素与要存入的元素的hash值和key是否相等，如果相等则覆盖，否则通过拉链法解决冲突。</li>
</ul>
<blockquote>
<p>扰动函数：即hash方法</p>
</blockquote>
<ul>
<li>JDK1.7的hash方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span></span>&#123;</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt;<span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>JDK1.8以后，当数组长度大于64，链表长度大于8时，将链表转化为红黑树；链表长度小于7时，红黑树转化为链表。</p>
</li>
<li><p>JDK1.8的hash方法：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-HashMap的长度为什么是2的幂次方？"><a href="#8-HashMap的长度为什么是2的幂次方？" class="headerlink" title="8 HashMap的长度为什么是2的幂次方？"></a>8 HashMap的长度为什么是2的幂次方？</h2><p>hash % length == hash &amp; (length - 1)的前提是length == 2 的幂次方。</p>
<h2 id="9-ConcurrentHashMap和HashTable的区别？"><a href="#9-ConcurrentHashMap和HashTable的区别？" class="headerlink" title="9 ConcurrentHashMap和HashTable的区别？"></a>9 ConcurrentHashMap和HashTable的区别？</h2><ul>
<li>实现线程安全的方式不同：<ul>
<li>JDK1.7的ConcurrentHashMap使用分段锁对整个数组进行分段加锁（Segment），多线程访问不同数据段的数据就不会发生锁竞争，提高并发效率；</li>
<li>JDK1.8的ConcurrentHashMap使用synchronized和CAS进行并发控制；</li>
<li>HashTable使用synchronized保证线程安全，效率低下。</li>
</ul>
</li>
<li>底层数据结构不同。</li>
</ul>
<blockquote>
<p>Segment：实现了ReentrantLock，是可重入锁。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java汇总</title>
    <url>/2020/10/18/00000000.Java%E5%90%8E%E7%AB%AF%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="Java语法"><a href="#Java语法" class="headerlink" title="Java语法"></a>Java语法</h1><h2 id="Java特点"><a href="#Java特点" class="headerlink" title="Java特点"></a>Java特点</h2><ul>
<li><strong>面向对象：</strong><ul>
<li>类：类是现实世界在计算机中的反映，它将数据和对这些数据的操作封装在一起。</li>
<li>对象：类的实例。</li>
<li>抽象：在定义一个类的时候，实际上就是把一类事物的公有的属性和行为提取出来，形成一个物理模型，这种研究问题的方法称为抽象。</li>
<li>封装：把对象的属性和行为（数据）结合为一个独立的整体，并尽可能隐藏对象的内部实现细节。<ul>
<li>1、通过隐藏对象的属性来保护对象的内部状态</li>
<li>2、提高代码的可用性和可维护性</li>
<li>3、禁止对象之间的不良交互来提高模块化</li>
</ul>
</li>
<li>继承：继承是从已有的类中派生出新的类称为子类，子类继承父类的数据属性和行为，并能根据自己的需求扩展出新的行为，提高了代码的复用性。</li>
<li>多态：指允许不同的对象对同一消息做出相应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式（发送消息就是函数调用）。<ul>
<li>多态存在的三个必要条件<ul>
<li>继承</li>
<li>重写</li>
<li>父类引用指向子类对象</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>健壮性：</strong>吸收C/C++语言的优点，去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等），提供了一个相对安全的内存管理和访问机制。</li>
<li><strong>跨平台性：</strong>通过Java语言编写的应用程序在不同的系统平台上都可以运行【JVM】</li>
</ul>
<h2 id="JDK，-JRE和JVM的区别"><a href="#JDK，-JRE和JVM的区别" class="headerlink" title="JDK， JRE和JVM的区别"></a>JDK， JRE和JVM的区别</h2><ul>
<li>JDK（Java Development Kid，Java 开发开源工具包），是针对 Java 开发人员的产品，是整个 Java 的核心，包括了 Java 运行环境 JRE、Java 工具和 Java 基础类库。</li>
<li>JRE（Java Runtime Environment，Java 运行环境）是运行 JAVA 程序所必须的环境的集合，包含 JVM 标准实现及 Java 核心类库。</li>
<li>JVM（Java Virtual Machine，Java 虚拟机）是整个 Java 实现跨平台的最核心的部分，能够运行以 Java 语言写作的软件程序。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018090519.png"></p>
<h2 id="Java基本数据类型"><a href="#Java基本数据类型" class="headerlink" title="Java基本数据类型"></a>Java基本数据类型</h2><p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018095519.png" alt="image-20201018095515731"></p>
<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><ul>
<li><p>让基本类型也具有对象的特征</p>
</li>
<li><p><strong>装箱</strong>：由基本数据类型构造出一个包装类的对象。</p>
</li>
<li><p><strong>拆箱</strong>：由一个包装类对象转换到相应的基本数据类型。</p>
</li>
</ul>
<h3 id="基本类型和包装类的区别"><a href="#基本类型和包装类的区别" class="headerlink" title="基本类型和包装类的区别"></a>基本类型和包装类的区别</h3><ol>
<li>声明方式不同：基本类型不使用new关键字，而包装类型需要使用new关键字来在<strong>堆中分配存储空间</strong>；</li>
<li>存储方式及位置不同：基本类型是直接将变量值存储在栈中，而包装类型是将对象放在堆中，然后通过引用来使用；</li>
<li>初始值不同：基本类型的初始值如int为0，boolean为false，而包装类型的初始值为null；</li>
<li>使用方式不同：基本类型直接赋值直接使用就好，而包装类型在集合如Collection、Map时会使用到。</li>
</ol>
<h2 id="“-”-和-equals-的区别"><a href="#“-”-和-equals-的区别" class="headerlink" title="“==” 和 equals() 的区别"></a>“==” 和 equals() 的区别</h2><ul>
<li>对于基本数据类型的变量，只能使用 == 判断值是否相等，不能使用equals();</li>
<li>对于引用数据类型，<ul>
<li>如果没有对 equals() 进行重写，== 和equals() 比较的都是引用类型的变量所指向的对象的地址；</li>
<li>诸如String、Date等类对equals方法进行了重写的话，equals() 比较的是所指向的对象的内容。</li>
</ul>
</li>
</ul>
<h2 id="equals-与-hashcode-的区别"><a href="#equals-与-hashcode-的区别" class="headerlink" title="equals() 与 hashcode() 的区别"></a>equals() 与 hashcode() 的区别</h2><ul>
<li>equals()相等的两个对象他们的hashCode()肯定相等。</li>
<li>hashCode()相等的两个对象他们的equals()不一定相等。</li>
</ul>
<h2 id="String、StringBuilder、StringBuffer的区别"><a href="#String、StringBuilder、StringBuffer的区别" class="headerlink" title="String、StringBuilder、StringBuffer的区别"></a>String、StringBuilder、StringBuffer的区别</h2><table>
<thead>
<tr>
<th>String</th>
<th>StringBuffer</th>
<th>StringBuilder</th>
</tr>
</thead>
<tbody><tr>
<td>String的值是不可变的，这就导致每次对String的操作都会生成新的String对象，不仅效率低下，而且浪费大量优先的内存空间</td>
<td>StringBuffer是可变类，和线程安全的字符串操作类，任何对它指向的字符串的操作都不会产生新的对象。每个StringBuffer对象都有一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会自动增加容量</td>
<td>可变类，速度更快</td>
</tr>
<tr>
<td>不可变</td>
<td>可变</td>
<td>可变</td>
</tr>
<tr>
<td></td>
<td>线程安全</td>
<td>线程不安全</td>
</tr>
</tbody></table>
<h2 id="String-s-“hello”和String-s-new-String-“hello”-区别"><a href="#String-s-“hello”和String-s-new-String-“hello”-区别" class="headerlink" title="String s = “hello”和String s = new String(“hello”);区别"></a>String s = “hello”和String s = new String(“hello”);区别</h2><ul>
<li><p><code>String s = &quot;hello&quot;</code>，JVM会直接检查字符串常量池是否已有”hello”字符串对象，如没有，就分配一个内存存放”hello”，如果有，则直接将字符串常量池中的地址返回给栈。(没有new，没有堆的操作)</p>
</li>
<li><p><code>String s = new String(&quot;hello&quot;);</code>可能创建两个对象也可能创建一个对象。如果常量池中有<code>hello</code>字符串常量的话，则仅仅在堆中创建一个对象。如果常量池中没有<code>hello</code>对象，则堆上和常量池都需要创建。</p>
</li>
</ul>
<h2 id="static和final区别"><a href="#static和final区别" class="headerlink" title="static和final区别"></a>static和final区别</h2><table>
<thead>
<tr>
<th align="left">关键词</th>
<th align="left">修饰物</th>
<th align="left">影响</th>
</tr>
</thead>
<tbody><tr>
<td align="left">final</td>
<td align="left">变量</td>
<td align="left">分配到常量池中，程序不可改变其值（引用变量不能变，引用对象可以变）</td>
</tr>
<tr>
<td align="left">final</td>
<td align="left">方法</td>
<td align="left">子类中将不能被重写</td>
</tr>
<tr>
<td align="left">final</td>
<td align="left">类</td>
<td align="left">不能被继承</td>
</tr>
<tr>
<td align="left">static</td>
<td align="left">变量</td>
<td align="left">分配在内存堆上，引用都会指向这一个地址而不会重新分配内存</td>
</tr>
<tr>
<td align="left">static</td>
<td align="left">方法块</td>
<td align="left">虚拟机优先加载</td>
</tr>
<tr>
<td align="left">static</td>
<td align="left">类</td>
<td align="left">可以直接通过类来调用而不需要new</td>
</tr>
</tbody></table>
<h2 id="引用类型是占用几个字节？"><a href="#引用类型是占用几个字节？" class="headerlink" title="引用类型是占用几个字节？"></a>引用类型是占用几个字节？</h2><p>hotspot在64位平台上，占8个字节，在32位平台上占4个字节。</p>
<h3 id="java中的-switch-e-选择结构可以使用数据类型的数据-JDK1-8"><a href="#java中的-switch-e-选择结构可以使用数据类型的数据-JDK1-8" class="headerlink" title="java中的 switch(e) 选择结构可以使用数据类型的数据(JDK1.8)"></a>java中的 switch(e) 选择结构可以使用数据类型的数据(JDK1.8)</h3><ul>
<li><p>在switch（e）中，e只能是一个整数表达式或者枚举常量（更大字体），整数表达式可以是int基本类型或Integer包装类型，由于byte,short,char都可以隐含转换为int，所以，这些类型以及这些类型的包装类型也是可以的。显然，boolean、double和long类型都不符合switch的语法规定，并且不能被隐式转换成int类型，所以，它们不能作用于swtich语句中。</p>
</li>
<li><p>1.7后支持String。</p>
</li>
<li><p>基本类型中，没有<code>boolean</code>和<code>浮点类型</code>+<code>长类型long</code>及其相应的包装类型。外加<code>String</code>和<code>enum</code>。</p>
</li>
</ul>
<h2 id="标识符的构成规则"><a href="#标识符的构成规则" class="headerlink" title="标识符的构成规则"></a>标识符的构成规则</h2><ul>
<li>标识符由数字（0<del>9）和字母（A</del>Z 和 a~z）、美元符号（$）和下划线（_）组合构成。</li>
<li>标识符不能使用数字作为第一个字符。</li>
<li>标识符不能是java的关键字和保留字，但可以包含关键字和保留字，不能包含空格</li>
<li>标识符不允许单独使用下划线作为分隔符。</li>
</ul>
<h2 id="amp-和-amp-amp-的区别"><a href="#amp-和-amp-amp-的区别" class="headerlink" title="&amp;和&amp;&amp;的区别"></a>&amp;和&amp;&amp;的区别</h2><ul>
<li>逻辑与，用&amp;连接的两个条件的最后结果计算第一个表达式为false也会计算第二个表达式</li>
<li>短路与，如果第一个表达式为false整个表达式直接为false跳过第二个判断表达式</li>
</ul>
<h2 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h2><ul>
<li><p>重载 Overload：表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）。</p>
</li>
<li><p>重写 Override：表示子类中的方法覆盖父类中的方法</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018092249.png"></p>
<h2 id="final、finally、finalize的区别"><a href="#final、finally、finalize的区别" class="headerlink" title="final、finally、finalize的区别"></a>final、finally、finalize的区别</h2><ul>
<li>final用于声明属性、方法和类，分别表示属性不可变、方法不可覆盖、类不可被继承（不能再派生出新的子类）</li>
<li>finally作为异常处理的一部分，它只能用在try/catch语句中，并且附带着一个语句块，表示这段语句最终一定被执行，经常被用在需要释放资源的情况下。</li>
<li>finalize是Object类中的一个方法，一旦垃圾回收器准备好释放对象占用的空间，将首先调用其 finalize() 方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。</li>
</ul>
<h2 id="Java修饰符"><a href="#Java修饰符" class="headerlink" title="Java修饰符"></a>Java修饰符</h2><table>
<thead>
<tr>
<th><strong>访问级别</strong></th>
<th><strong>访问控制修饰符</strong></th>
<th><strong>同类</strong></th>
<th><strong>同包</strong></th>
<th><strong>子类(不同包)</strong></th>
<th><strong>不同包(其他类)</strong></th>
</tr>
</thead>
<tbody><tr>
<td>公共</td>
<td>public</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>受保护</td>
<td>protected</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
<td>✖</td>
</tr>
<tr>
<td>默认</td>
<td>default</td>
<td>✔</td>
<td>✔</td>
<td>✖</td>
<td>✖</td>
</tr>
<tr>
<td>私有</td>
<td>private</td>
<td>✔</td>
<td>✖</td>
<td>✖</td>
<td>✖</td>
</tr>
</tbody></table>
<h2 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h2><ul>
<li><p>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</p>
</li>
<li><p>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。</p>
</li>
<li><p>抽象类是可以有静态代码块和静态方法，接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)。</p>
</li>
<li><p>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p>
</li>
</ul>
<h2 id="泛型、反射和注解"><a href="#泛型、反射和注解" class="headerlink" title="泛型、反射和注解"></a>泛型、反射和注解</h2><ul>
<li>泛型类型是通过类型参数化的泛型类或接口。数据类型是数据的参数化，而泛型就是数据类型的参数化，来解决程序的通用性设计和实现的若干问题。</li>
<li>反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</li>
<li>注解的本质就是一个继承了 Annotation 接口的接口，注解是代码里的特殊标记，这些标记可以在编译，类加载，运行时被读取，并执行相应的处理。<ul>
<li>元注解：注解的注解，分别有@Retention、 @Target、 @Document、 @Inherited和@Repeatable（JDK1.8加入）五种。</li>
<li>JDK注解：<ul>
<li>@Override 它是用来描述当前方法是一个重写的方法，在编译阶段对方法进行检查 jdk1.5中它只能描述继承中的重写，jdk1.6中它可以描述接口实现的重写,也能描述类的继承的重写  </li>
<li>@Deprecated 它是用于描述当前方法是一个过时的方法 </li>
<li>@SuppressWarnings 对程序中的警告去除。 </li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018101623.png"></p>
<h3 id="Error和Exception的区别"><a href="#Error和Exception的区别" class="headerlink" title="Error和Exception的区别"></a>Error和Exception的区别</h3><ul>
<li><p>Error，指程序中无法处理的错误，表示运行应用程序中出现了严重的错误。</p>
</li>
<li><p>Exception，程序本身可以捕获并且可以处理的异常。</p>
<ul>
<li><p>运行时异常</p>
<ul>
<li><p><strong>定义</strong>：RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。</p>
</li>
<li><p><strong>特点</strong>：Java 编译器不会检查它。也就是说，当程序中可能出现这类异常时，倘若既”没有通过throws声明抛出它”，也”没有用try-catch语句捕获它”，还是会编译通过。</p>
</li>
</ul>
</li>
<li><p>编译时异常</p>
<ul>
<li><p><strong>定义</strong>: Exception 中除 RuntimeException 及其子类之外的异常。</p>
</li>
<li><p><strong>特点</strong>: Java 编译器会检查它。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="受检异常与非受检异常"><a href="#受检异常与非受检异常" class="headerlink" title="受检异常与非受检异常"></a>受检异常与非受检异常</h3><ul>
<li><p>受检异常</p>
<ul>
<li>编译器要求必须处理的异常。正确的程序在运行过程中，经常容易出现的、符合预期的异常情况。一旦发生此类异常，就必须采用某种方式进行处理。</li>
<li><strong>除 RuntimeException 及其子类外，其他的 Exception 异常都属于受检异常</strong>。</li>
</ul>
</li>
<li><p>非受检异常</p>
<ul>
<li>编译器不会进行检查并且不要求必须处理的异常。</li>
<li><strong>该类异常包括运行时异常（RuntimeException极其子类）和错误（Error）。</strong></li>
</ul>
</li>
</ul>
<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018103150.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018103200.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018103228.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018103300.png"></p>
<h1 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h1><p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/JAVA-283.jpg" alt="img"></p>
<h2 id="ArrayList和Vector的区别"><a href="#ArrayList和Vector的区别" class="headerlink" title="ArrayList和Vector的区别"></a><strong>ArrayList和Vector的区别</strong></h2><p>​    这两个类都实现了List接口，都是有序可重复的。</p>
<ul>
<li>（1）同步性：</li>
</ul>
<p>​    Vector是线程安全的，而ArrayList是线程序不安全的。</p>
<ul>
<li><p>（2）数据增长：</p>
<p> Vector默认扩容为原来两倍，而ArrayList扩容为原来的1.5倍。</p>
</li>
</ul>
<h2 id="ArrayList的扩容机制？"><a href="#ArrayList的扩容机制？" class="headerlink" title="ArrayList的扩容机制？"></a>ArrayList的扩容机制？</h2><ul>
<li><p>默认初始大小为10；</p>
</li>
<li><p>底层其实是调用<code>Arrays.copyOf</code>方法来进行扩充数组容量。</p>
</li>
<li><p>默认情况下，新的容量会是原容量的1.5倍，这里用了位运算提高效率。一般情况下，如果扩容1.5倍后就大于期望容量，那就返回这个1.5倍旧容量的值。而如果小于期望容量，那就返回期望容量。</p>
</li>
<li><p>使用1.5倍这个数值而不是直接使用期望容量，是为了防止频繁扩容影响性能。试想如果每次add操作都要扩容一次，那性能将会非常低下。</p>
</li>
<li><p>可以手动扩容，没有缩容。</p>
</li>
</ul>
<h2 id="HashMap和HashTable的区别"><a href="#HashMap和HashTable的区别" class="headerlink" title="HashMap和HashTable的区别"></a>HashMap和HashTable的区别</h2><ul>
<li><strong>线程是否安全：</strong>HashMap是非线程安全的，HashTable使用synchronized修饰，是线程安全的；</li>
<li><strong>效率：</strong>HashTable的效率低，已被淘汰；</li>
<li><strong>Null值：</strong>HashMap的Key和Value可以为null，HashTab的Key如果为null，则会跑出NullPointerException。</li>
<li><strong>初始容量和扩容：</strong>HashMap的初始大小为16，扩容因子为0.75，每次扩容变为2倍，HashTable的初始大小为11，每次扩容变为原来的2n+1;</li>
<li><strong>底层实现不同</strong>，HashSet以HashMap的key作为value，并将HashMap的value默认为present。</li>
</ul>
<h2 id="HashMap的底层实现"><a href="#HashMap的底层实现" class="headerlink" title="HashMap的底层实现"></a>HashMap的底层实现</h2><ul>
<li>JDK1.8以前，HashMap的底层是数组和链表组合在一起。HashMap计算key的hashCode经过扰动函数处理后得到hash值，然后通过 (n-1) &amp; hash判断当前元素存放的位置，如果当前位置存在元素，则判断该元素与要存入的元素的hash值和key是否相等，如果相等则覆盖，否则通过<strong>拉链法</strong>解决冲突。</li>
</ul>
<blockquote>
<p>扰动函数：即hash方法</p>
</blockquote>
<ul>
<li>JDK1.7的hash方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span></span>&#123;</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt;<span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>JDK1.8以后，当数组长度大于64，链表长度大于8时，将链表转化为红黑树；链表长度小于7时，红黑树转化为链表。</p>
</li>
<li><p>JDK1.8的hash方法：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HashMap的长度为什么是2的幂次方？"><a href="#HashMap的长度为什么是2的幂次方？" class="headerlink" title="HashMap的长度为什么是2的幂次方？"></a>HashMap的长度为什么是2的幂次方？</h2><p>hash % length == hash &amp; (length - 1)的前提是length == 2 的幂次方。</p>
<h2 id="ConcurrentHashMap和HashTable的区别？"><a href="#ConcurrentHashMap和HashTable的区别？" class="headerlink" title="ConcurrentHashMap和HashTable的区别？"></a>ConcurrentHashMap和HashTable的区别？</h2><p>1）实现线程安全的方式不同：</p>
<ul>
<li>JDK1.7的ConcurrentHashMap使用分段锁对整个数组进行分段加锁（Segment，16个，0–15），多线程访问不同数据段的数据就不会发生锁竞争，提高并发效率；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018131121.webp"></p>
<ul>
<li><p>JDK1.8的ConcurrentHashMap使用node、synchronized和CAS进行并发控制；</p>
<p>  <img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018131216.png" alt="img"></p>
</li>
<li><p>HashTable使用synchronized保证线程安全，效率低下。</p>
</li>
</ul>
<p>2）底层数据结构不同。</p>
<blockquote>
<p>Segment：实现了ReentrantLock，是可重入锁。</p>
</blockquote>
<h2 id="Comparable和Comparator接口"><a href="#Comparable和Comparator接口" class="headerlink" title="Comparable和Comparator接口"></a><code>Comparable</code>和<code>Comparator</code>接口</h2><p>在 Java 中。 所有具有自动排序功能的集合都使用比较方法来确保元素的正确排序。 例如，使用排序的类为<code>TreeSet</code>，<code>TreeMap</code>等。</p>
<p><strong>为了对一个类的数据元素进行排序，需要实现<code>Comparator</code>或<code>Comparable</code>接口</strong>。 这就是所有包装器类（例如<code>Integer</code>，<code>Double</code>和<code>String</code>类）都实现<code>Comparable</code>接口的原因。</p>
<p><strong><code>Comparable</code>帮助保留默认的自然排序，而<code>Comparator</code>帮助以某些特殊的必需排序模式对元素进行排序。</strong> 比较器的实例，通常在支持集合时作为集合的构造器参数传递。</p>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><ul>
<li>类装载器子系统</li>
<li>运行时数据区域</li>
<li>执行引擎</li>
</ul>
<h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018210001.jpeg" alt="运行时数据区域"></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><ul>
<li>程序计数器是一块较小的内存空间,它的作用可以看作是当前线程所执行的字节码行号指示器。</li>
</ul>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><ul>
<li>虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会创建一个栈帧用于存储局部变量表，操作栈，动态链接，方法出口等信息。</li>
</ul>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><ul>
<li>本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。 </li>
</ul>
<h3 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h3><ul>
<li><code>Java</code> 堆是整个虚拟机所管理的最大内存区域，所有的对象创建都是在这个区域进行内存分配。</li>
<li>这块区域也是垃圾回收器重点管理的区域，由于大多数垃圾回收器都采用<code>分代回收算法</code>，所有堆内存也分为 <code>新生代</code>、<code>老年代</code>，可以方便垃圾的准确回收。</li>
</ul>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><ul>
<li>方法区主要用于存放已经被虚拟机加载的类信息，如<code>常量，静态变量</code>，即时编译器编译后的代码等。和Java堆一样不需要连续的内存，并且可以动态扩展。</li>
<li>对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。</li>
</ul>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><ul>
<li>运行时常量池是方法区的一部分。class文件除了有类的版本，字段，方法，接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，会在类加载后放入这个区域。</li>
</ul>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><ul>
<li>直接内存并不是虚拟机运行时数据区域的一部分。</li>
<li>在 JDK 1.4 中新加入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。</li>
</ul>
<h2 id="Minor-GC和Full-GC"><a href="#Minor-GC和Full-GC" class="headerlink" title="Minor GC和Full GC"></a>Minor GC和Full GC</h2><ul>
<li>Minor GC：指发生在新生代的垃圾收集动作。<code> Minor GC</code> 非常频繁，一般回收速度也比较快。</li>
<li>Major GC或Full GC：指发生在老年代的 GC，出现了 Major GC，经常会伴随至少一次的 Minor GC（但非绝对的，在 ParallelScavenge 收集器的收集策略里就有直接进行 <code>Major GC</code> 的策略选择过程） 。<code>MajorGC</code> 的速度一般会比 Minor GC 慢 10倍以上。</li>
</ul>
<h3 id="Minor-GC触发机制"><a href="#Minor-GC触发机制" class="headerlink" title="Minor GC触发机制"></a>Minor GC触发机制</h3><p>当年轻代满时就会触发Minor GC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC</p>
<h3 id="Full-GC触发机制"><a href="#Full-GC触发机制" class="headerlink" title="Full GC触发机制"></a>Full GC触发机制</h3><ul>
<li>当年老代满时会引发Full GC，Full GC将会同时回收年轻代、年老代，</li>
<li>当永久代满时也会引发Full GC，会导致Class、Method元信息的卸载</li>
</ul>
<h2 id="Java中的四种引用"><a href="#Java中的四种引用" class="headerlink" title="Java中的四种引用"></a>Java中的四种引用</h2><p>强引用,软引用,弱引用,虚引用</p>
<h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>就是指在程序代码中普遍存在的，类似Object obj=new Object()这类的引用，只要强引用还存在，垃圾回收期永远不会回收掉被引用的对象</p>
<h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>用来描述一些还有用，但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出前，将会把这些对象列进回收范围之内并进行第二次回收，如果这此次回收还是没有足够的内存，才会抛出内存溢出。</p>
<h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>用来描述非必须的对象，但是它的强度比软引用更弱一下，被弱引用关联的对象，只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收被弱引用关联的对象</p>
<h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>被称为幽灵引用或幻引用，是最弱的一种引用关系，为一个对象设置虚引用的目的就是在对象被回收时收到一个系统通知。</p>
<h2 id="怎样判断对象是否存活"><a href="#怎样判断对象是否存活" class="headerlink" title="怎样判断对象是否存活"></a>怎样判断对象是否存活</h2><ul>
<li><p>引用计数法：</p>
<ul>
<li>给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1，当引用失效时，计数器减1；</li>
<li>任何时刻计数器都为0的对象就是不可能再被使用的。客观的来说，引用计数法的实现简单，判定效率也很高，很难解决对象之间的互循环引用问题。</li>
</ul>
</li>
<li><p>可达性分析：</p>
<ul>
<li>这个算法的思路就是通过一系列的名为“GC roots”的对象作为起点，从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象的GC roots没有任何引用链相连时，则证明此对象是不可用的。</li>
</ul>
</li>
</ul>
<h2 id="作为GC-roots的几种对象"><a href="#作为GC-roots的几种对象" class="headerlink" title="作为GC roots的几种对象"></a>作为GC roots的几种对象</h2><ul>
<li>虚拟机栈(栈中的本地变量表)中的引用对象。</li>
<li>方法区中的类静态属性引用对象。</li>
<li>方法区中的常量引用的对象。</li>
<li>本地方法栈中 native 方法的引用对象。</li>
</ul>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><ul>
<li><p>算法分为标记和清除两个阶段。首先先标记所有要被回收的对象，标记完成后再统一清除被标记的对象。</p>
<p><strong>主要缺点有两个，</strong> </p>
</li>
<li><p>一是效率问题，标记和清除的过程效率都不高。二是空间问题，标记清除后会产生大量不连续的内存碎片，空间碎片太多,可能会导致当程序在以后的运行过程中需要分配较大的对象时无法找到足够的连续内存，而不得不提前出发另一次垃圾收集动作</p>
</li>
</ul>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><ul>
<li>为了解决效率问题，一种复制收集的算法出现了。它将可用内存按容量划分为大小相等的两块，每次只用其中的一块。当这一块内存用完，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对其中一块进行内存回收，内存分配时也就不用内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半未免太高了一点。</li>
</ul>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><ul>
<li>复制手机算法在对象存活率较高的时要执行多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要额外的空间进行分配担保，以应对被使用的内存中对象都100%存货的极端情况，所以在老年代一般不能直接选用这种算法。根据老年代的特点，有人提出了另一种 标记-整理的算法，标记过程仍然与 标记-清楚算法一样。但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存</li>
</ul>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><ul>
<li>把Java堆分为新生代和老年代，根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法。而老年代中因为对象存活率高，没有额外空间对它进行分配担保，就必须使用标记-清理或标记-整理算法来进行回收。</li>
</ul>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><ul>
<li>一个单线程的收集器，只会使用一个CPU或一条收集线程去完成垃圾收集工作。在进行垃圾收集时必须暂停其它所有的工作线程，直接到结束。(Stop The Word)这项工作是虚拟机在后台自动发起和完成的。</li>
<li>JDK1.3之前是新生代收集的唯一选择。</li>
<li>它依然是虚拟机运行在Client模式下的默认新手代收集器，简单而高效。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018132608.jpeg" alt="img"></p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>Serial收集器的多线程版本，使用多条线程收集。其余的和Serial一样，是许多运行在Server模式下的虚拟机首选新生代收集器。且目前除了Serial收集器，只有它可以与CMS收集器配合工作</p>
<p><img src="http://blogimg.chenhaoxiang.cn/18-11-7/69174322.jpg" alt="img"></p>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><ul>
<li>它是一款新生代收集器。使用复制算法收集，又是并行的多线程收集器</li>
<li>特点是达到一个可控制的吞吐量，也被称为“吞吐量优先”收集器。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018132752.jpeg" alt="img"></p>
<h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><ul>
<li>它是Serial收集器的老年代版本，是一个单线程收集器，使用标记-整理算法收集。</li>
<li>主要意义是给Client模式下虚拟机使用。如果是Server模式，则有两种用途，一是在JDK1.5之前与Parallel Scavenge收集器搭配使用。二是作为CMS收集器的后背预案</li>
</ul>
<h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>它是Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法。JDK1.6才开始提供。</p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><ul>
<li>是一种以获取最短回收停顿时间的为目标的收集器。</li>
<li>基于标记-清除算法实现。</li>
<li>运作过程分为四个阶段：初始标记,并发标记,重新标记,并发清除。</li>
<li>初始标记和重新标记仍然需要”Stop The Word”.初始标记只是记录下GC Roots能直接关联到对象，速度快。并发标记就是进行GC Roots Tracing过程。重新标记修正并发标记期间因程序继续运作导致标记产生变动的一部分对象的标记记录。整个过程耗时最长是并发标记和并发清除过程。</li>
<li>优点是并发收集，低停顿。缺点是：对CPU资源非常敏感，无法处理浮动垃圾。收集结束时会产生大量空间碎片</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018132849.jpeg" alt="img"></p>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><ul>
<li><p>将整个Java堆分为多个大小相等的独立区域。</p>
</li>
<li><p>虽然保留新生代和老年代，但它们不再是物理隔离，都是一部分不需要连续的集合。</p>
</li>
<li><p>G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。</p>
</li>
<li><p>特点是并行与并发充分利用CPU缩短停顿时间。分代收集，空间整合不会产生内存空间碎片，可预测的停顿。有计划的避免回收整个Java堆。</p>
</li>
<li><p>运行大致分为:初始标记,并发标记,最终标记,筛选回收。</p>
</li>
<li><p>筛选回收（Live Data Counting and Evacuation）</p>
<ul>
<li><p>首先排序各个Region的回收价值和成本；</p>
</li>
<li><p>然后根据用户期望的GC停顿时间来制定回收计划；</p>
</li>
<li><p>最后按计划回收一些价值高的Region中垃圾对象；</p>
</li>
<li><p>回收时采用”复制”算法，从一个或多个Region复制存活对象到堆上的另一个空的Region，并且在此过程中压缩和释放内存；</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018133022.jpeg" alt="img"></p>
<h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><h3 id="对象优先在Eden区分配"><a href="#对象优先在Eden区分配" class="headerlink" title="对象优先在Eden区分配"></a>对象优先在Eden区分配</h3><p>对象通常在新生代的Eden区进行分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC，与Minor GC对应的是Major GC、Full GC。</p>
<ul>
<li>Minor GC:指发生在新生代的垃圾收集动作，非常频繁，速度较快。</li>
<li>Major GC:指发生在老年代的GC，出现Major GC，经常会伴随一次Minor GC，同时Minor GC也会引起Major GC，一般在GC日志中统称为GC，不频繁。</li>
<li>Full GC:指发生在老年代和新生代的GC，速度很慢，需要Stop The World。</li>
</ul>
<h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><ul>
<li>需要大量连续内存空间的Java对象称为大对象，大对象的出现会导致提前触发垃圾收集以获取更大的连续的空间来进行大对象的分配。虚拟机提供了-XX:PretenureSizeThreadshold参数来设置大对象的阈值，超过阈值的对象直接分配到老年代。</li>
</ul>
<h3 id="长期存活的对象进入老年代"><a href="#长期存活的对象进入老年代" class="headerlink" title="长期存活的对象进入老年代"></a>长期存活的对象进入老年代</h3><ul>
<li>每个对象有一个对象年龄计数器，与前面的对象的存储布局中的GC分代年龄对应。对象出生在Eden区、经过一次Minor GC后仍然存活，并能够被Survivor容纳，设置年龄为1，对象在Survivor区每次经过一次Minor GC，年龄就加1，当年龄达到一定程度（默认15），就晋升到老年代，虚拟机提供了-XX:MaxTenuringThreshold来进行设置。</li>
</ul>
<h3 id="动态对象年龄判断"><a href="#动态对象年龄判断" class="headerlink" title="动态对象年龄判断"></a>动态对象年龄判断</h3><ul>
<li>如果在survivor区中相同年龄的所有对象大小的总和大于survivor区的一半，年龄大于等于该年龄的对象就可以直接进入老年代。</li>
</ul>
<h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><ul>
<li>发生Minor GC时，只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC。</li>
<li>冒险是指经过一次Minor GC后有大量对象存活，而新生代的survivor区很小，放不下这些大量存活的对象，所以需要老年代进行分配担保，把survivor区无法容纳的对象直接进入老年代。</li>
</ul>
<h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><ul>
<li>很多人认为方法区是没有垃圾回收的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而在方法区进行垃圾收集的性价比一般比较低，在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%~96%的空间，而永久代的垃圾收集效率远低于此。</li>
<li>永久代的垃圾主要回收两部分内容：废弃常量和无用的类。</li>
</ul>
<h2 id="Java中对象访问是如何进行的"><a href="#Java中对象访问是如何进行的" class="headerlink" title="Java中对象访问是如何进行的"></a>Java中对象访问是如何进行的</h2><ul>
<li>对象访问在Java中无处不在，即时是最简单的访问也会涉及到Java栈，Java堆，方法区这三个最重要的内存区域之间的关系。</li>
</ul>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span> obj=<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>假设这段代码出现在方法体中， 那吗“<code>Object obj</code>”这部分的语义将会反应到<code>Java栈</code>的本地变量中，作为一个<code>reference</code>类型数据出现。而“<code>new Object()</code>”这部分的语义将会反应到<code>Java堆</code>中,形成一块存储了Object类型所有实例数据值的结构化内存，根据具体类型以及虚拟机实现的对象内存布局的不同，这块内存的长度是不固定的。</li>
<li>另外，在Java堆中还必须包含能查找到此对象类型数据（如对象类型，父亲，实现的接口，方法等）的地址消息，这些类型数据则存储在方法区中。</li>
</ul>
<h2 id="JVM参数设置"><a href="#JVM参数设置" class="headerlink" title="JVM参数设置"></a>JVM参数设置</h2><p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018135117.jpeg" alt="JVM参数设置.png"></p>
<ul>
<li><code>-Xms</code>:Java堆内存大小</li>
<li><code>-Xmx</code>:Java堆内存最大大小</li>
<li><code>-Xmn</code>:Java堆内存中的新生代大小，扣除新生代剩下的就是老年代的内存大小了</li>
<li><code>-XX:PermSize</code>:永久代大小</li>
<li><code>-XX:MaxPermSize</code>:永久代最大大小</li>
<li><code>-Xss</code>：每个线程的栈内存大小</li>
<li>`java -Xms512M -Xmx512M -Xmn256M -Xss1M -XX:PermSize=128M -XX:MaxPermSize=128M -jar App.jar</li>
</ul>
<h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)7个阶段。其中准备、验证、解析3个部分统称为连接（Linking）。<br><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018133815.jpeg"></p>
<h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><h4 id="1-加载"><a href="#1-加载" class="headerlink" title="1.加载"></a>1.加载</h4><ul>
<li>通过一个类的全限定名来获取定义此类的二进制字节流；</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口；</li>
</ul>
<h4 id="2-验证"><a href="#2-验证" class="headerlink" title="2.验证"></a>2.验证</h4><ul>
<li><p>确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 </p>
<ul>
<li><p>文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以魔术0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</p>
</li>
<li><p>元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。</p>
</li>
<li><p>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的 </p>
</li>
<li><p>符号引用验证：确保解析动作能正确执行。</p>
</li>
</ul>
</li>
</ul>
<h4 id="3-准备"><a href="#3-准备" class="headerlink" title="3.准备"></a>3.准备</h4><ul>
<li>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在堆中。</li>
</ul>
<h4 id="4-解析"><a href="#4-解析" class="headerlink" title="4.解析"></a>4.解析</h4><ul>
<li>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</li>
</ul>
<h4 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5.初始化"></a>5.初始化</h4><ul>
<li>如果一个类被主动引用，就会触发类的初始化。</li>
<li>在java中，直接引用的情况有，通过new关键字实例化对象、读取或设置类的静态变量、调用类的静态方法。通过反射方式执行以上三种行为。初始化子类的时候，会触发父类的初始化。</li>
</ul>
<h4 id="6-使用"><a href="#6-使用" class="headerlink" title="6.使用"></a>6.使用</h4><ul>
<li>类的使用包括主动引用和被动引用</li>
<li>被动引用：引用父类的静态字段，只会引起父类的初始化，而不会引起子类的初始化。定义类数组，不会引起类的初始化。引用类的常量，不会引起类的初始化。</li>
</ul>
<h4 id="7-卸载"><a href="#7-卸载" class="headerlink" title="7.卸载"></a>7.卸载</h4><ul>
<li>满足下面的情况，类就会被卸载：该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。加载该类的ClassLoader已经被回收。该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
<li>如果以上三个条件全部满足，jvm就会在方法区垃圾回收的时候对类进行卸载，类的卸载过程其实就是在方法区中清空类信息，java类的整个生命周期就结束了。</li>
</ul>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ul>
<li>通过一个类的全限定名来获取描述此类的二进制字节流,这个动作放到java虚拟机外部去实现。以便让应用程序自己决定如何去获取所需要的类。实现各动作的代码模块称为“类加载器”。</li>
<li>比较两个类是否相等，只有这两个类是由同一个类加载器加载的前提下才有意义，否则即使这两个；即使来源同一个class文件，但类加载器不同，他们也不相等。</li>
</ul>
<h4 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h4><p>这个类加载器负责放在<JAVA_HOME>\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库。用户无法直接使用。</p>
<h4 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h4><p>这个类加载器由sun.misc.Launcher$AppClassLoader实现。它负责<JAVA_HOME>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库。用户可以直接使用。</p>
<h4 id="应用程序类加载器"><a href="#应用程序类加载器" class="headerlink" title="应用程序类加载器"></a>应用程序类加载器</h4><p>这个类由sun.misc.Launcher$AppClassLoader实现。是ClassLoader中getSystemClassLoader()方法的返回值。它负责用户路径（ClassPath）所指定的类库。用户可以直接使用。如果用户没有自己定义类加载器，默认使用这个</p>
<h4 id="自定义加载器"><a href="#自定义加载器" class="headerlink" title="自定义加载器"></a>自定义加载器</h4><p>用户自己定义的类加载器。</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存在在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的Bootstrap ClassLoader进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。</li>
<li>相反，如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个java.lang.Object的同名类并放在ClassPath中，那系统中将会出现多个不同的Object类，程序将混乱。因此，如果开发者尝试编写一个与rt.jar类库中重名的Java类，可以正常编译，但是永远无法被加载运行。</li>
</ul>
<h2 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens-before原则"></a>happens-before原则</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>我们无法就所有场景来规定某个线程修改的变量何时对其他线程可见，但是我们可以指定某些规则，这规则就是happens-before，从JDK 5 开始，JMM就使用happens-before的概念来阐述多线程之间的内存可见性。</li>
<li>在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。<br>  happens-before原则非常重要，它是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们解决在并发环境下两操作之间是否可能存在冲突的所有问题。下面我们就一个简单的例子稍微了解下happens-before ；</li>
</ul>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">i</span> = <span class="number">1</span><span class="comment">;       //线程A执行</span></span><br><span class="line"><span class="attr">j</span> = i <span class="comment">;      //线程B执行</span></span><br></pre></td></tr></table></figure>

<p>j 是否等于1呢？假定线程A的操作（i = 1）happens-before线程B的操作（j = i）,那么可以确定线程B执行后j = 1 一定成立，如果他们不存在happens-before原则，那么j = 1 不一定成立。这就是happens-before原则的威力。</p>
<h3 id="原则定义"><a href="#原则定义" class="headerlink" title="原则定义"></a>原则定义</h3><ul>
<li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。 </li>
<li>两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。</li>
</ul>
<h3 id="规则如下"><a href="#规则如下" class="headerlink" title="规则如下"></a>规则如下</h3><h4 id="程序次序规则"><a href="#程序次序规则" class="headerlink" title="程序次序规则"></a>程序次序规则</h4><p>一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；</p>
<h4 id="锁定规则"><a href="#锁定规则" class="headerlink" title="锁定规则"></a>锁定规则</h4><p>一个unLock操作先行发生于后面对同一个锁额lock操作；</p>
<h4 id="volatile变量规则"><a href="#volatile变量规则" class="headerlink" title="volatile变量规则"></a>volatile变量规则</h4><p>对一个变量的写操作先行发生于后面对这个变量的读操作；</p>
<h4 id="传递规则"><a href="#传递规则" class="headerlink" title="传递规则"></a>传递规则</h4><p>如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；</p>
<h4 id="线程启动规则"><a href="#线程启动规则" class="headerlink" title="线程启动规则"></a>线程启动规则</h4><p>Thread对象的start()方法先行发生于此线程的每个一个动作；</p>
<h4 id="程中断规则"><a href="#程中断规则" class="headerlink" title="程中断规则"></a>程中断规则</h4><p>对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</p>
<h4 id="线程终结规则"><a href="#线程终结规则" class="headerlink" title="线程终结规则"></a>线程终结规则</h4><p>线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；</p>
<h4 id="对象终结规则"><a href="#对象终结规则" class="headerlink" title="对象终结规则"></a>对象终结规则</h4><p>一个对象的初始化完成先行发生于他的finalize()方法的开始；</p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018152146.png" alt="img"></p>
<h2 id="什么是线程死锁-如何避免死锁"><a href="#什么是线程死锁-如何避免死锁" class="headerlink" title="什么是线程死锁?如何避免死锁?"></a>什么是线程死锁?如何避免死锁?</h2><p>多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p>
<p><strong>避免死锁的几个常见方法：</strong></p>
<ul>
<li><strong>避免一个线程同时获取多个锁</strong></li>
<li><strong>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。</strong></li>
<li><strong>尝试使用定时锁，使用 lock.tryLock(timeout) 来代替使用内部锁机制。</strong></li>
<li><strong>对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。</strong></li>
</ul>
<h2 id="线程的生命周期和状态-（重要！）"><a href="#线程的生命周期和状态-（重要！）" class="headerlink" title="线程的生命周期和状态?（重要！）"></a>线程的生命周期和状态?（重要！）</h2><p>　　<strong>初始状态、运行状态、阻塞状态、等待状态、超时等待状态、终止状态</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018152505.png" alt="img"></p>
<h2 id="多线程的特性"><a href="#多线程的特性" class="headerlink" title="多线程的特性"></a>多线程的特性</h2><ul>
<li><p>原子性：是指一个操作是不可中断的。即使是多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。</p>
</li>
<li><p>可见性：是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道这个修改。显然，对于串行来说，可见性问题是不存在的。</p>
</li>
<li><p>有序性：在并发时，允许编译器和处理器对指令重排序的，但是不管怎么重排序，程序的执行结果不能改变。。</p>
</li>
</ul>
<h2 id="sleep-方法和-wait-方法区别和共同点-（重要！）"><a href="#sleep-方法和-wait-方法区别和共同点-（重要！）" class="headerlink" title="sleep() 方法和 wait() 方法区别和共同点?（重要！）"></a>sleep() 方法和 wait() 方法区别和共同点?（重要！）</h2><p> <strong>相同点：</strong></p>
<p>　　两者都可以暂停线程的执行，都会让线程进入等待状态。</p>
<p><strong>不同点：</strong></p>
<ul>
<li><strong>sleep()方法没有释放锁，而 wait()方法释放了锁。</strong></li>
<li><strong>sleep()方法属于Thread类的静态方法，作用于当前线程；而wait()方法是Object类的实例方法，作用于对象本身。</strong></li>
<li><strong>执行sleep()方法后，可以通过超时或者调用interrupt()方法唤醒休眠中的线程；执行wait()方法后，通过调用notify()或notifyAll()方法唤醒等待线程。</strong></li>
</ul>
<h2 id="notify-和-notifyAll有什么区别？"><a href="#notify-和-notifyAll有什么区别？" class="headerlink" title="notify 和 notifyAll有什么区别？"></a>notify 和 notifyAll有什么区别？</h2><ul>
<li>notify()方法不能唤醒某个具体的线程，所以只有一个线程在等待的时候它才有用武之地。</li>
<li>notifyAll()唤醒所有线程并允许他们争夺锁确保了至少有一个线程能继续运行。</li>
</ul>
<h2 id="yield-方法有什么用？"><a href="#yield-方法有什么用？" class="headerlink" title="yield()方法有什么用？"></a>yield()方法有什么用？</h2><ul>
<li>yield() 方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。</li>
<li>只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行</li>
</ul>
<h2 id="join-方法有什么用？"><a href="#join-方法有什么用？" class="headerlink" title="join()方法有什么用？"></a>join()方法有什么用？</h2><ul>
<li><strong>join方法的主要作用就是同步，它可以使得线程之间的并行执行变为串行执行。</strong> </li>
</ul>
<h2 id="使用线程池的好处？"><a href="#使用线程池的好处？" class="headerlink" title="使用线程池的好处？"></a>使用线程池的好处？</h2><ol>
<li><strong>降低资源消耗</strong>。通过<strong>重复利用已创建的线程，降低线程创建和销毁造成的消耗</strong>。</li>
<li><strong>提高响应速度</strong>。<strong>当任务到达时，任务可以不需要等到线程创建就能立即执行</strong>。</li>
<li><strong>提高线程的可管理性</strong>。<strong>线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控</strong>。</li>
</ol>
<h2 id="创建线程的几种方式？（重要）"><a href="#创建线程的几种方式？（重要）" class="headerlink" title="创建线程的几种方式？（重要）"></a>创建线程的几种方式？（重要）</h2><ul>
<li><strong>继承Thread类</strong></li>
<li><strong>实现Runnable接口</strong></li>
<li><strong>实现Callable接口</strong></li>
<li><strong>使用线程池创建线程</strong></li>
</ul>
<h2 id="常见的线程池及适用场景？（重要）"><a href="#常见的线程池及适用场景？（重要）" class="headerlink" title="常见的线程池及适用场景？（重要）"></a>常见的线程池及适用场景？（重要）</h2><ul>
<li><p>FixedThreadPool：可重用固定线程数的线程池。（适用于负载比较重的服务器）</p>
<ul>
<li><strong>FixedThreadPool使用无界队列LinkedBlockingQueue作为线程池的工作队列</strong></li>
<li>该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li>
</ul>
</li>
<li><p>SingleThreadExecutor：只会创建一个线程执行任务。（适用于需要保证顺序执行各个任务；并且在任意时间点，没有多线程活动的场景。）</p>
<ul>
<li><strong>SingleThreadExecutorl也使用无界队列LinkedBlockingQueue作为工作队列</strong></li>
<li>若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li>
</ul>
</li>
<li><p>CachedThreadPool：是一个会根据需要调整线程数量的线程池。</p>
<p>  （大小无界，适用于执行很多的短期异步任务的小程序，或负载较轻的服务器）</p>
<ul>
<li><strong>CachedThreadPool使用没有容量的SynchronousQueue作为线程池的工作队列，但CachedThreadPool的maximumPool是无界的。</strong></li>
<li>线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li>
</ul>
</li>
<li><p><strong>ScheduledThreadPool</strong>：继承自ThreadPoolExecutor。它主要用来<strong>在给定的延迟之后运行任务，或者定期执行任务</strong>。使用DelayQueue作为任务队列。</p>
</li>
</ul>
<h2 id="说一下-runnable-和-callable-有什么区别？"><a href="#说一下-runnable-和-callable-有什么区别？" class="headerlink" title="说一下 runnable 和 callable 有什么区别？"></a>说一下 runnable 和 callable 有什么区别？</h2><ul>
<li>相同点：两者都是接口。都可以用来创建多线程。都需要调用Thread.start()启动线程</li>
<li>不同点：实现Callable接口的任务线程能返回执行结果；而实现Runnable接口的任务线程不能返回结果。</li>
<li>Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛；</li>
<li>Callable接口支持返回执行结果，此时需要调用FutureTask.get()方法实现，此方法会阻塞主线程直到获取‘将来’结果；当不调用此方法时，主线程不会阻塞</li>
</ul>
<h2 id="start-方法和run-方法简介和区别？"><a href="#start-方法和run-方法简介和区别？" class="headerlink" title="start() 方法和run() 方法简介和区别？"></a><strong>start() 方法和run() 方法简介和区别？</strong></h2><p>start() 方法：</p>
<p>1）用start方法来启动线程，真正实现了多线程运行，这时无需等待run方法体代码执行完毕而直接继续执行下面的代码。</p>
<p>2）通过调用Thread类的start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到CPU时间片，就开始执行run()方法。</p>
<p>run() 方法：</p>
<p>1）run()方法只是类的一个普通方法而已，如果直接调用Run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条。</p>
<h2 id="线程池都有哪几种工作队列？（重要）"><a href="#线程池都有哪几种工作队列？（重要）" class="headerlink" title="线程池都有哪几种工作队列？（重要）"></a>线程池都有哪几种工作队列？（重要）</h2><ul>
<li><strong>ArrayBlockingQueue</strong>：是一个<strong>基于数组结构的有界阻塞队列</strong>，此队列按FIFO（先进先出）原则对元素进行排序。</li>
<li><strong>LinkedBlockingQueue</strong>：是一个<strong>基于链表结构的阻塞队列</strong>，此队列按FIFO排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。</li>
<li><strong>SynchronousQueue</strong>：是一个<strong>不存储元素的阻塞队列</strong>。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于Linked-BlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。</li>
<li><strong>PriorityBlockingQueue</strong>：一个<strong>具有优先级的无限阻塞队列</strong>。</li>
</ul>
<h2 id="线程池参数？"><a href="#线程池参数？" class="headerlink" title="线程池参数？"></a><strong>线程池参数？</strong></h2><p>①<strong>corePoolSize：线程池的基本大小</strong>，当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。说白了就是，即便是线程池里没有任何任务，也会有corePoolSize个线程在候着等任务。</p>
<p>②<strong>maximumPoolSize:最大线程数</strong>，不管你提交多少任务，线程池里最多工作线程数就是maximumPoolSize。</p>
<p>③<strong>keepAliveTime:线程的存活时间</strong>。当线程池里的线程数大于corePoolSize时，如果等了keepAliveTime时长还没有任务可执行，则线程退出。</p>
<p>⑤<strong>unit</strong>：这个用来指定keepAliveTime的单位，比如秒:TimeUnit.SECONDS。</p>
<p>⑥<strong>workQueu</strong>e：用于保存等待执行任务的<strong>阻塞队列</strong>，提交的任务将会被放到这个队列里。</p>
<p>⑦<strong>threadFactory：线程工厂，用来创建线程</strong>。主要是为了给线程起名字，默认工厂的线程名字：pool-1-thread-3。</p>
<p>⑧<strong>handler：拒绝策略</strong>，即当线程和队列都已经满了的时候，应该采取什么样的策略来处理新提交的任务。</p>
<ul>
<li>默认策略是AbortPolicy（抛出异常）</li>
<li>CallerRunsPolicy(只用调用者所在线程来运行任务)</li>
<li>DiscardOldestPolicy(丢弃队列里最老的一个任务，并执行当前任务)</li>
<li>DiscardPolicy(不处理，丢弃掉)</li>
</ul>
<h2 id="线程池ThreadPoolExecutor的工作流程？"><a href="#线程池ThreadPoolExecutor的工作流程？" class="headerlink" title="线程池ThreadPoolExecutor的工作流程？"></a>线程池ThreadPoolExecutor的工作流程？</h2><ul>
<li>当提交一个新任务到线程池后，线程池首先会判断核心线程池(corePoolSize）里的线程是否都在执行任务。</li>
<li>如果核心线程池corePoolSize的线程都被占用在执行任务，线程池判断工作队列是否已满，如果工作队列没有满：则将新提交的任务存储到工作队列中，</li>
<li>如果工作队列已满：判断线程池（maximumPoolSize）的线程是否处于工作状态，如果没有，则创建一个新的工作线程来执行任务。</li>
<li>如果线程池已满，则交给饱和策略处理这个任务</li>
</ul>
<h2 id="线程池中-execute-和-submit-方法有什么区别？"><a href="#线程池中-execute-和-submit-方法有什么区别？" class="headerlink" title="线程池中 execute() 和 submit() 方法有什么区别？"></a>线程池中 execute() 和 submit() 方法有什么区别？</h2><ul>
<li>两个方法都可以向线程池提交任务</li>
<li>execute()方法的返回类型是void，它定义在Executor接口中</li>
<li>submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中</li>
</ul>
<h2 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a>synchronized 关键字</h2><p>synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p>
<p>synchronized关键字最主要的三种使用方式：</p>
<ul>
<li><strong>对于普通同步方法，锁是当前实例对象。</strong></li>
<li><strong>对于静态同步方法，锁是当前类的Class对象。</strong></li>
<li><strong>对于同步代码块，锁是synchronized括号里配置的对象。</strong></li>
</ul>
<p><strong>synchronized在JVM里是怎么实现的？</strong></p>
<p>　　<strong>synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置</strong>。 当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor的持有权。当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p>
<p><strong>synchronized用的锁是存在哪里的？</strong></p>
<p>　　synchronized用到的锁是存在<strong>Java对象头</strong>里的。</p>
<h4 id="synchronized的锁升级流程之偏向锁"><a href="#synchronized的锁升级流程之偏向锁" class="headerlink" title="synchronized的锁升级流程之偏向锁"></a>synchronized的锁升级流程之偏向锁</h4><ul>
<li>当一个线程访问同步代码块时，会在对象头和栈帧中的锁记录里存储偏向的线程ID，以后该线程进入和退出同步块时，不需要执行CAS操作来加锁和解锁，只需要简单的测试下对象头的Mark-Word是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已获取到锁</li>
<li>如果测试失败，则需要在测试下Mark-Word中偏向锁的表示是否设置为1（表示当前是偏向锁）；如果没有设置，则使用CAS竞争；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</li>
<li>偏向锁使用了一种等到竞争出现才释放锁的机制，当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁</li>
<li>偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）：它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否存活，如果线程处于不活动状态，则会将对象头设置成无锁状态</li>
<li>如果线程仍然活着，拥有偏向锁的线程会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程</li>
</ul>
<h4 id="synchronized的锁升级流程之轻量级锁"><a href="#synchronized的锁升级流程之轻量级锁" class="headerlink" title="synchronized的锁升级流程之轻量级锁"></a>synchronized的锁升级流程之轻量级锁</h4><ul>
<li>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间,并将对象头中的Mark Word复制到锁记录中</li>
<li>然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针</li>
<li>如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁</li>
<li>轻量级解锁时，会使用原子的CAS操作将Displaced-Mark-Word替换回到对象头。如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁</li>
<li>轻量级锁的加锁和释放锁都是使用CAS操作来执行的</li>
</ul>
<h4 id="synchronized的锁升级流程之重量级锁"><a href="#synchronized的锁升级流程之重量级锁" class="headerlink" title="synchronized的锁升级流程之重量级锁"></a>synchronized的锁升级流程之重量级锁</h4><ul>
<li>重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。</li>
</ul>
<h4 id="偏向锁-轻量锁，重量级锁的优缺点对比"><a href="#偏向锁-轻量锁，重量级锁的优缺点对比" class="headerlink" title="偏向锁,轻量锁，重量级锁的优缺点对比"></a>偏向锁,轻量锁，重量级锁的优缺点对比</h4><ul>
<li>偏向锁： 加锁和解锁不需要额外的消耗，和执行非同步方法只存在纳秒级的差距。缺点是如果线程间存在锁竞争，会带来额外的锁撤销的消耗。适用于只有一个线程访问同步块</li>
<li>轻量级锁：竞争的线程不会阻塞，提高了线程的响应速度。缺点是如果始终得不到锁竞争的线程，使用自旋会消耗CPU。适用于追求响应时间，同步块执行速度非常快</li>
<li>重量级锁：线程竞争不使用自旋，不会消耗CPU。缺点是线程阻塞，响应时间慢。适用追求吞吐量，同步块执行时间过长。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/094206_5f316f33_1478371.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<h4 id="彻底搞懂synchronized-从偏向锁到重量级锁"><a href="#彻底搞懂synchronized-从偏向锁到重量级锁" class="headerlink" title="彻底搞懂synchronized(从偏向锁到重量级锁)"></a>彻底搞懂synchronized(从偏向锁到重量级锁)</h4><ul>
<li>java对象在内存中的存储结构主要有一下三个部分：对象头,实例数据,填充数据.对象头中存储的是hashCode,GC分代年龄，锁信息。</li>
<li>对象被创建出来的那一刻，就有了偏向锁的标志位，偏向锁的标志位是“01”，状态是“0”。偏向锁默认是开启的，但是创建对象时初始化状态是没生效的。</li>
<li>线程执行到临界区时，此时会利用CAS操作，将线程ID插入到Markword中，同时修改偏向锁的标志位为1。所谓临界区，就是只允许一个线程进去执行操作的区域，即同步代码块</li>
<li>这个锁会偏向于第一个获得它的线程，在接下来的执行过程中，假如该锁没有被其他线程所获取，没有其他线程来竞争该锁，那么持有偏向锁的线程将永远不需要进行同步操作。而是简单判断一下当前线程id是否与Markword当中的线程id是否一致.一致则继续执行下面代码</li>
<li>不一致，则要检查一下对象是否还是可偏向。如果还未偏向，则利用CAS操作来竞争锁，也即是第一次获取锁时的操作。</li>
<li>如果此对象已经偏向了，并且不是偏向自己，则说明存在了竞争。此时可能就要根据另外线程的情况，可能是重新偏向，也有可能是做偏向撤销，但大部分情况下就是升级成轻量级锁了。</li>
<li>由于偏向锁失效了，那么接下来就得把该锁撤销，在一个安全点停止拥有锁的线程，遍历线程栈，如果存在锁记录的话，需要修复锁记录和Markword，使其变成无锁状态。唤醒当前线程，将当前锁升级成轻量级锁。</li>
<li>锁撤销升级为轻量级锁之后，那么对象的Markword也会进行相应的的变化。线程在自己的栈桢中创建锁记录LockRecord。将锁对象的对象头中的MarkWord复制到线程的刚刚创建的锁记录中。将锁记录中的Owner指针指向锁对象。将锁对象的对象头的MarkWord替换为指向锁记录的指针。</li>
<li>轻量级锁主要有两种：自旋锁，自适应自旋锁。所谓自旋，就是指当有另外一个线程来竞争锁时，这个线程会在原地循环等待，而不是把该线程给阻塞，直到那个获得锁的线程释放锁之后，这个线程就可以马上获得锁的。</li>
<li>默认情况下，自旋的次数为10次。当线程超过了这个次数，我们就认为，继续使用自旋锁就不适合了，此时锁会再次膨胀，升级为重量级锁。</li>
<li>重量级锁是依赖对象内部的monitor锁来实现的，而monitor又依赖操作系统的MutexLock(互斥锁)来实现的，所以重量级锁也被成为互斥锁。</li>
</ul>
<h2 id="什么是乐观锁和悲观锁？"><a href="#什么是乐观锁和悲观锁？" class="headerlink" title="什么是乐观锁和悲观锁？"></a>什么是乐观锁和悲观锁？</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>Java在JDK1.5之前都是靠synchronized关键字保证同步的，这种通过使用一致的锁定协议来协调对共享状态的访问，可以确保无论哪个线程持有共享变量的锁，都采用独占的方式来访问这些变量。独占锁其实就是一种悲观锁，所以可以说synchronized是悲观锁。</p>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁（ Optimistic Locking）其实是一种思想。相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。</p>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><ul>
<li>所谓自旋锁，就是让该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。怎么等待呢？执行一段无意义的循环即可（自旋）。</li>
</ul>
<h2 id="适应性自旋（CAS）"><a href="#适应性自旋（CAS）" class="headerlink" title="适应性自旋（CAS）"></a>适应性自旋（CAS）</h2><ul>
<li>在使用 <code>CAS</code> 时，如果操作失败，<code>CAS</code> 会自旋再次尝试。由于自旋是需要消耗 <code>CPU</code> 资源的，所以如果长期自旋就白白浪费了 <code>CPU</code>。<code>JDK1.6</code>加入了适应性自旋:如果某个锁自旋很少成功获得，那么下一次就会减少自旋。</li>
<li>所谓自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定</li>
<li>线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。</li>
</ul>
<h2 id="synchronized和-Lock-的区别？（重要）"><a href="#synchronized和-Lock-的区别？（重要）" class="headerlink" title="synchronized和 Lock 的区别？（重要）"></a>synchronized和 Lock 的区别？（重要）</h2><p>1）<strong>Lock是一个接口，而synchronized是Java中的关键字</strong>；</p>
<p>2）<strong>synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生</strong>；而<strong>Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁</strong>；</p>
<p>3）<strong>Lock可以让等待锁的线程响应中断</strong>，而<strong>synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断</strong>；</p>
<p>4）<strong>通过Lock可以知道有没有成功获取锁（tryLock()方法：如果获取锁成功，则返回true）</strong>，而<strong>synchronized却无法办到</strong>。</p>
<p>5）<strong>Lock可以提高多个线程进行读操作的效率</strong>。</p>
<h2 id="synchronized和ReentrantLock（重入锁）-的区别？"><a href="#synchronized和ReentrantLock（重入锁）-的区别？" class="headerlink" title="synchronized和ReentrantLock（重入锁） 的区别？"></a>synchronized和ReentrantLock（重入锁） 的区别？</h2><ul>
<li>两者都是可重进入锁，就是能够支持一个线程对资源的重复加锁。<ul>
<li>sychnronized关键字隐式的支持重进入，比如一个sychnronized修饰的递归方法，在方法执行时，执行线程在获取了锁之后仍能连续多次地获取该锁。</li>
<li>ReentrantLock虽然没能像sychnronized关键字一样隐式的重进入，但是在调用lock()方法时，已经获取到锁的线程，能够再次调用lock()方法获取锁而不被阻塞。</li>
</ul>
</li>
<li><strong>synchronized 依赖于 JVM，而 ReentrantLock 是 JDK 层面实现的</strong></li>
<li>ReentrantLock 比 synchronized 增加了一些高级功能，主要有3点：①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）<ul>
<li><strong>ReentrantLock提供了一种能够中断等待锁的线程的机制</strong>，也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。通过lock.lockInterruptibly()来实现这个机制。</li>
<li><strong>ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。</strong>（公平锁就是先等待的线程先获得锁）</li>
<li>synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制。ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。用ReentrantLock类结合Condition实例可以实现“选择性通知” 。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程</li>
</ul>
</li>
</ul>
<h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><ul>
<li><p><strong>保证共享变量的“可见性”</strong>。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。</p>
</li>
<li><p>禁止指令重排序</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018214521.jpeg"></p>
<p>编译器不会对 volatile 读与 volatile 读后面的任意内存操作重排序；编译器不会对 volatile 写与 volatile 写前面的任意内存操作重排序。</p>
<h2 id="synchronized-关键字和-volatile-关键字的区别"><a href="#synchronized-关键字和-volatile-关键字的区别" class="headerlink" title="synchronized 关键字和 volatile 关键字的区别"></a>synchronized 关键字和 volatile 关键字的区别</h2><ul>
<li><strong>volatile关键字只能用于变量而synchronized关键字还可以修饰方法以及代码块</strong>。</li>
<li><strong>多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞</strong>。</li>
<li><strong>volatile</strong>关键字主要用于<strong>解决变量在多个线程之间的可见性</strong>，而 <strong>synchronized</strong>关键字解决的是<strong>多个线程之间访问资源的同步性</strong>。</li>
<li>volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。</li>
</ul>
<h2 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h2><p>CAS（Compare and Swap），即比较并替换，CAS的思想很简单：三个参数，一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。</p>
<h3 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h3><ul>
<li>ABA问题。 CAS操作更新的基础是如果值没有变化则更新，若有变化则不更新。但如若有一值刚开始是A，然后变为B，最后又变为A。那么CAS检查时发现它没有变化就更新了，但实际上却是已经发生了变化。</li>
<li>CAS自旋。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。 </li>
<li>只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性。</li>
</ul>
<h2 id="什么是ThreadLocal变量？"><a href="#什么是ThreadLocal变量？" class="headerlink" title="什么是ThreadLocal变量？"></a>什么是ThreadLocal变量？</h2><p>ThreadLocal是Java里一种特殊的变量。每个线程都有一个ThreadLocal就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。它是为创建代价高昂的对象获取线程安全的好方法，因为那个类创建代价高昂且每次调用都需要创建不同的实例所以不值得在局部范围使用它，如果为每个线程提供一个自己独有的变量拷贝，将大大提高效率。首先，通过复用减少了代价高昂的对象的创建个数。其次，你在没有使用高代价的同步或者不变性的情况下获得了线程安全。</p>
<h2 id="Semaphore有什么作用？"><a href="#Semaphore有什么作用？" class="headerlink" title="Semaphore有什么作用？"></a>Semaphore有什么作用？</h2><ol>
<li>Semaphore就是一个信号量，<strong>它的作用是限制某段代码块的并发数</strong>。</li>
<li><strong>如果超出了n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入</strong>。</li>
<li>由此可以看出如果Semaphore构造函数中传入的int型整数n=1，相当于变成了一个synchronized了。</li>
</ol>
<h2 id="说一下-atomic-的原理？"><a href="#说一下-atomic-的原理？" class="headerlink" title="说一下 atomic 的原理？"></a>说一下 atomic 的原理？</h2><ul>
<li>在Atomic包里一共有12个类，四种原子更新方式，分别是原子更新基本类型，原子更新数组，原子更新引用和原子更新字段。</li>
<li>Atomic包里的类基本都是使用Unsafe实现的包装类。</li>
<li>Atomic包下的类是通过CAS操作来实现原子性的。jdk8直接使用了Unsafe的getAndAddInt方法</li>
</ul>
<h2 id="CyclicBarrier和CountDownLatch的区别？"><a href="#CyclicBarrier和CountDownLatch的区别？" class="headerlink" title="CyclicBarrier和CountDownLatch的区别？"></a>CyclicBarrier和CountDownLatch的区别？</h2><ul>
<li>CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；是通过调用await()方法计数加1，若加1后的值不等于构造方法的值，则线程阻塞。通俗的将；让一组线程到达一个屏障时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活</li>
<li>CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行，调用countDown()方法计数减一，调用await()方法只进行阻塞，对计数没任何影响</li>
<li>CountDownLatch内部通过共享锁实现。在创建CountDownLatch实例时，需要传递一个int型的参数：count，该参数为计数器的初始值，也可以理解为该共享锁可以获取的总次数。当某个线程调用await()方法，程序首先判断count的值是否为0，如果不会0的话则会一直等待直到为0为止。当其他线程调用countDown()方法时，则执行释放共享锁状态，使count值 – 1。当在创建CountDownLatch时初始化的count参数，必须要有count线程调用countDown方法才会使计数器count等于0，锁才会释放，前面等待的线程才会继续运行。注意CountDownLatch不能回滚重置。</li>
<li>CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务</li>
<li>CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了</li>
</ul>
<h2 id="说一说对ReentrantReadWriteLock的理解？"><a href="#说一说对ReentrantReadWriteLock的理解？" class="headerlink" title="说一说对ReentrantReadWriteLock的理解？"></a>说一说对ReentrantReadWriteLock的理解？</h2><ul>
<li>ReentrantReadWriteLock内部维护了一对锁，读锁和写锁。支持重入和公平以及平非公平模式。读锁是共享式的，它能够被多个线程同时获取，在没有其他写线程访问（或者写状态为0）时，读锁总会被成功地获取，而所做的也只是（线程安全的）增加读状态。如果当前线程已经获取了读锁，则增加读状态。如果当前线程在获取读锁时，写锁已被其他线程获取，则进入等待状态。</li>
<li>写锁是一个支持重进入的排它锁。如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取写锁时(还未获到)，读锁已经被获取或者该线程不是已经获取写锁的线程，则当前线程进入等待状态。</li>
<li>写锁要确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。</li>
<li>锁降级：遵循获取写锁，获取读锁在释放写锁的次序，写锁可以降级为读锁</li>
<li>锁降级中读锁的获取是否必要呢？答案是必要的。主要是为了保证数据的可见性，如果当前线程不获取读锁而是直接释放写锁，获取了写锁并修改了数据，那么当前线程无法感知线程T的数据更新</li>
</ul>
<h2 id="说一说Condition的理解？"><a href="#说一说Condition的理解？" class="headerlink" title="说一说Condition的理解？"></a>说一说Condition的理解？</h2><ul>
<li><code>Condition</code>是一个接口，与<code>Lock</code>配合可以实现的等待通知模式，类似<code>Object</code>的<code>wait</code>和<code>notify</code>。获取一个<code>Condition</code>对象需要调用Lock的<code>newCondition</code>方法或得<code>ConditionObject</code>,是AQS的一个内部类。Condition操作需要获取想关联的锁</li>
<li>一个线程获取锁后，通过调用Condition的<code>await()</code>方法，会释放锁，然后构造成节点并将节点从尾部加入等待队列,并进入等待状态。</li>
<li>当线程调用<code>signal()</code>方法后，程序首先检查当前线程是否获取了锁，然后通过<code>doSignal(Node first)</code>方法唤醒同步队列的等待时间最长的节点（首节点)。在唤醒节点之前，会将节点移动到同步队列中，被唤醒的线程，将从await()方法中的while循环中退出来，然后调用acquireQueued()方法竞争同步状态。</li>
</ul>
<h2 id="说一说你对exchanger的理解？"><a href="#说一说你对exchanger的理解？" class="headerlink" title="说一说你对exchanger的理解？"></a>说一说你对exchanger的理解？</h2><ul>
<li>Exchanger类允许在两个线程之间定义同步点。当两个线程都到达同步点时，他们交换数据结构，因此第一个线程的数据结构进入到第二个线程中，第二个线程的数据结构进入到第一个线程中</li>
<li>Exchanger算法的核心是通过一个可交换数据的slot，以及一个可以带有数据item的参与者。</li>
<li>在Exchanger中，如果一个线程已经到达了exchanger节点时，如果它的伙伴节点在该线程到达之前已经调用了exchanger方法，则它会唤醒它的伙伴然后进行数据交换，得到各自数据返回。如果它的伙伴节点还没有到达交换点，则该线程将会被挂起，等待它的伙伴节点到达被唤醒，完成数据交换。如果当前线程被中断了则抛出异常，或者等待超时了，则抛出超时异常。</li>
</ul>
<h2 id="生产者和消费者模型的作用是什么？"><a href="#生产者和消费者模型的作用是什么？" class="headerlink" title="生产者和消费者模型的作用是什么？"></a><strong>生产者和消费者模型的作用是什么？</strong></h2><p>1）通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用</p>
<p>2）解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约</p>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/1590590509208-c55e311d-4d15-4bd8-8b43-5bec5a1c2193.png" alt="image"></p>
<h2 id="一、MySQL架构"><a href="#一、MySQL架构" class="headerlink" title="一、MySQL架构"></a>一、MySQL架构</h2><p>和其它数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎的架构上，<strong>插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离</strong>。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/1590590539775-66b802ba-2c1c-4c50-9cd0-a41eb54578e5.png" alt="image"></p>
<ul>
<li><strong>连接层</strong>：最上层是一些客户端和连接服务。<strong>主要完成一些类似于连接处理、授权认证、及相关的安全方案</strong>。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</li>
<li><strong>服务层</strong>：第二层服务层，主要完成大部分的核心服务功能， 包括<strong>查询解析、分析、优化、缓存**</strong>、以及所有的内置函数<strong>，所有跨存储引擎的功能也都在这一层实现，包括</strong>触发器、存储过程、视图**等</li>
<li><strong>引擎层</strong>：第三层存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取</li>
<li><strong>存储层</strong>：第四层为数据存储层，主要是将数据存储在运行于该设备的文件系统之上，并完成与存储引擎的交互</li>
</ul>
<p><strong>MySQL 的查询流程</strong></p>
<p>（所有SQL语句都可以称为查询，包括INSERT,DELETE,UPDATE）</p>
<p>—&gt; 客户端请求</p>
<p>—&gt; 连接器（验证用户身份，给予权限）  </p>
<p>—&gt; 查询缓存（存在缓存则直接返回，不存在则执行后续操作）</p>
<p>—&gt; 分析器（对SQL进行词法分析和语法分析操作）  </p>
<p>—&gt; 优化器（主要对执行的sql优化选择最优的执行方案方法）  </p>
<p>—&gt; 执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口）</p>
<p>—&gt; 去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）</p>
<h2 id="二、MySQL-事务"><a href="#二、MySQL-事务" class="headerlink" title="二、MySQL 事务"></a>二、MySQL 事务</h2><h3 id="ACID-—-事务基本要素"><a href="#ACID-—-事务基本要素" class="headerlink" title="ACID — 事务基本要素"></a>ACID — 事务基本要素</h3><ul>
<li><strong>A (Atomicity) 原子性</strong>：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样</li>
<li><strong>C (Consistency) 一致性</strong>：在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。AID是手段，C是目的，即通过种种手段保证数据库在事务执行前后都处于正确的状态（即数据库列上没有限制数据的范围，但是转账业务中不可能出现账户余额为负的情况，所以要保证事务前后要保证数据库在业务上处于正确的状态）</li>
<li><strong>I (Isolation)隔离性</strong>：一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰</li>
<li><strong>D (Durability) 持久性</strong>：在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚</li>
</ul>
<h3 id="并发事务处理带来的问题"><a href="#并发事务处理带来的问题" class="headerlink" title="并发事务处理带来的问题"></a><strong>并发事务处理带来的问题</strong></h3><ul>
<li>**更新丢失（Lost Update)**：事务A和事务B选择同一行，并基于最初选定的值更新该行时，由于两个事务都不知道彼此的存在，就会发生丢失更新问题</li>
<li>**脏读(Dirty Reads)**：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</li>
<li>**不可重复读（Non-Repeatable Reads)**：事务 A 多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。</li>
<li>**幻读（Phantom Reads)**：幻读与不可重复读类似。它发生在一个事务A读取了几行数据，接着另一个并发事务B插入了一些数据时。在随后的查询中，事务A就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>
</ul>
<h4 id="幻读和不可重复读的区别："><a href="#幻读和不可重复读的区别：" class="headerlink" title="幻读和不可重复读的区别："></a><strong>幻读和不可重复读的区别：</strong></h4><ul>
<li><strong>不可重复读的重点是修改</strong>：在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样。（因为中间有其他事务提交了修改）</li>
<li><strong>幻读的重点在于新增或者删除</strong>：在同一事务中，同样的条件,第一次和第二次读出来的记录数不一样。（因为中间有其他事务提交了插入/删除）</li>
</ul>
<h4 id="并发事务处理带来的问题的解决办法："><a href="#并发事务处理带来的问题的解决办法：" class="headerlink" title="并发事务处理带来的问题的解决办法："></a><strong>并发事务处理带来的问题的解决办法：</strong></h4><ul>
<li><p>“更新丢失”通常是应该完全避免的。但防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决，因此，防止更新丢失应该是应用的责任。</p>
</li>
<li><p><strong>“脏读” 、 “不可重复读”和“幻读” ，其实都是数据库读一致性问题</strong>，必须由数据库提供一定的事务隔离机制来解决：</p>
</li>
<li><ul>
<li>一种是加锁：在读取数据前，对其加锁，阻止其他事务对数据进行修改。<ul>
<li>另一种是数据多版本并发控制（MultiVersion Concurrency Control，<strong>MVCC</strong> ）：可以认为是行级锁的变种， 通过一定机制生成一个数据请求时间点的一致性数据快照 （Snapshot)， 并用这个快照来提供一定级别 （语句级或事务级） 的一致性读取。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><ul>
<li><strong>READ-UNCOMMITTED(读未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li>
<li><strong>READ-COMMITTED(读已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li>
<li><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li>
<li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li>
</ul>
<h3 id="隔离级别比较"><a href="#隔离级别比较" class="headerlink" title="隔离级别比较"></a>隔离级别比较</h3><table>
<thead>
<tr>
<th>事务隔离级别</th>
<th>读数据一致性</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交（read-uncommitted）</td>
<td>最低级被，只能保证不读取物理上损坏的数据</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>读已提交（read-committed）</td>
<td>语句级</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>可重复读（repeatable-read）</td>
<td>事务级</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>串行化（serializable）</td>
<td>最高级别，事务级</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
<p><strong>这里需要注意的是：</strong>与 SQL 标准不同的地方在于InnoDB 存储引擎在 <strong>REPEATABLE-READ</strong>（可重读）事务隔离级别下使用的是<strong>Next-Key Lock</strong> 算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 <strong>SERIALIZABLE</strong>(可串行化)隔离级别，而且保留了比较好的并发性能。</p>
<p>大部分数据库系统的隔离级别都是<strong>READ-COMMITTED</strong>(读已提交):，但是你要知道的是<strong>InnoDB 存储引擎默认使用 REPEATABLE-READ（可重读）并不会有任何性能损失</strong>。</p>
<h2 id="三、MySQL锁机制"><a href="#三、MySQL锁机制" class="headerlink" title="三、MySQL锁机制"></a>三、MySQL锁机制</h2><blockquote>
<p>❝</p>
<p>数据库的乐观锁和悲观锁？</p>
<p>MySQL 中有哪几种锁，列举一下？</p>
<p>MySQL中InnoDB引擎的行锁是怎么实现的？</p>
<p>MySQL 间隙锁有没有了解，死锁有没有了解，写一段会造成死锁的 sql 语句，死锁发生了如何解决，MySQL 有没有提供什么机制去解决死锁</p>
</blockquote>
<h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><p><strong>从对数据操作的类型分类</strong>：</p>
<ul>
<li><strong>读锁</strong>（共享锁）：针对同一份数据，多个读操作可以同时进行，不会互相影响</li>
<li><strong>写锁</strong>（排他锁）：当前写操作没有完成前，它会阻断其他写锁和读锁</li>
</ul>
<p><strong>从对数据操作的粒度分类</strong>：</p>
<ul>
<li><strong>表级锁</strong>：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低（MyISAM 和 MEMORY 存储引擎采用的是表级锁）；</li>
<li><strong>行级锁</strong>：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高（InnoDB 存储引擎既支持行级锁也支持表级锁，但默认情况下是采用行级锁）；</li>
<li><strong>页面锁</strong>：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>行锁</th>
<th>表锁</th>
<th>页锁</th>
</tr>
</thead>
<tbody><tr>
<td>MyISAM</td>
<td></td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>BDB</td>
<td></td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>InnoDB</td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>Memory</td>
<td></td>
<td>√</td>
<td></td>
</tr>
</tbody></table>
<h3 id="MyISAM-表锁"><a href="#MyISAM-表锁" class="headerlink" title="MyISAM 表锁"></a>MyISAM 表锁</h3><p>MyISAM 的表锁有两种模式：</p>
<ul>
<li>表共享读锁 （Table Read Lock）：不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；</li>
<li>表独占写锁 （Table Write Lock）：会阻塞其他用户对同一表的读和写操作；</li>
</ul>
<p>MyISAM 表的读操作与写操作之间，以及写操作之间是串行的。当一个线程获得对一个表的写锁后， 只有持有锁的线程可以对表进行更新操作。其他线程的读、 写操作都会等待，直到锁被释放为止。</p>
<p>默认情况下，写锁比读锁具有更高的优先级：当一个锁释放时，这个锁会优先给写锁队列中等候的获取锁请求，然后再给读锁队列中等候的获取锁请求。</p>
<h3 id="InnoDB-行锁"><a href="#InnoDB-行锁" class="headerlink" title="InnoDB 行锁"></a>InnoDB 行锁</h3><ul>
<li>InnoDB 实现了以下两种类型的<strong>行锁</strong>：<ul>
<li>共享锁（shared lock S锁，又称读锁）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</li>
<li>排他锁（exclusive lock X锁，又称写锁）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。insert ，delete ， <strong>update在事务中都会自动默认加上排它锁</strong>。</li>
</ul>
</li>
<li>同时InnoDB还实现了<strong>多粒度锁</strong>：</li>
</ul>
<p><strong>为了允许行锁和表锁共存，实现多粒度锁机制——意向锁</strong>（Intention Locks）：未来的某个时刻，事务可能要加共享/排它锁了，先提前声明一个意向</p>
<ul>
<li><p>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。</p>
</li>
<li><p>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。</p>
</li>
<li><p>“冲突—兼容”规则：</p>
<ul>
<li><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/1590745463390-4377c2d2-8ea7-4d04-8a13-a78ec84125eb.png" alt="image"></li>
<li><strong>意向锁是怎么提高检测效率的？</strong><ul>
<li><strong>在加表锁的时可立即检测到是否存在意向锁，若存在，则说明有行锁，因此无须遍历整个表即可知道发生冲突</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="加锁机制"><a href="#加锁机制" class="headerlink" title="加锁机制"></a>加锁机制</h4><ul>
<li><strong>乐观锁与悲观锁是两种并发控制的思想，可用于解决丢失更新问题</strong><ul>
<li>乐观锁会“乐观地”假定大概率不会发生并发更新冲突，访问、<strong>处理数据过程中不加锁**</strong>，只在更新数据时再根据版本号或时间戳判断是否有冲突**，有则处理，无则提交事务。用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式</li>
<li>悲观锁会“悲观地”假定大概率会发生并发更新冲突，访问、<strong>处理数据前就加排他锁</strong>，<strong>在整个数据处理过程中锁定数据，事务提交或回滚后才释放锁</strong>。另外与乐观锁相对应的，<strong>悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。</strong></li>
</ul>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li><strong>InnoDB</strong> 中的<code>行锁</code>的实现依赖于<code>索引</code>，一旦某个加锁操作没有使用到索引，那么该锁就会退化为<code>表锁</code>。</li>
<li><strong>记录锁</strong>存在于包括<code>主键索引</code>在内的<code>唯一索引</code>中，锁定单条索引记录。</li>
<li><strong>间隙锁</strong>存在于<code>非唯一索引</code>中，锁定<code>开区间</code>范围内的一段间隔，它是基于<strong>临键锁</strong>实现的。</li>
<li><strong>临键锁</strong>存在于<code>非唯一索引</code>中，该类型的每条记录的索引上都存在这种锁，它是一种特殊的<strong>间隙锁</strong>，锁定一段<code>左开右闭</code>的索引区间。</li>
</ol>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><strong>死锁产生</strong>：</p>
<ul>
<li>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环</li>
<li>当事务试图以不同的顺序锁定资源时，就可能产生死锁。多个事务同时锁定同一个资源时也可能会产生死锁</li>
<li>锁的行为和顺序和存储引擎相关。以同样的顺序执行语句，有些存储引擎会产生死锁有些不会——死锁有双重原因：真正的数据冲突；存储引擎的实现方式。</li>
</ul>
<p><strong>检测死锁</strong>：数据库系统实现了各种死锁检测和死锁超时的机制。InnoDB存储引擎能检测到死锁的循环依赖并立即返回一个错误。</p>
<p><strong>死锁恢复</strong>：死锁发生以后，只有部分或完全回滚其中一个事务，才能打破死锁，InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。</p>
<p><strong>外部锁的死锁检测</strong>：发生死锁后，InnoDB 一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及表锁的情况下，InnoDB 并不能完全自动检测到死锁， 这需要通过设置锁等待超时参数 innodb_lock_wait_timeout 来解决</p>
<p><strong>死锁影响性能</strong>：死锁会影响性能而不是会产生严重错误，因为InnoDB会自动检测死锁状况并回滚其中一个受影响的事务。在高并发系统上，当许多线程等待同一个锁时，死锁检测可能导致速度变慢。</p>
<p><strong>MyISAM避免死锁</strong>：</p>
<ul>
<li><strong>在自动加锁的情况下，MyISAM 总是一次获得 SQL 语句所需要的全部锁，所以 MyISAM 表不会出现死锁。</strong></li>
</ul>
<h2 id="四、存储引擎"><a href="#四、存储引擎" class="headerlink" title="四、存储引擎"></a>四、存储引擎</h2><h3 id="存储引擎对比"><a href="#存储引擎对比" class="headerlink" title="存储引擎对比"></a>存储引擎对比</h3><p>常见的存储引擎就 InnoDB、MyISAM、Memory、NDB。</p>
<p>InnoDB 现在是 MySQL 默认的存储引擎，支持<strong>事务、行级锁定和外键</strong></p>
<h4 id="文件存储结构对比"><a href="#文件存储结构对比" class="headerlink" title="文件存储结构对比"></a>文件存储结构对比</h4><p>在 MySQL中建立任何一张数据表，在其数据目录对应的数据库目录下都有对应表的 <code>.frm</code> 文件，<code>.frm</code> 文件是用来保存每个数据表的元数据(meta)信息，包括表结构的定义等，与数据库存储引擎无关，也就是任何存储引擎的数据表都必须有<code>.frm</code>文件，命名方式为 数据表名.frm，如user.frm。</p>
<p>查看MySQL 数据保存在哪里：<code>show variables like &#39;data%&#39;</code></p>
<p><strong>MyISAM 物理文件结构为：</strong></p>
<ul>
<li><code>.frm</code>文件：与表相关的元数据信息都存放在frm文件，包括<strong>表结构的定义信息</strong>等</li>
<li><code>.MYD</code> (<code>MYData</code>) 文件：MyISAM 存储引擎专用，用于存储MyISAM <strong>表的数据</strong></li>
<li><code>.MYI</code> (<code>MYIndex</code>)文件：MyISAM 存储引擎专用，用于存储MyISAM <strong>表的索引相关信息</strong></li>
</ul>
<p><strong>InnoDB 物理文件结构为：</strong></p>
<ul>
<li><code>.frm</code> 文件：与表相关的元数据信息都存放在frm文件，包括<strong>表结构的定义信息</strong>等</li>
<li><code>.ibd</code> 文件或 <code>.ibdata</code> 文件：这两种文件都是存放 InnoDB 数据的文件，之所以有两种文件形式存放 InnoDB 的数据，是因为 InnoDB 的数据存储方式能够通过配置来决定是使用<strong>共享表空间</strong>存放存储数据，还是用<strong>独享表空间</strong>存放存储数据。<br>  独享表空间存储方式使用<code>.ibd</code>文件，并且每个表一个<code>.ibd</code>文件 共享表空间存储方式使用<code>.ibdata</code>文件，所有表共同使用一个<code>.ibdata</code>文件（或多个，可自己配置）</li>
</ul>
<h4 id="MyISAM和InnoDB区别"><a href="#MyISAM和InnoDB区别" class="headerlink" title="MyISAM和InnoDB区别"></a>MyISAM和InnoDB区别</h4><ol>
<li>InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</li>
<li>InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；</li>
<li>InnoDB 是聚簇索引，MyISAM 是非聚簇索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是二级索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和二级索引是独立的。</li>
<li>InnoDB 不保存表的具体行数，执行<code>select count(*) from table</code> 时需要全表扫描。而 MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</li>
<li>InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。MyISAM一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</li>
</ol>
<table>
<thead>
<tr>
<th>对比项</th>
<th>MyISAM</th>
<th>InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td>主外键</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>事务</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>行表锁</td>
<td>表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</td>
<td>行锁,操作时只锁某一行，不对其它行有影响，适合高并发的操作</td>
</tr>
<tr>
<td>缓存</td>
<td>只缓存索引，不缓存真实数据</td>
<td>不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响</td>
</tr>
<tr>
<td>表空间</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>关注点</td>
<td>性能</td>
<td>事务</td>
</tr>
<tr>
<td>默认安装</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<blockquote>
<p>❝一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15 ？</p>
</blockquote>
<p>如果表的类型是MyISAM，那么是18。因为MyISAM表会把自增主键的最大ID 记录到数据文件中，重启MySQL自增主键的最大ID也不会丢失；</p>
<p>如果表的类型是InnoDB，那么是15。因为InnoDB 表只是把自增主键的最大ID记录到内存中，所以重启数据库或对表进行OPTION操作，都会导致最大ID丢失。</p>
<blockquote>
<p>❝哪个存储引擎执行 select count(*) 更快，为什么?</p>
</blockquote>
<p>MyISAM更快，因为MyISAM内部维护了一个计数器，可以直接调取。</p>
<ul>
<li>在 MyISAM 存储引擎中，把表的总行数存储在磁盘上，当执行 select count(*) from t 时，直接返回总数据。</li>
<li>在 InnoDB 存储引擎中，跟 MyISAM 不一样，没有将总行数存储在磁盘上，当执行 select count(*) from t 时，会先把数据读出来，一行一行的累加，最后返回总数量。</li>
</ul>
<p>InnoDB 中 count(*) 语句是在执行的时候，全表扫描统计总数量，所以当数据越来越大时，语句就越来越耗时了，为什么 InnoDB 引擎不像 MyISAM 引擎一样，将总行数存储到磁盘上？这跟 InnoDB 的事务特性有关，<strong>由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的</strong>。</p>
<p>❝为什么MyISAM读取速度更快？</p>
<ul>
<li>InnoDB 在做 SELECT 的时候，要维护的东西比 MYISAM 引擎多很多，比如检查和维护MVCC</li>
<li>innodb寻址要映射到块，再到行，MYISAM记录的直接是文件的OFFSET，定位比INNODB要快</li>
</ul>
<h2 id="五、数据类型"><a href="#五、数据类型" class="headerlink" title="五、数据类型"></a>五、数据类型</h2><h3 id="MySQL的数据类型"><a href="#MySQL的数据类型" class="headerlink" title="MySQL的数据类型"></a>MySQL的数据类型</h3><ul>
<li>整数类型：BIT、BOOL、TINY INT、SMALL INT、MEDIUM INT、 INT、 BIG INT</li>
<li>浮点数类型：FLOAT、DOUBLE、DECIMAL</li>
<li>字符串类型：CHAR、VARCHAR、TINY TEXT、TEXT、MEDIUM TEXT、LONG TEXT、TINY BLOB、BLOB、MEDIUM BLOB、LONG BLOB</li>
<li>日期类型：Date、DateTime、TimeStamp、Time、Year</li>
<li>其他数据类型：BINARY、VARBINARY、ENUM、SET、Geometry、Point、MultiPoint、LineString、MultiLineString、Polygon、GeometryCollection等</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/1590590539852-f07a129b-1bfb-4487-af9a-df13273354c2.webp" alt="image"><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018141809.webp" alt="image"><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018141757.webp" alt="image"></p>
<blockquote>
<p>❝CHAR 和 VARCHAR 的区别？</p>
</blockquote>
<p>char是固定长度，varchar长度可变：</p>
<p>char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。</p>
<p>存储时，前者不管实际存储数据的长度，直接按 char 规定的长度分配存储空间；而后者会根据实际存储的数据分配最终的存储空间</p>
<p><strong>相同点：</strong></p>
<ol>
<li>char(n)，varchar(n)中的n都代表字符的个数</li>
<li>超过char，varchar最大长度n的限制后，字符串会被截断。</li>
</ol>
<p><strong>不同点：</strong></p>
<ol>
<li>char不论实际存储的字符数都会占用n个字符的空间，而varchar只会占用实际字符应该占用的字节空间加1（实际长度length，0&lt;=length&lt;255）或加2（length&gt;255）。因为varchar保存数据时除了要保存字符串之外还会加一个字节来记录长度（如果列声明长度大于255则使用两个字节来保存长度）。</li>
<li>能存储的最大空间限制不一样：char的存储上限为255字节。</li>
<li>char在存储时会截断尾部的空格，而varchar不会。</li>
</ol>
<p>char是适合存储很短的、一般固定长度的字符串。例如，char非常适合存储密码的MD5值，因为这是一个定长的值。对于非常短的列，char比varchar在存储空间上也更有效率。</p>
<blockquote>
<p>❝列的字符串类型可以是什么？</p>
</blockquote>
<p>字符串类型是：BIT、SET、BLOB、ENUM、CHAR、TEXT、VARCHAR</p>
<p>ENUM：使用枚举代替字符串类型，将不重复的字符串存储到预定义的集合中。列中存储的是整数，这样列表值会非常紧凑，压缩到1-2个字节中。定义好了ENUM的集合后，如果想向其中添加或删除字符串必须使用ALTER TABLE，除非是向集合列表末尾添加元素。</p>
<p>BIT：二进制的多个比特串，MySQL将其作为字符串类型处理</p>
<p>SET：多个BIT合并称的数据类型，有效利用存储空间。</p>
<p>上述三种都可以使用其他数据类型达到同样的功能，而且不容易犯错。</p>
<blockquote>
<p>❝BLOB和TEXT有什么区别？</p>
</blockquote>
<p>BLOB和TEXT都是为存储很大的数据而设计的字符串数据类型，且容纳可变数量的数据。</p>
<p>BLOB存储的是二进制数据，四种类型的BLOB：TINYBLOB、BLOB、MEDIUMBLO和 LONGBLOB</p>
<p>TEXT存储的是字符数据，四种TEXT类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。</p>
<h3 id="范式与反范式"><a href="#范式与反范式" class="headerlink" title="范式与反范式"></a>范式与反范式</h3><ul>
<li><p>范式化的数据库中，每个事实数据只会出现一次，而反范式化的数据库中，信息是冗余的，可能会存储在多个地方。</p>
</li>
<li><p>范式的优点：</p>
</li>
<li><ul>
<li>范式化修改的数据通常更少，更新操作通常比反范式化更快<ul>
<li>范式化的表通常更小，可以更好的放在内存里</li>
<li>范式化很少有多余的数据意味着检索列表数据时可能不需要DISTINCT/GROUP BY语句</li>
</ul>
</li>
</ul>
</li>
<li><p>范式的缺点：</p>
</li>
<li><ul>
<li>通常需要关联，不仅代价高而且可能使得一些索引无效。比如，将列存储在不用的表中，而这些列如果在一个表中则本可以属于同一个索引</li>
</ul>
</li>
<li><p>反范式的优点：</p>
</li>
<li><ul>
<li>避免了很多关联，在没有关联的情况下，反范式执行全表扫描是顺序I/O，可能比关联要快得多</li>
</ul>
</li>
</ul>
<h4 id="混合范式化和反范式化"><a href="#混合范式化和反范式化" class="headerlink" title="混合范式化和反范式化"></a>混合范式化和反范式化</h4><ul>
<li>实际并不会完全的范式化和反范式化，上面完全反范式化的例子user_message的表太大了，而且如果没有消息就会丢失用户信息。可以在user表和message表中都存储account_type字段，可以同时解决前面两个问题。但是新的问题是每次更新都要更新两张表，更新代价提高了。</li>
</ul>
<h4 id="缓存表和汇总表"><a href="#缓存表和汇总表" class="headerlink" title="缓存表和汇总表"></a>缓存表和汇总表</h4><ul>
<li>上面的混合范式化是在同一张表中保存衍生的冗余数据，而有时也需要创建完全独立的缓存表和汇总表</li>
<li>缓存表：保存比较简单的从其他表获取且速度较慢的的数据</li>
<li>汇总表：保存使用GROUP BY语句聚合的数据</li>
</ul>
<h2 id="六、索引"><a href="#六、索引" class="headerlink" title="六、索引"></a>六、索引</h2><blockquote>
<p>❝</p>
<p>说说你对 MySQL 索引的理解？</p>
<p>数据库索引的原理，为什么要用 B+树，为什么不用二叉树？</p>
<p>聚集索引与非聚集索引的区别？</p>
<p>InnoDB引擎中的索引策略，了解过吗？</p>
<p>创建索引的方式有哪些？</p>
<p>聚簇索引/非聚簇索引，mysql索引底层实现，为什么不用B-tree，为什么不用hash，叶子结点存放的是数据还是指向数据的内存地址，使用索引需要注意的几个地方？</p>
</blockquote>
<ul>
<li>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构，所以说<strong>索引的本质是：数据结构</strong></li>
<li>索引的目的在于提高查询效率，可以类比字典、 火车站的车次表、图书的目录等 </li>
<li>可以简单的理解为“排好序的快速查找数据结构”，数据本身之外，<strong>数据库还维护着一个满足特定查找算法的数据结构</strong>，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。下图是一种可能的索引方式示例<img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539862-061bbf2b-9b17-4cb6-9ec2-3c2139bbfbc1.webp?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></li>
<li>左边的数据表，一共有两列七条记录，最左边的是数据记录的物理地址。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值，和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在一定的复杂度内获取到对应的数据，从而快速检索出符合条件的记录。</li>
<li>索引本身也很大，不可能全部存储在内存中，<strong>一般以索引文件的形式存储在磁盘上</strong></li>
<li>平常说的索引，没有特别指明的话，就是B+树（多路搜索树，不一定是二叉树）结构组织的索引。其中聚集索引，次要索引，覆盖索引，符合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。此外还有哈希索引等。</li>
</ul>
<h3 id="索引的优势"><a href="#索引的优势" class="headerlink" title="索引的优势"></a>索引的优势</h3><ul>
<li><strong>大大减少服务器需要扫描的数据量</strong></li>
<li><strong>B+树种按照顺序存储数据，降低执行排序操作ORDER BY/GROUP BY的成本，避免生成临时表</strong></li>
<li><strong>B+树的特点+数据顺序存储，可以将随机I/O变为顺序I/O</strong></li>
</ul>
<h3 id="索引的劣势"><a href="#索引的劣势" class="headerlink" title="索引的劣势"></a>索引的劣势</h3><ul>
<li>索引也是一张表，保存了主键和索引字段，并指向实体表的记录，所以也需要占用内存</li>
<li><strong>虽然索引大大提高了查询速度，同时却会降低更新表的速度</strong>，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要更新索引文件中对应的索引列字段， 因为这三种操作会导致索引信息发生变化</li>
<li>对于非常小的表使用全表扫描更高效，中到大型表适合使用索引，特大型表建立和使用索引代价随之增加，可以使用分区技术</li>
</ul>
<h3 id="MySQL索引分类"><a href="#MySQL索引分类" class="headerlink" title="MySQL索引分类"></a>MySQL索引分类</h3><h4 id="数据结构角度"><a href="#数据结构角度" class="headerlink" title="数据结构角度"></a>数据结构角度</h4><ul>
<li>B+树索引</li>
<li>Hash索引</li>
<li>Full-Text全文索引</li>
<li>R-Tree索引</li>
</ul>
<h4 id="从物理存储角度"><a href="#从物理存储角度" class="headerlink" title="从物理存储角度"></a>从物理存储角度</h4><ul>
<li>聚集索引（clustered index）</li>
<li>非聚集索引（non-clustered index），也叫二级索引（secondary index）<br>  聚集索引和非聚集索引都是B+树结构</li>
</ul>
<h4 id="从逻辑角度"><a href="#从逻辑角度" class="headerlink" title="从逻辑角度"></a>从逻辑角度</h4><ul>
<li>主键索引：主键索引是一种特殊的唯一索引，不允许有空值</li>
<li>普通索引或者单列索引：每个索引只包含单个列，一个表可以有多个单列索引</li>
<li>联合索引（复合索引、多列索引）：联合索引指多个字段上创建的索引，使用联合索引时遵循匹配最左前缀，即联合索引必须从左至右依次使用（只有在精准匹配第一列之后才可以使用后面的列，<strong>如果出现了between则不能再使用后面的索引</strong>）</li>
<li>唯一索引或者非唯一索引</li>
<li>空间索引：空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，<strong>空间索引只能在存储引擎为MYISAM的表中创建</strong></li>
</ul>
<blockquote>
<p>❝</p>
<p>为什么MySQL 索引中用B+tree，不用B-tree 或者其他树，为什么不用 Hash 索引</p>
<p>聚簇索引/非聚簇索引，MySQL 索引底层实现，叶子结点存放的是数据还是指向数据的内存地址，使用索引需要注意的几个地方？</p>
<p>使用索引查询一定能提高查询的性能吗？为什么?</p>
</blockquote>
<h3 id="MySQL索引结构"><a href="#MySQL索引结构" class="headerlink" title="MySQL索引结构"></a>MySQL索引结构</h3><p><strong>首先要明白索引（index）是在存储引擎（storage engine）层面实现的，而不是server层面</strong>。不是所有的存储引擎都支持所有的索引类型。即使多个存储引擎支持某一索引类型，它们的实现和行为也可能有所差别。</p>
<h4 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B+Tree索引"></a>B+Tree索引</h4><p>MyISAM 和 InnoDB 存储引擎，都使用 B+Tree的数据结构，它相对与 B-Tree结构，所有的数据都存放在叶子节点上，且把叶子节点通过指针连接到一起，形成了一条数据链表，以加快相邻数据的检索效率</p>
<p><strong>先了解下 B-Tree 和 B+Tree 的区别</strong></p>
<h5 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h5><ul>
<li>B-Tree是为磁盘等外存储设备设计的一种平衡多路查找树（查找路径不止两个）。</li>
<li>系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。</li>
<li>InnoDB 存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB 存储引擎中默认每个页的大小为16KB，可通过参数 <code>innodb_page_size</code> 将页的大小设置为 4K、8K、16K，在 MySQL 中可通过如下命令查看页的大小：<code>show variables like &#39;innodb_page_size&#39;;</code></li>
<li>而系统一个磁盘块的存储空间往往没有这么大，因此 InnoDB 每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小 16KB。InnoDB 在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。</li>
<li>B-Tree 结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述 B-Tree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值，对应表中的主键值，data 为一行记录中除主键外的数据。对于不同的记录，key值互不相同。</li>
<li><strong>m阶的B-Tree的特性：</strong></li>
</ul>
<ol>
<li>每个节点最多有m个子节点</li>
<li>除了根节点和叶子节点外，其它每个节点至少有ceil(m/2)个子节点（ceil()向上取整）。</li>
<li>若根节点不是叶子节点，则至少有2个子节点</li>
<li>所有叶子节点都在同一层，且不包含其它关键字信息</li>
<li>关键字的个数n满足：ceil(m/2)-1 &lt;= n &lt;= m-1</li>
<li>每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn）</li>
<li>ki(i=1,…n)为关键字，且关键字升序排序</li>
<li>Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)</li>
</ol>
<ul>
<li><p>B-Tree 中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个 3 阶的 B-Tree：</p>
</li>
<li><ul>
<li>每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。<ul>
<li>模拟查找关键字29的过程：</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li><ol>
<li><ol>
<li>根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】<ol start="2">
<li>比较关键字29在区间（17,35），找到磁盘块1的指针P2。</li>
<li>根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】</li>
<li>比较关键字29在区间（26,30），找到磁盘块3的指针P2。</li>
<li>根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】</li>
<li>在磁盘块8中的关键字列表中找到关键字29。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<ul>
<li><ul>
<li>分析上面过程，发现需要3次磁盘I/O操作，和3次内存查找操作。而3次磁盘I/O操作是影响整个B-Tree查找效率的决定因素，所以<strong>B-Tree相对于AVLTree缩减了节点个数</strong>，从而提高了查询效率。</li>
</ul>
</li>
</ul>
<h5 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h5><ul>
<li>B+Tree 是在 B-Tree 基础上的一种优化，使其更适合实现外存储索引结构，InnoDB 存储引擎就是用 B+Tree 实现其索引结构。</li>
<li>B-Tree结构图中每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。在B+Tree中，<strong>所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上**</strong>，而非叶子节点上只存储key值信息**<strong>，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度</strong>。</li>
<li>B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对B+Tree进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。</li>
<li><strong>B+Tree相对于B-Tree有几点不同：</strong></li>
</ul>
<ol>
<li>非叶子节点只存储键值信息；</li>
<li>所有叶子节点之间都有一个链指针；</li>
<li>数据记录都存放在叶子节点中</li>
</ol>
<ul>
<li>假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示：</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539886-ed20e377-d331-41d0-a2f8-1f7273b9442d.webp?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<ul>
<li><p>可能上面例子中只有22条数据记录，看不出B+Tree的优点，下面做一个推算：</p>
</li>
<li><ul>
<li>InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为10^3）。也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录。</li>
</ul>
</li>
<li><p>实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2-4层。MySQL的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。</p>
</li>
<li><p>B+Tree性质</p>
</li>
</ul>
<ol>
<li>通过上面的分析，我们知道IO次数取决于B+树的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有<img src="https://cdn.nlark.com/yuque/__latex/419c87720465f7f5a8523f3cc041af27.svg" alt="img">，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。</li>
<li>当B+树的数据项是复合的数据结构，比如(name,age,sex)的时候，B+树是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，B+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即<strong>索引的最左匹配特性</strong>。</li>
</ol>
<blockquote>
<p>❝B+树是怎么保证平衡的？</p>
</blockquote>
<p><a href="https://www.cnblogs.com/nullzx/p/8729425.html">B树、B+树插入删除过程</a></p>
<h5 id="MyISAM主键索引与二级索引的结构"><a href="#MyISAM主键索引与二级索引的结构" class="headerlink" title="MyISAM主键索引与二级索引的结构"></a>MyISAM主键索引与二级索引的结构</h5><ul>
<li><p>MyISAM引擎的索引文件和数据文件是分离的。<strong>MyISAM引擎索引结构的叶子节点的数据域，存放的并不是实际的数据记录，而是数据记录的地址</strong>。索引文件与数据文件分离，这样的索引称为”非聚簇索引”。MyISAM的主索引与二级索引区别并不大，只是主索引不能有重复的关键字</p>
</li>
<li><p>MyISAM索引</p>
</li>
<li><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590541902-8b1f0c77-6a43-4901-beab-7f3a2f3b0ff5.webp?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></li>
</ul>
</li>
<li><p>在MyISAM中，索引（含叶子节点）存放在单独的.myi文件中，叶子节点存放的是数据的物理地址偏移量</p>
</li>
<li><p>主索引是指主键索引，键值不可能重复；二级索引则是普通索引，键值可能重复。</p>
</li>
<li><p>通过索引查找数据的流程：先从索引文件中查找到索引节点，从中拿到数据的文件指针，再到数据文件中通过文件指针定位了具体的数据。二级索引类似。</p>
</li>
</ul>
<h5 id="InnoDB主键索引与二级索引的结构"><a href="#InnoDB主键索引与二级索引的结构" class="headerlink" title="InnoDB主键索引与二级索引的结构"></a>InnoDB主键索引与二级索引的结构</h5><ul>
<li><strong>InnoDB引擎索引结构的叶子节点的数据域，存放的就是实际的数据记录</strong>（对于主索引，此处会存放表中所有的数据记录；对于二级索引叶子节点存储的是主键，检索的时候通过叶子节点的主键到主键索引中找到对应数据行，即二级索引需要访问两次索引）</li>
<li>或者说，<strong>InnoDB的数据文件本身就是主键索引文件</strong>，这样的索引被称为“聚簇索引”，一个表只能有一个聚簇索引。</li>
<li><strong>向聚簇索引中的页插入新行，如果超出了存储容量则需要执行“页分裂”**</strong>，会导致页与页之间不连续**（分裂的页就不是聚簇的概念，会通过优化表的操作重新完成聚簇）</li>
</ul>
<h6 id="主键索引："><a href="#主键索引：" class="headerlink" title="主键索引："></a>主键索引：</h6><ul>
<li>InnoDB索引是聚集索引，它的索引和数据是存入同一个.idb文件中的，因此它的索引结构是在同一个树节点中同时存放索引和数据，如下图中最底层的叶子节点有三行数据，对应于数据表中的id、stu_id、name数据项。</li>
<li>在Innodb中，索引分叶子节点和非叶子节点，非叶子节点就像新华字典的目录，单独存放在索引段中，叶子节点则是顺序排列的，在数据段中。Innodb的数据文件可以按照表来切分（只需要开启<code>innodb_file_per_table)</code>，切分后存放在<code>xxx.ibd</code>中，默认不切分，存放在<code>xxx.ibdata</code>中。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539905-19dcb659-d0cf-440b-995d-2a62040981f3.webp?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<h6 id="二级（非主键）索引："><a href="#二级（非主键）索引：" class="headerlink" title="二级（非主键）索引："></a>二级（非主键）索引：</h6><ul>
<li>以示例中学生表中的name列建立二级索引，它的索引结构跟主键索引的结构有很大差别，在最底层的叶子结点有两行数据，第一行的字符串是二级索引，按照ASCII码进行排序，第二行的整数是主键的值。</li>
<li>这就意味着，对name列进行条件搜索，需要两个步骤：</li>
</ul>
<ol>
<li>在二级索引上检索name，到达其叶子节点获取对应的主键；</li>
<li>使用主键在主索引上再进行对应的检索操作</li>
</ol>
<p>这也就是所谓的“<strong>回表查询</strong>”</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539900-bb4d422c-e6a4-4b89-a3f0-44deb87c26cf.webp?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<h5 id="InnoDB-索引结构需要注意的点"><a href="#InnoDB-索引结构需要注意的点" class="headerlink" title="InnoDB 索引结构需要注意的点"></a>InnoDB 索引结构需要注意的点</h5><ol>
<li>数据文件本身就是索引文件</li>
<li>聚集索引中叶节点包含了完整的数据记录</li>
<li>InnoDB 表必须要有主键，并且推荐使用整型自增主键</li>
</ol>
<ul>
<li>不管是主键索引还是二级索引，所有的查询都是通过先查找到索引节点才能拿到相对应的数据，所以如果在设计表结构时没有显式指定索引列的话，MySQL 会从表中选择数据不重复的列建立索引，如果没有符合的列，则 MySQL 自动为 InnoDB 表生成一个隐含字段作为主键，并且这个字段长度为6个字节，类型为整型。</li>
</ul>
<blockquote>
<p>❝那为什么推荐使用整型自增主键而不是选择UUID？</p>
</blockquote>
<ul>
<li>UUID是字符串，比整型消耗更多的存储空间；</li>
<li>在B+树中进行查找时需要跟经过的节点值比较大小，整型数据的比较运算比字符串更快速；</li>
<li>自增的整型索引在磁盘中会连续存储，在读取一页数据时也是连续；UUID是随机产生的，读取的上下两行数据存储是分散的，不适合执行where id &gt; 5 &amp;&amp; id &lt; 20的条件查询语句。</li>
<li>在插入或删除数据时，整型自增主键会在叶子结点的末尾建立新的叶子节点，不会破坏左侧子树的结构；UUID主键很容易就破坏了原有树结构，B+树为了维持自身的特性，有可能会进行结构的重构，消耗更多的时间。</li>
</ul>
<blockquote>
<p>❝为什么非主键索引结构叶子节点存储的是主键值？</p>
</blockquote>
<p>保证数据一致性（更新数据的时候只更新主键索引中的数据即可）和节省存储空间，</p>
<h4 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h4><ul>
<li><p>主要就是通过Hash算法，将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。<br>  检索算法：在检索查询时，就再次对待查关键字再次执行相同的Hash算法，得到Hash值，到对应Hash表对应位置取出数据即可，如果发生Hash碰撞，则需要在取值时进行筛选。</p>
</li>
<li><p><strong>Hash索引的限制：</strong></p>
</li>
<li><ul>
<li>value存储的是行指针，不能实现覆盖索引<ul>
<li>哈希索引不是按照索引值顺序存储的，所以不能用于排序，也就不支持范围查找</li>
<li>联合索引时不支持使用部分索引进行查找，因为hash值是由全部索引列计算得到的</li>
<li>哈希冲突严重的时候相当于遍历链表，反而比不上二叉树</li>
</ul>
</li>
</ul>
</li>
<li><p>MySQL目前有Memory引擎和NDB引擎支持Hash索引。</p>
</li>
<li><p>InnoDB可以创建自定义哈希索引：</p>
</li>
<li><ul>
<li>当需要根据URL进行索引时，可以将URL的hash值作为索引的列，这样可以降低索引值长度，并且是整数比较速度快<ul>
<li>即使有大量的哈希冲突，但是索引仍然可以过滤很多数据，而且速度比直接使用URL快</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="full-text全文索引"><a href="#full-text全文索引" class="headerlink" title="full-text全文索引"></a>full-text全文索引</h4><ul>
<li>全文索引也是MyISAM的一种特殊索引类型，主要用于全文索引，InnoDB从MYSQL5.6版本提供对全文索引的支持。</li>
<li>它用于替代效率较低的LIKE模糊匹配操作，而且可以通过多字段组合的全文索引一次性全模糊匹配多个字段。</li>
<li>同样使用B-Tree存放索引数据，但使用的是特定的算法，将字段数据分割后再进行索引（一般每4个字节一次分割），索引文件存储的是分割前的索引字符串集合，与分割后的索引信息，对应B-tree结构的节点存储的是分割后的词信息以及它在分割前的索引字符串集合中的位置。</li>
</ul>
<h4 id="R-Tree空间索引"><a href="#R-Tree空间索引" class="headerlink" title="R-Tree空间索引"></a>R-Tree空间索引</h4><p>空间索引是MyISAM的一种特殊索引类型，主要用于地理空间数据类型</p>
<blockquote>
<p>❝为什么Mysql索引要用B+树不是B树？</p>
</blockquote>
<p>用B+树不用B树考虑的是IO对性能的影响，B树的每个节点都存储数据，而B+树只有叶子节点才存储数据，所以查找相同数据量的情况下，B树的高度更高，IO更频繁。数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。其中在MySQL底层对B+树进行进一步优化：在叶子节点中是双向链表，且在链表的头结点和尾节点也是循环指向的。</p>
<blockquote>
<p>❝面试官：为何不采用Hash方式？</p>
</blockquote>
<p>因为Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。所以，哈希索引只适用于等值查询的场景。而B+Tree是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描。</p>
<p>哈希索引不支持多列联合索引的最左匹配规则，如果有大量重复键值的情况下，哈希索引的效率会很低，因为存在哈希碰撞问题。</p>
<h3 id="哪些情况需要创建索引"><a href="#哪些情况需要创建索引" class="headerlink" title="哪些情况需要创建索引"></a>哪些情况需要创建索引</h3><ol>
<li>主键自动建立唯一索引</li>
<li>频繁作为查询条件的字段</li>
<li>查询中与其他表关联的字段，外键关系建立索引</li>
<li>单键/组合索引的选择问题，高并发下倾向创建组合索引</li>
<li>查询中排序的字段，排序字段通过索引访问大幅提高排序速度</li>
<li>查询中统计或分组字段</li>
</ol>
<h3 id="哪些情况不要创建索引"><a href="#哪些情况不要创建索引" class="headerlink" title="哪些情况不要创建索引"></a>哪些情况不要创建索引</h3><ol>
<li>表记录太少</li>
<li>经常增删改的表</li>
<li>数据重复且分布均匀的表字段，只应该为最经常查询和最经常排序的数据列建立索引（如果某个数据类包含太多的重复数据，建立索引没有太大意义）</li>
<li>频繁更新的字段不适合创建索引（会加重I/O负担）</li>
<li>where条件里用不到的字段不创建索引</li>
</ol>
<h3 id="高性能创建索引"><a href="#高性能创建索引" class="headerlink" title="高性能创建索引"></a>高性能创建索引</h3><h4 id="列前缀索引"><a href="#列前缀索引" class="headerlink" title="列前缀索引"></a>列前缀索引</h4><ul>
<li><p>有时需要索引很长的字符列，会让索引变得大且慢。一个策略是使用哈希索引，另一种方式是使用列前缀索引，即使用该列前一部分字符建立索引，并查询时也只使用该列的前一部分字符。注意：列前缀索引和匹配最前缀索引不是一回事，前者是一个列，后者是多个列</p>
</li>
<li><ul>
<li>例如</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>建立city列字符串的前3个字符的索引：</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>ALTER TABLE sakila.city_demo ADD KEY (city(7));</p>
<ul>
<li><ul>
<li><ul>
<li>查询city列字符串的前3个字符：</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>SELECT COUNT(*) AS cnt, LEFT(city,3) AS pref</p>
<p>FROM sakila.city_demo GROUP BY pref ORDER BY cnt DESC LIMIT 10;</p>
<ul>
<li><p>查询时究竟选择几个字符需要根据实际列判断索引选择性：</p>
</li>
<li><ul>
<li><ul>
<li>索引选择性：不重复的索引项/数据表的记录总数（即，分支越多索引选择性越大）<ul>
<li>选择全部的字符串时索引选择性大</li>
<li>当选择前n个字符的索引选择性接近全字符串的索引选择性时是最佳的列前缀索引</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>使用列前缀索引则不能在该列上使用ORDER BY/GROUP BY，也不能作为覆盖索引</p>
</li>
</ul>
<h4 id="联合索引中索引顺序"><a href="#联合索引中索引顺序" class="headerlink" title="联合索引中索引顺序"></a>联合索引中索引顺序</h4><ul>
<li><p>“三星”索引概念：</p>
</li>
<li><ul>
<li>与查询相关的索引行是相邻的，也就是where后面的等值谓词，可以匹配索引列顺序——where和索引匹配越多，扫描的数据行越少<ul>
<li>索引行的顺序与查询语句需求一致，也就是order by 中的排序和索引顺序是否一致——避免排序</li>
<li>索引行包含查询语句中所有的列——避免扫描数据行</li>
</ul>
</li>
</ul>
</li>
<li><p>一个联合索引中的索引列顺序可以影响到一个索引是否是“三星”索引</p>
</li>
<li><p>通用经验是将选择性高的列放在索引最前列，这样仅仅在where进行查找时效果较好，仅仅是一个经验，排序和分组时这样并不一定适合，实践中并不一定这么做</p>
</li>
</ul>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p><strong>覆盖索引</strong>（Covering Index）,或者叫索引覆盖， 可以不需要回表操作</p>
<ul>
<li>就是select查询数据列在索引中就已经完全包含，不必读取数据行，利用索引返回select列表中的字段，而不必根据索引再次读取数据文件，换句话说<strong>查询列要被所建的索引覆盖</strong>。</li>
<li>索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据，当能通过读取索引就可以得到想要的数据，那就不需要读取行了。一个索引包含（覆盖）满足查询结果的数据就叫做覆盖索引。</li>
<li><strong>判断标准</strong><br>  使用explain，可以通过输出的extra列来判断，对于一个索引覆盖查询，显示为<strong>using index</strong>，MySQL查询优化器在执行查询前会决定是否有索引覆盖查询</li>
</ul>
<h2 id="七、MySQL查询"><a href="#七、MySQL查询" class="headerlink" title="七、MySQL查询"></a>七、MySQL查询</h2><ul>
<li>查询优化、索引优化、库表结构优化需要齐头并进</li>
</ul>
<h3 id="优化慢查询"><a href="#优化慢查询" class="headerlink" title="优化慢查询"></a>优化慢查询</h3><ul>
<li>是否查询了大量的结果，但是仅使用前10条——使用LIMIT</li>
<li>多表关联的时候返回了全部的列（SELECT * FROM actor INNER JOIN film_actor USING(actor_id) WHERE …）——仅返回需要的列</li>
<li>取出不需要的列（SELECT * FROM xxx）</li>
</ul>
<p>取出不需要的列会导致优化器无法使用索引覆盖进行优化，同时还会带来额外的I/O、内存和CPU消耗</p>
<h3 id="索引效果与优化"><a href="#索引效果与优化" class="headerlink" title="索引效果与优化"></a>索引效果与优化</h3><p>使用WHERE条件的三种方式，从好到坏：</p>
<ul>
<li>索引中使用WHERE条件过滤不匹配的记录。在存储引擎层完成</li>
<li>使用索引覆盖扫描返回记录（Explain中Extra列为Using index）。在MySQL服务器层完成，不需要回表查询</li>
<li>从数据表中返回记录，然后根据WHERE过滤不满足条件的记录（Explain中Extra列为Using Where）。在MySQL服务器层完成，需要先从数据表读出记录再过滤</li>
</ul>
<p>发现扫描大量数据，但只返回需要的少量数据，优化方式：</p>
<ul>
<li>从索引角度入手，使用索引覆盖扫描</li>
<li>从库表结构入手，例如使用单独的汇总表（优化count()语句）</li>
<li>从查询语句入手，重写查询语句，下面会介绍</li>
</ul>
<h3 id="重构查询的方式"><a href="#重构查询的方式" class="headerlink" title="重构查询的方式"></a>重构查询的方式</h3><h4 id="切分查询"><a href="#切分查询" class="headerlink" title="切分查询"></a>切分查询</h4><ul>
<li><p>有时候可以将一个大查询切分成小查询</p>
</li>
<li><p>例如，删除旧数据</p>
</li>
<li><ul>
<li>一次删除大量数据可能锁住很多数据，占满整个事务日志、耗尽资源、阻塞很多重要查询<ul>
<li>将要删除的数据分为多次小删除对服务器影响较小</li>
<li>原SQL语句一次删除大量数据：DELETE FROM messages WHERE created &lt; DATE_SUB(NOW(),INTERVAL 3 MONTH);</li>
<li>一次只删除10000行数据：rows_affected = 0</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>do {</p>
<p> rows_affected = do_query{</p>
<p>“DELETE FROM messages WHERE created &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH)</p>
<p>LIMIT 10000”)</p>
<p>} while rows_affected &gt; 0</p>
<h4 id="分解关联查询"><a href="#分解关联查询" class="headerlink" title="分解关联查询"></a>分解关联查询</h4><ul>
<li><p><strong>将一条关联查询分解成多个独立的单表查询，可以具有如下优势：</strong></p>
</li>
<li><ul>
<li>缓存的效率更高。缓存单表查询的话重复查询的频率会更高<ul>
<li>执行单个查询可以减少锁竞争</li>
<li>持久层分解，应用层关联，可以更容易拆分数据库，提高可伸缩性</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="查询执行的基础"><a href="#查询执行的基础" class="headerlink" title="查询执行的基础"></a>查询执行的基础</h3><ul>
<li><p>客户端向服务器发送请求时的步骤：</p>
</li>
<li><ul>
<li>客户端发送一条查询给服务器<ul>
<li>服务器先检查<strong>查询缓存</strong>，如果命中缓存则立即返回缓存中的结果，否则进入下一阶段</li>
<li>服务器端进行SQL<strong>解析、预处理</strong>，再由<strong>优化器</strong>生成对应的<strong>执行计划</strong></li>
<li>根据执行计划调用存储引擎的API来执行查询</li>
<li>将结果返回给客户端</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1590917863447-22c656bd-a4c5-4b08-8c99-7b39215b5f4f.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><ul>
<li>解析查询语句前MySQL会解析查询是否命中缓存中的数据。检查是通过大小写敏感的哈希查找，即使查询语句有一个字节不同也不会匹配</li>
<li>如果匹配了则检查权限，并直接返回缓存中的结果</li>
<li>如果没有匹配则执行下面的步骤</li>
</ul>
<h4 id="查询优化处理"><a href="#查询优化处理" class="headerlink" title="查询优化处理"></a>查询优化处理</h4><ul>
<li>查询在查询缓存后的下一个生命周期是将SQL转换成一个执行计划，具体步骤包括：<strong>解析SQL、预处理、优化SQL执行计划</strong></li>
</ul>
<h5 id="语法解析器和预处理"><a href="#语法解析器和预处理" class="headerlink" title="语法解析器和预处理"></a>语法解析器和预处理</h5><ul>
<li>解析器根据SQL关键字解析，并生成“解析树”。这个步骤会进行验证和解析查询，例如，验证是否错误的关键字，关键字顺序是否正确</li>
<li>预处理器进一步检查解析树是否合法，例如，查询数据表和数据列是否存在。同时会验证权限。</li>
</ul>
<h5 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h5><ul>
<li><p>优化器将这个合法的语法树转化成执行计划</p>
</li>
<li><p>一条查询语句可以有多种执行方式，返回相同的结果，优化器的作用就是找到其中最好的执行计划</p>
</li>
<li><p>MySQL使用基于成本的优化器，主要是完成查询需要读取数据页的数量。受限于统计信息不准确（MVCC架构），没有考虑并发情况等，最终的执行计划并不一定是最优的</p>
</li>
<li><p>优化策略可以分为两种：</p>
</li>
<li><ul>
<li>静态优化：直接对解析树进行优化，例如通过简单的代数变换将where条件转换成另一种等价形式（下面有例子）<ul>
<li>动态优化：与查询的上下文有关，也可能和很多其他因素有关，例如where条件中的取值、索引中条目对应的数据行数。因为不是固定的优化策略，所以每次查询都要重新评估。</li>
</ul>
</li>
</ul>
</li>
<li><p>MySQL能够处理的优化类型：</p>
</li>
<li><ul>
<li><strong>重新定义关联表的顺序：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>下面会说</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>将外连接转化成内连接：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>有些外连接LEFT OUTER JOIN 可以转换成内连接INNER JOIN，这样就可以调整管关联顺序了</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>优化COUNT()、MIN()、MAX()：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>例如最小值可以直接查询B-Tree最左端记录</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>预估并转换为常数表达式：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>检测到表达式可以转化成常数时会将其当作常数进行优化处理<ul>
<li>此外，有时候一个查询也可以转化为一个常数，例子：</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>EXPLAIN SELECT film.film_id, film_actor.actor_id</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>FROM sakila.film</p>
<p>INNER JOIN sakila.film_actor USING(film_id)</p>
<p>WHERE film.film_id=1;</p>
<ul>
<li><ul>
<li><ul>
<li><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1590914393242-1ebaea4c-d929-4b6a-820e-b21c8c6de7a9.png" alt="image.png"><pre><code>- 上面查询分为两步：
- ①：先从film表找到需要的行，因为film_id字段上有主键索引，所以MySQL知道只会返回一行数据，所以表的访问类型是const
- ②：因为第一步返回的film_id列当作已知取值的列，那么对表film_actor的访问类型也是const</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>覆盖索引扫描：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>索引中的列包含所有查询中需要的列时就可以使用索引返回需要的数据，无须查询对应的数据行</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>子查询优化：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>某些情况下会将子查询转换一种形式，从而减少多个查询多次对数据进行访问的次数</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>提前终止查询：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>发现已经满足查询需求时候会立刻终止查询，比如使用LIMIT的时候，或者发现一个不成立的条件时（SELECT  film.film_id FROM sakila.film WHERE film_id = -1）</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>等值传播：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>如果两个列通过等式关联，那么MySQL能够把其中一个列的WHERE条件传递到另一个列上，例如：</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>SELECT film.film_id</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>FROM sakila.film</p>
<p>INNER JOIN sakila.film_actor USING(film_id)</p>
<p>WHERE film.film_id&gt;500;</p>
<ul>
<li><ul>
<li><ul>
<li><ul>
<li>由于WHERE 子句中的film_id字段同样适用于film_actor表，那么MySQL会优化成下面的形式：<pre><code>- ... WHERE film.film_id &gt; 500 AND film_actor.film_id &gt; 500</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>列表IN()</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>很多数据库系统中，IN()完全等同于多个OR条件的子句，复杂度O(n)。但是MySQL会将IN()中的数据先排序，然后通过二分查找确定IN()中的值是否满足条件，复杂度O(logn)。IN()中有大量取值时，MySQL处理速度会快一定</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="数据和索引的统计信息"><a href="#数据和索引的统计信息" class="headerlink" title="数据和索引的统计信息"></a>数据和索引的统计信息</h5><ul>
<li><p>统计信息由存储引擎实现</p>
</li>
<li><p>查询优化器在生成查询计划时，需要向存储引擎获取相应的统计信息，包括</p>
</li>
<li><ul>
<li>每个表或索引有多少页<ul>
<li>每个表的每个索引的基数是多少（索引选择性）</li>
<li>数据行和索引长度、索引的分布信息等</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="如何执行关联查询"><a href="#如何执行关联查询" class="headerlink" title="如何执行关联查询"></a>如何执行关联查询</h5><ul>
<li><p>MySQL概念中不仅仅是查询需要到两个表才叫关联，，每个查询都是一次关联。</p>
</li>
<li><p>MySQL关联执行的策略：</p>
</li>
<li><ul>
<li>嵌套循环关联：先在一个表中循环取出单条数据，然后再执行嵌套循环到下一个表中匹配的行，依次下去，直到找到所有表中匹配的行。然后根据各表匹配的行，返回查询中需要的各个列。先在最后一个关联表尝试找到所有匹配的行，然后再回溯到上一个表。<ul>
<li>即，循环+嵌套获取所有匹配的行，然后回溯返回数据</li>
</ul>
</li>
</ul>
</li>
<li><p>MySQL多表关联示意图：</p>
</li>
<li><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1590918172760-399cd7a4-0411-4da4-8812-47e69bb74014.png" alt="image.png"></li>
</ul>
</li>
<li><p>MySQL关联查询示例图</p>
</li>
<li><ul>
<li>SQL语句：SELECT tbl1.col1, tbl2.col2 FROM tbl1 INNER JOIN tbl2 USING(col3) WHERE tbl1.col1 IN(5,6);<ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1590917828821-0399668d-00d1-4c66-8d35-70e18754ede5.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="关联查询优化器"><a href="#关联查询优化器" class="headerlink" title="关联查询优化器"></a>关联查询优化器</h5><ul>
<li><p>MySQL优化器最重要的部分就是关联查询优化，多表关联时可以有多种不同的关联顺序来获取相同的结果，关联查询优化器就是通过评估不同顺序时的成本来选择代价最小的关联顺序</p>
</li>
<li><p>例子：</p>
</li>
<li><ul>
<li>SQL语句：SELECT film_id, film.title, film.release_year, actor.actor_id, actor.first_name, actor.last_name</li>
</ul>
</li>
</ul>
<p>FROM sakila.<strong>film</strong></p>
<p>INNER JOIN sakila.<strong>film_actor</strong> USING(film_id)</p>
<p>INNER JOIN sakila.<strong>actor</strong> USING(actor_id);</p>
<ul>
<li><ul>
<li>MySQL没有按照SQL关联的顺序，而是优化了关联顺序，EXPLAIN结果如下：<ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1590918875519-95211bf1-b239-4546-924d-652fd842d47d.png" alt="image.png"></li>
<li>如果让MySQL强行按照SQL顺序执行，在SELECT后加STRAIGHT_JOIN，EXPLAIN结果如下：</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1590919015592-d17f26a1-03b9-416c-966d-b313c527d900.png" alt="image.png"></li>
<li>可以发现修改关联顺序可以减少扫描的行数，让查询进行更少的嵌套循环和回溯操作</li>
<li>如果可以的话，优化器会遍历每一个表然后逐个做嵌套循环计算成本，然后返回最优的执行计划</li>
<li>但是n个表的关联种数是阶乘，所以会使用“启发式”优化策略，并不会遍历计算所有可能的执行计划</li>
<li>（注意：各个查询的顺序不能随意安排，因为后面的表的查询需要依赖于前面表的查询结果。比如左外连接、相关子查询）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h5><ul>
<li><p>MySQL排序规则：</p>
</li>
<li><ul>
<li>当不能使用索引生成排序结果时，MySQL会使用filesort进行排序<ul>
<li><strong>如果数据量小于“排序缓冲区”会在内存中使用快排进行排序。如果数据量大于则会在磁盘中进行排序，先将数据分块，对每个独立的块使用快排，然后将各个块的排序结果存放在磁盘上，然后将各个排好序的块进行合并，最后返回结果</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>MySQL排序算法：</p>
</li>
<li><ul>
<li>两次传输排序：① 读取行指针和需要排序的字段，并对其排序。② 然后根据排序结果读取所需要的数据行<ul>
<li>单次传输排序：① 读取查询需要的所有列，然后根据给定列进行排序，最后直接返回排序结果</li>
<li>两种算法各有优劣</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>两次传输排序：因为排序后再读取数据行，会产生大量的随机I/O<ul>
<li>顺序读取数据行，不会随机I/O，缺点是如果需要返回的列非常多，会额外占用大量的空间，而这些列对排序本身没有帮助</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="查询执行计划"><a href="#查询执行计划" class="headerlink" title="查询执行计划"></a>查询执行计划</h4><ul>
<li>查询执行引擎根据执行计划调用API完成查询</li>
</ul>
<h4 id="返回结果给客户端"><a href="#返回结果给客户端" class="headerlink" title="返回结果给客户端"></a>返回结果给客户端</h4><ul>
<li>将查询结果返回给客户端，如果缓存开启，则将结果存放到查询缓存中</li>
<li>并不是查询彻底完成后才开始返回的，一旦服务器处理完最后一个关联表，开始生成第一条结果时，就开始向客户端逐步返回结果集</li>
<li>好处：服务器端不用存储太多了结果，客户端可以第一时间获得返回的结果</li>
</ul>
<h3 id="几个查询语句的区别"><a href="#几个查询语句的区别" class="headerlink" title="几个查询语句的区别"></a>几个查询语句的区别</h3><h5 id="count-和count-列名-查询"><a href="#count-和count-列名-查询" class="headerlink" title="count(*)和count(列名)查询"></a>count(*)和count(列名)查询</h5><ul>
<li>count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL</li>
<li>count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数，即某个字段值为NULL时，不统计。</li>
</ul>
<h5 id="in和-exists-的区别？"><a href="#in和-exists-的区别？" class="headerlink" title="in和 exists 的区别？"></a>in和 exists 的区别？</h5><ul>
<li>exists：exists对外表用loop逐条查询，每次查询都会查看exists的条件语句，当exists里的条件语句能够返回记录行时（无论记录行是的多少，只要能返回），条件就为真，返回当前loop到的这条记录；反之，如果exists里的条件语句不能返回记录行，则当前loop到的这条记录被丢弃，exists的条件就像一个bool条件，当能返回结果集则为true，不能返回结果集则为false</li>
<li>in：in查询相当于多个or条件的叠加</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> A.id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> B);</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> * <span class="keyword">from</span> B <span class="keyword">WHERE</span> B.id = A.id);</span><br></pre></td></tr></table></figure>

<ul>
<li>如果查询的两个表大小相当，那么用in和exists差别不大</li>
<li>如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in</li>
</ul>
<h5 id="UNION和UNION-ALL的区别"><a href="#UNION和UNION-ALL的区别" class="headerlink" title="UNION和UNION ALL的区别?"></a>UNION和UNION ALL的区别?</h5><p>UNION和UNION ALL都是将两个结果集合并为一个，<strong>两个要联合的SQL语句 字段个数必须一样，而且字段类型要“相容”（一致）；</strong></p>
<ul>
<li>UNION在进行表连接后会筛选掉重复的数据记录（效率较低），而UNION ALL则不会去掉重复的数据记录；</li>
<li>UNION会按照字段的顺序进行排序，而UNION ALL只是简单的将两个结果合并就返回；</li>
</ul>
<h3 id="SQL执行顺序"><a href="#SQL执行顺序" class="headerlink" title="SQL执行顺序"></a>SQL执行顺序</h3><ul>
<li>手写</li>
</ul>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> &lt;select_list&gt;</span><br><span class="line"><span class="keyword">FROM</span>  &lt;left_table&gt; &lt;join_type&gt;</span><br><span class="line"><span class="keyword">JOIN</span>  &lt;right_table&gt; <span class="keyword">ON</span> &lt;join_condition&gt;</span><br><span class="line"><span class="keyword">WHERE</span>  &lt;where_condition&gt;</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span>  &lt;group_by_list&gt;</span><br><span class="line"><span class="keyword">HAVING</span> &lt;having_condition&gt;</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;order_by_condition&gt;</span><br><span class="line"><span class="keyword">LIMIT</span> &lt;limit_number&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>机读</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span>  &lt;left_table&gt;</span><br><span class="line"><span class="keyword">ON</span> &lt;join_condition&gt;</span><br><span class="line">&lt;join_type&gt; <span class="keyword">JOIN</span>  &lt;right_table&gt;</span><br><span class="line"><span class="keyword">WHERE</span>  &lt;where_condition&gt;</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span>  &lt;group_by_list&gt;</span><br><span class="line"><span class="keyword">HAVING</span> &lt;having_condition&gt;</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">DISTINCT</span> &lt;select_list&gt;</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;order_by_condition&gt;</span><br><span class="line"><span class="keyword">LIMIT</span> &lt;limit_number&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>总结</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539949-2595b2b5-7eac-4a9f-a6ca-016a37625d12.webp" alt="image"></p>
<blockquote>
<p>❝</p>
<p>mysql 的内连接、左连接、右连接有什么区别？</p>
<p>什么是内连接、外连接、交叉连接、笛卡尔积呢？</p>
</blockquote>
<h3 id="Join图"><a href="#Join图" class="headerlink" title="Join图"></a>Join图</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539969-2ac4a686-05ba-4792-baa4-251a6c5bd854.webp?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<h2 id="八、MySQL调优"><a href="#八、MySQL调优" class="headerlink" title="八、MySQL调优"></a>八、MySQL调优</h2><blockquote>
<p>❝</p>
<p>日常工作中你是怎么优化SQL的？</p>
<p>SQL优化的一般步骤是什么，怎么看执行计划（explain），如何理解其中各个字段的含义？</p>
<p>如何写sql能够有效的使用到复合索引？</p>
<p>一条sql执行过长的时间，你如何优化，从哪些方面入手？</p>
<p>什么是最左前缀原则？什么是最左匹配原则？</p>
</blockquote>
<h3 id="影响mysql的性能因素"><a href="#影响mysql的性能因素" class="headerlink" title="影响mysql的性能因素"></a>影响mysql的性能因素</h3><ul>
<li><p>业务需求对MySQL的影响(合适合度)</p>
</li>
<li><p>存储定位对MySQL的影响</p>
</li>
<li><ul>
<li>系统各种配置及规则数据<ul>
<li>活跃用户的基本信息数据</li>
<li>活跃用户的个性化定制信息数据</li>
<li>准实时的统计信息数据</li>
<li>其他一些访问频繁但变更较少的数据</li>
<li>二进制多媒体数据</li>
<li>流水队列数据</li>
<li>超大文本数据</li>
<li>不适合放进MySQL的数据</li>
<li>需要放进缓存的数据</li>
</ul>
</li>
</ul>
</li>
<li><p>Schema设计对系统的性能影响</p>
</li>
<li><ul>
<li>尽量减少对数据库访问的请求<ul>
<li>尽量减少无用数据的查询请求</li>
</ul>
</li>
</ul>
</li>
<li><p>硬件环境对系统性能的影响</p>
</li>
</ul>
<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><h4 id="MySQL-Query-Optimizer"><a href="#MySQL-Query-Optimizer" class="headerlink" title="MySQL Query Optimizer"></a>MySQL Query Optimizer</h4><ol>
<li>MySQL 中有专门负责优化 SELECT 语句的优化器模块，主要功能：通过计算分析系统中收集到的统计信息，为客户端请求的 Query 提供他认为最优的执行计划（他认为最优的数据检索方式，但不见得是 DBA 认为是最优的，这部分最耗费时间）</li>
<li>当客户端向 MySQL 请求一条 Query，命令解析器模块完成请求分类，区别出是 SELECT 并转发给 MySQL Query Optimize r时，MySQL Query Optimizer 首先会对整条 Query 进行优化，处理掉一些常量表达式的预算，直接换算成常量值。并对 Query 中的查询条件进行简化和转换，如去掉一些无用或显而易见的条件、结构调整等。然后分析 Query 中的 Hint 信息（如果有），看显示 Hint 信息是否可以完全确定该 Query 的执行计划。如果没有 Hint 或 Hint 信息还不足以完全确定执行计划，则会读取所涉及对象的统计信息，根据 Query 进行写相应的计算分析，然后再得出最后的执行计划。</li>
</ol>
<h4 id="MySQL常见瓶颈"><a href="#MySQL常见瓶颈" class="headerlink" title="MySQL常见瓶颈"></a>MySQL常见瓶颈</h4><ul>
<li>CPU：CPU在饱和的时候一般发生在数据装入内存或从磁盘上读取数据时候</li>
<li>IO：磁盘I/O瓶颈发生在装入数据远大于内存容量的时候</li>
<li>服务器硬件的性能瓶颈：top，free，iostat 和 vmstat来查看系统的性能状态</li>
</ul>
<h4 id="性能下降SQL慢-执行时间长-等待时间长-原因分析"><a href="#性能下降SQL慢-执行时间长-等待时间长-原因分析" class="headerlink" title="性能下降SQL慢 执行时间长 等待时间长 原因分析"></a>性能下降SQL慢 执行时间长 等待时间长 原因分析</h4><ul>
<li>查询语句写的烂</li>
<li>索引失效（单值、复合）</li>
<li>关联查询太多join（设计缺陷或不得已的需求）</li>
<li>服务器调优及各个参数设置（缓冲、线程数等）</li>
</ul>
<h4 id="MySQL常见性能分析手段"><a href="#MySQL常见性能分析手段" class="headerlink" title="MySQL常见性能分析手段"></a>MySQL常见性能分析手段</h4><p>在优化MySQL时，通常需要对数据库进行分析，常见的分析手段有<strong>慢查询日志</strong>，<strong>EXPLAIN 分析查询</strong>，<strong>profiling分析</strong>以及<strong>show命令查询系统状态及系统变量</strong>，通过定位分析性能的瓶颈，才能更好的优化数据库系统的性能。</p>
<h5 id="性能瓶颈定位"><a href="#性能瓶颈定位" class="headerlink" title="性能瓶颈定位"></a>性能瓶颈定位</h5><p>我们可以通过 show 命令查看 MySQL 状态及变量，找到系统的瓶颈：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">Mysql&gt; <span class="keyword">show</span> status ——显示状态信息（扩展<span class="keyword">show</span> status <span class="keyword">like</span> ‘XXX’）</span><br><span class="line">Mysql&gt; <span class="keyword">show</span> variables ——显示系统变量（扩展<span class="keyword">show</span> variables <span class="keyword">like</span> ‘XXX’）</span><br><span class="line">Mysql&gt; <span class="keyword">show</span> innodb status ——显示InnoDB存储引擎的状态</span><br><span class="line">Mysql&gt; <span class="keyword">show</span> processlist ——查看当前<span class="keyword">SQL</span>执行，包括执行状态、是否锁表等</span><br><span class="line">Shell&gt; mysqladmin variables -u username -p <span class="keyword">password</span>——显示系统变量</span><br><span class="line">Shell&gt; mysqladmin extended-status -u username -p <span class="keyword">password</span>——显示状态信息</span><br></pre></td></tr></table></figure>

<h5 id="Explain-执行计划"><a href="#Explain-执行计划" class="headerlink" title="Explain(执行计划)"></a>Explain(执行计划)</h5><p>是什么：使用 <strong>Explain</strong> 关键字可以模拟优化器执行SQL查询语句，从而知道 MySQL 是如何处理你的 SQL 语句的。分析你的查询语句或是表结构的性能瓶颈</p>
<p>能干吗：</p>
<ul>
<li>表的读取顺序</li>
<li>数据读取操作的操作类型</li>
<li>哪些索引可以使用</li>
<li>哪些索引被实际使用</li>
<li>表之间的引用</li>
<li>每张表有多少行被优化器查询</li>
</ul>
<p>怎么玩：</p>
<ul>
<li>Explain + SQL语句</li>
<li>执行计划包含的信息（如果有分区表的话还会有<strong>partitions</strong>）</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539945-f25d6d79-1cb8-42b6-a6fa-b57a1ba9b5c9.webp" alt="image">expalin</p>
<p>各字段解释</p>
<ul>
<li><p><strong>id</strong>（select 查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序）</p>
</li>
<li><ul>
<li>id相同，执行顺序从上往下<ul>
<li>id全不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</li>
<li>id部分相同，执行顺序是先按照数字大的先执行，然后数字相同的按照从上往下的顺序执行</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>select_type</strong>（查询类型，用于区别普通查询、联合查询、子查询等复杂查询）</p>
</li>
<li><ul>
<li><strong>SIMPLE</strong> ：简单的select查询，查询中不包含子查询或UNION<ul>
<li><strong>PRIMARY</strong>：查询中若包含任何复杂的子部分，最外层查询被标记为PRIMARY</li>
<li><strong>SUBQUERY</strong>：在select或where列表中包含了子查询</li>
<li><strong>DERIVED</strong>：在from列表中包含的子查询被标记为DERIVED，MySQL会递归执行这些子查询，把结果放在临时表里</li>
<li><strong>UNION</strong>：若第二个select出现在UNION之后，则被标记为UNION，若UNION包含在from子句的子查询中，外层select将被标记为DERIVED</li>
<li><strong>UNION RESULT</strong>：从UNION表获取结果的select</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>table</strong>（显示这一行的数据是关于哪张表的）</p>
</li>
<li><p><strong>type</strong>（显示查询使用了那种类型，从最好到最差依次排列 <strong>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</strong> ）<br>  tip: 一般来说，得保证查询至少达到range级别，最好到达ref</p>
</li>
<li><ul>
<li>system：表只有一行记录（等于系统表），是 const 类型的特例，平时不会出现<ul>
<li>const：表示通过索引一次就找到了，const 用于比较 primary key 或 unique 索引，因为只要匹配一行数据，所以很快，如将主键置于 where 列表中，mysql 就能将该查询转换为一个常量</li>
<li>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常见于主键或唯一索引扫描</li>
<li>ref：非唯一性索引扫描，范围匹配某个单独值得所有行。本质上也是一种索引访问，他返回所有匹配某个单独值的行，然而，它可能也会找到多个符合条件的行，多以他应该属于查找和扫描的混合体</li>
<li>range：只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引，一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询，这种范围扫描索引比全表扫描要好，因为它只需开始于索引的某一点，而结束于另一点，不用扫描全部索引</li>
<li>index：Full Index Scan，index于ALL区别为index类型只遍历索引树。通常比ALL快，因为索引文件通常比数据文件小。（<strong>也就是说虽然all和index都是读全表，但index是从索引中读取的，而all是从硬盘中读的</strong>）</li>
<li>ALL：Full Table Scan，将遍历全表找到匹配的行</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>possible_keys</strong>（显示可能应用在这张表中的索引，一个或多个，查询涉及到的字段若存在索引，则该索引将被列出，但不一定被查询实际使用）</p>
</li>
<li><p><strong>key</strong></p>
</li>
<li><ul>
<li>实际使用的索引，如果为NULL，则没有使用索引<ul>
<li><strong>查询中若使用了覆盖索引，则该索引和查询的 select 字段重叠，仅出现在key列表中</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539958-bcf79915-a194-4c29-9bb0-f8a828626624.webp" alt="image">explain-key</p>
<ul>
<li><p><strong>key_len</strong></p>
</li>
<li><ul>
<li>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好<ul>
<li>key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>ref</strong>（显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值）</p>
</li>
<li><p><strong>rows</strong>（根据表统计信息及索引选用情况，大致估算找到所需的记录所需要读取的行数）</p>
</li>
<li><p><strong>Extra</strong>（包含不适合在其他列中显示但十分重要的额外信息）</p>
</li>
</ul>
<ol>
<li><ol>
<li>using filesort: 说明mysql会对数据使用一个外部的索引排序，不是按照表内的索引顺序进行读取。mysql中无法利用索引完成的排序操作称为“文件排序”。常见于order by和group by语句中<ol start="2">
<li>Using temporary：使用了临时表保存中间结果，mysql在对查询结果排序时使用临时表。常见于排序order by和分组查询group by。</li>
<li>using index：表示相应的select操作中使用了覆盖索引，避免访问了表的数据行，效率不错，如果同时出现using where，表明索引被用来执行索引键值的查找；否则索引被用来读取数据而非执行查找操作</li>
<li>using where：使用了where过滤</li>
<li>using join buffer：使用了连接缓存</li>
<li>impossible where：where子句的值总是false，不能用来获取任何元祖</li>
<li>select tables optimized away：在没有group by子句的情况下，基于索引优化操作或对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化</li>
<li>distinct：优化distinct操作，在找到第一匹配的元祖后即停止找同样值的动作</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><strong>case</strong>:</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539975-a8ae7858-047b-4816-a2d7-c5b3cab09fab.webp" alt="image">explain-demo</p>
<ol>
<li>第一行（执行顺序4）：id列为1，表示是union里的第一个select，select_type列的primary表示该查询为外层查询，table列被标记为，表示查询结果来自一个衍生表，其中derived3中3代表该查询衍生自第三个select查询，即id为3的select。【select d1.name……】</li>
<li>第二行（执行顺序2）：id为3，是整个查询中第三个select的一部分。因查询包含在from中，所以为derived。【select id,name from t1 where other_column=’’】</li>
<li>第三行（执行顺序3）：select列表中的子查询select_type为subquery，为整个查询中的第二个select。【select id from t3】</li>
<li>第四行（执行顺序1）：select_type为union，说明第四个select是union里的第二个select，最先执行【select name,id from t2】</li>
<li>第五行（执行顺序5）：代表从union的临时表中读取行的阶段，table列的&lt;union1,4&gt;表示用第一个和第四个select的结果进行union操作。【两个结果union操作】</li>
</ol>
<h5 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h5><p>MySQL 的慢查询日志是 MySQL 提供的一种日志记录，它用来记录在 MySQL 中响应时间超过阈值的语句，具体指运行时间超过 <code>long_query_time</code> 值的 SQL，则会被记录到慢查询日志中。</p>
<ul>
<li><code>long_query_time</code> 的默认值为10，意思是运行10秒以上的语句</li>
<li>默认情况下，MySQL数据库没有开启慢查询日志，需要手动设置参数开启</li>
</ul>
<p><strong>查看开启状态</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">&#x27;%slow_query_log%&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>开启慢查询日志</strong></p>
<ul>
<li>临时配置：</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">mysql&gt; <span class="builtin-name">set</span> global <span class="attribute">slow_query_log</span>=<span class="string">&#x27;ON&#x27;</span>;</span><br><span class="line">mysql&gt; <span class="builtin-name">set</span> global <span class="attribute">slow_query_log_file</span>=<span class="string">&#x27;/var/lib/mysql/hostname-slow.log&#x27;</span>;</span><br><span class="line">mysql&gt; <span class="builtin-name">set</span> global <span class="attribute">long_query_time</span>=2;</span><br></pre></td></tr></table></figure>

<p>也可set文件位置，系统会默认给一个缺省文件host_name-slow.log</p>
<p>使用set操作开启慢查询日志只对当前数据库生效，如果MySQL重启则会失效。</p>
<ul>
<li>永久配置<br>  修改配置文件my.cnf或my.ini，在[mysqld]一行下面加入两个配置参数</li>
</ul>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">slow_query_log</span> = <span class="literal">ON</span></span><br><span class="line"><span class="attr">slow_query_log_file</span> = /var/lib/mysql/hostname-slow.log</span><br><span class="line"><span class="attr">long_query_time</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>注：log-slow-queries 参数为慢查询日志存放的位置，一般这个目录要有 MySQL 的运行帐号的可写权限，一般都将这个目录设置为 MySQL 的数据存放目录；long_query_time=2 中的 2 表示查询超过两秒才记录；在my.cnf或者 my.ini 中添加 log-queries-not-using-indexes 参数，表示记录下没有使用索引的查询。</p>
<p>可以用 <code>select sleep(4)</code> 验证是否成功开启。</p>
<p>在生产环境中，如果手工分析日志，查找、分析SQL，还是比较费劲的，所以MySQL提供了日志分析工具<strong>mysqldumpslow</strong>。</p>
<p>通过 mysqldumpslow –help 查看操作帮助信息</p>
<ul>
<li>得到返回记录集最多的10个SQL<br>  <code>mysqldumpslow -s r -t 10 /var/lib/mysql/hostname-slow.log</code></li>
<li>得到访问次数最多的10个SQL<br>  <code>mysqldumpslow -s c -t 10 /var/lib/mysql/hostname-slow.log</code></li>
<li>得到按照时间排序的前10条里面含有左连接的查询语句<br>  <code>mysqldumpslow -s t -t 10 -g &quot;left join&quot; /var/lib/mysql/hostname-slow.log</code></li>
<li>也可以和管道配合使用<br>  <code>mysqldumpslow -s r -t 10 /var/lib/mysql/hostname-slow.log | more</code></li>
</ul>
<p><strong>也可使用 pt-query-digest 分析 RDS MySQL 慢查询日志</strong></p>
<h5 id="Show-Profile-分析查询"><a href="#Show-Profile-分析查询" class="headerlink" title="Show Profile 分析查询"></a>Show Profile 分析查询</h5><p>通过慢日志查询可以知道哪些 SQL 语句执行效率低下，通过 explain 我们可以得知 SQL 语句的具体执行情况，索引使用等，还可以结合<code>Show Profile</code>命令查看执行状态。</p>
<ul>
<li><p>Show Profile 是 MySQL 提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于SQL的调优的测量</p>
</li>
<li><p>默认情况下，参数处于关闭状态，并保存最近15次的运行结果</p>
</li>
<li><p>分析步骤<br>  mysql&gt; show profiles; +———-+————+———————————+ | Query_ID | Duration  | Query              | +———-+————+———————————+ |     1 | 0.00385450 | show variables like “profiling” | |     2 | 0.00170050 | show variables like “profiling” | |     3 | 0.00038025 | select * from t_base_user    | +———-+————+———————————+</p>
</li>
<li><ul>
<li>converting HEAP to MyISAM 查询结果太大，内存都不够用了往磁盘上搬了。<ul>
<li>create tmp table 创建临时表，这个要注意</li>
<li>Copying to tmp table on disk  把内存临时表复制到磁盘</li>
<li>locked</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li><ol>
<li>诊断SQL，show profile cpu,block io for query  id(上一步前面的问题SQL数字号码)<ol start="2">
<li>日常开发需要注意的结论</li>
<li>是否支持，看看当前的mysql版本是否支持</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">mysql&gt;Show  <span class="keyword">variables</span> like <span class="comment">&#x27;profiling&#x27;</span>;  --默认是关闭，使用前需要开启</span><br></pre></td></tr></table></figure>

<ol>
<li><ol>
<li>开启功能，默认是关闭，使用前需要开启</li>
</ol>
</li>
</ol>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">mysql&gt;<span class="builtin-name">set</span> <span class="attribute">profiling</span>=1;</span><br></pre></td></tr></table></figure>

<ol>
<li><ol>
<li>运行SQL<ol start="2">
<li>查看结果</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>❝查询中哪些情况不会使用索引？</p>
</blockquote>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><h4 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h4><ol>
<li>全值匹配我最爱</li>
<li>最佳左前缀法则，比如建立了一个联合索引(a,b,c)，那么其实我们可利用的索引就有(a), (a,b), (a,b,c)</li>
<li>不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描</li>
<li>存储引擎不能使用索引中范围条件右边的列</li>
<li>尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致))，减少select</li>
<li>is null ,is not null 也无法使用索引</li>
<li>like “xxxx%” 是可以用到索引的，like “%xxxx” 则不行(like “%xxx%” 同理)。like以通配符开头(‘%abc…’)索引失效会变成全表扫描的操作，</li>
<li>字符串不加单引号索引失效</li>
<li>少用or，用它来连接时会索引失效</li>
<li>&lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN 可用到索引，&lt;&gt;，not in ，!= 则不行，会导致全表扫描</li>
</ol>
<p><strong>一般性建议</strong></p>
<ul>
<li>对于单键索引，尽量选择针对当前query过滤性更好的索引</li>
<li>在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。</li>
<li>在选择组合索引的时候，尽量选择可以能够包含当前query中的where字句中更多字段的索引</li>
<li>尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的</li>
<li>少用Hint强制索引</li>
</ul>
<h4 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h4><p><strong>永远小表驱动大表（小的数据集驱动大的数据集）</strong></p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">slect * <span class="keyword">from</span> A <span class="keyword">where</span> <span class="built_in">id</span> <span class="keyword">in</span> (select <span class="built_in">id</span> <span class="keyword">from</span> B)`等价于</span><br><span class="line"><span class="comment">#等价于</span></span><br><span class="line">select <span class="built_in">id</span> <span class="keyword">from</span> B</span><br><span class="line">select * <span class="keyword">from</span> A <span class="keyword">where</span> A.<span class="built_in">id</span>=B.<span class="built_in">id</span></span><br></pre></td></tr></table></figure>

<p>当 B 表的数据集必须小于 A 表的数据集时，用 in 优于 exists</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> B <span class="keyword">where</span> B.id=A.id)</span><br><span class="line"><span class="comment">#等价于</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> B <span class="keyword">where</span> B.id = A.id<span class="string">`</span></span><br></pre></td></tr></table></figure>

<p>当 A 表的数据集小于B表的数据集时，用 exists优于用 in</p>
<p>注意：A表与B表的ID字段应建立索引。</p>
<p><strong>order by关键字优化</strong></p>
<ul>
<li><p>order by子句，尽量使用 Index 方式排序，避免使用 FileSort 方式排序</p>
</li>
<li><p>MySQL 支持两种方式的排序，FileSort 和 Index，Index效率高，它指 MySQL 扫描索引本身完成排序，FileSort 效率较低；</p>
</li>
<li><p>ORDER BY 满足两种情况，会使用Index方式排序；①ORDER BY语句使用索引最左前列 ②使用where子句与ORDER BY子句条件列组合满足索引最左前列</p>
</li>
<li><p>尽可能在索引列上完成排序操作，遵照索引建的最佳最前缀</p>
</li>
<li><p>如果不在索引列上，filesort 有两种算法，mysql就要启动双路排序和单路排序</p>
</li>
<li><ul>
<li>双路排序：MySQL 4.1之前是使用双路排序,字面意思就是两次扫描磁盘，最终得到数据<ul>
<li>单路排序：从磁盘读取查询需要的所有列，按照order by 列在 buffer对它们进行排序，然后扫描排序后的列表进行输出，效率高于双路排序</li>
</ul>
</li>
</ul>
</li>
<li><p>优化策略</p>
</li>
<li><ul>
<li>增大sort_buffer_size参数的设置<ul>
<li>增大max_lencth_for_sort_data参数的设置</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>GROUP BY关键字优化</strong></p>
<ul>
<li>group by实质是先排序后进行分组，遵照索引建的最佳左前缀</li>
<li>当无法使用索引列，增大 <code>max_length_for_sort_data</code> 参数的设置，增大<code>sort_buffer_size</code>参数的设置</li>
<li>where高于having，能写在where限定的条件就不要去having限定了</li>
</ul>
<h4 id="数据类型优化"><a href="#数据类型优化" class="headerlink" title="数据类型优化"></a>数据类型优化</h4><p>MySQL 支持的数据类型非常多，选择正确的数据类型对于获取高性能至关重要。不管存储哪种类型的数据，下面几个简单的原则都有助于做出更好的选择。</p>
<ul>
<li>更小的通常更好：一般情况下，应该尽量使用可以正确存储数据的最小数据类型。<br>  简单就好：简单的数据类型通常需要更少的CPU周期。例如，整数比字符操作代价更低，因为字符集和校对规则（排序规则）使字符比较比整型比较复杂。</li>
<li>尽量避免NULL：通常情况下最好指定列为NOT NULL</li>
</ul>
<h2 id="九、分区、分表、分库"><a href="#九、分区、分表、分库" class="headerlink" title="九、分区、分表、分库"></a>九、分区、分表、分库</h2><h3 id="MySQL分区"><a href="#MySQL分区" class="headerlink" title="MySQL分区"></a>MySQL分区</h3><p>一般情况下我们创建的表对应一组存储文件，使用<code>MyISAM</code>存储引擎时是一个<code>.MYI</code>和<code>.MYD</code>文件，使用<code>Innodb</code>存储引擎时是一个<code>.ibd</code>和<code>.frm</code>（表结构）文件。</p>
<p>当数据量较大时（一般千万条记录级别以上），MySQL的性能就会开始下降，这时我们就需要将数据分散到多组存储文件，保证其单个文件的执行效率</p>
<p><strong>能干嘛</strong></p>
<ul>
<li>逻辑数据分割</li>
<li>提高单一的写和读应用速度</li>
<li>提高分区范围读查询的速度</li>
<li>分割数据能够有多个不同的物理文件路径</li>
<li>高效的保存历史数据</li>
</ul>
<p><strong>怎么玩</strong></p>
<p>首先查看当前数据库是否支持分区</p>
<ul>
<li>MySQL5.6以及之前版本：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">&#x27;%partition%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>MySQL5.6：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> plugins;</span><br></pre></td></tr></table></figure>

<p><strong>分区类型及操作</strong></p>
<ul>
<li><strong>RANGE分区</strong>：基于属于一个给定连续区间的列值，把多行分配给分区。mysql将会根据指定的拆分策略，,把数据放在不同的表文件上。相当于在文件上,被拆成了小块.但是,对外给客户的感觉还是一张表，透明的。<br>  按照 range 来分，就是每个库一段连续的数据，这个一般是按比如<strong>时间范围</strong>来的，比如交易表啊，销售表啊等，可以根据年月来存放数据。可能会产生热点问题，大量的流量都打在最新的数据上了。<br>  range 来分，好处在于说，扩容的时候很简单。</li>
<li><strong>LIST分区</strong>：类似于按RANGE分区，每个分区必须明确定义。它们的主要区别在于，LIST分区中每个分区的定义和选择是基于某列的值从属于一个值列表集中的一个值，而RANGE分区是从属于一个连续区间值的集合。</li>
<li><strong>HASH分区</strong>：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL 中有效的、产生非负整数值的任何表达式。<br>  hash 分发，好处在于说，可以平均分配每个库的数据量和请求压力；坏处在于说扩容起来比较麻烦，会有一个数据迁移的过程，之前的数据需要重新计算 hash 值重新分配到不同的库或表</li>
<li><strong>KEY分区</strong>：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL服务器提供其自身的哈希函数。必须有一列或多列包含整数值。</li>
</ul>
<p><strong>看上去分区表很帅气，为什么大部分互联网还是更多的选择自己分库分表来水平扩展咧？</strong></p>
<ul>
<li>分区表，分区键设计不太灵活，如果不走分区键，很容易出现全表锁</li>
<li>一旦数据并发量上来，如果在分区表实施关联，就是一个灾难</li>
<li>自己分库分表，自己掌控业务场景与访问模式，可控。分区表，研发写了一个sql，都不确定mysql是怎么玩的，不太可控</li>
</ul>
<blockquote>
<p>❝</p>
<p>随着业务的发展，业务越来越复杂，应用的模块越来越多，总的数据量很大，高并发读写操作均超过单个数据库服务器的处理能力怎么办？</p>
</blockquote>
<p>这个时候就出现了<strong>数据分片</strong>，数据分片指按照某个维度将存放在单一数据库中的数据分散地存放至多个数据库或表中。数据分片的有效手段就是对关系型数据库进行分库和分表。</p>
<p>区别于分区的是，分区一般都是放在单机里的，用的比较多的是时间范围分区，方便归档。只不过分库分表需要代码实现，分区则是mysql内部实现。分库分表和分区并不冲突，可以结合使用。</p>
<blockquote>
<p>❝</p>
<p>说说分库与分表的设计</p>
</blockquote>
<h3 id="MySQL分表"><a href="#MySQL分表" class="headerlink" title="MySQL分表"></a>MySQL分表</h3><p>分表有两种分割方式，一种垂直拆分，另一种水平拆分。</p>
<ul>
<li><p><strong>垂直拆分</strong><br>  垂直分表，通常是按照业务功能的使用频次，把主要的、热门的字段放在一起做为主要表。然后把不常用的，按照各自的业务属性进行聚集，拆分到不同的次要表中；主要表和次要表的关系一般都是一对一的。</p>
</li>
<li><p><strong>水平拆分(数据分片)</strong><br>  单表的容量不超过500W，否则建议水平拆分。是把一个表复制成同样表结构的不同表，然后把数据按照一定的规则划分，分别存储到这些表中，从而保证单表的容量不会太大，提升性能；当然这些结构一样的表，可以放在一个或多个数据库中。<br>  水平分割的几种方法：</p>
</li>
<li><ul>
<li>使用MD5哈希，做法是对UID进行md5加密，然后取前几位（我们这里取前两位），然后就可以将不同的UID哈希到不同的用户表（user_xx）中了。<ul>
<li>还可根据时间放入不同的表，比如：article_201601，article_201602。</li>
<li>按热度拆分，高点击率的词条生成各自的一张表，低热度的词条都放在一张大表里，待低热度的词条达到一定的贴数后，再把低热度的表单独拆分成一张表。</li>
<li>根据ID的值放入对应的表，第一个表user_0000，第二个100万的用户数据放在第二 个表user_0001中，随用户增加，直接添加用户表就行了。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539957-9e85fd78-eebe-4644-a408-80ff3dfc87cd.webp?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<h3 id="MySQL分库"><a href="#MySQL分库" class="headerlink" title="MySQL分库"></a>MySQL分库</h3><blockquote>
<p>❝为什么要分库?</p>
</blockquote>
<p>数据库集群环境后都是多台 slave，基本满足了读取操作;  但是写入或者说大数据、频繁的写入操作对master性能影响就比较大，这个时候，单库并不能解决大规模并发写入的问题，所以就会考虑分库。</p>
<blockquote>
<p>❝分库是什么？</p>
</blockquote>
<p>一个库里表太多了，导致了海量数据，系统性能下降，把原本存储于一个库的表拆分存储到多个库上， 通常是将表按照功能模块、关系密切程度划分出来，部署到不同库上。</p>
<p>优点：</p>
<ul>
<li>减少增量数据写入时的锁对查询的影响</li>
<li>由于单表数量下降，常见的查询操作由于减少了需要扫描的记录，使得单表单次查询所需的检索行数变少，减少了磁盘IO，时延变短</li>
</ul>
<p>但是它无法解决单表数据量太大的问题</p>
<p><strong>分库分表后的难题</strong></p>
<p>分布式事务的问题，数据的完整性和一致性问题。</p>
<p>数据操作维度问题：用户、交易、订单各个不同的维度，用户查询维度、产品数据分析维度的不同对比分析角度。跨库联合查询的问题，可能需要两次查询 跨节点的count、order by、group by以及聚合函数问题，可能需要分别在各个节点上得到结果后在应用程序端进行合并 额外的数据管理负担，如：访问数据表的导航定位 额外的数据运算压力，如：需要在多个节点执行，然后再合并计算程序编码开发难度提升，没有太好的框架解决，更多依赖业务看如何分，如何合，是个难题。</p>
<blockquote>
<p>❝配主从，正经公司的话，也不会让 Javaer 去搞的，但还是要知道</p>
</blockquote>
<h2 id="十、主从复制"><a href="#十、主从复制" class="headerlink" title="十、主从复制"></a>十、主从复制</h2><h3 id="复制的基本原理"><a href="#复制的基本原理" class="headerlink" title="复制的基本原理"></a>复制的基本原理</h3><ul>
<li>slave 会从 master 读取 binlog 来进行数据同步</li>
<li>三个步骤<br>  <img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590540019-3b79bd00-05a5-47a9-a4bb-c594e451c33c.webp?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image">img</li>
</ul>
<ol>
<li><ol>
<li>master将改变记录到二进制日志（binary log）。这些记录过程叫做二进制日志事件，binary log events；<ol start="2">
<li>salve 将 master 的 binary log events 拷贝到它的中继日志（relay log）;</li>
<li>slave 重做中继日志中的事件，将改变应用到自己的数据库中。MySQL 复制是异步且是串行化的。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="复制的基本原则"><a href="#复制的基本原则" class="headerlink" title="复制的基本原则"></a>复制的基本原则</h3><ul>
<li>每个 slave只有一个 master</li>
<li>每个 salve只能有一个唯一的服务器 ID</li>
<li>每个master可以有多个salve</li>
</ul>
<h3 id="复制的最大问题"><a href="#复制的最大问题" class="headerlink" title="复制的最大问题"></a>复制的最大问题</h3><ul>
<li>延时</li>
</ul>
<h2 id="十一、其他问题"><a href="#十一、其他问题" class="headerlink" title="十一、其他问题"></a>十一、其他问题</h2><h3 id="说一说三个范式"><a href="#说一说三个范式" class="headerlink" title="说一说三个范式"></a>说一说三个范式</h3><ul>
<li>第一范式（1NF）：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。</li>
<li>第二范式（2NF）：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。</li>
<li>第三范式（3NF）：在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。所谓传递函数依赖，指的是如 果存在”A → B → C”的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系：关键字段 → 非关键字段 x → 非关键字段y</li>
</ul>
<h3 id="百万级别或以上的数据如何删除"><a href="#百万级别或以上的数据如何删除" class="headerlink" title="百万级别或以上的数据如何删除"></a>百万级别或以上的数据如何删除</h3><p>关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。</p>
<ol>
<li>所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）</li>
<li>然后删除其中无用数据（此过程需要不到两分钟）</li>
<li>删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。</li>
<li>与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。</li>
</ol>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>阶段汇总集合：<a href="http://mp.weixin.qq.com/s?__biz=MzIyNDU2ODA4OQ==&mid=2247486073&idx=2&sn=a26a44e561a468d94be99761ab5fc1fc&chksm=e80dbc0fdf7a3519999f1fdf0ee5b98b12a519c539f3ede9152ef66e4a3fb6a7f771cc2db382&scene=21#wechat_redirect">001期~180期汇总，方便阅读（增加设计模式）</a></p>
<p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/10/java4-1602932967.png" alt="Redis 常见面试题（2020最新版）"></p>
<h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><h3 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h3><p>Redis(Remote Dictionary Server) 是一个使用 C 语言编写的，开源的（BSD许可）高性能非关系型（NoSQL）的键值对数据库。</p>
<p>Redis 可以存储键和五种不同类型的值之间的映射。键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。</p>
<p>与传统数据库不同的是 Redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存方向，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。另外，Redis 也经常用来做分布式锁。除此之外，Redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。</p>
<h3 id="Redis有哪些优缺点"><a href="#Redis有哪些优缺点" class="headerlink" title="Redis有哪些优缺点"></a>Redis有哪些优缺点</h3><ul>
<li><p>优点</p>
<ul>
<li>读写性能优异， Redis能读的速度是110000次/s，写的速度是81000次/s。</li>
<li>支持数据持久化，支持AOF和RDB两种持久化方式。</li>
<li>支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。</li>
<li>数据结构丰富，除了支持string类型的value外还支持hash、set、zset、list等数据结构。</li>
<li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</li>
<li>Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。</li>
<li>主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。</li>
<li>Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。</li>
</ul>
</li>
</ul>
<h3 id="为什么要用-Redis-为什么要用缓存"><a href="#为什么要用-Redis-为什么要用缓存" class="headerlink" title="为什么要用 Redis /为什么要用缓存"></a>为什么要用 Redis /为什么要用缓存</h3><p>主要从“高性能”和“高并发”这两点来看待这个问题。</p>
<h4 id="高性能："><a href="#高性能：" class="headerlink" title="高性能："></a>高性能：</h4><p>假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p>
<p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/10/java6-1602932967.png" alt="Redis 常见面试题（2020最新版）">img</p>
<h4 id="高并发："><a href="#高并发：" class="headerlink" title="高并发："></a>高并发：</h4><p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p>
<p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/10/java0-1602932967.png" alt="Redis 常见面试题（2020最新版）">img</p>
<h3 id="为什么要用-Redis-而不用-map-guava-做缓存"><a href="#为什么要用-Redis-而不用-map-guava-做缓存" class="headerlink" title="为什么要用 Redis 而不用 map/guava 做缓存?"></a>为什么要用 Redis 而不用 map/guava 做缓存?</h3><p>缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。</p>
<p>使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 或 memcached服务的高可用，整个程序架构上较为复杂。</p>
<h3 id="Redis为什么这么快"><a href="#Redis为什么这么快" class="headerlink" title="Redis为什么这么快"></a>Redis为什么这么快</h3><p>1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)；</p>
<p>2、数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的；</p>
<p>3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</p>
<p>4、使用多路 I/O 复用模型，非阻塞 IO；</p>
<p>5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="Redis有哪些数据类型"><a href="#Redis有哪些数据类型" class="headerlink" title="Redis有哪些数据类型"></a>Redis有哪些数据类型</h3><p>Redis主要有5种数据类型，包括String，List，Set，Zset，Hash，满足大部分的使用要求</p>
<p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/10/java3-1602932967.png" alt="Redis 常见面试题（2020最新版）"></p>
<h3 id="Redis的应用场景"><a href="#Redis的应用场景" class="headerlink" title="Redis的应用场景"></a>Redis的应用场景</h3><h3 id="总结一"><a href="#总结一" class="headerlink" title="总结一"></a>总结一</h3><ul>
<li>计数器</li>
</ul>
<p>可以对 String 进行自增自减运算，从而实现计数器功能。Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。</p>
<ul>
<li>缓存</li>
</ul>
<p>将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。</p>
<ul>
<li>会话缓存</li>
</ul>
<p>可以使用 Redis 来统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。</p>
<ul>
<li>全页缓存（FPC）</li>
</ul>
<p>除基本的会话token之外，Redis还提供很简便的FPC平台。以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</p>
<ul>
<li>查找表</li>
</ul>
<p>例如 DNS 记录就很适合使用 Redis 进行存储。查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。</p>
<ul>
<li>消息队列(发布/订阅功能)</li>
</ul>
<p>List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息。不过最好使用 Kafka、RabbitMQ 等消息中间件。</p>
<ul>
<li>分布式锁实现</li>
</ul>
<p>在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。</p>
<ul>
<li>其它</li>
</ul>
<p>Set 可以实现交集、并集等操作，从而实现共同好友等功能。ZSet 可以实现有序性操作，从而实现排行榜等功能。</p>
<h4 id="总结二"><a href="#总结二" class="headerlink" title="总结二"></a>总结二</h4><p>Redis相比其他缓存，有一个非常大的优势，就是支持多种数据类型。</p>
<p>数据类型说明string字符串，最简单的k-v存储hashhash格式，value为field和value，适合ID-Detail这样的场景。list简单的list，顺序列表，支持首位或者末尾插入数据set无序list，查找速度快，适合交集、并集、差集处理sorted set有序的set</p>
<p>其实，通过上面的数据类型的特性，基本就能想到合适的应用场景了。</p>
<p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/10/java8-1602932967.png" alt="Redis 常见面试题（2020最新版）"></p>
<p>如上所述，虽然Redis不像关系数据库那么复杂的数据结构，但是，也能适合很多场景，比一般的缓存数据结构要多。了解每种数据结构适合的业务场景，不仅有利于提升开发效率，也能有效利用Redis的性能。</p>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h3 id="什么是Redis持久化？"><a href="#什么是Redis持久化？" class="headerlink" title="什么是Redis持久化？"></a>什么是Redis持久化？</h3><p>持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。</p>
<h3 id="Redis-的持久化机制是什么？各自的优缺点？"><a href="#Redis-的持久化机制是什么？各自的优缺点？" class="headerlink" title="Redis 的持久化机制是什么？各自的优缺点？"></a>Redis 的持久化机制是什么？各自的优缺点？</h3><p>Redis 提供两种持久化机制 RDB（默认） 和 AOF 机制:</p>
<p><strong>RDB：是Redis DataBase缩写快照</strong></p>
<p>RDB是Redis默认的持久化方式。按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为dump.rdb。通过配置文件中的save参数来定义快照的周期。</p>
<p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/10/java0-1602932967-1.png" alt="Redis 常见面试题（2020最新版）">img</p>
<p>优点：</p>
<ul>
<li>1、只有一个文件 dump.rdb，方便持久化。</li>
<li>2、容灾性好，一个文件可以保存到安全的磁盘。</li>
<li>3、性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能</li>
<li>4.相对于数据集大时，比 AOF 的启动效率更高。</li>
</ul>
<p>缺点：</p>
<ul>
<li>1、数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候)</li>
<li>2、AOF（Append-only file)持久化方式：是指所有的命令行记录以 redis 命令请 求协议的格式完全持久化存储)保存为 aof 文件。</li>
</ul>
<p><strong>AOF：持久化</strong></p>
<p>AOF持久化(即Append Only File持久化)，则是将Redis执行的每次写命令记录到单独的日志文件中，当重启Redis会重新将持久化的日志中文件恢复数据。</p>
<p>当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。</p>
<p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/10/java6-1602932967-1.png" alt="Redis 常见面试题（2020最新版）">img</p>
<p>优点：</p>
<ul>
<li>1、数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次。</li>
<li>2、通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。</li>
<li>3、AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）)</li>
</ul>
<p>缺点：</p>
<ul>
<li>1、AOF 文件比 RDB 文件大，且恢复速度慢。</li>
<li>2、数据集大的时候，比 rdb 启动效率低。</li>
</ul>
<p>优缺点是什么？</p>
<ul>
<li>AOF文件比RDB更新频率高，优先使用AOF还原数据。</li>
<li>AOF比RDB更安全也更大</li>
<li>RDB性能比AOF好</li>
<li>如果两个都配了优先加载AOF</li>
</ul>
<h3 id="如何选择合适的持久化方式"><a href="#如何选择合适的持久化方式" class="headerlink" title="如何选择合适的持久化方式"></a>如何选择合适的持久化方式</h3><ul>
<li>一般来说， 如果想达到足以媲美PostgreSQL的数据安全性，你应该同时使用两种持久化功能。在这种情况下，当 Redis 重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</li>
<li>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以只使用RDB持久化。</li>
<li>有很多用户都只使用AOF持久化，但并不推荐这种方式，因为定时生成RDB快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比AOF恢复的速度要快，除此之外，使用RDB还可以避免AOF程序的bug。</li>
<li>如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式。</li>
</ul>
<h3 id="Redis持久化数据和缓存怎么做扩容？"><a href="#Redis持久化数据和缓存怎么做扩容？" class="headerlink" title="Redis持久化数据和缓存怎么做扩容？"></a>Redis持久化数据和缓存怎么做扩容？</h3><ul>
<li>如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。</li>
<li>如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。</li>
</ul>
<p>搜索公众号 Java面试题精选，回复“面试资料”，送你一份Java面试宝典.pdf</p>
<h2 id="过期键的删除策略"><a href="#过期键的删除策略" class="headerlink" title="过期键的删除策略"></a>过期键的删除策略</h2><h3 id="Redis的过期键的删除策略"><a href="#Redis的过期键的删除策略" class="headerlink" title="Redis的过期键的删除策略"></a>Redis的过期键的删除策略</h3><p>我们都知道，Redis是key-value数据库，我们可以设置Redis中缓存的key的过期时间。Redis的过期策略就是指当Redis中缓存的key过期了，Redis如何处理。</p>
<p>过期策略通常有以下三种：</p>
<ul>
<li>定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</li>
<li>惰性过期：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</li>
<li>定期过期：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。<br>  (expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。)</li>
</ul>
<p>Redis中同时使用了惰性过期和定期过期两种过期策略。</p>
<h3 id="Redis-key的过期时间和永久有效分别怎么设置？"><a href="#Redis-key的过期时间和永久有效分别怎么设置？" class="headerlink" title="Redis key的过期时间和永久有效分别怎么设置？"></a>Redis key的过期时间和永久有效分别怎么设置？</h3><p>EXPIRE和PERSIST命令。</p>
<h3 id="我们知道通过expire来设置key-的过期时间，那么对过期的数据怎么处理呢"><a href="#我们知道通过expire来设置key-的过期时间，那么对过期的数据怎么处理呢" class="headerlink" title="我们知道通过expire来设置key 的过期时间，那么对过期的数据怎么处理呢?"></a>我们知道通过expire来设置key 的过期时间，那么对过期的数据怎么处理呢?</h3><p>除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：</p>
<ol>
<li>定时去清理过期的缓存；</li>
<li>当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</li>
</ol>
<p>两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。</p>
<h2 id="内存相关"><a href="#内存相关" class="headerlink" title="内存相关"></a>内存相关</h2><h3 id="MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"><a href="#MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据" class="headerlink" title="MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"></a>MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据</h3><p>redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。</p>
<h3 id="Redis的内存淘汰策略有哪些"><a href="#Redis的内存淘汰策略有哪些" class="headerlink" title="Redis的内存淘汰策略有哪些"></a>Redis的内存淘汰策略有哪些</h3><p>Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。</p>
<p>全局的键空间选择性移除</p>
<ul>
<li>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。</li>
<li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。（这个是最常用的）</li>
<li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。</li>
</ul>
<p>设置过期时间的键空间选择性移除</p>
<ul>
<li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。</li>
<li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。</li>
<li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。</li>
</ul>
<p><strong>总结</strong></p>
<p>Redis的内存淘汰策略的选取并不会影响过期的key的处理。内存淘汰策略用于处理内存不足时的需要申请额外空间的数据；过期策略用于处理过期的缓存数据。</p>
<h3 id="Redis主要消耗什么物理资源？"><a href="#Redis主要消耗什么物理资源？" class="headerlink" title="Redis主要消耗什么物理资源？"></a>Redis主要消耗什么物理资源？</h3><p>内存。</p>
<h3 id="Redis的内存用完了会发生什么？"><a href="#Redis的内存用完了会发生什么？" class="headerlink" title="Redis的内存用完了会发生什么？"></a>Redis的内存用完了会发生什么？</h3><p>如果达到设置的上限，Redis的写命令会返回错误信息（但是读命令还可以正常返回。）或者你可以配置内存淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容。</p>
<h3 id="Redis如何做内存优化？"><a href="#Redis如何做内存优化？" class="headerlink" title="Redis如何做内存优化？"></a>Redis如何做内存优化？</h3><p>可以好好利用Hash,list,sorted set,set等集合类型数据，因为通常情况下很多小的Key-Value可以用更紧凑的方式存放到一起。尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key，而是应该把这个用户的所有信息存储到一张散列表里面</p>
<h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><h3 id="Redis线程模型"><a href="#Redis线程模型" class="headerlink" title="Redis线程模型"></a>Redis线程模型</h3><p>Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处理器（file event handler）。它的组成结构为4部分：多个套接字、IO多路复用程序、文件事件分派器、事件处理器。因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型。</p>
<ul>
<li>文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li>
<li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li>
</ul>
<p>虽然文件事件处理器以单线程方式运行， 但通过使用 I/O 多路复用程序来监听多个套接字， 文件事件处理器既实现了高性能的网络通信模型， 又可以很好地与 redis 服务器中其他同样以单线程方式运行的模块进行对接， 这保持了 Redis 内部单线程设计的简单性。</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h3><p>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
<p>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p>
<h3 id="Redis事务的概念"><a href="#Redis事务的概念" class="headerlink" title="Redis事务的概念"></a>Redis事务的概念</h3><p>Redis 事务的本质是通过MULTI、EXEC、WATCH等一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p>
<p>总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</p>
<p>搜索公众号 Java面试题精选，回复“面试资料”，送你一份Java面试宝典.pdf</p>
<h3 id="Redis事务的三个阶段"><a href="#Redis事务的三个阶段" class="headerlink" title="Redis事务的三个阶段"></a>Redis事务的三个阶段</h3><ol>
<li>事务开始 MULTI</li>
<li>命令入队</li>
<li>事务执行 EXEC</li>
</ol>
<p>事务执行过程中，如果服务端收到有EXEC、DISCARD、WATCH、MULTI之外的请求，将会把请求放入队列中排</p>
<h3 id="事务管理（ACID）概述"><a href="#事务管理（ACID）概述" class="headerlink" title="事务管理（ACID）概述"></a>事务管理（ACID）概述</h3><ul>
<li>原子性（Atomicity）</li>
</ul>
<p>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</p>
<ul>
<li>一致性（Consistency）</li>
</ul>
<p>事务前后数据的完整性必须保持一致。</p>
<ul>
<li>隔离性（Isolation）</li>
</ul>
<p>多个事务并发执行时，一个事务的执行不应影响其他事务的执行</p>
<ul>
<li>持久性（Durability）</li>
</ul>
<p>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响</p>
<p>Redis的事务总是具有ACID中的一致性和隔离性，其他特性是不支持的。当服务器运行在_AOF_持久化模式下，并且appendfsync选项的值为always时，事务也具有耐久性。</p>
<h3 id="Redis事务支持隔离性吗"><a href="#Redis事务支持隔离性吗" class="headerlink" title="Redis事务支持隔离性吗"></a>Redis事务支持隔离性吗</h3><p>Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，Redis 的事务是总是带有隔离性的。</p>
<h3 id="Redis事务保证原子性吗，支持回滚吗"><a href="#Redis事务保证原子性吗，支持回滚吗" class="headerlink" title="Redis事务保证原子性吗，支持回滚吗"></a>Redis事务保证原子性吗，支持回滚吗</h3><p>Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。</p>
<h3 id="Redis事务其他实现"><a href="#Redis事务其他实现" class="headerlink" title="Redis事务其他实现"></a>Redis事务其他实现</h3><ul>
<li>基于Lua脚本，Redis可以保证脚本内的命令一次性、按顺序地执行，<br>  其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完</li>
<li>基于中间标记变量，通过另外的标记变量来标识事务是否执行完成，读取数据时先读取该标记变量判断是否事务执行完成。但这样会需要额外写代码实现，比较繁琐</li>
</ul>
<h2 id="集群方案"><a href="#集群方案" class="headerlink" title="集群方案"></a>集群方案</h2><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/10/java7-1602932968.png" alt="Redis 常见面试题（2020最新版）"></p>
<p>哨兵的介绍</p>
<p>sentinel，中文名是哨兵。哨兵是 redis 集群机构中非常重要的一个组件，主要有以下功能：</p>
<ul>
<li>集群监控：负责监控 redis master 和 slave 进程是否正常工作。</li>
<li>消息通知：如果某个 redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</li>
<li>故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。</li>
<li>配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。</li>
</ul>
<p>哨兵用于实现 redis 集群的高可用，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。</p>
<ul>
<li>故障转移时，判断一个 master node 是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举的问题。</li>
<li>即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成部分的故障转移系统本身是单点的，那就很坑爹了。</li>
</ul>
<p>哨兵的核心知识</p>
<ul>
<li>哨兵至少需要 3 个实例，来保证自己的健壮性。</li>
<li>哨兵 + redis 主从的部署架构，是不保证数据零丢失的，只能保证 redis 集群的高可用性。</li>
<li>对于哨兵 + redis 主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。</li>
</ul>
<h3 id="官方Redis-Cluster-方案-服务端路由查询"><a href="#官方Redis-Cluster-方案-服务端路由查询" class="headerlink" title="官方Redis Cluster 方案(服务端路由查询)"></a>官方Redis Cluster 方案(服务端路由查询)</h3><p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/10/java9-1602932968.png" alt="Redis 常见面试题（2020最新版）"></p>
<p>redis 集群模式的工作原理能说一下么？在集群模式下，redis 的 key 是如何寻址的？分布式寻址都有哪些算法？了解一致性 hash 算法吗？</p>
<p><strong>简介</strong></p>
<p>Redis Cluster是一种服务端Sharding技术，3.0版本开始正式提供。Redis Cluster并没有使用一致性hash，而是采用slot(槽)的概念，一共分成16384个槽。将请求发送到任意节点，接收到请求的节点会将查询请求发送到正确的节点上执行</p>
<p><strong>方案说明</strong></p>
<ol>
<li>通过哈希的方式，将数据分片，每个节点均分存储一定哈希槽(哈希值)区间的数据，默认分配了16384 个槽位</li>
<li>每份数据分片会存储在多个互为主从的多节点上</li>
<li>数据写入先写主节点，再同步到从节点(支持配置为阻塞同步)</li>
<li>同一分片多个节点间的数据不保持一致性</li>
<li>读取数据时，当客户端操作的key没有分配在该节点上时，redis会返回转向指令，指向正确的节点</li>
<li>扩容时时需要需要把旧节点的数据迁移一部分到新节点</li>
</ol>
<p>在 redis cluster 架构下，每个 redis 要放开两个端口号，比如一个是 6379，另外一个就是 加1w 的端口号，比如 16379。</p>
<p>16379 端口号是用来进行节点间通信的，也就是 cluster bus 的东西，cluster bus 的通信，用来进行故障检测、配置更新、故障转移授权。cluster bus 用了另外一种二进制的协议，<code>gossip</code> 协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。</p>
<p>节点间的内部通信机制</p>
<p>基本通信原理</p>
<p>集群元数据的维护有两种方式：集中式、Gossip 协议。redis cluster 节点间采用 gossip 协议进行通信。</p>
<p>分布式寻址算法</p>
<ul>
<li>hash 算法（大量缓存重建）</li>
<li>一致性 hash 算法（自动缓存迁移）+ 虚拟节点（自动负载均衡）</li>
<li>redis cluster 的 hash slot 算法</li>
</ul>
<p>优点</p>
<ul>
<li>无中心架构，支持动态扩容，对业务透明</li>
<li>具备Sentinel的监控和自动Failover(故障转移)能力</li>
<li>客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可</li>
<li>高性能，客户端直连redis服务，免去了proxy代理的损耗</li>
</ul>
<p>缺点</p>
<ul>
<li>运维也很复杂，数据迁移需要人工干预</li>
<li>只能使用0号数据库</li>
<li>不支持批量操作(pipeline管道操作)</li>
<li>分布式逻辑和存储模块耦合等</li>
</ul>
<h3 id="基于客户端分配"><a href="#基于客户端分配" class="headerlink" title="基于客户端分配"></a>基于客户端分配</h3><p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/10/java0-1602932968.jpeg" alt="Redis 常见面试题（2020最新版）"></p>
<p><strong>简介</strong></p>
<p>Redis Sharding是Redis Cluster出来之前，业界普遍使用的多Redis实例集群方法。其主要思想是采用哈希算法将Redis数据的key进行散列，通过hash函数，特定的key会映射到特定的Redis节点上。Java redis客户端驱动jedis，支持Redis Sharding功能，即ShardedJedis以及结合缓存池的ShardedJedisPool</p>
<p>优点</p>
<ul>
<li>优势在于非常简单，服务端的Redis实例彼此独立，相互无关联，每个Redis实例像单服务器一样运行，非常容易线性扩展，系统的灵活性很强</li>
</ul>
<p>缺点</p>
<ul>
<li>由于sharding处理放到客户端，规模进一步扩大时给运维带来挑战。</li>
<li>客户端sharding不支持动态增删节点。服务端Redis实例群拓扑结构有变化时，每个客户端都需要更新调整。连接不能共享，当应用规模增大时，资源浪费制约优化</li>
</ul>
<h3 id="基于代理服务器分片"><a href="#基于代理服务器分片" class="headerlink" title="基于代理服务器分片"></a>基于代理服务器分片</h3><p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/10/java5-1602932968.jpeg" alt="Redis 常见面试题（2020最新版）"></p>
<p><strong>简介</strong></p>
<p>客户端发送请求到一个代理组件，代理解析客户端的数据，并将请求转发至正确的节点，最后将结果回复给客户端</p>
<p><strong>特征</strong></p>
<ul>
<li>透明接入，业务程序不用关心后端Redis实例，切换成本低</li>
<li>Proxy 的逻辑和存储的逻辑是隔离的</li>
<li>代理层多了一次转发，性能有所损耗</li>
</ul>
<p><strong>业界开源方案</strong></p>
<ul>
<li>Twtter开源的Twemproxy</li>
<li>豌豆荚开源的Codis</li>
</ul>
<h3 id="Redis-主从架构"><a href="#Redis-主从架构" class="headerlink" title="Redis 主从架构"></a>Redis 主从架构</h3><p>单机的 redis，能够承载的 QPS 大概就在上万到几万不等。对于缓存来说，一般都是用来支撑读高并发的。因此架构做成主从(master-slave)架构，一主多从，主负责写，并且将数据复制到其它的 slave 节点，从节点负责读。所有的读请求全部走从节点。这样也可以很轻松实现水平扩容，支撑读高并发。</p>
<p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/10/java1-1602932968.png" alt="Redis 常见面试题（2020最新版）">redis-master-slave</p>
<p>redis replication -&gt; 主从架构 -&gt; 读写分离 -&gt; 水平扩容支撑读高并发</p>
<p>redis replication 的核心机制</p>
<ul>
<li>redis 采用异步方式复制数据到 slave 节点，不过 redis2.8 开始，slave node 会周期性地确认自己每次复制的数据量；</li>
<li>一个 master node 是可以配置多个 slave node 的；</li>
<li>slave node 也可以连接其他的 slave node；</li>
<li>slave node 做复制的时候，不会 block master node 的正常工作；</li>
<li>slave node 在做复制的时候，也不会 block 对自己的查询操作，它会用旧的数据集来提供服务；但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了；</li>
<li>slave node 主要用来进行横向扩容，做读写分离，扩容的 slave node 可以提高读的吞吐量。</li>
</ul>
<p>注意，如果采用了主从架构，那么建议必须开启 master node 的持久化，不建议用 slave node 作为 master node 的数据热备，因为那样的话，如果你关掉 master 的持久化，可能在 master 宕机重启的时候数据是空的，然后可能一经过复制， slave node 的数据也丢了。</p>
<p>另外，master 的各种备份方案，也需要做。万一本地的所有文件丢失了，从备份中挑选一份 rdb 去恢复 master，这样才能确保启动的时候，是有数据的，即使采用了后续讲解的高可用机制，slave node 可以自动接管 master node，但也可能 sentinel 还没检测到 master failure，master node 就自动重启了，还是可能导致上面所有的 slave node 数据被清空。</p>
<p>往期面试题汇总：<a href="http://mp.weixin.qq.com/s?__biz=MzIyNDU2ODA4OQ==&mid=2247485351&idx=2&sn=214225ab4345f4d9c562900cb42a52ba&chksm=e80db1d1df7a38c741137246bf020a5f8970f74cd03530ccc4cb2258c1ced68e66e600e9e059&scene=21#wechat_redirect">001期~150期汇总</a></p>
<h4 id="redis-主从复制的核心原理"><a href="#redis-主从复制的核心原理" class="headerlink" title="redis 主从复制的核心原理"></a>redis 主从复制的核心原理</h4><p>当启动一个 slave node 的时候，它会发送一个 <code>PSYNC</code> 命令给 master node。</p>
<p>如果这是 slave node 初次连接到 master node，那么会触发一次 <code>full resynchronization</code> 全量复制。此时 master 会启动一个后台线程，开始生成一份 <code>RDB</code> 快照文件，</p>
<p>同时还会将从客户端 client 新收到的所有写命令缓存在内存中。<code>RDB</code> 文件生成完毕后， master 会将这个 <code>RDB</code> 发送给 slave，slave 会先写入本地磁盘，然后再从本地磁盘加载到内存中，</p>
<p>接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。</p>
<p>slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。</p>
<p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/10/java6-1602932968.png" alt="Redis 常见面试题（2020最新版）">redis-master-slave-replication</p>
<h4 id="过程原理"><a href="#过程原理" class="headerlink" title="过程原理"></a>过程原理</h4><ol>
<li>当从库和主库建立MS关系后，会向主数据库发送SYNC命令</li>
<li>主库接收到SYNC命令后会开始在后台保存快照(RDB持久化过程)，并将期间接收到的写命令缓存起来</li>
<li>当快照完成后，主Redis会将快照文件和所有缓存的写命令发送给从Redis</li>
<li>从Redis接收到后，会载入快照文件并且执行收到的缓存的命令</li>
<li>之后，主Redis每当接收到写命令时就会将命令发送从Redis，从而保证数据的一致</li>
</ol>
<p>缺点</p>
<ul>
<li>所有的slave节点数据的复制和同步都由master节点来处理，会照成master节点压力太大，使用主从从结构来解决</li>
</ul>
<h3 id="Redis集群的主从复制模型是怎样的？"><a href="#Redis集群的主从复制模型是怎样的？" class="headerlink" title="Redis集群的主从复制模型是怎样的？"></a>Redis集群的主从复制模型是怎样的？</h3><p>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型，每个节点都会有N-1个复制品</p>
<h3 id="生产环境中的-redis-是怎么部署的？"><a href="#生产环境中的-redis-是怎么部署的？" class="headerlink" title="生产环境中的 redis 是怎么部署的？"></a>生产环境中的 redis 是怎么部署的？</h3><p>redis cluster，10 台机器，5 台机器部署了 redis 主实例，另外 5 台机器部署了 redis 的从实例，每个主实例挂了一个从实例，5 个节点对外提供读写服务，每个节点的读写高峰qps可能可以达到每秒 5 万，5 台机器最多是 25 万读写请求/s。</p>
<p>机器是什么配置？32G 内存+ 8 核 CPU + 1T 磁盘，但是分配给 redis 进程的是10g内存，一般线上生产环境，redis 的内存尽量不要超过 10g，超过 10g 可能会有问题。</p>
<p>5 台机器对外提供读写，一共有 50g 内存。</p>
<p>因为每个主实例都挂了一个从实例，所以是高可用的，任何一个主实例宕机，都会自动故障迁移，redis 从实例会自动变成主实例继续提供读写服务。</p>
<p>你往内存里写的是什么数据？每条数据的大小是多少？商品数据，每条数据是 10kb。100 条数据是 1mb，10 万条数据是 1g。常驻内存的是 200 万条商品数据，占用内存是 20g，仅仅不到总内存的 50%。目前高峰期每秒就是 3500 左右的请求量。</p>
<p>其实大型的公司，会有基础架构的 team 负责缓存集群的运维。</p>
<h3 id="说说Redis哈希槽的概念？"><a href="#说说Redis哈希槽的概念？" class="headerlink" title="说说Redis哈希槽的概念？"></a>说说Redis哈希槽的概念？</h3><p>Redis集群没有使用一致性hash,而是引入了哈希槽的概念，Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。</p>
<h3 id="Redis集群会有写操作丢失吗？为什么？"><a href="#Redis集群会有写操作丢失吗？为什么？" class="headerlink" title="Redis集群会有写操作丢失吗？为什么？"></a>Redis集群会有写操作丢失吗？为什么？</h3><p>Redis并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。</p>
<h3 id="Redis集群之间是如何复制的？"><a href="#Redis集群之间是如何复制的？" class="headerlink" title="Redis集群之间是如何复制的？"></a>Redis集群之间是如何复制的？</h3><p>异步复制</p>
<h3 id="Redis集群最大节点个数是多少？"><a href="#Redis集群最大节点个数是多少？" class="headerlink" title="Redis集群最大节点个数是多少？"></a>Redis集群最大节点个数是多少？</h3><p>16384个</p>
<h3 id="Redis集群如何选择数据库？"><a href="#Redis集群如何选择数据库？" class="headerlink" title="Redis集群如何选择数据库？"></a>Redis集群如何选择数据库？</h3><p>Redis集群目前无法做数据库选择，默认在0数据库。</p>
<h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><h3 id="Redis是单线程的，如何提高多核CPU的利用率？"><a href="#Redis是单线程的，如何提高多核CPU的利用率？" class="headerlink" title="Redis是单线程的，如何提高多核CPU的利用率？"></a>Redis是单线程的，如何提高多核CPU的利用率？</h3><p>可以在同一个服务器部署多个Redis的实例，并把他们当作不同的服务器来使用，在某些时候，无论如何一个服务器是不够的， 所以，如果你想使用多个CPU，你可以考虑一下分片（shard）。</p>
<h3 id="为什么要做Redis分区？"><a href="#为什么要做Redis分区？" class="headerlink" title="为什么要做Redis分区？"></a>为什么要做Redis分区？</h3><p>分区可以让Redis管理更大的内存，Redis将可以使用所有机器的内存。如果没有分区，你最多只能使用一台机器的内存。分区使Redis的计算能力通过简单地增加计算机得到成倍提升，Redis的网络带宽也会随着计算机和网卡的增加而成倍增长。</p>
<h3 id="你知道有哪些Redis分区实现方案？"><a href="#你知道有哪些Redis分区实现方案？" class="headerlink" title="你知道有哪些Redis分区实现方案？"></a>你知道有哪些Redis分区实现方案？</h3><ul>
<li>客户端分区就是在客户端就已经决定数据会被存储到哪个redis节点或者从哪个redis节点读取。大多数客户端已经实现了客户端分区。</li>
<li>代理分区 意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。代理根据分区规则决定请求哪些Redis实例，然后根据Redis的响应结果返回给客户端。redis和memcached的一种代理实现就是Twemproxy</li>
<li>查询路由(Query routing) 的意思是客户端随机地请求任意一个redis实例，然后由Redis将请求转发给正确的Redis节点。Redis Cluster实现了一种混合形式的查询路由，但并不是直接将请求从一个redis节点转发到另一个redis节点，而是在客户端的帮助下直接redirected到正确的redis节点。</li>
</ul>
<h3 id="Redis分区有什么缺点？"><a href="#Redis分区有什么缺点？" class="headerlink" title="Redis分区有什么缺点？"></a>Redis分区有什么缺点？</h3><ul>
<li>涉及多个key的操作通常不会被支持。例如你不能对两个集合求交集，因为他们可能被存储到不同的Redis实例（实际上这种情况也有办法，但是不能直接使用交集指令）。</li>
<li>同时操作多个key,则不能使用Redis事务.</li>
<li>分区使用的粒度是key，不能使用一个非常长的排序key存储一个数据集（The partitioning granularity is the key, so it is not possible to shard a dataset with a single huge key like a very big sorted set）</li>
<li>当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的Redis实例和主机同时收集RDB / AOF文件。</li>
<li>分区时动态扩容或缩容可能非常复杂。Redis集群在运行时增加或者删除Redis节点，能做到最大程度对用户透明地数据再平衡，但其他一些客户端分区或者代理分区方法则不支持这种特性。然而，有一种预分片的技术也可以较好的解决这个问题。</li>
</ul>
<h2 id="分布式问题"><a href="#分布式问题" class="headerlink" title="分布式问题"></a>分布式问题</h2><h3 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h3><p>Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系Redis中可以使用SETNX命令实现分布式锁。</p>
<p>当且仅当 key 不存在，将 key 的值设为 value。若给定的 key 已经存在，则 SETNX 不做任何动作</p>
<p>SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。</p>
<p>返回值：设置成功，返回 1 。设置失败，返回 0 。</p>
<p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/10/java10-1602932968.png" alt="Redis 常见面试题（2020最新版）">img</p>
<p>使用SETNX完成同步锁的流程及事项如下：</p>
<p>使用SETNX命令获取锁，若返回0（key已存在，锁已存在）则获取失败，反之获取成功</p>
<p>为了防止获取锁后程序出现异常，导致其他线程/进程调用SETNX命令总是返回0而进入死锁状态，需要为该key设置一个“合理”的过期时间</p>
<p>释放锁，使用DEL命令将锁数据删除</p>
<h3 id="如何解决-Redis-的并发竞争-Key-问题"><a href="#如何解决-Redis-的并发竞争-Key-问题" class="headerlink" title="如何解决 Redis 的并发竞争 Key 问题"></a>如何解决 Redis 的并发竞争 Key 问题</h3><p>所谓 Redis 的并发竞争 Key 的问题也就是多个系统同时对一个 key 进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同！</p>
<p>推荐一种方案：分布式锁（zookeeper 和 redis 都可以实现分布式锁）。（如果不存在 Redis 的并发竞争 Key 问题，不要使用分布式锁，这样会影响性能）</p>
<p>基于zookeeper临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。</p>
<p>在实践中，当然是从以可靠性为主。所以首推Zookeeper。</p>
<p>参考：<a href="https://www.jianshu.com/p/8bddd381de06">https://www.jianshu.com/p/8bddd381de06</a></p>
<h3 id="分布式Redis是前期做还是后期规模上来了再做好？为什么？"><a href="#分布式Redis是前期做还是后期规模上来了再做好？为什么？" class="headerlink" title="分布式Redis是前期做还是后期规模上来了再做好？为什么？"></a>分布式Redis是前期做还是后期规模上来了再做好？为什么？</h3><p>既然Redis是如此的轻量（单实例只使用1M内存），为防止以后的扩容，最好的办法就是一开始就启动较多实例。即便你只有一台服务器，你也可以一开始就让Redis以分布式的方式运行，使用分区，在同一台服务器上启动多个实例。</p>
<p>一开始就多设置几个Redis实例，例如32或者64个实例，对大多数用户来说这操作起来可能比较麻烦，但是从长久来看做这点牺牲是值得的。</p>
<p>这样的话，当你的数据不断增长，需要更多的Redis服务器时，你需要做的就是仅仅将Redis实例从一台服务迁移到另外一台服务器而已（而不用考虑重新分区的问题）。一旦你添加了另一台服务器，你需要将你一半的Redis实例从第一台机器迁移到第二台机器。</p>
<h3 id="什么是-RedLock"><a href="#什么是-RedLock" class="headerlink" title="什么是 RedLock"></a>什么是 RedLock</h3><p>Redis 官方站提出了一种权威的基于 Redis 实现分布式锁的方式名叫 <em>Redlock</em>，此种方式比原先的单节点的方法更安全。它可以保证以下特性：</p>
<ol>
<li>安全特性：互斥访问，即永远只有一个 client 能拿到锁</li>
<li>避免死锁：最终 client 都可能拿到锁，不会出现死锁的情况，即使原本锁住某资源的 client crash 了或者出现了网络分区</li>
<li>容错性：只要大部分 Redis 节点存活就可以正常提供服务</li>
</ol>
<p>往期面试题汇总：<a href="http://mp.weixin.qq.com/s?__biz=MzIyNDU2ODA4OQ==&mid=2247485351&idx=2&sn=214225ab4345f4d9c562900cb42a52ba&chksm=e80db1d1df7a38c741137246bf020a5f8970f74cd03530ccc4cb2258c1ced68e66e600e9e059&scene=21#wechat_redirect">001期~150期汇总</a></p>
<h2 id="缓存异常"><a href="#缓存异常" class="headerlink" title="缓存异常"></a>缓存异常</h2><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩是指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p>解决方案</p>
<ol>
<li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li>
<li>一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。</li>
<li>给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存。</li>
</ol>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p>解决方案</p>
<ol>
<li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截；</li>
<li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</li>
<li>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力</li>
</ol>
<h3 id="附加"><a href="#附加" class="headerlink" title="附加"></a>附加</h3><p>对于空间的利用到达了一种极致，那就是Bitmap和布隆过滤器(Bloom Filter)。</p>
<p>Bitmap：典型的就是哈希表</p>
<p>缺点是，Bitmap对于每个元素只能记录1bit信息，如果还想完成额外的功能，恐怕只能靠牺牲更多的空间、时间来完成了。</p>
<p><strong>布隆过滤器（推荐）</strong></p>
<p>就是引入了k(k&gt;1)k(k&gt;1)个相互独立的哈希函数，保证在给定的空间、误判率下，完成元素判重的过程。</p>
<p>它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p>
<p>Bloom-Filter算法的核心思想就是利用多个不同的Hash函数来解决“冲突”。</p>
<p>Hash存在一个冲突（碰撞）的问题，用同一个Hash得到的两个URL的值有可能相同。为了减少冲突，我们可以多引入几个Hash，如果通过其中的一个Hash值我们得出某元素不在集合中，那么该元素肯定不在集合中。只有在所有的Hash函数告诉我们该元素在集合中时，才能确定该元素存在于集合中。这便是Bloom-Filter的基本思想。</p>
<p>Bloom-Filter一般用于在大数据量的集合中判定某元素是否存在。</p>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p>
<p>解决方案</p>
<ol>
<li>设置热点数据永远不过期。</li>
<li>加互斥锁，互斥锁</li>
</ol>
<h3 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h3><p>缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p>
<p>解决方案</p>
<ol>
<li>直接写个缓存刷新页面，上线时手工操作一下；</li>
<li>数据量不大，可以在项目启动的时候自动进行加载；</li>
<li>定时刷新缓存；</li>
</ol>
<h3 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h3><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p>
<p>缓存降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p>
<p>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p>
<ol>
<li>一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</li>
<li>警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</li>
<li>错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</li>
<li>严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</li>
</ol>
<p>服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。</p>
<h3 id="热点数据和冷数据"><a href="#热点数据和冷数据" class="headerlink" title="热点数据和冷数据"></a>热点数据和冷数据</h3><p>热点数据，缓存才有价值</p>
<p>对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。频繁修改的数据，看情况考虑使用缓存</p>
<p>对于热点数据，比如我们的某IM产品，生日祝福模块，当天的寿星列表，缓存以后可能读取数十万次。再举个例子，某导航产品，我们将导航信息，缓存以后可能读取数百万次。</p>
<p>数据更新前至少读取两次，缓存才有意义。这个是最基本的策略，如果缓存还没有起作用就失效了，那就没有太大价值了。</p>
<p>那存不存在，修改频率很高，但是又不得不考虑缓存的场景呢？有！比如，这个读取接口对数据库的压力很大，但是又是热点数据，这个时候就需要考虑通过缓存手段，减少数据库的压力，比如我们的某助手产品的，点赞数，收藏数，分享数等是非常典型的热点数据，但是又不断变化，此时就需要将数据同步保存到Redis缓存，减少数据库压力。</p>
<h3 id="缓存热点key"><a href="#缓存热点key" class="headerlink" title="缓存热点key"></a>缓存热点key</h3><p>缓存中的一个Key(比如一个促销商品)，在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p>
<p><strong>解决方案</strong></p>
<p>对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入DB查询</p>
<h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h2><h3 id="Redis支持的Java客户端都有哪些？官方推荐用哪个？"><a href="#Redis支持的Java客户端都有哪些？官方推荐用哪个？" class="headerlink" title="Redis支持的Java客户端都有哪些？官方推荐用哪个？"></a>Redis支持的Java客户端都有哪些？官方推荐用哪个？</h3><p>Redisson、Jedis、lettuce等等，官方推荐使用Redisson。</p>
<h3 id="Redis和Redisson有什么关系？"><a href="#Redis和Redisson有什么关系？" class="headerlink" title="Redis和Redisson有什么关系？"></a>Redis和Redisson有什么关系？</h3><p>Redisson是一个高级的分布式协调Redis客服端，能帮助用户在分布式环境中轻松实现一些Java的对象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish / Subscribe, HyperLogLog)。</p>
<h3 id="Jedis与Redisson对比有什么优缺点？"><a href="#Jedis与Redisson对比有什么优缺点？" class="headerlink" title="Jedis与Redisson对比有什么优缺点？"></a>Jedis与Redisson对比有什么优缺点？</h3><p>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p>
<h3 id="Redis与Memcached的区别"><a href="#Redis与Memcached的区别" class="headerlink" title="Redis与Memcached的区别"></a>Redis与Memcached的区别</h3><p>两者都是非关系型内存键值数据库，现在公司一般都是用 Redis 来实现缓存，而且 Redis 自身也越来越强大了！Redis 与 Memcached 主要有以下不同：</p>
<p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/10/java2-1602932968.png" alt="Redis 常见面试题（2020最新版）"></p>
<p>(1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型</p>
<p>(2) redis的速度比memcached快很多</p>
<p>(3) redis可以持久化其数据</p>
<h3 id="如何保证缓存与数据库双写时的数据一致性？"><a href="#如何保证缓存与数据库双写时的数据一致性？" class="headerlink" title="如何保证缓存与数据库双写时的数据一致性？"></a>如何保证缓存与数据库双写时的数据一致性？</h3><p>你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？</p>
<p>一般来说，就是如果你的系统不是严格要求缓存+数据库必须一致性的话，缓存可以稍微的跟数据库偶尔有不一致的情况，最好不要做这个方案，读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况</p>
<p>串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。</p>
<p>还有一种方式就是可能会暂时产生不一致的情况，但是发生的几率特别小，就是<strong>先更新数据库，然后再删除缓存。</strong></p>
<p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/10/java10-1602932968-1.png" alt="Redis 常见面试题（2020最新版）"></p>
<h3 id="Redis常见性能问题和解决方案？"><a href="#Redis常见性能问题和解决方案？" class="headerlink" title="Redis常见性能问题和解决方案？"></a>Redis常见性能问题和解决方案？</h3><ol>
<li>Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化。</li>
<li>如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。</li>
<li>为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内。</li>
<li>尽量避免在压力较大的主库上增加从库</li>
<li>Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。</li>
<li>为了Master的稳定性，主从复制不要用图状结构，用单向链表结构更稳定，即主从关系为：Master&lt;–Slave1&lt;–Slave2&lt;–Slave3…，这样的结构也方便解决单点故障问题，实现Slave对Master的替换，也即，如果Master挂了，可以立马启用Slave1做Master，其他不变。</li>
</ol>
<h3 id="Redis官方为什么不提供Windows版本？"><a href="#Redis官方为什么不提供Windows版本？" class="headerlink" title="Redis官方为什么不提供Windows版本？"></a>Redis官方为什么不提供Windows版本？</h3><p>因为目前Linux版本已经相当稳定，而且用户量很大，无需开发windows版本，反而会带来兼容性等问题。</p>
<h3 id="一个字符串类型的值能存储最大容量是多少？"><a href="#一个字符串类型的值能存储最大容量是多少？" class="headerlink" title="一个字符串类型的值能存储最大容量是多少？"></a>一个字符串类型的值能存储最大容量是多少？</h3><p>512M</p>
<h3 id="Redis如何做大量数据插入？"><a href="#Redis如何做大量数据插入？" class="headerlink" title="Redis如何做大量数据插入？"></a>Redis如何做大量数据插入？</h3><p>Redis2.6开始redis-cli支持一种新的被称之为pipe mode的新模式用于执行大量数据插入工作。</p>
<h3 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><a href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？" class="headerlink" title="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"></a>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？</h3><p>使用keys指令可以扫出指定模式的key列表。</p>
<p>对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？</p>
<p>这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p>
<h3 id="使用Redis做过异步队列吗，是如何实现的"><a href="#使用Redis做过异步队列吗，是如何实现的" class="headerlink" title="使用Redis做过异步队列吗，是如何实现的"></a>使用Redis做过异步队列吗，是如何实现的</h3><p>使用list类型保存数据信息，rpush生产消息，lpop消费消息，当lpop没有消息时，可以sleep一段时间，然后再检查有没有信息，如果不想sleep的话，可以使用blpop, 在没有信息的时候，会一直阻塞，直到信息的到来。redis可以通过pub/sub主题订阅模式实现一个生产者，多个消费者，当然也存在一定的缺点，当消费者下线时，生产的消息会丢失。</p>
<h3 id="Redis如何实现延时队列"><a href="#Redis如何实现延时队列" class="headerlink" title="Redis如何实现延时队列"></a>Redis如何实现延时队列</h3><p>使用sortedset，使用时间戳做score, 消息内容作为key,调用zadd来生产消息，消费者使用zrangbyscore获取n秒之前的数据做轮询处理。</p>
<h3 id="Redis回收进程如何工作的？"><a href="#Redis回收进程如何工作的？" class="headerlink" title="Redis回收进程如何工作的？"></a>Redis回收进程如何工作的？</h3><ol>
<li>一个客户端运行了新的命令，添加了新的数据。</li>
<li>Redis检查内存使用情况，如果大于maxmemory的限制， 则根据设定好的策略进行回收。</li>
<li>一个新的命令被执行，等等。</li>
<li>所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。</li>
</ol>
<p>如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。</p>
<h3 id="Redis回收使用的是什么算法？"><a href="#Redis回收使用的是什么算法？" class="headerlink" title="Redis回收使用的是什么算法？"></a>Redis回收使用的是什么算法？</h3><p>LRU算法</p>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="OSI七层体系结构"><a href="#OSI七层体系结构" class="headerlink" title="OSI七层体系结构"></a>OSI七层体系结构</h2><p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018114733.webp"></p>
<h2 id="中继设备"><a href="#中继设备" class="headerlink" title="中继设备"></a>中继设备</h2><p>* <strong>物理层</strong>中继系统：<strong>转发器</strong>(repeater)。</p>
<p>* <strong>数据链路层</strong>中继系统：<strong>网桥</strong>(bridge)。</p>
<p>* <strong>网络层</strong>中继系统：<strong>路由器</strong>(router)，路由器连接了多个网络，所以至少有2个以上IP地址。</p>
<p>* <strong>网络层以上</strong>的中继系统：**网关(**gateway)。</p>
<h2 id="各层数据"><a href="#各层数据" class="headerlink" title="各层数据"></a><strong>各层数据</strong></h2><p><strong>数据包(packet)：</strong>应用层；</p>
<p><strong>段(segment)：</strong>传输层;</p>
<p><strong>IP数据报(datagram)：</strong>网络层，也有人称IP数据包</p>
<p><strong>数据帧(frame)：</strong>数据链路层；</p>
<h2 id="每一层的协议"><a href="#每一层的协议" class="headerlink" title="每一层的协议"></a>每一层的协议</h2><ul>
<li>物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器，网关）</li>
<li>数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）</li>
<li>网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）</li>
<li>传输层：TCP、UDP、SPX</li>
<li>会话层：NFS、SQL、NETBIOS、RPC</li>
<li>表示层：JPEG、MPEG、ASII</li>
<li>应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS</li>
</ul>
<h2 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h2><blockquote>
<p>TCP/IP模型实际上是OSI模型的一个浓缩版本，它只有四个层次：</p>
</blockquote>
<ol>
<li>应用层，对应着OSI的应用层、表示层、会话层</li>
<li>传输层，对应着OSI的传输层</li>
<li>网络层，对应着OSI的网络层</li>
<li>网络接口层，对应着OSI的数据链路层和物理层</li>
</ol>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p><strong>1 TCP是面向连接的</strong>；</p>
<p><strong>2 每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）；</strong></p>
<p><strong>3 TCP提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达；</strong></p>
<p><strong>4 TCP提供全双工通信。</strong>TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；</p>
<p><strong>5 面向字节流。</strong>TCP中的“流”（stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。</p>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p><strong>1 UDP是无连接的；</strong></p>
<p><strong>2 UDP使用尽最大努力交付</strong>，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）；</p>
<p><strong>3 UDP是面向报文的；</strong></p>
<p><strong>4 UDP没有拥塞控制</strong>，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）；</p>
<p><strong>5 UDP支持一对一、一对多、多对一和多对多的交互通信；</strong></p>
<p><strong>6 UDP的首部开销小，</strong>只有8个字节，比TCP的20个字节的首部要短。</p>
<h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201016094553.png" alt="image"></p>
<p>握手之前主动打开连接的客户端结束CLOSED阶段，被动打开的服务器端也结束CLOSED阶段，并进入LISTEN阶段。随后开始“三次握手”：</p>
<p>（1）首先客户端向服务器端发送一段TCP报文，其中：</p>
<ul>
<li>标记位为SYN，表示“请求建立新连接”;</li>
<li>序号为Seq=X（X一般为1）；</li>
<li>客户端进入SYN-SENT阶段。</li>
</ul>
<p>（2）服务器端接收到来自客户端的TCP报文之后，结束LISTEN阶段。并返回一段TCP报文，其中：</p>
<ul>
<li>标志位为SYN和ACK；</li>
<li>序号为Seq=y；确认号为Ack=x+1；</li>
<li>服务器端进入SYN-RCVD阶段。</li>
</ul>
<p>（3）客户端接收到来自服务器端的确认收到数据的TCP报文之后，明确了从客户端到服务器的数据传输是正常的，结束SYN-SENT阶段。并返回最后一段TCP报文。其中：</p>
<ul>
<li>标志位为ACK；</li>
<li>序号为Seq=x+1，表示收到服务器端的确认号Ack，并将其值作为自己的序号值；</li>
<li>确认号为Ack=y+1，表示收到服务器端序号Seq，并将其值加1作为自己的确认号Ack的值；</li>
<li>随后客户端进入ESTABLISHED阶段。</li>
</ul>
<blockquote>
<p>注意：若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包</p>
</blockquote>
<h3 id="为什么要三次握手？"><a href="#为什么要三次握手？" class="headerlink" title="为什么要三次握手？"></a>为什么要三次握手？</h3><ol>
<li>保持信息对等。</li>
<li>防止请求超时导致脏连接。</li>
</ol>
<h3 id="两次握手会怎样？"><a href="#两次握手会怎样？" class="headerlink" title="两次握手会怎样？"></a>两次握手会怎样？</h3><p>如果两次握手就创建连接，客户端传输完数据并释放连接后，第一个超时的连接请求才到达服务器，服务器会认为是客户端创建新连接的请求，然后创建连接。此时客户端的状态不是SYN_SENT，所以会直接丢弃服务器传来的确认数据，导致最后只是服务器单方面建立了连接。</p>
<h3 id="三次握手时可以携带数据吗？"><a href="#三次握手时可以携带数据吗？" class="headerlink" title="三次握手时可以携带数据吗？"></a>三次握手时可以携带数据吗？</h3><ul>
<li>第三次握手是可以携带数据的，前两次握手是不可以携带数据的</li>
</ul>
<h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201016094655.png" alt="image"></p>
<ul>
<li>第一次挥手：客户端发送一个FIN，seq = u 用来关闭客户端到服务端的数据传送；</li>
<li>第二次挥手：服务端发送一个FIN，确认序号ACK = u+1给对方；</li>
<li>第三次挥手：服务端发送一个FIN，seq = w，确认序号ACK = u+1 用来关闭服务端到客户端的数据传送；</li>
<li>第四次挥手：客户端发送一个ACK = w+1 给服务端。</li>
</ul>
<h4 id="为什么不直接关闭而是进入TIME-WAIT（2MSL）呢？"><a href="#为什么不直接关闭而是进入TIME-WAIT（2MSL）呢？" class="headerlink" title="为什么不直接关闭而是进入TIME_WAIT（2MSL）呢？"></a>为什么不直接关闭而是进入TIME_WAIT（2MSL）呢？</h4><ol>
<li>客户端要确认服务器能收到ACK信号。(如果不确认这一点，服务器会认为客户端没有收到自己的FIN+ACK报文，所以会重发)</li>
<li>防止失效请求。(为了防止已失效的连接的请求数据包和正常的混淆)</li>
</ol>
<h2 id="TCP协议如何保证可靠传输"><a href="#TCP协议如何保证可靠传输" class="headerlink" title="TCP协议如何保证可靠传输"></a>TCP协议如何保证可靠传输</h2><p>1 应用数据被分割成TCP认为最适合发送的数据块。</p>
<p><strong>2 超时重传</strong>： 当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</p>
<p>3 TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</p>
<p><strong>4 校验和：</strong> TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。</p>
<p>5 TCP的接收端会丢弃重复的数据。</p>
<p><strong>6 流量控制：</strong> TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的我数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。 （TCP利用滑动窗口实现流量控制）</p>
<p><strong>7 拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</p>
<p><strong>8 停止等待ARQ协议（stop and wait）</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</p>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><blockquote>
<p>ACK 确认，确认方收到包后的确认报文</p>
<p>拥塞窗口值 cwnd，</p>
<p>ssthresh （slow start threshold）慢启动阈值</p>
<p>MSS (Maximum segment size) 最大分段大小</p>
<p>RTT (round-trip time) 往返时间，来回通信延迟</p>
<p>RTO (retransmission timeout) 重传超时</p>
</blockquote>
<h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h3><ul>
<li>TCP 刚建立连接，逐渐提速试探网络承受能力<br>  1 慢启动初始启动时设置拥塞窗口值（cwnd）为1、2、4或10个MSS<br>  2 cwnd 大小每当收到一个ACK增加，每个 RTT 内成倍增加, 呈指数上升<br>  3 当达到慢启动阈值 ssthresh 时 cwnd &gt;= ssthresh，进入拥塞避免算法-线性增长阶段</li>
</ul>
<h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><ul>
<li>拥塞窗口值 cwnd &gt;= ssthresh 慢启动阈值时，cwnd 进入线性增长阶段</li>
<li>cwnd 大小每当收到一个ACK增加，每个 RTT 只增加 1, 呈线性上升</li>
</ul>
<h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><blockquote>
<p>Tahoe：如果收到三次重复确认——即第四次收到相同确认号的分段确认，并且分段对应包无负载分段和无改变接收窗口——的话，Tahoe算法则进入快速重传，将慢启动阈值改为当前拥塞窗口的一半，将拥塞窗口降为1个MSS，并重新进入慢启动阶段。</p>
</blockquote>
<ul>
<li>设置 ssthresh 为当前 cwnd 的一半</li>
<li>cwnd 变为 1MSS，</li>
<li>重新进入慢启动 - 指数上升再线性上升</li>
<li>对于RTO，将拥塞窗口降为1个MSS，然后进入慢启动阶段</li>
</ul>
<h3 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h3><blockquote>
<p>Reno：如果收到三次重复确认，Reno算法则进入快速重传，只将拥塞窗口减半来跳过慢启动阶段，将慢启动阈值设为当前新的拥塞窗口值，进入一个称为“快速恢复”的新设计阶段。</p>
</blockquote>
<ul>
<li>设置 ssthresh 为当前 cwnd 的一半</li>
<li>cwnd 也设置为 ssthresh 大小</li>
<li>进入拥塞避免阶段 - 线性上升</li>
<li>对于RTO，将拥塞窗口降为1个MSS，然后进入慢启动阶段</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018161850.jpeg" alt="img"></p>
<h3 id="常用端口以及对应服务"><a href="#常用端口以及对应服务" class="headerlink" title="常用端口以及对应服务"></a>常用端口以及对应服务</h3><table>
<thead>
<tr>
<th align="center">常见服务</th>
<th align="center">端口</th>
</tr>
</thead>
<tbody><tr>
<td align="center">HTTP</td>
<td align="center">80</td>
</tr>
<tr>
<td align="center">FTP</td>
<td align="center">21</td>
</tr>
<tr>
<td align="center">DNS</td>
<td align="center">53</td>
</tr>
<tr>
<td align="center">POP3</td>
<td align="center">110</td>
</tr>
<tr>
<td align="center">SMTP</td>
<td align="center">25</td>
</tr>
<tr>
<td align="center">SSH</td>
<td align="center">22</td>
</tr>
<tr>
<td align="center">nginx</td>
<td align="center">80</td>
</tr>
<tr>
<td align="center">MEMCACHED</td>
<td align="center">11211</td>
</tr>
<tr>
<td align="center">MYSQL</td>
<td align="center">3306</td>
</tr>
<tr>
<td align="center">TOMCAT</td>
<td align="center">8080</td>
</tr>
<tr>
<td align="center">NFS</td>
<td align="center">2049</td>
</tr>
<tr>
<td align="center">TLENET</td>
<td align="center">23</td>
</tr>
<tr>
<td align="center">HTTPS</td>
<td align="center">443</td>
</tr>
<tr>
<td align="center">SAMBA</td>
<td align="center">UDP139 TCP139</td>
</tr>
<tr>
<td align="center">POSTFIX</td>
<td align="center">25</td>
</tr>
<tr>
<td align="center">IMAP</td>
<td align="center">143</td>
</tr>
<tr>
<td align="center">ZABBIX</td>
<td align="center">10051</td>
</tr>
<tr>
<td align="center">DHCP</td>
<td align="center">56</td>
</tr>
</tbody></table>
<h3 id="在浏览器中输入网址之后执行会发生什么？"><a href="#在浏览器中输入网址之后执行会发生什么？" class="headerlink" title="在浏览器中输入网址之后执行会发生什么？"></a>在浏览器中输入网址之后执行会发生什么？</h3><ol>
<li><strong>浏览器查找域名的IP地址</strong></li>
</ol>
<blockquote>
<p>1.查找浏览器缓存</p>
<p>2.查找系统缓存</p>
<p>3.查找路由器缓存</p>
<p>4.递归查询：如果以上步骤还找不到，则ISP的DNS服务器就会进行递归查询，所谓递归查询就是如果主机所询问的本地域名服务器不知道被查询域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其他根域名服务器继续发出查询请求报文，而不是让该主机自己进行下一步查询。（本地域名服务器地址是通过DHPC协议获取地址，DHPC是负责分配IP地址的）</p>
<p>5.迭代查询：本地域名服务器采用迭代查询，它先向一个根域名服务器查询。本地域名服务器向根域名服务器的查询一般都是采用迭代查询。所谓迭代查询就是当根域名服务器收到本地域名服务器发出的查询请求报文后，要么告诉本地域名服务器下一步应该查询哪一个域名服务器，然后本地域名服务器自己进行后续的查询。（而不是替代本地域名服务器进行后续查询）。</p>
<p>本例子中：根域名服务器告诉本地域名服务器，下一次应查询的顶级域名服务器dns.net的IP地址。本地域名服务器向顶级域名服务器dns.net进行查询。顶级域名服务器dns.net告诉本地域名服务器，下一次应查询的权限域名服务器dns.csdn.net的IP地址。本地域名服务器向权限域名服务器dns.csdn.net进行查询。权限域名服务器dns.csdn.net告诉本地域名服务器，所查询的主机<a href="http://www.csdn.net的ip地址.本地域名服务器最后把结果告诉主机./">www.csdn.net的IP地址。本地域名服务器最后把结果告诉主机。</a></p>
</blockquote>
<ol start="2">
<li><strong>浏览器与目标服务器建立TCP连接</strong></li>
</ol>
<ul>
<li>浏览器所在的客户机向服务器发出连接请求报文（SYN标志为1）；服务器接收报文后，同意建立连接，向客户机发出确认报文（SYN，ACK标志位均为1）；客户机接收到确认报文后，再次向服务器发出报文，确认已接收到确认报文；此处客户机与服务器之间的TCP连接建立完成，开始通信。</li>
</ul>
<ol start="3">
<li><p><strong>浏览器通过http协议发送请求</strong></p>
</li>
<li><p><strong>服务器处理请求并返回数据</strong></p>
</li>
<li><p><strong>浏览器接收到数据并渲染页面</strong></p>
</li>
</ol>
<h2 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h2><ul>
<li><p>A类地址：以0开头，第一个字节范围：0~127（1.0.0.0 - 126.255.255.255)；</p>
</li>
<li><p>B类地址：以10开头，第一个字节范围：128~191（128.0.0.0 - 191.255.255.255);</p>
</li>
<li><p>C类地址：以110开头，第一个字节范围：192~223（192.0.0.0 - 223.255.255.255);</p>
</li>
<li><p>内部地址：10.0.0.0—10.255.255.255， 172.16.0.0—172.31.255.255， 192.168.0.0—192.168.255.255。</p>
</li>
</ul>
<h2 id="IP地址与物理地址的区别"><a href="#IP地址与物理地址的区别" class="headerlink" title="IP地址与物理地址的区别"></a>IP地址与物理地址的区别</h2><p>物理地址：数据链路层和物理层使用的地址</p>
<p>IP地址：网络层和以上各层使用的地址，逻辑地址</p>
<p>ARP协议：用于IP地址和MAC地址的对应</p>
<h2 id="GET和POST的区别？"><a href="#GET和POST的区别？" class="headerlink" title="GET和POST的区别？"></a>GET和POST的区别？</h2><h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><ul>
<li>get重点是从服务器上获取资源</li>
<li>get传输数据是通过URL请求，以field（字段） = value的形式，置于URL后，并用“？”连接，多个请求数据间用“&amp;”连接</li>
<li>get传输数据量小，因为受URL长度限制，但是效率高</li>
<li>get是不安全的，因为URL是可见的，可能会泄漏私密信息</li>
<li>get方式只能支持ASCII字符，向服务器传的中文字符可能会乱码</li>
</ul>
<h4 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h4><ul>
<li>post重点是向服务器发送数据。</li>
<li>post传输数据是通过HTTP的post机制。将字段和对应值封存在请求实体中发送给服务器。这个过程用户是不可见的</li>
<li>post可以传输大量数据，所以上传文件时只能用post</li>
<li>post支持标准字符集，可以正确传递中文字符</li>
<li>post 较get安全性高</li>
</ul>
<h2 id="HTTP常见的状态码有哪些？"><a href="#HTTP常见的状态码有哪些？" class="headerlink" title="HTTP常见的状态码有哪些？"></a>HTTP常见的状态码有哪些？</h2><ul>
<li>1xx：指示信息–表示请求已接收，继续处理</li>
<li>2xx：成功–表示请求已被成功接收、理解、接受</li>
<li>3xx：重定向–要完成请求必须进行更进一步的操作</li>
<li>4xx：客户端错误–请求有语法错误或请求无法实现</li>
<li>5xx：服务器端错误–服务器未能实现合法的请求</li>
</ul>
<h4 id="常见的状态码："><a href="#常见的状态码：" class="headerlink" title="常见的状态码："></a>常见的状态码：</h4><ul>
<li>200：请求被正常处理</li>
<li>204：请求被受理但没有资源可以返回</li>
<li>206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。</li>
<li>301：永久性重定向</li>
<li>302：临时重定向</li>
<li>303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上</li>
<li>304：发送附带条件的请求时，条件不满足时返回，与重定向无关</li>
<li>307：临时重定向，与302类似，只是强制要求使用POST方法</li>
<li>400：请求报文语法有误，服务器无法识别</li>
<li>401：请求需要认证</li>
<li>403：请求的对应资源禁止被访问</li>
<li>404：服务器无法找到对应资源</li>
<li>500：服务器内部错误</li>
<li>503：服务器正忙</li>
</ul>
<h2 id="HTTP中重定向和请求转发的区别？"><a href="#HTTP中重定向和请求转发的区别？" class="headerlink" title="HTTP中重定向和请求转发的区别？"></a>HTTP中重定向和请求转发的区别？</h2><p>本质区别：</p>
<ul>
<li>转发是服务器行为</li>
<li>重定向是客户端行为</li>
</ul>
<p>重定向特点：两次请求，浏览器地址发生变化，可以访问自己 web 之外的资源，传输的数据会丢失。</p>
<p>请求转发特点：一次请求，浏览器地址不变，访问的是自己本身的 web 资源，传输的数据不会丢失。</p>
<h2 id="HTTP和HTTPS的区别？"><a href="#HTTP和HTTPS的区别？" class="headerlink" title="HTTP和HTTPS的区别？"></a>HTTP和HTTPS的区别？</h2><p>HTTPS = HTTP + SSL，SSL协议工作在应用层与传输层之间</p>
<ul>
<li>https有ca证书，http一般没有</li>
<li>http是超文本传输协议，信息是明文传输。https则是具有安全性的ssl加密传输协议</li>
<li>http默认80端口，https默认443端口</li>
</ul>
<h2 id="HTTP-2-与-HTTP-1-x-的主要区别？"><a href="#HTTP-2-与-HTTP-1-x-的主要区别？" class="headerlink" title="HTTP/2 与 HTTP/1.x 的主要区别？"></a>HTTP/2 与 HTTP/1.x 的主要区别？</h2><ul>
<li>二进制协议代替文本协议，更加简洁高效</li>
<li>针对每个域只使用一个多路复用的连接</li>
<li>压缩头部信息减小开销</li>
<li>允许服务器主动推送应答到客户端的缓存中</li>
</ul>
<h2 id="HTTP请求报文与响应报文格式？"><a href="#HTTP请求报文与响应报文格式？" class="headerlink" title="HTTP请求报文与响应报文格式？"></a>HTTP请求报文与响应报文格式？</h2><p>请求报文：</p>
<p>a、请求行：包含请求方法、URI、HTTP版本信息<br>b、请求首部字段<br>c、请求内容实体</p>
<p>响应报文：</p>
<p>a、状态行：包含HTTP版本、状态码、状态码的原因短语<br>b、响应首部字段<br>c、响应内容实体</p>
<h2 id="什么是HTTP协议无状态协议？"><a href="#什么是HTTP协议无状态协议？" class="headerlink" title="什么是HTTP协议无状态协议？"></a>什么是HTTP协议无状态协议？</h2><p>无状态协议对于事物处理没有记忆能力。缺少状态意味着后续的处理需要前面的信息。</p>
<h2 id="cookie和session的区别和联系"><a href="#cookie和session的区别和联系" class="headerlink" title="cookie和session的区别和联系"></a>cookie和session的区别和联系</h2><h3 id="Cookie的工作原理"><a href="#Cookie的工作原理" class="headerlink" title="Cookie的工作原理"></a><strong>Cookie的工作原理</strong></h3><ul>
<li>浏览器端第一次发送请求到服务器端</li>
<li>服务器端创建Cookie，该Cookie中包含用户的信息，然后将该Cookie发送到浏览器端</li>
<li>浏览器端再次访问服务器端时会携带服务器端创建的Cookie</li>
<li>服务器端通过Cookie中携带的数据区分不同的用户</li>
</ul>
<h3 id="Session的工作原理"><a href="#Session的工作原理" class="headerlink" title="Session的工作原理"></a><strong>Session的工作原理</strong></h3><ul>
<li>浏览器端第一次发送请求到服务器端，服务器端创建一个Session，同时会创建一个特殊的Cookie（name为JSESSIONID的固定值，value为session对象的ID），然后将该Cookie发送至浏览器端</li>
<li>浏览器端发送第N（N&gt;1）次请求到服务器端,浏览器端访问服务器端时就会携带该name为JSESSIONID的Cookie对象</li>
<li>服务器端根据name为JSESSIONID的Cookie的value(sessionId),去查询Session对象，从而区分不同用户。</li>
</ul>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><h4 id="1、存储位置不同"><a href="#1、存储位置不同" class="headerlink" title="1、存储位置不同"></a>1、存储位置不同</h4><blockquote>
<p>cookie的数据信息存放在客户端浏览器上。</p>
</blockquote>
<blockquote>
<p>session的数据信息存放在服务器上。</p>
</blockquote>
<h4 id="2、存储容量不同"><a href="#2、存储容量不同" class="headerlink" title="2、存储容量不同"></a>2、存储容量不同</h4><blockquote>
<p>单个cookie保存的数据&lt;=4KB，一个站点最多保存20个Cookie。</p>
</blockquote>
<blockquote>
<p>对于session来说并没有上限，但出于对服务器端的性能考虑，session内不要存放过多的东西，并且设置session删除机制。</p>
</blockquote>
<h4 id="3、存储方式不同"><a href="#3、存储方式不同" class="headerlink" title="3、存储方式不同"></a>3、存储方式不同</h4><blockquote>
<p>cookie中只能保管ASCII字符串，并需要通过编码方式存储为Unicode字符或者二进制数据。</p>
</blockquote>
<blockquote>
<p>session中能够存储任何类型的数据，包括且不限于string，integer，list，map等。</p>
</blockquote>
<h4 id="4、隐私策略不同"><a href="#4、隐私策略不同" class="headerlink" title="4、隐私策略不同"></a>4、隐私策略不同</h4><blockquote>
<p>cookie对客户端是可见的，所以它是不安全的。</p>
</blockquote>
<blockquote>
<p>session存储在服务器上，对客户端是透明的，不存在敏感信息泄漏的风险。</p>
</blockquote>
<h4 id="5、有效期上不同"><a href="#5、有效期上不同" class="headerlink" title="5、有效期上不同"></a>5、有效期上不同</h4><blockquote>
<p>可以通过设置cookie的属性，达到使cookie长期有效的效果。</p>
</blockquote>
<blockquote>
<p>session依赖于名为JSESSIONID的cookie，而cookie JSESSIONID的过期时间默认为-1，只需关闭窗口该session就会失效，因而session不能达到长期有效的效果。</p>
</blockquote>
<h4 id="6、服务器压力不同"><a href="#6、服务器压力不同" class="headerlink" title="6、服务器压力不同"></a>6、服务器压力不同</h4><blockquote>
<p>cookie保管在客户端，不占用服务器资源。对于并发用户十分多的网站，cookie是很好的选择。</p>
</blockquote>
<blockquote>
<p>session是保管在服务器端的，每个用户都会产生一个session。假如并发访问的用户十分多，会产生十分多的session，耗费大量的内存。</p>
</blockquote>
<h2 id="HTTPS方式与web服务器通信的步骤？"><a href="#HTTPS方式与web服务器通信的步骤？" class="headerlink" title="HTTPS方式与web服务器通信的步骤？"></a>HTTPS方式与web服务器通信的步骤？</h2><p>1、客户使用HTTPS的URL访问web服务器，要求与web服务器建立SSL连接<br>2、web服务器收到客户端请求后，将网站的证书信息（证书中包含公钥）传送一份给客户端<br>3、客户端的浏览器与web服务器开始协商SSL连接的安全等级，也就是信息的加密等级<br>4、客户端的浏览器根据双方同意的安全等级，建立会话秘钥，然后利用网站的公钥将会话秘钥加密，并传送给网站<br>5、web服务器利用自己的私钥解密出会话秘钥<br>6、web服务器利用会话秘钥加密与客户端之间的通信</p>
<h2 id="说说常见的常见HTTP首部字段？"><a href="#说说常见的常见HTTP首部字段？" class="headerlink" title="说说常见的常见HTTP首部字段？"></a>说说常见的常见HTTP首部字段？</h2><p>通用首部字段（请求报文与响应报文都会使用的首部字段）</p>
<p>Date：创建报文时间Connection：连接的管理Cache-Control：缓存的控制Transfer-Encoding：报文主体的传输编码方式</p>
<p>请求首部字段（请求报文会使用的首部字段）</p>
<p>Host：请求资源所在服务器Accept：可处理的媒体类型Accept-Charset：可接收的字符集Accept-Encoding：可接受的内容编码Accept-Language：可接受的自然语言</p>
<p>响应首部字段（响应报文会使用的首部字段）</p>
<p>Accept-Ranges：可接受的字节范围Location：令客户端重新定向到的URIServer：HTTP服务器的安装信息</p>
<p>实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）</p>
<p>Allow：资源可支持的HTTP方法Content-Type：实体主类的类型Content-Encoding：实体主体适用的编码方式Content-Language：实体主体的自然语言Content-Length：实体主体的的字节数Content-Range：实体主体的位置范围，一般用于发出部分请求时使用</p>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p><strong>概念：</strong>父进程创建一个子进程，子进程退出后，父进程没有调用 <strong>wait</strong> 或 <strong>waitpid</strong> 获取子进程的<strong>状态信息</strong>，那么子进程的<strong>状态描述符</strong>仍然保存在系统中</p>
<p><strong>危害：</strong>不调用 wait 或者 waitpid，保留的信息不会被释放，进程号会被一直占用，但是系统的进程号是有限的，如果有大量的僵尸进程，系统会因为没有进程号而无法创建新的进程</p>
<h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p><strong>概念：</strong>父进程退出，而它的子进程仍然在执行，那么子进程就会成为孤儿进程</p>
<p><strong>无危害：</strong>孤儿进程被 init 进程（进程号为1）所收养，并由 init 进程对它们完成状态收集工作</p>
<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><h3 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h3><ol>
<li>并发</li>
</ol>
<ul>
<li>并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。</li>
<li>并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。</li>
<li>操作系统通过引入进程和线程，使得程序能够并发运行。</li>
</ul>
<ol>
<li>共享</li>
</ol>
<ul>
<li>共享是指系统中的资源可以被多个并发进程共同使用。</li>
<li>有两种共享方式：互斥共享和同时共享。</li>
<li>互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。</li>
</ul>
<ol>
<li>虚拟</li>
</ol>
<ul>
<li><p>虚拟技术把一个物理实体转换为多个逻辑实体。</p>
</li>
<li><p>主要有两种虚拟技术：时分复用技术和空分复用技术。</p>
<ul>
<li><p>多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</p>
</li>
<li><p><strong>虚拟内存使用了空分复用技术，它**</strong>将物理内存抽象为地址空间**<strong>，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存**</strong>中。**</p>
</li>
</ul>
</li>
</ul>
<ol>
<li>异步</li>
</ol>
<ul>
<li>异步指进程不是一次性执行完毕</li>
</ul>
<h2 id="二、进程管理"><a href="#二、进程管理" class="headerlink" title="二、进程管理"></a>二、进程管理</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul>
<li><strong>进程是资源分配的基本单位</strong></li>
<li>进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。</li>
</ul>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul>
<li>线程是基本的CPU执行单元，也是程序执行流的最小单元，系统独立调度和分派的基本单位</li>
<li>线程由线程ID、程序计数器、寄存器集合和堆栈组成</li>
<li>进程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但是可与同属于一个进程的其他线程共享所拥有的全部资源</li>
<li>一个进程中可以有多个线程，它们共享进程资源</li>
<li>引入线程后，进程的内涵发生了改变，进程只作为除CPU外的系统资源的分配单元，而线程则作为处理器的分配单元</li>
<li>引入进程的目的是为了更好的使多程序并发执行，提高资源利用率和系统吞吐量；引入线程的目的是为了减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能</li>
</ul>
<h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><ul>
<li><p><strong>拥有资源</strong></p>
<ul>
<li>进程是资源分配的基本单位，但是线程不拥有资源（除了一点必不可少的资源），线程可以访问隶属进程的系统资源</li>
<li>如果线程也拥有资源，则切换线程就需要较大的时空开销，线程的概念就没有意义了</li>
</ul>
</li>
<li><p>调度</p>
<ul>
<li>传统操作系统中拥有资源和独立调度的基本单位都是进程</li>
<li>引入线程后，线程是独立调度的基本单位，进程是拥有资源的基本单位</li>
<li>在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</li>
</ul>
</li>
<li><p><strong>系统开销</strong></p>
<ul>
<li>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。</li>
<li>类似地，在进行<strong>进程切换时</strong>，涉及当前<strong>执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置（即，Context）</strong>，而<strong>线程切换时</strong>只需<strong>保存和设置少量寄存器内容</strong>，开销很小</li>
<li>同一个进程内的多个线程共享进程的地址空间，因此这些线程间同步与通信非常容易，甚至无须操作系统的干预</li>
</ul>
</li>
<li><p>并发性：</p>
<ul>
<li>引入线程后，不仅进程间可以并发执行，而且多个线程之间也可以并发执行，提高了并发性和吞吐量</li>
</ul>
</li>
<li><p><strong>通信方面</strong></p>
<ul>
<li>进程间通信需要进程同步和互斥手段的辅助，以保证数据的一致性，而线程间通信可以直接读/写进程数据段（如全局变量）来进行通信</li>
</ul>
</li>
</ul>
<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><ul>
<li>协程，是一种基于线程之上，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，自主开辟的异步任务，具有对内核来说不可见的特性</li>
<li>正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程</li>
</ul>
<h3 id="协程和线程的区别"><a href="#协程和线程的区别" class="headerlink" title="协程和线程的区别"></a>协程和线程的区别</h3><table>
<thead>
<tr>
<th>比较项</th>
<th>线程</th>
<th>协程</th>
</tr>
</thead>
<tbody><tr>
<td>占用资源</td>
<td>初始单位为1MB,固定不可变</td>
<td>初始一般为 2KB，可随需要而增大</td>
</tr>
<tr>
<td>调度所属</td>
<td>由 OS 的内核完成</td>
<td>由用户完成</td>
</tr>
<tr>
<td>切换开销</td>
<td>涉及模式切换(从用户态切换到内核态)、16个寄存器、PC、SP…等寄存器的刷新等</td>
<td>只有三个寄存器的值修改 - PC / SP / DX.</td>
</tr>
<tr>
<td>性能问题</td>
<td>资源占用太高，频繁创建销毁会带来严重的性能问题</td>
<td>资源占用小,不会带来严重的性能问题</td>
</tr>
<tr>
<td>数据同步</td>
<td>需要用锁等机制确保数据的一直性和可见性</td>
<td>不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</td>
</tr>
</tbody></table>
<h3 id="进程状态的切换"><a href="#进程状态的切换" class="headerlink" title="进程状态的切换"></a>进程状态的切换</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1599655539465-7c6412b9-cf1c-41eb-98c2-631439893c16.png" alt="image.png"></p>
<ul>
<li>就绪状态（ready）：进程获取了除处理器以外的一切所需资源，等待被调度，多个处于就绪状态的进程拍成就绪队列</li>
<li>运行状态（running）：进程正在处理器上运行</li>
<li>阻塞状态（waiting）：等待某资源为可用</li>
<li>创建态（created）：进程正在被创建，尚未转到就绪态</li>
<li>结束态（terminated）：进程正从系统消失，可能是进程正常结束或其他原因中断退出运行</li>
</ul>
<p>应该注意以下内容：</p>
<ul>
<li>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li>
<li>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</li>
</ul>
<h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><h4 id="1-批处理系统"><a href="#1-批处理系统" class="headerlink" title="1. 批处理系统"></a>1. 批处理系统</h4><ul>
<li>批处理系统在很老的计算机时使用，没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）</li>
</ul>
<p><strong>1.1 先来先服务 first-come first-serverd（FCFS）</strong></p>
<ul>
<li>非抢占式的调度算法，按照请求的顺序进行调度</li>
<li><strong>有利于长作业，但不利于短作业</strong>，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长</li>
</ul>
<p><strong>1.2 短作业优先 shortest job first（SJF）</strong></p>
<ul>
<li>非抢占式的调度算法，按估计运行时间最短的顺序进行调度</li>
<li><strong>长作业有可能会饿死</strong>，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度</li>
</ul>
<p><strong>1.3 高响应比优先</strong> </p>
<ul>
<li>高响应比优先调度算法是FCFS和SJF的综合平衡，每次进行作业调度时，先计算后备作业队列中每个作业的响应比，从中选出响应比最高的作业投入运行</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1599725265351-ac1b4730-41f4-45af-ab73-a8e3bf6ae880.png" alt="image.png"></li>
<li>要求服务时间短，响应比高，有利于短作业</li>
<li>等待时间长，响应比高，不会出现长作业饿死的情况</li>
</ul>
<h4 id="2-交互式系统"><a href="#2-交互式系统" class="headerlink" title="2. 交互式系统"></a>2. 交互式系统</h4><p><strong>2.1 时间片轮转</strong></p>
<p><strong>2.2 优先级调度</strong></p>
<p><strong>2.3 多级反馈队列</strong></p>
<ul>
<li>多级队列是为这种需要连续执行多个时间片的进程考虑，<strong>设置了多个队列，每个队列时间片大小都不同</strong>，例如 1,2,4,8,..。<strong>进程在第一个队列没执行完，就会被移到下一个队列</strong>。这种方式下，之前的进程只需要交换 7 次</li>
<li><strong>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列中的进程</strong></li>
<li>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合</li>
</ul>
<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><ul>
<li><p><strong>进程间通信(IPC，InterProcess Communication)的目的</strong></p>
</li>
<li><ul>
<li><strong>数据传输：</strong>一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几兆字节之间<ul>
<li><strong>共享数据：</strong>多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到</li>
<li><strong>通知事件：</strong>一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）</li>
<li><strong>资源共享：</strong>多个进程之间共享同样的资源。为了作到这一点，需要内核提供锁和同步机制</li>
<li><strong>进程控制：</strong>有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变</li>
</ul>
</li>
</ul>
</li>
<li><p>IPC方式包括：管道、系统IPC（信号量、消息队列、共享内存）和套接字（socket）</p>
</li>
</ul>
<h4 id="管道-pipe"><a href="#管道-pipe" class="headerlink" title="管道(pipe)"></a>管道(pipe)</h4><ul>
<li><p><strong>管道的特点：</strong></p>
</li>
<li><ul>
<li><strong>管道是半双工</strong>，数据只能向一个方向流动；双方需要互相通信时，需要建立起两个管道<ul>
<li>只能用于具有亲缘关系的进程（<strong>父子进程或者兄弟进程</strong>）之间</li>
<li>管道对于两端通信的进程来说就只是一种<strong>文件</strong>，一种<strong>不属于文件系统仅存在内存中的“伪文件”</strong></li>
<li>管道的通信方式为：写端每次都将数据写入管道缓冲区的 <strong>末尾</strong> ，而读端每次都从管道缓冲区的 <strong>头部</strong> 读出数据</li>
<li>当一个管道建立时，它会创建两个文件描述符：fd[0]为读而打开，fd[1]为写而打开，要关闭管道只需将这两个文件描述符关闭即可。如下图：</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1598175402011-cbc30792-6045-4701-b33c-2222787f89e6.png" alt="image.png"></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>管道的实质</strong></p>
</li>
<li><ul>
<li>管道的实质是一个<strong>内核缓冲区</strong>，进程以先进先出的方式从缓冲区存取数据：管道一端的进程顺序地将进程数据写入缓冲区，另一端的进程则顺序地读取数据<ul>
<li>该缓冲区可以看做一个循环队列，读和写的位置都是自动增加的，一个数据只能被读一次，读出以后再缓冲区都不复存在了</li>
<li>当缓冲区读空或者写满时，有一定的规则控制相应的读进程或写进程是否进入等待队列，当空的缓冲区有新数据写入或慢的缓冲区有数据读出时，就唤醒等待队列中的进程继续读写</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="信号-signals"><a href="#信号-signals" class="headerlink" title="信号(signals)"></a>信号(signals)</h4><ul>
<li><p><strong>信号的特点：</strong></p>
</li>
<li><ul>
<li>Unix系统中使用的最古老的进程间通信的方法之一，操作系统通过信号来通知进程系统中发生了某种预先规定好的事件（一组事件中的一个），它也是用户进程之间通信和同步的一种原始机制<ul>
<li>一个键盘中断或者一个错误条件（比如进程试图访问它的虚拟内存中不存在的位置等）都有可能产生一个信号</li>
<li>信号可以在任何时候发给某一进程，而无需知道该进程的状态、</li>
<li>对信号的任何处理，包括终止进程，都必须由接收到信号的进程真正执行时才能处理，所以信号处理可能需要延迟一段时间</li>
<li>如果该进程当前并未处于执行状态，则内核保存该信号，直到该进程回复执行并传递给它为止</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>信号的来源：</strong></p>
</li>
<li><ul>
<li><strong>信号是软件层次上对中断机制的一种模拟，是一种异步通信方式（所以信号不是中断，**</strong>信号处理程序在用户态下运行的, 中断程序在核心态下运行的**<strong>）</strong><ul>
<li><strong>信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发生了哪些系统事件</strong></li>
<li>信号事件主要有两个来源：</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>硬件来源：用户按键输入 <code>Ctrl+C</code> 退出、硬件异常如无效的存储访问等<ul>
<li>软件终止：终止进程信号、其他进程调用 <code>kill</code> 函数、软件异常产生信号</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>信号生命周期和处理流程</strong></p>
</li>
</ul>
<ol>
<li><ol>
<li><strong>信号被某个进程产生</strong>，并设置此信号传递的对象（一般为<strong>对应进程的pid</strong>），然后<strong>传递给操作系统</strong><ol start="2">
<li>操作系统根据接收进程的设置（是否阻塞）而选择性的发送给接收者，如果接收者阻塞该信号（且该信号是可以阻塞的），操作系统将暂时保留该信号，而不传递，直到该进程解除了对此信号的阻塞（如果对应进程已经退出，则丢弃此信号），<strong>如果对应进程没有阻塞，操作系统将传递此信号</strong></li>
<li><strong>目的进程接收到此信号后</strong>，将根据当前进程对此信号设置的预处理方式，<strong>暂时终止当前代码的执行，**</strong>保护上下文<strong>（主要包括临时寄存器数据，当前程序位置以及当前CPU的状态）、</strong>转而执行中断服务程序**<strong>，执行完成后在回复到中断的位置</strong>。当然，对于抢占式内核，在中断返回时还将引发新的调度</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="消息队列-message"><a href="#消息队列-message" class="headerlink" title="消息队列(message)"></a>消息队列(message)</h4><ul>
<li><p>消息队列的特点：</p>
</li>
<li><ul>
<li>消息队列是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识<ul>
<li>消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区受限等特点</li>
<li>消息队列允许一个或多个进程向它写入与读取消息</li>
<li>管道和消息队列的通信数据都是先进先出的原则</li>
<li>与管道相比，管道发送的数据没有类型；消息队列有类型，读端可以根据数据类型读取特定的数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="共享内存-share-memory"><a href="#共享内存-share-memory" class="headerlink" title="共享内存(share memory)"></a>共享内存(share memory)</h4><ul>
<li>使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的</li>
<li>为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率</li>
<li>信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问</li>
</ul>
<h4 id="信号量-semaphore"><a href="#信号量-semaphore" class="headerlink" title="信号量(semaphore)"></a>信号量(semaphore)</h4><ul>
<li><p><strong>信号量</strong></p>
</li>
<li><ul>
<li>信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于<strong>进程间同步</strong></li>
</ul>
</li>
<li><p><strong>信号量与普通整型变量的区别：</strong></p>
</li>
<li><ul>
<li>信号量是非负整型变量，除了初始化之外，它只能通过两个标准原子操作：wait(semap) , signal(semap) ; 来进行访问<ul>
<li>操作也被成为PV原语，而普通整型变量则可以在任何语句块中被访问</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="套接字-socket"><a href="#套接字-socket" class="headerlink" title="套接字(socket)"></a>套接字(socket)</h4><ul>
<li>适合<strong>同一主机的不同进程间</strong>和<strong>不同主机的进程间</strong>进行全双工网络通信</li>
</ul>
<h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><h4 id="1-临界区"><a href="#1-临界区" class="headerlink" title="1. 临界区"></a>1. 临界区</h4><ul>
<li>对临界资源进行访问的那段代码称为临界区。</li>
<li>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</li>
<li>// entry section</li>
<li>// critical section;</li>
<li>// exit section</li>
</ul>
<h4 id="2-同步与互斥"><a href="#2-同步与互斥" class="headerlink" title="2. 同步与互斥"></a>2. 同步与互斥</h4><ul>
<li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li>
<li>互斥：多个进程在同一时刻只有一个进程能进入临界区。</li>
</ul>
<h4 id="3-信号量"><a href="#3-信号量" class="headerlink" title="3. 信号量"></a>3. 信号量</h4><ul>
<li><p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p>
</li>
<li><ul>
<li><strong>down</strong> : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；<ul>
<li><strong>up</strong> ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断</strong>。</p>
</li>
<li><p>如果信号量的取值只能为 0 或者 1，那么就成为了 <strong>互斥量（Mutex）</strong> ，0 表示临界区已经加锁，1 表示临界区解锁。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>使用信号量实现生产者-消费者问题</strong></p>
<p>问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。</p>
<p>因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。</p>
<p>为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。</p>
<p>注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。</p>
<figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">#define N 100</span><br><span class="line">typedef int semaphore;</span><br><span class="line">semaphore mutex = 1;</span><br><span class="line">semaphore empty = N;</span><br><span class="line">semaphore full = 0;</span><br><span class="line">void producer() &#123;</span><br><span class="line">    <span class="meta">while</span>(TRUE) &#123;</span><br><span class="line">        int item = produce_item();</span><br><span class="line">        <span class="meta">do</span><span class="meta">wn(</span><span class="variable">&amp;empty</span>);</span><br><span class="line">        <span class="meta">do</span><span class="meta">wn(</span><span class="variable">&amp;mutex</span>);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        up(<span class="variable">&amp;mutex</span>);</span><br><span class="line">        up(<span class="variable">&amp;full</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void consumer() &#123;</span><br><span class="line">    <span class="meta">while</span>(TRUE) &#123;</span><br><span class="line">        <span class="meta">do</span><span class="meta">wn(</span><span class="variable">&amp;full</span>);</span><br><span class="line">        <span class="meta">do</span><span class="meta">wn(</span><span class="variable">&amp;mutex</span>);</span><br><span class="line">        int item = remove_item();</span><br><span class="line">        consume_item(item);</span><br><span class="line">        up(<span class="variable">&amp;mutex</span>);</span><br><span class="line">        up(<span class="variable">&amp;empty</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-管程"><a href="#4-管程" class="headerlink" title="4. 管程"></a>4. 管程</h4><ul>
<li>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</li>
<li>c 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。</li>
</ul>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">monitor ProducerConsumer</span><br><span class="line">    integer i;</span><br><span class="line">    condition c;</span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">()</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">remove</span><span class="params">()</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span> monitor;</span><br></pre></td></tr></table></figure>

<ul>
<li>管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。</li>
<li>管程引入了 <strong>条件变量</strong> 以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</li>
<li><strong>使用管程实现生产者-消费者问题</strong></li>
</ul>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 管程</span></span><br><span class="line">monitor ProducerConsumer</span><br><span class="line">    condition full, <span class="keyword">empty</span>;</span><br><span class="line">    integer count := <span class="number">0</span>;</span><br><span class="line">    condition c;</span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">(item: integer)</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> count = N <span class="keyword">then</span> wait(full);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        count := count + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">1</span> <span class="keyword">then</span> signal(<span class="keyword">empty</span>);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">remove</span>:</span> integer;</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">0</span> <span class="keyword">then</span> wait(<span class="keyword">empty</span>);</span><br><span class="line">        <span class="keyword">remove</span> = remove_item;</span><br><span class="line">        count := count - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = N -<span class="number">1</span> <span class="keyword">then</span> signal(full);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span> monitor;</span><br><span class="line"><span class="comment">// 生产者客户端</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">producer</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="title">true</span> <span class="title">do</span></span></span><br><span class="line"><span class="function">    <span class="title">begin</span></span></span><br><span class="line"><span class="function">        <span class="title">item</span> = <span class="title">produce_item</span>;</span></span><br><span class="line">        ProducerConsumer.insert(item);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">// 消费者客户端</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">consumer</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="title">true</span> <span class="title">do</span></span></span><br><span class="line"><span class="function">    <span class="title">begin</span></span></span><br><span class="line"><span class="function">        <span class="title">item</span> = <span class="title">ProducerConsumer</span>.<span class="title">remove</span>;</span></span><br><span class="line">        consume_item(item);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>

<h2 id="三、死锁"><a href="#三、死锁" class="headerlink" title="三、死锁"></a>三、死锁</h2><h3 id="1、死锁、饥饿、死循环的区别"><a href="#1、死锁、饥饿、死循环的区别" class="headerlink" title="1、死锁、饥饿、死循环的区别"></a>1、死锁、饥饿、死循环的区别</h3><ul>
<li><p>死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。至少有两个进程或以上同时发生死锁。</p>
</li>
<li><p>饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。</p>
</li>
<li><p>死循环：某进程执行过程中一直跳不出某个循环的现象。</p>
</li>
</ul>
<h3 id="2、死锁产生的必要条件"><a href="#2、死锁产生的必要条件" class="headerlink" title="2、死锁产生的必要条件"></a>2、死锁产生的必要条件</h3><p>产生死锁必须同时满足以下四个条件，只要其中一个不成立，死锁就不会发生。</p>
<ul>
<li>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁（如哲学家的筷子、打印机设备）。</li>
<li>不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</li>
<li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。（有了一个，还想要另一个，但是自己原来那个不放手。）</li>
<li>循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</li>
</ul>
<h3 id="3、什么时候会发生死锁"><a href="#3、什么时候会发生死锁" class="headerlink" title="3、什么时候会发生死锁"></a>3、什么时候会发生死锁</h3><p>1、对系统资源的竞争。各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁。</p>
<p>2、进程推进顺序非法。请求和释放资源的顺序不当，同样也会导致死锁。例如，并发执行进程P1、P2分别申请并占有了资源R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又申请R1，两者会因为申请的资源被对方占有而阻塞，从而发生死锁。</p>
<p>3、信号量的使用不当也会造成死锁。如生产者-消费者问题中，如果实现互斥的P操作在实现同步的P操作之前，就有可能导致死锁。（可以把互斥信号量、同步信号量也看做是一种抽象的系统资源）</p>
<h3 id="4、死锁的处理——预防死锁"><a href="#4、死锁的处理——预防死锁" class="headerlink" title="4、死锁的处理——预防死锁"></a>4、死锁的处理——预防死锁</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/png/218528/1575718340782-6dca5998-47bd-490f-bab3-2417f36e8825.png?x-oss-process=image/resize,w_1500" alt="image.png"></p>
<h4 id="4-1-破坏互斥条件"><a href="#4-1-破坏互斥条件" class="headerlink" title="4.1 破坏互斥条件"></a>4.1 破坏互斥条件</h4><h4 id="4-2-破坏不剥夺条件"><a href="#4-2-破坏不剥夺条件" class="headerlink" title="4.2 破坏不剥夺条件"></a>4.2 破坏不剥夺条件</h4><h4 id="4-3-破坏请求和保持条件"><a href="#4-3-破坏请求和保持条件" class="headerlink" title="4.3 破坏请求和保持条件"></a>4.3 破坏请求和保持条件</h4><h4 id="4-4-破坏循环等待条件"><a href="#4-4-破坏循环等待条件" class="headerlink" title="4.4 破坏循环等待条件"></a>4.4 破坏循环等待条件</h4><h3 id="5、死锁的处理——避免死锁"><a href="#5、死锁的处理——避免死锁" class="headerlink" title="5、死锁的处理——避免死锁"></a>5、死锁的处理——避免死锁</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/png/218528/1575722844700-df890c05-54b7-4217-898b-4cce009af1db.png?x-oss-process=image/resize,w_1500" alt="image.png"></p>
<h4 id="5-2-银行家算法"><a href="#5-2-银行家算法" class="headerlink" title="5.2 银行家算法"></a>5.2 银行家算法</h4><p><img src="https://cdn.nlark.com/yuque/0/2019/png/218528/1575723680965-560e06d5-2688-40b9-bede-4f3822bf6237.png?x-oss-process=image/resize,w_1500" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/218528/1575725368390-6e09854f-9422-4228-b3d3-36cb7473d161.png?x-oss-process=image/resize,w_1500" alt="image.png"></p>
<p>银行家算法总结：</p>
<p>用Available向量表示系统当前的可用资源数。</p>
<p>试分配：</p>
<p>在某一时刻，进程提出资源申请，系统首先检查申请的资源数是否超过进程的最大需求量。</p>
<p>不超过，则检查是否超过当前可用的资源数。</p>
<p>如果都不超过，则试着分配给该进程。</p>
<p>然后用安全性算法检查此次分配是否会导致系统进入不安全状态。</p>
<p>安全性算法简单理解：系统当前剩余的资源数超过了某个进程的Need向量，就把该进程加入安全序列，并将Allocation添加到Available，不断循环此过程，看最终能否让所有进程都加入安全序列，如果可以，此次分配时安全的，系统开始分配。</p>
<p>注意：处于安全状态一定不会死锁，死锁一定处于不安全状态，处于不安全状态不一定会死锁。</p>
<h3 id="6、死锁的处理——检测和解除"><a href="#6、死锁的处理——检测和解除" class="headerlink" title="6、死锁的处理——检测和解除"></a>6、死锁的处理——检测和解除</h3><h4 id="6-1-数据结构"><a href="#6-1-数据结构" class="headerlink" title="6.1 数据结构"></a>6.1 数据结构</h4><p>1、用种数据结构来保存资源的请求和分配信息。数据结构定义如下：</p>
<ul>
<li><p>两种结点：</p>
</li>
<li><ul>
<li>进程结点：对应一个进程<pre><code>- 资源结点：对应一类资源，一类资源可能有多个</code></pre>
</li>
</ul>
</li>
<li><p>两种边：</p>
</li>
<li><ul>
<li>进程结点-&gt;资源结点：表示进程想申请几个资源（每条边代表一个）<pre><code>- 资源结点-&gt;进程结点：表示进程想申请几个资源（每条边代表一个）</code></pre>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/218528/1575734720016-bc4c28fa-fae9-478a-aed9-816b1286e6f3.png" alt="image.png"></p>
<p>（矩形中的小圆代表资源的数量）</p>
<p>2、提供一种算法，利用上述信息来检测系统是否已进入死锁状态。算法描述如下：</p>
<p>如果系统中剩余的可用资源满足进程的需求，则进程将顺利自行下去，然后将资源归还系统，然后激活正在等待资源的进程，并顺利执行下去，一直这样下去，如果最终能消除所有边，就称这个图是可完全简化的，此时一定没有发生死锁（相当于找一个安全序列）。如果最终不能消除所有边，那么此时就是发生了死锁。最终连着边的那些进程就是处于死锁状态的进程。</p>
<p>算法简单理解：把没有处于阻塞态的进程的边都去掉，循环此过程。</p>
<h4 id="6-2-死锁的解除"><a href="#6-2-死锁的解除" class="headerlink" title="6.2 死锁的解除"></a>6.2 死锁的解除</h4><p>1、一旦检测出死锁的发生，就应该立即解除死锁。</p>
<p>2、并不是系统中所有进程都是死锁状态，用死锁检测算法简化资源分配图后，还连着边的那些进程就是死锁进程。</p>
<p>3、解除死锁的主要方法有：</p>
<ul>
<li>资源剥夺法：挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</li>
<li>撤销进程法（终止进程法）：强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的有点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束，一旦被终止可谓功亏一篑，以后还得从头再来。</li>
<li>进程回退法：让一个或多个死锁进程回退到足以避免死锁的地步。这就是要求系统要记录进程的历史信息，设置还原点。</li>
</ul>
<p>问题：决定对谁动手？</p>
<ul>
<li>进程优先级</li>
<li>已执行了多长时间</li>
<li>还要多久完成</li>
<li>进程已经使用了多少资源（资源分配多的优先）</li>
<li>进程是交互式的还是批处理式的（批处理优先）</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/218528/1575734667024-d54814af-cee6-49d8-8a26-4798efd42280.png?x-oss-process=image/resize,w_746"></p>
<h2 id="四、内存管理"><a href="#四、内存管理" class="headerlink" title="四、内存管理"></a>四、内存管理</h2><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><ul>
<li><strong>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存</strong>。</li>
<li>为了更好的管理内存，<strong>操作系统将内存抽象成地址空间。</strong> <strong>每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中</strong>。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</li>
<li>从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个<strong>程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能</strong>。<strong>例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序</strong>。</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1597062741056-0b5eeebc-b334-4929-9319-359a8cf9e7cc.png" alt="image.png"></li>
</ul>
<h3 id="分页与分段"><a href="#分页与分段" class="headerlink" title="分页与分段"></a>分页与分段</h3><ul>
<li><strong>分页</strong>管理方式是从计算机的角度考虑设计的，以<strong>提高内存的利用率</strong>，提升计算机的性能, 且分页通过硬件机制实现，对用户完全透明</li>
<li><strong>分段</strong>管理方式的提出则是考虑了用户和程序员，以<strong>满足方便编程、信息保护和共享、动态增长及动态链接</strong>等多方面的需要</li>
</ul>
<h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><ul>
<li><p><strong>内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表</strong>。</p>
</li>
<li><p>一个虚拟地址分成两个部分，一部分存储页号，一部分存储偏移量。</p>
</li>
<li><p>页表：</p>
</li>
<li><ul>
<li>为了便于在内存中找到进程的每个页面所对应的物理块，<strong>系统为每个进程建立一张页表</strong>，记录页面在内存中对应的物理块号，页表一般存放在内存中。在配置了页表后，进程执行时，通过查找该表，即可找到每页在内存中的物理块号。可见，页表的作用是实现从页号到物理块号的地址映射<ul>
<li>下图的页表存放着 16 个页，这 16 个页需要用 4 个bit来进行索引定位。</li>
</ul>
</li>
</ul>
</li>
<li><p>例如对于虚拟地址（0010 000000000100），前 4 位是当在虚拟地址对应的存储页号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。那么映射后，这个页（地址空间）对应的页框（物理内存地址）的地址为 （110 000000000100）。</p>
</li>
<li><p><strong>相当于前缀做一个Mapping，前缀决定虚拟地址属于哪个块，后缀决定这个虚拟地址在块中的相对位置</strong></p>
</li>
<li><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1266758/1597064732122-fa391785-bc91-450c-a6db-3284d9ee19ea.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
</li>
</ul>
<h4 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h4><ul>
<li><p>分段式管理方式按照用户进程中的自然段划分逻辑空间</p>
</li>
<li><ul>
<li>例如，用户进程由主程序、两个子程序、栈和一段数据组成，于是可以把这个用户进程划分为5个段，每段从0 开始编址，并分配一段连续的地址空间<ul>
<li>段内要求连续，段间不要求连续，因此整个作业的地址空间是二维的，其<strong>逻辑地址</strong>由<strong>段号S</strong>与<strong>段内偏移量W</strong>两部分组成</li>
</ul>
</li>
</ul>
</li>
<li><p>页式系统中，逻辑地址的页号和页内偏移量对用户是透明的，段式系统中，段号和段内偏移量必须由用户显示提供，，在髙级程序设计语言中，这个工作由编译程序完成</p>
</li>
<li><p>段表</p>
</li>
<li><ul>
<li>每个进程都有一张逻辑空间与内存空间映射的段表，其中每一个段表项对应进程的一个段，段表项记录该段在内存中的起始地址和段的长度<ul>
<li>在配置了段表后，执行中的进程可通过查找段表，找到每个段所对应的内存区</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1598085231446-c4b4cce0-09de-4296-85a2-7a2021e9f923.png" alt="image.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>段的共享和保护</p>
</li>
<li><ul>
<li>共享：通过两个作业的段表中相应表项指向被共享的段的同一个物理副本来实现的<ul>
<li>保护：存取控制保护、地址越界保护</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h4><ul>
<li>分页能有效地提高内存利用率，分段能反映程序的逻辑结构并有利于段的共享，将这两种存储管理方法结合起来，就形成了段页式存储管理方式</li>
<li>程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1598086260778-9d62781d-6da7-4186-af92-ecf9e30b8b47.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image.png"></li>
</ul>
<h3 id="分页与分段的比较"><a href="#分页与分段的比较" class="headerlink" title="分页与分段的比较"></a>分页与分段的比较</h3><ul>
<li>对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段</li>
<li>地址空间的维度：分页是一维地址空间，分段是二维的</li>
<li>大小是否可以改变：页的大小不可变，段的大小可以动态改变</li>
<li>出现的原因：<strong>分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护</strong></li>
</ul>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p><strong>页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）</strong></p>
<ol>
<li><strong>最佳（OPT, Optimal replacement algorithm）</strong></li>
</ol>
<ul>
<li>所<strong>选择的被换出的页面在未来最长时间内不再被访问</strong>，通常可以保证获得最低的缺页率。</li>
<li>是一种<strong>理论上的算法</strong>，因为无法知道一个页面多长时间不再被访问。</li>
</ul>
<ol start="2">
<li><p><strong>最近最久未使用（LRU, Least Recently Used）</strong></p>
</li>
<li><p><strong>最近未使用（NRU, Not Recently Used）</strong></p>
</li>
</ol>
<ul>
<li><p>每个页面都有两个状态位：R 与 M，<strong>当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1</strong>。其中 R 位会定时被清零。可以将页面分成以下四类：</p>
</li>
<li><ul>
<li><p>R=0，M=0 </p>
<ul>
<li>R=0，M=1</li>
<li>R=1，M=0</li>
<li>R=1，M=1</li>
</ul>
</li>
</ul>
</li>
<li><p>当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。</p>
</li>
<li><p><strong>NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）</strong>。</p>
</li>
</ul>
<ol start="4">
<li><strong>先进先出（FIFO, First In First Out）</strong></li>
</ol>
<ul>
<li><ul>
<li>选择换出的页面是最先进入的页面。<ul>
<li><strong>该算法会将那些经常被访问的页面换出，导致缺页率升高</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="5">
<li><strong>第二次机会算法</strong></li>
</ol>
<ul>
<li><ul>
<li><strong>FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：</strong><ul>
<li><strong>当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。</strong></li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1597061941454-03800959-859a-4877-abfd-27c39e401945.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="6">
<li><strong>时钟（Clock）</strong></li>
</ol>
<ul>
<li><ul>
<li>第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。<ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1597062565754-826091ad-7dc4-4c83-943d-343b7bd7bdac.png" alt="image.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="五、设备管理"><a href="#五、设备管理" class="headerlink" title="五、设备管理"></a>五、设备管理</h2><h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><ul>
<li><p>读写一个磁盘块的时间的影响因素有：</p>
</li>
<li><ul>
<li>旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）<ul>
<li>寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）</li>
<li>实际的数据传输时间</li>
</ul>
</li>
</ul>
</li>
<li><p>其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p>
<ul>
<li><p>先来先服务（FCFS, First Come First Served） </p>
</li>
<li><p>最短寻道时间优先（SSTF, Shortest Seek Time First）</p>
</li>
<li><p>电梯算法（SCAN） </p>
<ul>
<li>电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</li>
<li>电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。</li>
<li>因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="什么是-Spring-框架"><a href="#什么是-Spring-框架" class="headerlink" title="什么是 Spring 框架"></a>什么是 Spring 框架</h2><p>Spring 是一种轻量级开发框架，旨在提高开发人员的开发效率以及系统的可维护性。</p>
<p>一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助开发。这些模块是：核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。比如：Core Container 中的 Core 组件是Spring 所有组件的核心，Beans 组件和 Context 组件是实现IOC和依赖注入的基础，AOP组件用来实现面向切面编程。</p>
<p>Spring 官网列出的 Spring 的 6 个特征:</p>
<ul>
<li><strong>核心技术</strong> ：依赖注入(DI)，AOP，事件(events)，资源，i18n，验证，数据绑定，类型转换，SpEL。</li>
<li><strong>测试</strong> ：模拟对象，TestContext框架，Spring MVC 测试，WebTestClient。</li>
<li><strong>数据访问</strong> ：事务，DAO支持，JDBC，ORM，编组XML。</li>
<li><strong>Web支持</strong> : Spring MVC和Spring WebFlux Web框架。</li>
<li><strong>集成</strong> ：远程处理，JMS，JCA，JMX，电子邮件，任务，调度，缓存。</li>
<li><strong>语言</strong> ：Kotlin，Groovy，动态语言。</li>
</ul>
<h2 id="Spring模块"><a href="#Spring模块" class="headerlink" title="Spring模块"></a>Spring模块</h2><p>下图对应的是 Spring4.x 版本。目前最新的5.x版本中 Web 模块的 Portlet 组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/spring.jpg"></p>
<ul>
<li><strong>Spring Core：</strong> 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IoC 依赖注入功能。</li>
<li><strong>Spring Aspects</strong> ： 该模块为与AspectJ的集成提供支持。</li>
<li><strong>Spring AOP</strong> ：提供了面向切面的编程实现。</li>
<li><strong>Spring JDBC</strong> : Java数据库连接。</li>
<li><strong>Spring JMS</strong> ：Java消息服务。</li>
<li><strong>Spring ORM</strong> : 用于支持Hibernate等ORM工具。</li>
<li><strong>Spring Web</strong> : 为创建Web应用程序提供支持。</li>
<li><strong>Spring Test</strong> : 提供了对 JUnit 和 TestNG 测试的支持。</li>
</ul>
<h2 id="Spring框架的优点是什么"><a href="#Spring框架的优点是什么" class="headerlink" title="Spring框架的优点是什么"></a>Spring框架的优点是什么</h2><ul>
<li>轻量：Spring 是轻量的，基本的版本大约2MB。</li>
<li>控制反转：Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。</li>
<li>面向切面的编程(AOP)：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。</li>
<li>容器：Spring 包含并管理应用中对象的生命周期和配置。</li>
<li>MVC框架：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。</li>
<li>事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。</li>
<li>异常处理：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常。</li>
</ul>
<h2 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h2><p>IoC（Inverse of Control:控制反转）是一种<strong>设计思想</strong>，就是 <strong>将原本在程序中手动创建对象的控制权，交由Spring框架来管理。</strong> IoC 在其他语言中也有应用，并非 Spring 特有。 <strong>IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。</strong></p>
<p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 <strong>IoC 容器就像是一个工厂一样，当需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</strong> 在实际项目中一个 Service 类可能有几百甚至上千个类作为它的底层，假如需要实例化这个 Service，可能要每次都要搞清这个 Service 所有底层类的构造函数。如果利用 IoC 的话，只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。</p>
<p><strong>Spring IoC的初始化过程：</strong></p>
<p><strong><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201015160750.png" alt="image.png"></strong></p>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</p>
<p><strong>Spring AOP就是基于动态代理的</strong>，如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用<strong>Cglib</strong> ，这时候Spring AOP会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理。</p>
<p>当然也可以使用 AspectJ ,Spring AOP 已经集成了AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p>
<p>使用 AOP 之后可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。</p>
<h2 id="Spring-中的-bean-的作用域有哪些"><a href="#Spring-中的-bean-的作用域有哪些" class="headerlink" title="Spring 中的 bean 的作用域有哪些?"></a>Spring 中的 bean 的作用域有哪些?</h2><ul>
<li>singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li>
<li>prototype : 每次请求都会创建一个新的 bean 实例。</li>
<li>request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。</li>
<li>session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。</li>
<li>global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话</li>
</ul>
<h2 id="Spring-中的单例-bean-的线程安全问题了解吗？"><a href="#Spring-中的单例-bean-的线程安全问题了解吗？" class="headerlink" title="Spring 中的单例 bean 的线程安全问题了解吗？"></a>Spring 中的单例 bean 的线程安全问题了解吗？</h2><p>单例 bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候，对这个对象的非静态成员变量的写操作会存在线程安全问题。</p>
<p>常见的有两种解决办法：</p>
<ol>
<li>在Bean对象中尽量避免定义可变的成员变量（不太现实）。</li>
<li>在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。</li>
</ol>
<h2 id="Component-和-Bean-的区别是什么？"><a href="#Component-和-Bean-的区别是什么？" class="headerlink" title="@Component 和 @Bean 的区别是什么？"></a>@Component 和 @Bean 的区别是什么？</h2><ol>
<li>作用对象不同: <code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</li>
<li><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中（可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。<code>@Bean</code> 注解通常是在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了Spring这是某个类的示例，当需要用它的时候Spring进行装配加载。</li>
<li><code>@Bean</code> 注解比 <code>Component</code> 注解的自定义性更强，而且很多地方只能通过 <code>@Bean</code> 注解来注册bean。比如当引用第三方库中的类需要装配到 <code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</li>
</ol>
<h2 id="将一个类声明为Spring的-bean-的注解有哪些"><a href="#将一个类声明为Spring的-bean-的注解有哪些" class="headerlink" title="将一个类声明为Spring的 bean 的注解有哪些?"></a>将一个类声明为Spring的 bean 的注解有哪些?</h2><p>一般使用 <code>@Autowired</code> 注解自动装配 bean，要想把类标识成可用于 <code>@Autowired</code> 注解自动装配的 bean 的类,采用以下注解可实现：</p>
<ul>
<li><code>@Component</code> ：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个Bean不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li>
<li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li>
<li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao层。</li>
<li><code>@Controller</code> : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</li>
</ul>
<h2 id="SpringMVC-工作原理"><a href="#SpringMVC-工作原理" class="headerlink" title="SpringMVC 工作原理"></a>SpringMVC 工作原理</h2><ol>
<li><p>客户端（浏览器）发送请求，直接请求到 <code>DispatcherServlet</code>。</p>
</li>
<li><p><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code>，解析请求对应的 <code>Handler</code>。</p>
</li>
<li><p>解析到对应的 <code>Handler</code>（也就是平常说的 <code>Controller</code> 控制器）后，开始由 <code>HandlerAdapter</code> 适配器处理。</p>
</li>
<li><p><code>HandlerAdapter</code> 会根据 <code>Handler</code>来调用真正的处理器开处理请求，并处理相应的业务逻辑。</p>
</li>
<li><p>处理器处理完业务后，会返回一个 <code>ModelAndView</code> 对象，<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</p>
</li>
<li><p><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</p>
</li>
<li><p><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</p>
</li>
<li><p>把 <code>View</code> 返回给请求者（浏览器）</p>
<h5 id="SpringMVC-的流程"><a href="#SpringMVC-的流程" class="headerlink" title="SpringMVC 的流程"></a>SpringMVC 的流程</h5></li>
</ol>
<pre><code>![image](https://cdn.jsdelivr.net/gh/xray1025/image01/20201015152955.png)





![image](https://cdn.jsdelivr.net/gh/xray1025/image01/20201015153017.png)</code></pre>
<h2 id="Spring-框架中用到了哪些设计模式？"><a href="#Spring-框架中用到了哪些设计模式？" class="headerlink" title="Spring 框架中用到了哪些设计模式？"></a>Spring 框架中用到了哪些设计模式？</h2><ul>
<li><strong>工厂设计模式</strong> : Spring使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li>
<li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li>
<li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li>
<li><strong>包装器设计模式</strong> : 项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让可以根据客户的需求能够动态切换不同的数据源。</li>
<li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li>
<li><strong>适配器模式</strong> :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li>
</ul>
<h2 id="Spring-管理事务的方式有几种？"><a href="#Spring-管理事务的方式有几种？" class="headerlink" title="Spring 管理事务的方式有几种？"></a>Spring 管理事务的方式有几种？</h2><ul>
<li>编程式事务，在代码中硬编码。(不推荐使用)</li>
<li>声明式事务，在配置文件中配置（推荐使用） <ul>
<li>基于XML的声明式事务</li>
<li>基于注解的声明式事务 </li>
</ul>
</li>
</ul>
<h2 id="Spring-事务中的隔离级别有哪几种"><a href="#Spring-事务中的隔离级别有哪几种" class="headerlink" title="Spring 事务中的隔离级别有哪几种?"></a>Spring 事务中的隔离级别有哪几种?</h2><p><strong>TransactionDefinition 接口中定义了五个表示隔离级别的常量：</strong></p>
<ul>
<li><strong>TransactionDefinition.ISOLATION_DEFAULT:</strong> 使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.</li>
<li><strong>TransactionDefinition.ISOLATION_READ_UNCOMMITTED:</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></li>
<li><strong>TransactionDefinition.ISOLATION_READ_COMMITTED:</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li>
<li><strong>TransactionDefinition.ISOLATION_REPEATABLE_READ:</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li>
<li><strong>TransactionDefinition.ISOLATION_SERIALIZABLE:</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ul>
<h2 id="Spring-事务中哪几种事务传播行为"><a href="#Spring-事务中哪几种事务传播行为" class="headerlink" title="Spring 事务中哪几种事务传播行为?"></a>Spring 事务中哪几种事务传播行为?</h2><p><strong>支持当前事务的情况：</strong></p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_REQUIRED：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li>
<li><strong>TransactionDefinition.PROPAGATION_SUPPORTS：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li><strong>TransactionDefinition.PROPAGATION_MANDATORY：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</li>
</ul>
<p><strong>不支持当前事务的情况：</strong></p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_REQUIRES_NEW：</strong> 创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li>
<li><strong>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：</strong> 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li><strong>TransactionDefinition.PROPAGATION_NEVER：</strong> 以非事务方式运行，如果当前存在事务，则抛出异常。</li>
</ul>
<p><strong>其他情况：</strong></p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_NESTED：</strong> 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</li>
</ul>
<h2 id="Spring如何解决循环依赖"><a href="#Spring如何解决循环依赖" class="headerlink" title="Spring如何解决循环依赖"></a>Spring如何解决循环依赖</h2><h4 id="1、-循环依赖"><a href="#1、-循环依赖" class="headerlink" title="1、 循环依赖"></a>1、 循环依赖</h4><ul>
<li>循环引用：即2个或以上bean 互相持有对方，最终形成闭环。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201015150352.png" alt="img"></p>
<h4 id="2、循环依赖的场景？"><a href="#2、循环依赖的场景？" class="headerlink" title="2、循环依赖的场景？"></a>2、循环依赖的场景？</h4><p>①构造器依赖（这个解决不了，具体原因往下看）。</p>
<p>②通过setter循环依赖。（这个可以解决）。</p>
<h4 id="3-如何发现？"><a href="#3-如何发现？" class="headerlink" title="3 如何发现？"></a>3 如何发现？</h4><ul>
<li><p>spring在创建对象之前（对象还未出现）的时候，会将放在一个Set容器里，beanName为key，表示该对象正在被创建中。</p>
</li>
<li><p>如果是构造器依赖，ABC构造器循环依赖，在创建A的时候singletonsCurrentlyInCreation中有A的beanName，然后发现需要B对象，先获取B，发现B不存在，那么继续创建B，先在singletonsCurrentlyInCreation中存放B的beanName，然后发现创建B对象的时候，需要先创建C，继续查询C，发现C不存在，那么现在singletonsCurrentlyInCreation中存放C的beanName，但是创建C的时候发现需要先创建A，获取A的时候spring发现singletonsCurrentlyInCreation存在A的beanName，那么表示A当前正在被创建中，spring抛出异常。</p>
</li>
</ul>
<h4 id="4-如何解决？"><a href="#4-如何解决？" class="headerlink" title="4.如何解决？"></a>4.如何解决？</h4><p>spring的创建分为3步。</p>
<p><img src="https://www.pianshen.com/images/544/0d52e6561321baa378f949ae43fab9e0.png" alt="img"></p>
<p>①createBeanInstance：初始化对象，类似于clazz.newInstance()</p>
<p>②populateBean：填充属性，bean的对象依赖属性就是在这一步进行填充</p>
<p>③initializeBean：调用spring配置中的init-method方法</p>
<p>经过上述三步，一个spring的bean才被完全创建。setter形式的循环依赖出现在第一步跟第二步之间，所以spring在存放bean的时候做了一点文章。</p>
<p>spring将单例bean的存放利用三个hashmap作为三个级别的缓存解决循环引用问题。</p>
<h4 id="5-三级缓存"><a href="#5-三级缓存" class="headerlink" title="5 三级缓存"></a>5 三级缓存</h4><p>三级缓存源码主要是指：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Cache of singleton objects: bean name --&gt; bean instance */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;(<span class="number">256</span>);</span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name --&gt; ObjectFactory */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;String, ObjectFactory&lt;?&gt;&gt;(<span class="number">16</span>);</span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name --&gt; bean instance */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;String, Object&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<p>这三级缓存分别指：</p>
<ul>
<li>一级缓存：singletonObjects，存放完全实例化属性赋值完成的Bean，直接可以使用。</li>
<li>二级缓存：earlySingletonObjects，存放早期Bean的引用，尚未属性装配的Bean</li>
<li>三级缓存：singletonFactories，存放实例化完成的Bean工厂。</li>
</ul>
<h4 id="6-解决"><a href="#6-解决" class="headerlink" title="6 解决"></a>6 解决</h4><ul>
<li><p>bean对象填充属性的时候，先判断该bean对象是否为单例，并且是否允许提前暴露（一般都为true），如果条件都符合，则调用addSingletonFactory方法，将创建改bean对象的工厂类存存放到第三级缓存registeredSingletons中，然后如果创建过程中，该bean对象完整创建，那么该对象会被registeredSingletons移除 然后加入到一级缓存singletonObjects中。</p>
</li>
<li><p>但是如果这个时候对象创建出现了循环引用，用之前的ABC对象举例。A对象装配之前，先讲自己的对象引用存放三级缓存中registeredSingletons然后，然后发现需要对象B，调用getSingleton(B)方法，获取B的过程，先去一级缓存中查询，如果没找到，再去二级缓存，三级缓存，这个时候因为B还没有创建，所以需要创建B对象，这个时候重复之前创建A的过程，B对象先将自己的对象引用存放到registeredSingletons中 然后，装配B对象，发现这个时候需要对象C，同理，先创建C。</p>
</li>
<li><p>注意！这个时候循环引用出现了，C的创建时需要装配A的，所以利索当然的调用getSingleton(A)方法，但是之前A虽然没有创建完全，不存在一级缓存singletonObjects,但是A的对象引用存在三级缓存registeredSingletons中，C获取到A之后，讲A从三级缓存registeredSingletons中删除，移到二级缓存earlySingletonObjects中，然后C创建完成，放置一级缓存singletonObjects中，B也创建完成，放置一级缓存singletonObjects中，随后A也创建完成，放置一级缓存singletonObjects中。</p>
</li>
</ul>
<p>循环引用的问题就此解决。</p>
<h2 id="Spring容器中Bean的生命周期非常简单"><a href="#Spring容器中Bean的生命周期非常简单" class="headerlink" title="Spring容器中Bean的生命周期非常简单"></a>Spring容器中Bean的生命周期非常简单</h2><p>1.容器寻找Bean的定义信息并且将其实例化。</p>
<p>2.使用依赖注入，Spring按照Bean定义信息配置Bean的所有属性。</p>
<p>3.如果Bean实现了BeanNameAware接口，工厂调用Bean的setBeanName()方法传递Bean的ID。</p>
<p>4.如果Bean实现了BeanFactoryAware接口，工厂调用setBeanFactory()方法传入工厂自身。</p>
<p>5.如果BeanPostProcessor和Bean关联，那么它们的postProcessBeforeInitialzation()方法将被调用。</p>
<p>6.如果Bean指定了init-method方法，它将被调用。</p>
<p>7.最后，如果有BeanPsotProcessor和Bean关联，那么它们的postProcessAfterInitialization()方法将被调用。</p>
<p>到这个时候，Bean已经可以被应用系统使用了，并且将被保留在Bean Factory中知道它不再需要。有两种方法可以把它从Bean Factory中删除掉。</p>
<p>1.如果Bean实现了DisposableBean接口，destory()方法被调用。</p>
<p>2.如果指定了订制的销毁方法，就调用这个方法。</p>
<p>Bean在Spring应用上下文的生命周期与在Bean工厂中的生命周期只有一点不同，唯一不同的是，如果Bean实现了ApplicationContextAwre接口，setApplicationContext()方法被调用。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码导读</title>
    <url>/2020/11/02/0000.Spring%E6%BA%90%E7%A0%81-%E9%9B%B7%E4%B8%B0%E9%98%B3/</url>
    <content><![CDATA[<h1 id="Spring-源码导读"><a href="#Spring-源码导读" class="headerlink" title="Spring 源码导读"></a>Spring 源码导读</h1><h2 id="Spring注解"><a href="#Spring注解" class="headerlink" title="Spring注解"></a>Spring注解</h2><h3 id="组件添加"><a href="#组件添加" class="headerlink" title="组件添加"></a>组件添加</h3><ul>
<li><strong>@Configuration</strong>：用于标注配置类</li>
<li><strong>@Bean</strong> <ul>
<li>结合@Configuration（full mode）使用或结合@Component（light mode）使用。可以导入第三方组件,入方法有参数默认从IOC容器中获取，可以指定initMethod和destroyMethod 指定初始化和销毁方法,多实例对象不会调用销毁方法.</li>
</ul>
</li>
<li><strong>@ComponentScan</strong> ，包扫描<ul>
<li>@ComponentScans可以配置多个扫描</li>
<li>@TypeFilter:指定过滤规则：ANNOTATION（注解），ASSIGNABLE_TYPE（指定类型）， ASPECTJ（使用ASPECTJ表达式），cCUSTOM（自定义）<ul>
<li>includeFilters()：想要包含的注解</li>
<li>excludeFilters()：想要排除的注解</li>
</ul>
</li>
<li>组件(<strong>@Controller、@Service、@Repository、@Component</strong>)：包扫描+组件注解导入注解</li>
</ul>
</li>
<li><strong>@Scope</strong>：设置组件作用域<ul>
<li>singleton：单例的（默认值），饿汉式</li>
<li>prototype：多例的，懒汉式</li>
<li>request</li>
<li>session</li>
</ul>
</li>
<li>@Lazy 懒加载</li>
<li><strong><em>@Conditional({Condition})</em></strong><ul>
<li>按照一定的条件进行判断,满足条件给容器中注册Bean,传入Condition数组,，使用时需自己创建类继承Condition然后重写match方法。</li>
<li>Condition：<ul>
<li>ConditionContext：判断条件能使用的上下文（环境）</li>
<li>AnnotatedTypeMetadata：注释信息</li>
</ul>
</li>
</ul>
</li>
<li><strong>@Primary</strong>：Spring自动装配的时候，默认首选的 bean，配合 @Bean 使用</li>
<li><em>@<strong>Import</strong></em>[快速给容器中导入一个组件]<ol>
<li>Import(类名),容器中就会自动注册这个组件，id默认是组件的全名</li>
<li>ImportSelector：返回需要导入的组件的全类名的数组</li>
<li>ImportBeanDefinitionRegistrar：手动注册bean</li>
</ol>
</li>
<li><strong>FactoryBean</strong>：<ul>
<li>工厂Bean，交给 Spring 用来生产 Bean 到 Spring 容器中</li>
<li>默认获取 FactoryBean 调用 getObject() 创建的对象</li>
<li>可以通过前缀 &amp; 来获取 FactoryBean 本身。</li>
</ul>
</li>
</ul>
<h3 id="组件赋值"><a href="#组件赋值" class="headerlink" title="组件赋值"></a>组件赋值</h3><ul>
<li><p><strong>@Value</strong>：给属性赋值</p>
<ul>
<li>基本数值</li>
<li>#{}：SpEL</li>
<li>${}：取配置文件properties中的值（运行环境变量的值）</li>
</ul>
</li>
<li><p><strong>@Autowried</strong></p>
<ul>
<li><p>自动装配：Spring利用依赖注入（DI），完成对IOC容器中各个组件的依赖关系赋值。 </p>
</li>
<li><p>装配优先级如下：</p>
<ul>
<li><p>优先按照类型去容器中找对应的组件</p>
</li>
<li><p>其次按照属性名称去作为组件id去找对应的组件</p>
</li>
</ul>
</li>
<li><p>可以注解于构造器、参数、方法、属性，都是从IOC容器中获取参数组件的值</p>
<ul>
<li>标注在构造器上：Spring创建对象时调用构造器创建对象，只有一个有参构造器时，@Autowired可以省略</li>
<li>标注在方法上：Spring创建对象时调用方法创建对象，搭配 @Bean使用， 默认不写 </li>
</ul>
</li>
<li><p><strong>@Qualifier</strong></p>
<ul>
<li>指定默认的组件的id，而不是使用属性名称，结合 @Autowried 使用</li>
</ul>
</li>
<li><p>@Resource(JSR250)：jsr 规范，按照组件名称进行装配，不支持 require=false，属于Java注解</p>
</li>
<li><p>@Inject(JSR330)：jsr 规范和 @Autowired 功能一致，不支持 require=false，属于Java注解</p>
</li>
</ul>
</li>
<li><p>@PropertySource：读取外部配置文件中的k/v保存到运行环境中，结合@value使用，或使用ConfigurableEnvironment获取</p>
</li>
<li><p>@Profile：结合@Bean使用，默认为default环境</p>
<ul>
<li>可以通过命令行参数（-Dspring.profiles.active=test）来切换环境</li>
<li>也可通过代码激活环境：<code>applicationContext.getEnvironment().setActiveProfiles(&quot;dev&quot;);</code></li>
</ul>
</li>
</ul>
<h3 id="组件注入"><a href="#组件注入" class="headerlink" title="组件注入"></a>组件注入</h3><ul>
<li>自定义组件使用Spring容器底层的组件：需要让自定义组件实现<strong>xxxAware</strong>接口，（例如:ApplicationContextAware），spring在创建对象的时候，会帮我们自动注入。spring通过BeanPostProcessor机制，（例如:ApplicationContextAwareProcesser），来实现XXXXAware的自动注入。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContextProcessor.java</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareInterfaces</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123; </span><br><span class="line">            <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ResourceLoaderAware) &#123;</span><br><span class="line">                ((ResourceLoaderAware)bean).setResourceLoader(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationContextAware) &#123;</span><br><span class="line">                ((ApplicationContextAware)bean).setApplicationContext(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>

<h2 id="Bean生命周期"><a href="#Bean生命周期" class="headerlink" title="Bean生命周期:"></a>Bean生命周期:</h2><p><strong>指定初始化和销毁方法</strong></p>
<ol>
<li><p>通过@Bean 指定 init-method 和 destroy-method：<code>@Bean(initMethod=&quot;init&quot;,destroyMethod=&quot;destroy&quot;)</code></p>
</li>
<li><p>让 Bean 实现 InitializingBean 接口的 afterPropertiesSet() 方法定义初始化逻辑，实现 DisposableBean 接口的 destroy 方法定义销毁方法</p>
</li>
<li><p>JSR250：@PostComstruct：初始化，@PreDestroy：销毁</p>
</li>
<li><p>实现BeanPostProcessor接口的后置拦截器放入容器中，可以拦截bean初始化.</p>
<ol>
<li>postProcessBeforeInitialization() 可以在被拦截的Bean的初始化前进行处理工作。 </li>
<li>postProcessAfterInitialization() 可以在被拦截的Bean的初始化后进行一些处理工作。</li>
</ol>
</li>
</ol>
<p>spring底层常用的BeanPostProcessor：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>BeanValidationPostProcessor用来实现数据校验</span><br><span class="line"><span class="bullet">* </span>AutowireAnnotationBeanPostProcessor,@Autowire实现</span><br><span class="line"><span class="bullet">* </span>ApplicationContextProcessor实现XXXAware的自动注入。</span><br></pre></td></tr></table></figure>

<p><strong>执行时机</strong></p>
<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">doCreateBean</span><br><span class="line">-<span class="ruby">populateBean（）：给bean的各种属性赋值</span></span><br><span class="line"><span class="ruby">-initializeBean（）：初始化bean</span></span><br><span class="line"><span class="ruby">-处理Aware方法</span></span><br><span class="line"><span class="ruby">-applyBeanPostProcessorsBeforeInitialization：后置处理器的实例化前拦截</span></span><br><span class="line"><span class="ruby">-<span class="symbol">invokeInitMethods:</span>执行@Bean指定的initMethod</span></span><br><span class="line"><span class="ruby">-applyBeanPostProcessorsAfterInitialization：后置处理器的实例化后拦截</span></span><br></pre></td></tr></table></figure>

<h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ol>
<li>导入AOP模块：spring-aspects</li>
<li>定义一个业务逻辑类</li>
<li>定义一个日志切面类</li>
<li>给切面类的目标方法标注何时何地运行<ul>
<li>@Before（前置通知）</li>
<li>@After（后置通知）</li>
<li>@AfterReturning（返回通知）</li>
<li>@AfterTrowing（异常通知）</li>
<li>@Around（环绕通知）：动态代理，手动推进目标方法运行（joinPoint.procced()）</li>
<li>顺序：前置、业务逻辑、后置、返回/异常</li>
<li>5.2.7 以及之后的 spring 版本AOP的后置通知会在AfterReturning和AfterThrowing通知之后执行。</li>
</ul>
</li>
<li>将切面类和业务逻辑类加入到容器中</li>
<li>在切面类上添加注解：@Aspect</li>
<li>在配置类上添加注解：@EnableAspectJAutoProxy</li>
</ol>
<h3 id="AOP-原理"><a href="#AOP-原理" class="headerlink" title="AOP 原理"></a>AOP 原理</h3><ol>
<li><strong>@EnableAspectJAutoProxy</strong> 开启AOP功能</li>
<li>@EnableAspectJAutoProxy 回给容器注册一个组件 AnnotationAwareAspectJAutoProxyCreator；</li>
<li><strong>AnnotationAwareAspectJAutoProxyCreator</strong> 是一个后置处理器</li>
<li>容器的创建流程：<ol>
<li>registerBeanPostProcessors() 注册后置处理器，创建 AnnotationAwareAspectJAutoProxyCreator</li>
<li>finishBeanFactoryInitialization() 初始化剩下的单实例 bean</li>
<li>组件创建完成后，判断组件是否需要增强【切面的通知方法，包装成增强器（Advisor）；给业务逻辑组件创建一个代理对象（cglib）】</li>
</ol>
</li>
<li>执行目标方法<ol>
<li>代理对象执行目标方法</li>
<li>CglibAopProxy.intercept()<ol>
<li>得到目标方法的拦截器链（增强器包装成拦截器 MethodInterceptor）</li>
<li>得到拦截器的链式机制，依次进入每一个拦截器进行执行</li>
<li>顺序：前置通知、目标方法、后置通知、返回通知/异常通知</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<ol>
<li>@EnableAspectJAutoProxy<ul>
<li>@EnableAspectJAutoProxy 通过@Import(AspectJAutoProxyRegistrar.class)给spring容器中导入了一个AnnotationAwareAspectJAutoProxyCreator。</li>
<li>AnnotationAwareAspectJAutoProxyCreator实现了InstantiationAwareBeanPostProcessor,InstantiationAwareBeanPostProcessor是一个BeanPostProcessor。它可以拦截spring的Bean初始化(Initialization)前后和实例化(Initialization)前后。</li>
</ul>
</li>
<li>AnnotationAwareAspectJAutoProxyCreator的postProcessBeforeInstantiation(bean实例化前)：会通过调用isInfrastructureClass(beanClass)来判断 被拦截的类是否是基础类型的Advice、PointCut、Advisor、AopInfrastructureBean，或者是否是切面（@Aspect），若是则放入adviseBean集合。这里主要是用来处理我们的切面类。</li>
<li>AnnotationAwareAspectJAutoProxyCreator的BeanPostProcessorsAfterInitialization（bean初始化后）：<ol>
<li>首先找到被拦截的Bean的匹配的增强器（通知方法），这里有切入点表达式匹配的逻辑</li>
<li>将增强器保存到proxyFactory中，</li>
<li>根据被拦截的Bean是否实现了接口，spring自动决定使用JdkDynamicAopProxy还是ObjenesisCglibAopProxy</li>
<li>最后返回被拦截的Bean的代理对象，注册到spring容器中</li>
</ol>
</li>
<li>代理Bean的目标方法执行过程：CglibAopProxy.intercept();<ol>
<li>保存所有的增强器，并处理转换为一个拦截器链</li>
<li>如果没有拦截器链，就直接执行目标方法</li>
<li>如果有拦截器链，就将目标方法，拦截器链等信息传入并创建CglibMethodInvocation对象，并调用proceed()方法获取返回值。proceed方法内部会依次执行拦截器链。</li>
</ol>
</li>
</ol>
</blockquote>
<h2 id="Spring-声明式事务"><a href="#Spring-声明式事务" class="headerlink" title="Spring 声明式事务"></a>Spring 声明式事务</h2><p><strong>基本步骤</strong></p>
<ol>
<li>配置数据源：DataSource</li>
<li>配置事务管理器来控制事务：PlatformTransactionManager</li>
<li><strong>@EnableTransactionManagement</strong>开启基于注解的事务管理功能</li>
<li>给方法上面标注**@Transactional**标识当前方法是一个事务方法</li>
</ol>
<p><strong>声明式事务实现原理</strong></p>
<ol>
<li><strong>@EnableTransactionManagement</strong> 利用 TransactionManagementConfigurationSelector 给spring容器中导入两个组件：AutoProxyRegistrar和ProxyTransactionManagementConfiguration</li>
<li><strong>AutoProxyRegistrar **给spring容器中注册一个 InfrastructureAdvisorAutoProxyCreator 组件，InfrastructureAdvisorAutoProxyCreator 实现了InstantiationAwareBeanPostProcessor，InstantiationAwareBeanPostProcessor是一个BeanPostProcessor。它可以拦截spring的Bean初始化(Initialization)前后和实例化(Initialization)前后。</strong>利用后置处理器机制，在被拦截的bean创建以后，包装该bean并返回一个代理对象，代理对象执行方法，利用拦截器链进行调用（同 SpringAOP 的原理）**</li>
<li><strong>ProxyTransactionManagementConfiguration</strong>：是一个spring的配置类，它为spring容器注册了一个事务增强器 BeanFactoryTransactionAttributeSourceAdvisor。它有两个重要的字段：AnnotationTransactionAttributeSource 和 TransactionInterceptor。<ol>
<li>AnnotationTransactionAttributeSource：用于解析事务注解的相关信息</li>
<li>TransactionInterceptor：事务拦截器，在事务方法执行时，首先获取事务相关的属性，都会调用 TransactionInterceptor 的 invoke-&gt;invokeWithinTransaction 方法，通过配置的 PlatformTransactionManager （是否抛出异常）控制着事务的提交和回滚。</li>
</ol>
</li>
</ol>
<h2 id="Spring-扩展"><a href="#Spring-扩展" class="headerlink" title="Spring 扩展"></a>Spring 扩展</h2><ol start="2">
<li><strong>BeanPostProcessor：</strong>bean后置处理器，拦截时机：bean创建对象初始化前后进行拦截工作。可以对每一个Bean进行一些操作。</li>
<li><strong>BeanFactoryPostProcessor：</strong>beanFactory后置处理器，拦截时机：在 BeanFactory 标准初始化之后调用，所有Bean的定义信息已经加载到容器，但还没有被实例化。可以对beanFactory进行一些操作。</li>
<li><strong>BeanDefinitionRegistryPostProcessor：</strong>是 BeanFactoryPostProcessor 的子接口，拦截时机：所有Bean的定义信息将要加载到容器，但还没有被实例化，可以对每一个Bean的 BeanDefinition 进行一些操作。</li>
<li><strong>ApplicationListener</strong>：自定义 ApplicationListener 实现类并加入到容器中，可以监听 Spring 容器中发布的事件。Spring在创建容器的时候（finishRefresh() 方法）会发布 <strong>ContextRefreshedEvent</strong> 事件，关闭的时候（doClose()）会发布 <strong>ContextClosedEvent</strong> 事件。也可以通过 Spring 容器的 publishEvent 发布自己的事件。<ol>
<li>事件发布流程：publishEvent方法<ol>
<li>获取事件的多播器：getApplicationEventMulticaster()。</li>
<li>调用 multicastEvent(applicationEvent, eventType) 派发事件。获取到所有的 ApplicationListener，即 getApplicationListeners()，然后同步或者异步的方式执行监听器的 onApplicationEvent。</li>
</ol>
</li>
<li>事件的多播器的初始化中（initApplicationEventMulticaster()），如果容器中没有配置applicationEventMulticaster，就使用SimpleApplicationEventMulticaster。然后获取所有的监听器，并把它们注册到SimpleApplicationEventMulticaster中。</li>
</ol>
</li>
<li>**@EventListener(class={})**：在普通的业务逻辑的方法上监听事件特定的事件。原理：EventListenerMethodProcessor是一个SmartInitializingSingleton，当所有的单例bean都初始化完以后， 容器会回调该接口的方法afterSingletonsInstantiated(),该方法里会遍历容器中所有的bean，并判断每一个bean里是否带有@EventListener注解的Method，然后创建ApplicationListenerMethodAdapter存储并包装该Method，最后将ApplicationListenerMethodAdapter添加到spring容器中。</li>
</ol>
<h2 id="Spring源代码分析"><a href="#Spring源代码分析" class="headerlink" title="Spring源代码分析"></a>Spring源代码分析</h2><p>spring核心逻辑AbstractApplicationContext的refresh()方法如下</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public void refresh<span class="literal">()</span> &#123;</span><br><span class="line">    synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// 刷新前的预准备工作</span></span><br><span class="line">        prepare<span class="constructor">Refresh()</span>;</span><br><span class="line">        <span class="comment">// 提取bean的配置信息并封装成BeanDefinition实例，然后将其添加到注册中心。注册中心是一个ConcurrentHashMap&lt;String,BeanDefinition&gt;类型，key为Bean的名字，value为BeanDefinition实例。</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = obtain<span class="constructor">FreshBeanFactory()</span>;</span><br><span class="line">       <span class="comment">//对beanFactory进行一些配置，注册一些BeanPostProcessor和一些特殊的Bean。</span></span><br><span class="line">        prepare<span class="constructor">BeanFactory(<span class="params">beanFactory</span>)</span>;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">//留给子类在BeanFactory准备工作完成后处理一些工作。</span></span><br><span class="line">            post<span class="constructor">ProcessBeanFactory(<span class="params">beanFactory</span>)</span>;</span><br><span class="line">           <span class="comment">//调用 BeanFactory的后置处理器。</span></span><br><span class="line">           invoke<span class="constructor">BeanFactoryPostProcessors(<span class="params">beanFactory</span>)</span>;</span><br><span class="line">           <span class="comment">//注册Bean的后置处理器。</span></span><br><span class="line">            register<span class="constructor">BeanPostProcessors(<span class="params">beanFactory</span>)</span>;</span><br><span class="line">            <span class="comment">//国际化相关功能</span></span><br><span class="line">            init<span class="constructor">MessageSource()</span>;</span><br><span class="line">            <span class="comment">//初始化事件派发器；</span></span><br><span class="line">            init<span class="constructor">ApplicationEventMulticaster()</span>;</span><br><span class="line">            <span class="comment">// 提供给子容器类，供子容器去实例化其他的特殊的Bean</span></span><br><span class="line">            on<span class="constructor">Refresh()</span>;</span><br><span class="line">            <span class="comment">// 处理容器中已有的ApplicationListener</span></span><br><span class="line">            register<span class="constructor">Listeners()</span>;</span><br><span class="line">            <span class="comment">//初始化容器中剩余的单实例bean</span></span><br><span class="line">            finish<span class="constructor">BeanFactoryInitialization(<span class="params">beanFactory</span>)</span>;</span><br><span class="line">            <span class="comment">//最后一步</span></span><br><span class="line">            finish<span class="constructor">Refresh()</span>;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="prepareRefresh"><a href="#prepareRefresh" class="headerlink" title="prepareRefresh()"></a>prepareRefresh()</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 记录启动时间，设置容器的active和close状态。 </span><br><span class="line"><span class="number">2.</span> initPropertySources():提供给子容器类，子容器类可覆盖该方法进行一些自定义的属性设置。</span><br><span class="line"><span class="number">3.</span> getEnvironment().validateRequiredProperties()：检验属性的合法性</span><br><span class="line"><span class="number">4.</span> <span class="keyword">this</span>.earlyApplicationEvents = new LinkedHashSet&lt;ApplicationEvent&gt;() ：保存容器中的一些早期的事件，待事件多播器创建后执行。</span><br></pre></td></tr></table></figure>

<h3 id="obtainFreshBeanFactory"><a href="#obtainFreshBeanFactory" class="headerlink" title="obtainFreshBeanFactory()"></a>obtainFreshBeanFactory()</h3><p>提取bean的配置信息并封装成BeanDefinition实例，然后将其添加到注册中心。注册中心是一个ConcurrentHashMap&lt;String,BeanDefinition&gt;类型，key为Bean的名字，value为BeanDefinition实例。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> refreshBeanFactory：如果当前容器已经有了BeanFactory就销毁原来的BeanFactory。然后创建一个DefaultListableBeanFactory();</span><br><span class="line"><span class="bullet">    *</span> 对BeanFactory并进行配置，主要配置是否允许BeanDefinition覆盖，是否允许Bean间的循环引用。</span><br><span class="line"><span class="bullet">    *</span> 加载BeanDefinition，解析XML文件和配置文件，将其转换为BeanDefinition，然后保存到DefaultListableBeanFactory的beanDefinitionMap字段中。</span><br><span class="line"><span class="bullet">2.</span> getBeanFactory() 简单的返回beanFactory，即DefaultListableBeanFactory。</span><br></pre></td></tr></table></figure>

<h3 id="prepareBeanFactory（）"><a href="#prepareBeanFactory（）" class="headerlink" title="prepareBeanFactory（）"></a>prepareBeanFactory（）</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 设置BeanFactory的类加载器、设置支持SPEL表达式的解析器。</span><br><span class="line"><span class="number">2.</span> 添加ApplicationContextAwareProcessor用于处理XXXAware接口的回调。 </span><br><span class="line"><span class="number">3.</span> 设置忽略一些接口。并注册一些类，这些类可以在bean里直接进行自动装配。</span><br><span class="line"><span class="number">4.</span> 添加ApplicationListenerDetector用于识别并保存ApplicationListener的子类。</span><br></pre></td></tr></table></figure>

<h3 id="postProcessBeanFactory（）："><a href="#postProcessBeanFactory（）：" class="headerlink" title="postProcessBeanFactory（）："></a>postProcessBeanFactory（）：</h3><p>提供给子容器类，子容器类可以覆盖该方法在BeanFactory准备工作完成后处理一些工作。</p>
<h3 id="invokeBeanFactoryPostProcessors"><a href="#invokeBeanFactoryPostProcessors" class="headerlink" title="invokeBeanFactoryPostProcessors()"></a>invokeBeanFactoryPostProcessors()</h3><p>执行BeanFactoryPostProcessor类型的监听方法。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span> BeanFactoryPostProcessor是beanFactory后置处理器，在整个BeanFactory标准初始化完成后进行拦截调用， </span><br><span class="line"><span class="bullet">*</span> BeanDefinitionRegistryPostProcessor继承了BeanFactoryPostProcessor，在beanFactory解析完所有的BeanDefinition后拦截调用。</span><br><span class="line"><span class="bullet">*</span> BeanFactoryPostProcessor来源</span><br><span class="line"><span class="bullet">    *</span> 通过ApplicationContent的addBeanFactoryPostProcessor()方法手动添加自己的拦截器</span><br><span class="line"><span class="bullet">    *</span> 系统默认了一些BeanFactoryPostProcessor。例如：ConfigurationClassPostProcessor用来处理@Configuration标注的Spring配置类。</span><br><span class="line"><span class="bullet">*</span> 调用顺序 </span><br><span class="line"><span class="bullet">    1.</span> 先调用BeanDefinitionRegistryPostProcessor类型的拦截器，</span><br><span class="line"><span class="bullet">    2.</span> 然后再依次调用实现了PriorityOrdered,Ordered接口的BeanFactoryPostProcessor</span><br><span class="line"><span class="bullet">    3.</span> 最后调用普通的BeanFactoryPostProcessor</span><br></pre></td></tr></table></figure>

<h3 id="registerBeanPostProcessors"><a href="#registerBeanPostProcessors" class="headerlink" title="registerBeanPostProcessors()"></a>registerBeanPostProcessors()</h3><p>注册Bean的后置处理器。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 从beanFactory里获取所有BeanPostProcessor类型的Bean的名称。</span><br><span class="line"><span class="number">2.</span> 调用beanFactory的getBean方法并传入每一个BeanPostProcesso类型的Bean名称，从容器中获取该Bean的实例。</span><br><span class="line"><span class="number">3.</span> </span><br><span class="line">    <span class="number">1.</span> 第一步向beanFactory注册实现了PriorityOrdered的BeanPostProcessor类型的Bean实例。</span><br><span class="line">    <span class="number">2.</span> 第二步向beanFactory注册实现了Ordered的BeanPostProcessor类型的Bean实例。</span><br><span class="line">    <span class="number">3.</span> 第三步向beanFactory注册普通的BeanPostProcessor类型的Bean实例。</span><br><span class="line">    <span class="number">4.</span> 最后一步向beanFactory重新注册实现了MergedBeanDefinitionPostProcessor的BeanPostProcessor类型的Bean实例</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 向beanFactory注册BeanPostProcessor的过程就是简单的将实例保存到beanFactory的beanPostProcessors属性中。</span><br></pre></td></tr></table></figure>

<h3 id="initMessageSource"><a href="#initMessageSource" class="headerlink" title="initMessageSource()"></a>initMessageSource()</h3><p>国际化相关功能</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 看容器中是否有id为messageSource的，类型是MessageSource的Bean实例。如果有赋值给messageSource，如果没有自己创建一个DelegatingMessageSource。</span><br><span class="line"><span class="number">2.</span> 把创建好的MessageSource注册在容器中，以后获取国际化配置文件的值的时候，可以自动注入MessageSource。</span><br></pre></td></tr></table></figure>

<h3 id="initApplicationEventMulticaster"><a href="#initApplicationEventMulticaster" class="headerlink" title="initApplicationEventMulticaster()"></a>initApplicationEventMulticaster()</h3><p>初始化事件派发器；</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 看容中是否有名称为applicationEventMulticaster的，类型是ApplicationEventMulticaster的Bean实例。如果没有就创建一个SimpleApplicationEventMulticaster。</span><br><span class="line"><span class="number">2.</span> 把创建好的ApplicationEventMulticaster添加到BeanFactory中。</span><br></pre></td></tr></table></figure>

<h3 id="onRefresh-："><a href="#onRefresh-：" class="headerlink" title="onRefresh()："></a>onRefresh()：</h3><p>提供给子容器类，供子容器去实例化其他的特殊的Bean。</p>
<h3 id="registerListeners-："><a href="#registerListeners-：" class="headerlink" title="registerListeners()："></a>registerListeners()：</h3><p>处理容器中已有的ApplicationListener。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 从容器中获得所有的ApplicationListener</span><br><span class="line"><span class="number">2.</span> 将每个监听器添加到事件派发器（ApplicationEventMulticaster）中；</span><br><span class="line"><span class="number">3.</span> 处理之前步骤产生的事件；</span><br></pre></td></tr></table></figure>

<h3 id="finishBeanFactoryInitialization-："><a href="#finishBeanFactoryInitialization-：" class="headerlink" title="finishBeanFactoryInitialization()："></a>finishBeanFactoryInitialization()：</h3><p>初始化容器中剩余的单实例bean：拿到剩余的所有的BeanDefinition，依次调用getBean方法（详看beanFactory.getBean的执行流程）</p>
<h3 id="finishRefresh-："><a href="#finishRefresh-：" class="headerlink" title="finishRefresh()："></a>finishRefresh()：</h3><p>最后一步。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 初始化和生命周期有关的后置处理器；LifecycleProcessor，如果容器中没有指定处理就创建一个DefaultLifecycleProcessor加入到容器。</span><br><span class="line"><span class="number">2.</span> 获取容器中所有的LifecycleProcessor回调onRefresh()方法。</span><br><span class="line"><span class="number">3.</span> 发布容器刷新完成事件ContextRefreshedEvent。</span><br></pre></td></tr></table></figure>

<h3 id="ConfigurationClassPostProcessor处理-Configuration的过程："><a href="#ConfigurationClassPostProcessor处理-Configuration的过程：" class="headerlink" title="ConfigurationClassPostProcessor处理@Configuration的过程："></a>ConfigurationClassPostProcessor处理@Configuration的过程：</h3><ol>
<li>先从主从中心取出所有的 BeanDefinition。依次判断，若一个 BeanDefinition 是被 @Configuration 标注的，spring 将其标记为 FullMode，否则若一个 BeanDefinition 没有被 @Configuration 标注，但有被 @Bean 标注的方法，spring 将其标记为 LightMode。筛选出所有候选配置BeanDefinition（FullMode和LightMode）</li>
<li>创建一个 ConfigurationClassParser，调用 parse 方法解析每一个配置类。<ol>
<li>解析@PropertySources,将解析结果设置到Environment</li>
<li>利用ComponentScanAnnotationParser，将@ComponentScans标签解析成BeanDefinitionHolder。再迭代解析BeanDefinitionHolder</li>
<li>解析@Import，@ImportResource</li>
<li>将@Bean解析为MethodMetadata，将结果保存到ConfigurationClass中。最终ConfigurationClass会被保存到ConfigurationClassParser的configurationClasses中。</li>
</ol>
</li>
<li>调用ConfigurationClassParser的loadBeanDefinitions方法，加载解析结果到注册中。<ol>
<li>从利用ComponentScanAnnotationParser的configurationClasses获取所有的ConfigurationClass，依次调用loadBeanDefinitionsForConfigurationClass方法。</li>
<li>loadBeanDefinitionsForConfigurationClass会将每一个BeanMethod转为ConfigurationClassBeanDefinition，最后将其添加到spring的注册中心。</li>
</ol>
</li>
</ol>
<h3 id="beanFactory-getBean方法执行的过程"><a href="#beanFactory-getBean方法执行的过程" class="headerlink" title="beanFactory.getBean方法执行的过程"></a>beanFactory.getBean方法执行的过程</h3><ol>
<li>首先将方法传入的beanName进行转换：先去除FactoryBean前缀（&amp;符）如果传递的beanName是别名，则通过别名找到bean的原始名称。</li>
<li>根据名称先从singletonObjects（一个Map类型的容）获取bean实例。如果能获取到就先判断该bean实例是否实现了FactoryBean，如果是FactoryBean类型的bean实例，就通过FactoryBean获取Bean。然后直接返回该bean实例。getBean方法结束。</li>
<li>如果从singletonObjects没有获取到bean实例就开始创建Bean的过程。<ol>
<li>首先标记该Bean处于创建状态。</li>
<li>根据Bean的名称找到BeanDefinition。查看该Bean是否有前置依赖的Bean。若有则先创建该Bean前置依赖的Bean。</li>
<li>spring调用AbstractAutowireCapableBeanFactory的createBean方法并传入BeanDefinition开始创建对象。先调用resolveBeforeInstantiation给BeanPostProcessor一个机会去返回一个代理对象去替代目标Bean的实例。</li>
<li>如果BeanPostProcessor没有返回Bean的代理就通过doCreateBean方法创建对象。<ol>
<li>首先确定Bean的构造函数，如果有有参构造器，先自动装配有参构造器，默认使用无参数构造器。</li>
<li>选择一个实例化策略去实例化bean。默认使用CglibSubclassingInstantiationStrategy。该策略模式中,首先判断bean是否有方法被覆盖,如果没有则直接通过反射的方式来创建,如果有的话则通过CGLIB来实例化bean对象. 把创建好的bean对象包裹在BeanWrapper里。</li>
<li>调用MergedBeanDefinitionPostProcessor的postProcessMergedBeanDefinition</li>
<li>判断容器是否允许循环依赖，如果允许循环依赖，就创建一个ObjectFactory类并实现ObjectFactory接口的唯一的一个方法getObject（）用于返回Bean。然后将该ObjectFactory添加到singletonFactories中。</li>
<li>调用populateBean为bean实例赋值。在赋值之前执行InstantiationAwareBeanPostProcessor的postProcessAfterInstantiation和postProcessPropertyValues方法。</li>
<li>调用initializeBean初始化bean。如果Bean实现了XXXAware，就先处理对应的Aware方法。然后调用beanProcessor的postProcessBeforeInitialization方法。再以反射的方式调用指定的bean指定的init方法。最后调用beanProcessor的postProcessAfterInitialization方法。</li>
<li>调用registerDisposableBeanIfNecessary，将该bean保存在一个以beanName为key，以包装了bean引用的DisposableBeanAdapter，为value的map中，在spring容器关闭时，遍历这个map来获取需要调用bean来依次调用Bean的destroyMethod指定的方法。</li>
</ol>
</li>
<li>将新创建出来的Bean保存到singletonObjects中</li>
</ol>
</li>
</ol>
<h2 id="spring原理补充"><a href="#spring原理补充" class="headerlink" title="spring原理补充"></a>spring原理补充</h2><h3 id="spring解决循环依赖"><a href="#spring解决循环依赖" class="headerlink" title="spring解决循环依赖"></a>spring解决循环依赖</h3><p><strong>以类A，B互相依赖注入为例</strong></p>
<ol>
<li>根据类A的名称先从singletonObjects获取Bean实例，发现获取不到，就通过doGetBean方法开始创建Bean的流程。</li>
<li>根据A的名称找到对应的BeanDefinition，通过doCreateBean（）方法创建对象，先确定类A的构造函数，然后选择一个实例化策略去实例化类A。</li>
<li>判断容器是否允许循环依赖，如果允许循环依赖，就创建一个ObjectFactory类并实现ObjectFactory接口的唯一的一个方法getObject（）用于返回类A。然后将该ObjectFactory添加到singletonFactories中。</li>
<li>调用populateBean（）为类A进行属性赋值，发现需要依赖类B，此时类B尚未创建，启动创建类B的流程。<ol>
<li>根据类B的名称先从singletonObjects获取Bean实例，发现获取不到，就开始通过doGetBean方法开始创建Bean的流程</li>
<li>找到类B对应的BeanDefinition，确认B的构造函数，然后实例化B。</li>
<li>判断容器是否允许循环依赖，创建一个ObjectFactory并实现getObject（）方法，用于返回类B，并添加到singletonFactories中。</li>
<li>调用populateBean（）为类B进行属性赋值，发现需要依赖类A，调用getSingleton方法获取A：A现在已存在于singletonFactories中，getSingleton将A从singletonFactories方法中移除并放入earlySingletonObjects中。</li>
<li>调用getSingleton（）方法获取B：getSingleton将A从singletonFactories方法中移除并放入earlySingletonObjects中。</li>
<li>调用initializeBean初始化bean，最后将新创建出来的类B保存到singletonObjects中</li>
</ol>
</li>
<li>调用getSingleton（）方法获取A，这时A已在earlySingletonObjects中了，就直接返回A</li>
<li>调用initializeBean初始化bean，最后将新创建出来的类B保存到singletonObjects中。</li>
</ol>
<h3 id="Autowire-实现原理"><a href="#Autowire-实现原理" class="headerlink" title="@Autowire 实现原理"></a>@Autowire 实现原理</h3><p>上面介绍<strong>beanFactory.getBean方法执行的过程</strong>中提到：populateBean为bean实例赋值。在赋值之前执行InstantiationAwareBeanPostProcessor的postProcessAfterInstantiation和postProcessPropertyValues方法。@Autowire由AutowiredAnnotationBeanPostProcessor完成，它实现了InstantiationAwareBeanPostProcessor。<br>AutowiredAnnotationBeanPostProcessor执行过程：</p>
<ol>
<li>postProcessAfterInstantiation方法执行，直接return null。</li>
<li>postProcessPropertyValues方法执行，主要逻辑在此处理。待补充。。。。。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis面试题</title>
    <url>/2020/10/15/0000.Mybatis%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="Mybatis面试题"><a href="#Mybatis面试题" class="headerlink" title="Mybatis面试题"></a>Mybatis面试题</h1><h1 id="1、-和-的区别是什么？"><a href="#1、-和-的区别是什么？" class="headerlink" title="1、#{}和${}的区别是什么？"></a>1、#{}和${}的区别是什么？</h1><ul>
<li><code>$&#123;&#125;</code>是 Properties 文件中的变量占位符，它可以用于标签属性值和 sql 内部，属于静态文本替换，比如${driver}会被静态替换为<code>com.mysql.jdbc.Driver</code>。</li>
<li><code>#&#123;&#125;</code>是 sql 的参数占位符，Mybatis 会将 sql 中的<code>#&#123;&#125;</code>替换为?号，在 sql 执行前会使用 PreparedStatement 的参数设置方法，按序给 sql 的?号占位符设置参数值，比如 ps.setInt(0, parameterValue)，<code>#&#123;item.name&#125;</code> 的取值方式为使用反射从参数对象中获取 item 对象的 name 属性值，相当于 <code>param.getItem().getName()</code>。</li>
</ul>
<h1 id="2、Xml-映射文件中，除了常见的-select-insert-updae-delete-标签之外，还有哪些标签？"><a href="#2、Xml-映射文件中，除了常见的-select-insert-updae-delete-标签之外，还有哪些标签？" class="headerlink" title="2、Xml 映射文件中，除了常见的 select|insert|updae|delete 标签之外，还有哪些标签？"></a>2、Xml 映射文件中，除了常见的 select|insert|updae|delete 标签之外，还有哪些标签？</h1><p>还有很多其他的标签，<code>&lt;resultMap&gt;</code>、<code>&lt;parameterMap&gt;</code>、<code>&lt;sql&gt;</code>、<code>&lt;include&gt;</code>、<code>&lt;selectKey&gt;</code>，加上动态 sql 的 9 个标签，<code>trim|where|set|foreach|if|choose|when|otherwise|bind</code>等，其中为 sql 片段标签，通过<code>&lt;include&gt;</code>标签引入 sql 片段，<code>&lt;selectKey&gt;</code>为不支持自增的主键生成策略标签。</p>
<h1 id="3、通常一个-Xml-映射文件，都会写一个-Dao-接口与之对应，请问，这个-Dao-接口的工作原理是什么？Dao-接口里的方法，参数不同时，方法能重载吗？"><a href="#3、通常一个-Xml-映射文件，都会写一个-Dao-接口与之对应，请问，这个-Dao-接口的工作原理是什么？Dao-接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="3、通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？"></a>3、通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？</h1><p>Dao 接口，就是人们常说的 <code>Mapper</code>接口，接口的全限名，就是映射文件中的 namespace 的值，接口的方法名，就是映射文件中<code>MappedStatement</code>的 id 值，接口方法内的参数，就是传递给 sql 的参数。<code>Mapper</code>接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个<code>MappedStatement</code>，举例：<code>com.mybatis3.mappers.StudentDao.findStudentById</code>，可以唯一找到 namespace 为<code>com.mybatis3.mappers.StudentDao</code>下面<code>id = findStudentById</code>的<code>MappedStatement</code>。在 Mybatis 中，每一个<code>&lt;select&gt;</code>、<code>&lt;insert&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;delete&gt;</code>标签，都会被解析为一个<code>MappedStatement</code>对象。</p>
<p>Dao 接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</p>
<p>Dao 接口的工作原理是 JDK 动态代理，Mybatis 运行时会使用 JDK 动态代理为 Dao 接口生成代理 proxy 对象，代理对象 proxy 会拦截接口方法，转而执行<code>MappedStatement</code>所代表的 sql，然后将 sql 执行结果返回。</p>
<h1 id="4、Mybatis-是如何进行分页的？分页插件的原理是什么？"><a href="#4、Mybatis-是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="4、Mybatis 是如何进行分页的？分页插件的原理是什么？"></a>4、Mybatis 是如何进行分页的？分页插件的原理是什么？</h1><p>Mybatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页，而非物理分页，可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p>
<p>分页插件的基本原理是使用 Mybatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。</p>
<p>举例：<code>select _ from student</code>，拦截 sql 后重写为：<code>select t._ from （select \* from student）t limit 0，10</code></p>
<h1 id="5、简述-Mybatis-的插件运行原理，以及如何编写一个插件。"><a href="#5、简述-Mybatis-的插件运行原理，以及如何编写一个插件。" class="headerlink" title="5、简述 Mybatis 的插件运行原理，以及如何编写一个插件。"></a>5、简述 Mybatis 的插件运行原理，以及如何编写一个插件。</h1><p>Mybatis 仅可以编写针对 <code>ParameterHandler</code>、<code>ResultSetHandler</code>、<code>StatementHandler</code>、<code>Executor</code> 这 4 种接口的插件，Mybatis 使用 JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 <code>InvocationHandler</code> 的 <code>invoke()</code>方法，当然，只会拦截那些指定需要拦截的方法。</p>
<p>实现 Mybatis 的 Interceptor 接口并复写<code>intercept()</code>方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，在配置文件中配置编写的插件。</p>
<h1 id="6、Mybatis-执行批量插入，能返回数据库主键列表吗？"><a href="#6、Mybatis-执行批量插入，能返回数据库主键列表吗？" class="headerlink" title="6、Mybatis 执行批量插入，能返回数据库主键列表吗？"></a>6、Mybatis 执行批量插入，能返回数据库主键列表吗？</h1><p>能，JDBC 都能，Mybatis 当然也能。</p>
<h1 id="7、Mybatis-动态-sql-是做什么的？都有哪些动态-sql？能简述一下动态-sql-的执行原理不？"><a href="#7、Mybatis-动态-sql-是做什么的？都有哪些动态-sql？能简述一下动态-sql-的执行原理不？" class="headerlink" title="7、Mybatis 动态 sql 是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？"></a>7、Mybatis 动态 sql 是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？</h1><p>Mybatis 动态 sql 可以在 Xml 映射文件内，以标签的形式编写动态 sql，完成逻辑判断和动态拼接 sql 的功能，Mybatis 提供了 9 种动态 sql 标签 <code>trim|where|set|foreach|if|choose|when|otherwise|bind</code>。</p>
<p>其执行原理为，使用 OGNL 从 sql 参数对象中计算表达式的值，根据表达式的值动态拼接 sql，以此来完成动态 sql 的功能。</p>
<h1 id="8、Mybatis-是如何将-sql-执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#8、Mybatis-是如何将-sql-执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="8、Mybatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>8、Mybatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？</h1><p>第一种是使用<code>&lt;resultMap&gt;</code>标签，逐一定义列名和对象属性名之间的映射关系。第二种是使用 sql 列的别名功能，将列别名书写为对象属性名，比如 T_NAME AS NAME，对象属性名一般是 name，小写，但是列名不区分大小写，Mybatis 会忽略列名大小写，智能找到与之对应对象属性名，甚至可以写成 T_NAME AS NaMe，Mybatis 一样可以正常工作。</p>
<p>有了列名与属性名的映射关系后，Mybatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p>
<h1 id="9、Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#9、Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="9、Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？"></a>9、Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？</h1><p>Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载，association 指的就是一对一，collection 指的就是一对多查询。在 Mybatis 配置文件中，可以配置是否启用延迟加载 <code>lazyLoadingEnabled=true|false。</code></p>
<p>它的原理是，使用<code>CGLIB</code> 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 <code>a.getB().getName()</code>，拦截器 <code>invoke()</code>方法发现 <code>a.getB()</code>是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 <code>a.getB().getName()</code>方法的调用。这就是延迟加载的基本原理。</p>
<p>当然了，不光是 Mybatis，几乎所有的包括 Hibernate，支持延迟加载的原理都是一样的。</p>
<h1 id="10、Mybatis-的-Xml-映射文件中，不同的-Xml-映射文件，id-是否可以重复？"><a href="#10、Mybatis-的-Xml-映射文件中，不同的-Xml-映射文件，id-是否可以重复？" class="headerlink" title="10、Mybatis 的 Xml 映射文件中，不同的 Xml 映射文件，id 是否可以重复？"></a>10、Mybatis 的 Xml 映射文件中，不同的 Xml 映射文件，id 是否可以重复？</h1><p>不同的 Xml 映射文件，如果配置了 namespace，那么 id 可以重复；如果没有配置 namespace，那么 id 不能重复；毕竟 namespace 不是必须的，只是最佳实践而已。</p>
<p>原因就是 namespace+id 是作为 <code>Map&lt;String, MappedStatement&gt;</code>的 key 使用的，如果没有 namespace，就剩下 id，那么，id 重复会导致数据互相覆盖。有了 namespace，自然 id 就可以重复，namespace 不同，namespace+id 自然也就不同。</p>
<h1 id="11、Mybatis-中如何执行批处理？"><a href="#11、Mybatis-中如何执行批处理？" class="headerlink" title="11、Mybatis 中如何执行批处理？"></a>11、Mybatis 中如何执行批处理？</h1><p>使用 BatchExecutor 完成批处理。</p>
<h1 id="12、Mybatis-都有哪些-Executor-执行器？它们之间的区别是什么？"><a href="#12、Mybatis-都有哪些-Executor-执行器？它们之间的区别是什么？" class="headerlink" title="12、Mybatis 都有哪些 Executor 执行器？它们之间的区别是什么？"></a>12、Mybatis 都有哪些 Executor 执行器？它们之间的区别是什么？</h1><p>Mybatis 有三种基本的 Executor 执行器，**<code>SimpleExecutor</code>、<code>ReuseExecutor</code>、<code>BatchExecutor</code>。**</p>
<p><strong><code>SimpleExecutor</code>：</strong>每执行一次 update 或 select，就开启一个 Statement 对象，用完立刻关闭 Statement 对象。</p>
<p><strong><code>ReuseExecutor</code>：</strong>执行 update 或 select，以 sql 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后，不关闭 Statement 对象，而是放置于 Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用 Statement 对象。</p>
<p><strong><code>BatchExecutor</code>：</strong>执行 update（没有 select，JDBC 批处理不支持 select），将所有 sql 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理。与 JDBC 批处理相同。</p>
<p>作用范围：Executor 的这些特点，都严格限制在 SqlSession 生命周期范围内。</p>
<h1 id="13、Mybatis-中如何指定使用哪一种-Executor-执行器？"><a href="#13、Mybatis-中如何指定使用哪一种-Executor-执行器？" class="headerlink" title="13、Mybatis 中如何指定使用哪一种 Executor 执行器？"></a>13、Mybatis 中如何指定使用哪一种 Executor 执行器？</h1><p>在 Mybatis 配置文件中，可以指定默认的 ExecutorType 执行器类型，也可以手动给 <code>DefaultSqlSessionFactory</code> 的创建 SqlSession 的方法传递 ExecutorType 类型参数。</p>
<h1 id="14、Mybatis-是否可以映射-Enum-枚举类？"><a href="#14、Mybatis-是否可以映射-Enum-枚举类？" class="headerlink" title="14、Mybatis 是否可以映射 Enum 枚举类？"></a>14、Mybatis 是否可以映射 Enum 枚举类？</h1><p>Mybatis 可以映射枚举类，不单可以映射枚举类，Mybatis 可以映射任何对象到表的一列上。映射方式为自定义一个 <code>TypeHandler</code>，实现 <code>TypeHandler</code> 的 <code>setParameter()</code>和 <code>getResult()</code>接口方法。<code>TypeHandler</code> 有两个作用，一是完成从 javaType 至 jdbcType 的转换，二是完成 jdbcType 至 javaType 的转换，体现为 <code>setParameter()</code>和 <code>getResult()</code>两个方法，分别代表设置 sql 问号占位符参数和获取列查询结果。</p>
<h1 id="15、Mybatis-映射文件中，如果-A-标签通过-include-引用了-B-标签的内容，请问，B-标签能否定义在-A-标签的后面，还是说必须定义在-A-标签的前面？"><a href="#15、Mybatis-映射文件中，如果-A-标签通过-include-引用了-B-标签的内容，请问，B-标签能否定义在-A-标签的后面，还是说必须定义在-A-标签的前面？" class="headerlink" title="15、Mybatis 映射文件中，如果 A 标签通过 include 引用了 B 标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在 A 标签的前面？"></a>15、Mybatis 映射文件中，如果 A 标签通过 include 引用了 B 标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在 A 标签的前面？</h1><p>虽然 Mybatis 解析 Xml 映射文件是按照顺序解析的，但是，被引用的 B 标签依然可以定义在任何地方，Mybatis 都可以正确识别。</p>
<p>原理是，Mybatis 解析 A 标签，发现 A 标签引用了 B 标签，但是 B 标签尚未解析到，尚不存在，此时，Mybatis 会将 A 标签标记为未解析状态，然后继续解析余下的标签，包含 B 标签，待所有标签解析完毕，Mybatis 会重新解析那些被标记为未解析的标签，此时再解析 A 标签时，B 标签已经存在，A 标签也就可以正常解析完成了。</p>
<h1 id="16、简述-Mybatis-的-Xml-映射文件和-Mybatis-内部数据结构之间的映射关系？"><a href="#16、简述-Mybatis-的-Xml-映射文件和-Mybatis-内部数据结构之间的映射关系？" class="headerlink" title="16、简述 Mybatis 的 Xml 映射文件和 Mybatis 内部数据结构之间的映射关系？"></a>16、简述 Mybatis 的 Xml 映射文件和 Mybatis 内部数据结构之间的映射关系？</h1><p>Mybatis 将所有 Xml 配置信息都封装到 All-In-One 重量级对象 Configuration 内部。在 Xml 映射文件中，<code>&lt;parameterMap&gt;</code>标签会被解析为 <code>ParameterMap</code> 对象，其每个子元素会被解析为 ParameterMapping 对象。<code>&lt;resultMap&gt;</code>标签会被解析为 <code>ResultMap</code> 对象，其每个子元素会被解析为 <code>ResultMapping</code> 对象。每一个<code>&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;</code>标签均会被解析为 <code>MappedStatement</code> 对象，标签内的 sql 会被解析为 BoundSql 对象。</p>
<h1 id="17、为什么说-Mybatis-是半自动-ORM-映射工具？它与全自动的区别在哪里？"><a href="#17、为什么说-Mybatis-是半自动-ORM-映射工具？它与全自动的区别在哪里？" class="headerlink" title="17、为什么说 Mybatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？"></a>17、为什么说 Mybatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？</h1><p>Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而 Mybatis 在查询关联对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自动 ORM 映射工具。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot面试题</title>
    <url>/2020/10/30/000001.SpringBoot%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="SpringBoot和SpringMVC的区别"><a href="#SpringBoot和SpringMVC的区别" class="headerlink" title="SpringBoot和SpringMVC的区别"></a>SpringBoot和SpringMVC的区别</h1><ol>
<li>SpringMVC是Spring的一个模式，是一个Web框架，提供了一个轻度耦合的方式来开发Web应用；</li>
<li>SpringBoot是习惯优于配置，降低了项目搭建的难度；</li>
<li>SpringMVC需要使用到 Tomcat 服务器，SpringBoot 的话是内嵌了 Tomcat 服务器的。</li>
</ol>
<h1 id="SpringBoot相对于Spring的优势"><a href="#SpringBoot相对于Spring的优势" class="headerlink" title="SpringBoot相对于Spring的优势"></a>SpringBoot相对于Spring的优势</h1><ol>
<li>SpringBoot 提供了大量的 starters 用于快速构建业务框架，，一站式地集成了Spring的依赖包；</li>
<li>SpringBoot 提供了起步依赖，在创建 SpringBoot 项目时可以直接勾选依赖模块；</li>
<li>SpringBoot 内嵌了 Tomcat 等容器；</li>
<li>SpringBoot 自带 Actuator 监控器，可以监控和控制应用程序的运行。 </li>
</ol>
]]></content>
      <categories>
        <category>Sping</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>0563.二叉树的坡度</title>
    <url>/2020/11/02/0563.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9D%A1%E5%BA%A6/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-tree-tilt/">https://leetcode-cn.com/problems/binary-tree-tilt/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTilt</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">traverse</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = traverse(node.left);</span><br><span class="line">        <span class="keyword">int</span> r = traverse(node.right);</span><br><span class="line">        res += Math.abs(l - r);</span><br><span class="line">        <span class="keyword">return</span> l + r + node.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中 n 是结点的数目。每个结点访问一次。</li>
<li>空间复杂度：O(n)，在最糟糕的情形下，当树倾斜时，树的深度可以达到 n。平均情况下，树的深度为 logn。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>TreeNode</tag>
      </tags>
  </entry>
  <entry>
    <title>0349.两个数组的交集</title>
    <url>/2020/11/02/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/">https://leetcode-cn.com/problems/intersection-of-two-arrays/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; set1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        HashSet&lt;Integer&gt; set2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums1)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set1.contains(num))</span><br><span class="line">                set1.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set1.contains(num) &amp;&amp; !set2.contains(num))&#123;</span><br><span class="line">                set2.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[set2.size()];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s : set2)&#123;</span><br><span class="line">            res[i++] = s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(m+n)，其中 m 和 n 分别是两个数组的长度。使用两个集合分别存储两个数组中的元素需要 O(m+n) 的时间。</p>
</li>
<li><p>空间复杂度：O(m+n)，其中 m 和 n 分别是两个数组的长度。空间复杂度主要取决于两个集合。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>HashSet</tag>
      </tags>
  </entry>
  <entry>
    <title>EXPLAIN执行计划中要重点关注哪些要素</title>
    <url>/2020/10/26/EXPLAIN%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%B8%AD%E8%A6%81%E9%87%8D%E7%82%B9%E5%85%B3%E6%B3%A8%E5%93%AA%E4%BA%9B%E8%A6%81%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><blockquote>
<p>EXPLAIN的结果中，有哪些关键信息值得注意呢？</p>
</blockquote>
<p>MySQL的EXPLAIN当然和ORACLE的没法比，不过我们从它输出的结果中，也可以得到很多有用的信息。</p>
<p>总的来说，我们只需要关注结果中的几列：</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td>本次查询表联接类型，从这里可以看到本次查询大概的效率</td>
</tr>
<tr>
<td>key</td>
<td>最终选择的索引，如果没有索引的话，本次查询效率通常很差</td>
</tr>
<tr>
<td>key_len</td>
<td>本次查询用于结果过滤的索引实际长度，参见另一篇分享（FAQ系列-解读EXPLAIN执行计划中的key_len）</td>
</tr>
<tr>
<td>rows</td>
<td>预计需要扫描的记录数，预计需要扫描的记录数<strong>越小越好</strong></td>
</tr>
<tr>
<td>Extra</td>
<td>额外附加信息，主要确认是否出现 <strong>Using filesort、Using temporary</strong> 这两种情况</td>
</tr>
</tbody></table>
<p>首先看下 <strong>type</strong> 有几种结果，分别表示什么意思：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>ALL</td>
<td>执行<strong>full table scan</strong>，这是<strong>最差</strong>的一种方式</td>
</tr>
<tr>
<td>index</td>
<td>执行<strong>full index scan</strong>，并且可以通过索引完成结果扫描并且直接从索引中取的想要的结果数据，也就是可以避免<strong>回表</strong>，比ALL略好，因为索引文件通常比全部数据要来的小</td>
</tr>
<tr>
<td>range</td>
<td>利用索引进行范围查询，比index略好</td>
</tr>
<tr>
<td>index_subquery</td>
<td>子查询中可以用到索引</td>
</tr>
<tr>
<td>unique_subquery</td>
<td>子查询中可以用到唯一索引，效率比 index_subquery 更高些</td>
</tr>
<tr>
<td>index_merge</td>
<td>可以利用<strong>index merge</strong>特性用到多个索引，提高查询效率</td>
</tr>
<tr>
<td>ref_or_null</td>
<td>表连接类型是ref，但进行扫描的索引列中可能包含NULL值</td>
</tr>
<tr>
<td>fulltext</td>
<td>全文检索</td>
</tr>
<tr>
<td>ref</td>
<td>基于索引的等值查询，或者表间等值连接</td>
</tr>
<tr>
<td>eq_ref</td>
<td>表连接时基于主键或非NULL的唯一索引完成扫描，比ref略好</td>
</tr>
<tr>
<td>const</td>
<td>基于主键或唯一索引唯一值查询，最多返回一条结果，比eq_ref略好</td>
</tr>
<tr>
<td>system</td>
<td>查询对象表只有一行数据，这是最好的情况</td>
</tr>
</tbody></table>
<p>上面几种情况，从上到下一次是<strong>最差到最好</strong>。</p>
<p>再来看下Extra列中需要注意出现的几种情况：</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>Using filesort</td>
<td>将用外部排序而不是按照索引顺序排列结果，数据较少时从内存排序，否则需要在磁盘完成排序，代价非常高，<strong>需要添加合适的索引</strong></td>
</tr>
<tr>
<td>Using temporary</td>
<td>需要创建一个临时表来存储结果，这通常发生在对没有索引的列进行GROUP BY时，或者ORDER BY里的列不都在索引里，<strong>需要添加合适的索引</strong></td>
</tr>
<tr>
<td>Using index</td>
<td>表示MySQL使用覆盖索引避免全表扫描，不需要再到表中进行二次查找数据，这是比较好的结果之一。注意不要和type中的index类型混淆</td>
</tr>
<tr>
<td>Using where</td>
<td>通常是进行了全表引扫描后再用WHERE子句完成结果过滤，<strong>需要添加合适的索引</strong></td>
</tr>
<tr>
<td>Impossible WHERE</td>
<td>对Where子句判断的结果总是false而不能选择任何数据，例如where 1=0，无需过多关注</td>
</tr>
<tr>
<td>Select tables optimized away</td>
<td>使用某些聚合函数来访问存在索引的某个字段时，优化器会通过索引直接一次定位到所需要的数据行完成整个查询，例如MIN()\MAX()，这种也是比较好的结果之一</td>
</tr>
</tbody></table>
<p>再说下，5.6开始支持optimizer trace功能，看样子在执行计划方面是要逐渐和ORACLE看齐 ：）</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>Java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis的一级缓存和二级缓存</title>
    <url>/2020/10/22/Mybatis%E7%9A%84%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E5%92%8C%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<p><a href="https://tech.meituan.com/2018/01/19/mybatis-cache.html">https://tech.meituan.com/2018/01/19/mybatis-cache.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>循环中删除掉ArrayList中的元素安全吗？</title>
    <url>/2020/10/26/%E5%BE%AA%E7%8E%AF%E4%B8%AD%E5%88%A0%E9%99%A4Arraylist%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E5%AE%89%E5%85%A8%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<p><strong>list遍历，分为普通遍历，增强for循环，和iterator遍历</strong></p>
<h1 id="1、for循环遍历list"><a href="#1、for循环遍历list" class="headerlink" title="1、for循环遍历list"></a>1、for循环遍历list</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;    </span><br><span class="line">    <span class="keyword">if</span>(list.get(i).equals(<span class="string">&quot;del&quot;</span>))</span><br><span class="line">        list.remove(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除某个元素后，list的大小发生了变化，而你的索引也在变化，所以会导致你在遍历的时候漏掉某些元素。比如当你删除第1个元素后，继续根据索引访问第2个元素时，因为删除的关系后面的元素都往前移动了一位，所以实际访问的是第3个元素。因此，这种方式可以用在删除特定的一个元素时使用，但不适合循环删除多个元素时使用。</p>
<p>解决方法：</p>
<p><strong>从list最后一元素开始开始遍历。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=list.size()-<span class="number">1</span>;i&gt;+<span class="number">0</span>;i--)&#123;</span><br><span class="line">    <span class="keyword">if</span>(list.get(i).equals(<span class="string">&quot;del&quot;</span>))</span><br><span class="line">        list.remove(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2、增强for循环"><a href="#2、增强for循环" class="headerlink" title="2、增强for循环"></a>2、增强for循环</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(String x:list)&#123;</span><br><span class="line">    <span class="keyword">if</span>(x.equals(<span class="string">&quot;del&quot;</span>))</span><br><span class="line">        list.remove(x);</span><br><span class="line">&#125;       </span><br></pre></td></tr></table></figure>

<p>删除元素后继续循环会报错误信息ConcurrentModificationException，因为元素在使用的时候发生了并发的修改，导致异常抛出</p>
<p><strong>解决：删除完毕马上使用break跳出，则不会触发报错。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(String x:list)&#123;</span><br><span class="line">    <span class="keyword">if</span>(x.equals(<span class="string">&quot;del&quot;</span>))</span><br><span class="line">        list.remove(x);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3、iterator遍历"><a href="#3、iterator遍历" class="headerlink" title="3、iterator遍历"></a>3、iterator遍历</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    String x = it.next();</span><br><span class="line">    <span class="keyword">if</span>(x.equals(<span class="string">&quot;del&quot;</span>))&#123;</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式可以正常的循环及删除。但要注意的是，<strong>使用iterator的remove方法</strong>，如果用list的remove方法同样会报上面提到的ConcurrentModificationException错误。</p>
<p>总结：</p>
<p>　　（1）循环删除list中特定一个元素的，可以使用三种方式中的任意一种，但在使用中要注意上面分析的各个问题。</p>
<p>　　（2）循环删除list中多个元素的，应该使用迭代器iterator方式，或者list从后往前删除。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>ArrayList</tag>
        <tag>Java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令</title>
    <url>/2020/10/26/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、文件目录操作"><a href="#一、文件目录操作" class="headerlink" title="一、文件目录操作"></a>一、文件目录操作</h2><h3 id="1-ls-命令"><a href="#1-ls-命令" class="headerlink" title="1. ls 命令"></a>1. ls 命令</h3><p>ls 命令不仅可以查看 linux 文件夹包含的文件而且可以查看文件权限(包括目录、文件夹、文件权限)查看目录信息等等。</p>
<h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><p>ls [选项][目录名]</p>
<h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><ul>
<li>-l ：列出长数据串，包含文件的属性与权限数据等</li>
<li>-a ：列出全部的文件，连同隐藏文件（开头为.的文件）一起列出来（常用）</li>
<li>-d ：仅列出目录本身，而不是列出目录的文件数据</li>
<li>-h ：将文件容量以较易读的方式（GB，kB等）列出来</li>
<li>-R ：连同子目录的内容一起列出（递归列出），等于该目录下的所有文件都会显示出来</li>
</ul>
<h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><p>1.列出 home 目录下的所有文件和目录的详细资料。</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ls</span> -a -l <span class="string">/home</span></span><br><span class="line"><span class="keyword">ls</span> -al <span class="string">/home</span></span><br></pre></td></tr></table></figure>

<p>2.列出当前目录下所有以”d”开头的文件目录详情内容。</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ls</span> -l d*</span><br></pre></td></tr></table></figure>

<h3 id="2-cd命令"><a href="#2-cd命令" class="headerlink" title="2.cd命令"></a>2.cd命令</h3><p>最基本的命令语句，其他的命令语句要进行操作，都是建立在使用 cd 命令上的。用于切换当前目录至dirName。</p>
<h3 id="命令格式-1"><a href="#命令格式-1" class="headerlink" title="命令格式"></a>命令格式</h3><p>cd [目录名]</p>
<h3 id="操作案例"><a href="#操作案例" class="headerlink" title="操作案例"></a>操作案例</h3><p>1.从当前目录进入系统根目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /</span><br></pre></td></tr></table></figure>

<p>2.跳转到 home/Code 目录。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">cd <span class="regexp">/home/</span>Code</span><br></pre></td></tr></table></figure>

<h3 id="3-pwd-命令"><a href="#3-pwd-命令" class="headerlink" title="3.pwd 命令"></a>3.pwd 命令</h3><p>查看”当前工作目录”的完整路径。</p>
<h3 id="命令格式："><a href="#命令格式：" class="headerlink" title="命令格式："></a>命令格式：</h3><p>pwd [选项]</p>
<h3 id="常用参数："><a href="#常用参数：" class="headerlink" title="常用参数："></a>常用参数：</h3><ul>
<li>-P :显示实际物理路径，而非使用连接（link）路径</li>
<li>-L :当目录为连接路径时，显示连接路径</li>
</ul>
<h3 id="操作案例-1"><a href="#操作案例-1" class="headerlink" title="操作案例"></a>操作案例</h3><p>1.显示当前所在路径。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br></pre></td></tr></table></figure>

<h3 id="4-mkdir-命令"><a href="#4-mkdir-命令" class="headerlink" title="4.mkdir 命令"></a>4.mkdir 命令</h3><p>用来创建指定的名称的目录，要求创建目录的用户在当前目录中具有写权限，并且指定的目录名不能是当前目录中已有的目录。</p>
<h3 id="命令格式-2"><a href="#命令格式-2" class="headerlink" title="命令格式"></a>命令格式</h3><p>mkdir [选项] 目录</p>
<h3 id="常用参数-1"><a href="#常用参数-1" class="headerlink" title="常用参数"></a>常用参数</h3><ul>
<li>-m, –mode=模式，设定权限&lt;模式&gt; (类似 chmod)，而不是 rwxrwxrwx 减 umask</li>
<li>-p, –parents 可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后,系统将自动建立好那些尚不存在的目录,即一次可以建立多个目录;</li>
<li>-v, –verbose 每次创建新目录都显示信息</li>
<li>–help 显示此帮助信息并退出</li>
<li>–version 输出版本信息并退出</li>
</ul>
<h3 id="使用实例-1"><a href="#使用实例-1" class="headerlink" title="使用实例"></a>使用实例</h3><p>1.创建一个空目录。</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mkdir</span> <span class="keyword">test</span></span><br></pre></td></tr></table></figure>

<p>2.递归创建多个目录。</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mkdir</span> <span class="keyword">test</span>/test1</span><br></pre></td></tr></table></figure>

<p>3.创建权限为777的目录。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">mkdir</span> -m <span class="number">777</span> test<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>4.创建目录都显示信息。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">mkdir</span> -v test<span class="number">4</span></span><br></pre></td></tr></table></figure>

<h3 id="5-rm-命令"><a href="#5-rm-命令" class="headerlink" title="5.rm 命令"></a>5.rm 命令</h3><p>删除一个目录中的一个或多个文件或目录，如果没有使用- r选项，则rm不会删除目录。如果使用 rm 来删除文件，通常仍可以将该文件恢复原状。</p>
<h3 id="命令格式-3"><a href="#命令格式-3" class="headerlink" title="命令格式"></a>命令格式</h3><p>rm [选项] 文件</p>
<h3 id="常用参数-2"><a href="#常用参数-2" class="headerlink" title="常用参数"></a>常用参数</h3><ul>
<li>-f, –force 忽略不存在的文件，从不给出提示。</li>
<li>-i, –interactive 进行交互式删除</li>
<li>-r, -R, –recursive 指示rm将参数中列出的全部目录和子目录均递归地删除。</li>
<li>-v, –verbose 详细显示进行的步骤</li>
<li>–help 显示此帮助信息并退出</li>
<li>–version 输出版本信息并退出</li>
</ul>
<h3 id="使用实例-2"><a href="#使用实例-2" class="headerlink" title="使用实例"></a>使用实例</h3><p>1.删除文件 test.txt,系统会提示是否删除。</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">rm</span> <span class="keyword">test</span>.txt</span><br></pre></td></tr></table></figure>

<p>2.强制删除 test.txt，系统不再提示。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> <span class="operator">-f</span> test.txt</span><br></pre></td></tr></table></figure>

<p>3.将 test 子目录及目录中所有档案删除。</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">rm</span> -r <span class="keyword">test</span></span><br></pre></td></tr></table></figure>

<h3 id="6-rmdir-命令"><a href="#6-rmdir-命令" class="headerlink" title="6.rmdir 命令"></a>6.rmdir 命令</h3><p>该命令从一个目录中删除一个或多个子目录项，删除某目录时也必须具有对父目录的写权限。</p>
<h3 id="命令格式-4"><a href="#命令格式-4" class="headerlink" title="命令格式"></a>命令格式</h3><p>rmdir [选项] 目录</p>
<h3 id="常用参数-3"><a href="#常用参数-3" class="headerlink" title="常用参数"></a>常用参数</h3><ul>
<li>p 递归删除目录dirname，当子目录删除后其父目录为空时，也一同被删除。如果整个路径被删除或者由于某种原因保留部分路径，则系统在标准输出上显示相应的信息。</li>
<li>-v, –verbose 显示指令执行过程</li>
</ul>
<h3 id="使用实例-3"><a href="#使用实例-3" class="headerlink" title="使用实例"></a>使用实例</h3><p>1.删除空目录 test1，非空目录无法删除。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">rmdir</span> test<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>2.当子目录被删除后使它也成为空目录的话，则顺便一并删除</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">rmdir</span> -p test<span class="number">2</span> # test 目录下仅有 test<span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="7-mv-命令"><a href="#7-mv-命令" class="headerlink" title="7. mv 命令"></a>7. mv 命令</h3><p>可以用来移动文件或者将文件改名（move (rename) files）。当第二个参数类型是文件时，mv命令完成文件重命名。当第二个参数是已存在的目录名称时，源文件或目录参数可以有多个，mv命令将各参数指定的源文件均移至目标目录中。</p>
<h3 id="命令格式-5"><a href="#命令格式-5" class="headerlink" title="命令格式"></a>命令格式</h3><p>mv [选项] 源文件或目录 目标文件或目录</p>
<h3 id="常用参数-4"><a href="#常用参数-4" class="headerlink" title="常用参数"></a>常用参数</h3><ul>
<li>-b ：若需覆盖文件，则覆盖前先行备份</li>
<li>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖</li>
<li>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖</li>
<li>-u ：若目标文件已经存在，且 source 比较新，才会更新(update)</li>
<li>-t ： –target-directory=DIRECTORY move all SOURCE arguments into DIRECTORY，即指定mv的目标目录，该选项适用于移动多个源文件到一个目录的情况，此时目标目录在前，源文件在后</li>
</ul>
<h3 id="使用实例-4"><a href="#使用实例-4" class="headerlink" title="使用实例"></a>使用实例</h3><p>1.将 test1.txt 重命名为 test2.txt。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">mv</span> <span class="selector-tag">test1</span><span class="selector-class">.txt</span> <span class="selector-tag">test2</span><span class="selector-class">.txt</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>2.移动文件 test1.txt 到目录 test2</p>
<figure class="highlight cos"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mv</span> test1.txt test2</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>3.将文件 test1.txt、test2.txt、test3.txt 移动到目录 test3。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">mv</span> <span class="selector-tag">test1</span><span class="selector-class">.txt</span> <span class="selector-tag">test2</span><span class="selector-class">.txt</span> <span class="selector-tag">test3</span><span class="selector-class">.txt</span> <span class="selector-tag">test3</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="8-cp-命令"><a href="#8-cp-命令" class="headerlink" title="8.cp 命令"></a>8.cp 命令</h3><p>将源文件复制至目标文件，或将多个源文件复制至目标目录。</p>
<h3 id="命令格式-6"><a href="#命令格式-6" class="headerlink" title="命令格式"></a>命令格式</h3><p>cp [选项] 源文件 目录 或 cp [选项] -t 目录 源文件</p>
<h3 id="常用参数-5"><a href="#常用参数-5" class="headerlink" title="常用参数"></a>常用参数</h3><ul>
<li>-t –target-directory 指定目标目录</li>
<li>-i –interactive 覆盖前询问（使前面的 -n 选项失效）</li>
<li>-n –no-clobber 不要覆盖已存在的文件（使前面的 -i 选项失效）</li>
<li>-f –force 强行复制文件或目录，不论目的文件或目录是否已经存在</li>
<li>-u –update 使用这项参数之后，只会在源文件的修改时间较目的文件更新时，或是对应的目的文件并不存在，才复制文件</li>
</ul>
<h3 id="使用实例-5"><a href="#使用实例-5" class="headerlink" title="使用实例"></a>使用实例</h3><p>1.复制文件 test1.txt 到 test1 目录</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cp</span> test1.txt test1 <span class="meta"># 若文件存在，会提示是否覆盖。若不存在直接完成复制</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ol>
<li>复制 test1 整个目录到 test2</li>
</ol>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cp</span> -a test1 test2</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="9-touch-命令"><a href="#9-touch-命令" class="headerlink" title="9. touch 命令"></a>9. touch 命令</h3><p>touch命令参数可更改文档或目录的日期时间，包括存取时间和更改时间。</p>
<h3 id="命令格式-7"><a href="#命令格式-7" class="headerlink" title="命令格式"></a>命令格式</h3><p>touch [选项] 文件</p>
<h3 id="常用参数-6"><a href="#常用参数-6" class="headerlink" title="常用参数"></a>常用参数</h3><ul>
<li>-a 或–time=atime或–time=access或–time=use  只更改存取时间</li>
<li>-c 或–no-create  不建立任何文档</li>
<li>-d  使用指定的日期时间，而非现在的时间</li>
<li>-f  此参数将忽略不予处理，仅负责解决BSD版本touch指令的兼容性问题</li>
<li>-m 或–time=mtime或–time=modify  只更改变动时间</li>
<li>-r  把指定文档或目录的日期时间，统统设成和参考文档或目录的日期时间相同 -t  使用指定的日期时间，而非现在的时间</li>
</ul>
<h3 id="使用实例-6"><a href="#使用实例-6" class="headerlink" title="使用实例"></a>使用实例</h3><p>1.创建不存在的文件test.txt</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">touch <span class="keyword">test</span>.txt</span><br></pre></td></tr></table></figure>

<p>2.更新 test.txt 的实践和 test1.txt 时间戳相同</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">touch</span> <span class="selector-tag">-r</span> <span class="selector-tag">test</span><span class="selector-class">.txt</span> <span class="selector-tag">test1</span><span class="selector-class">.txt</span></span><br></pre></td></tr></table></figure>

<h3 id="10-cat-命令"><a href="#10-cat-命令" class="headerlink" title="10.cat 命令"></a>10.cat 命令</h3><p>用来显示文件内容，或者将几个文件连接起来显示，或者从标准输入读取内容并显示，它常与重定向符号配合使用。</p>
<h3 id="命令格式-8"><a href="#命令格式-8" class="headerlink" title="命令格式"></a>命令格式</h3><p>cat [选项] [文件]</p>
<h3 id="常用参数-7"><a href="#常用参数-7" class="headerlink" title="常用参数"></a>常用参数</h3><ul>
<li>-A, –show-all 等价于 -vET</li>
<li>-b, –number-nonblank 对非空输出行编号</li>
<li>-e 等价于 -vE</li>
<li>-E, –show-ends 在每行结束处显示 $</li>
<li>-n, –number 对输出的所有行编号,由1开始对所有输出的行数编号</li>
<li>-s, –squeeze-blank 有连续两行以上的空白行，就代换为一行的空白行</li>
<li>-t 与 -vT 等价</li>
<li>-T, –show-tabs 将跳格字符显示为 ^I</li>
<li>-u (被忽略)</li>
<li>-v, –show-nonprinting 使用 ^ 和 M- 引用，除了 LFD 和 TAB 之外</li>
</ul>
<h3 id="使用实例-7"><a href="#使用实例-7" class="headerlink" title="使用实例"></a>使用实例</h3><p>1.把 test.log 的文件内容加上行号后输入 test1.log 这个文件里。</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cat</span> -<span class="keyword">n</span> <span class="keyword">test</span>.<span class="keyword">log</span>  test1.<span class="keyword">log</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ol>
<li>将 test.log 的文件内容反向显示。</li>
</ol>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">tac  <span class="keyword">test</span>.<span class="keyword">log</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="11-nl-命令"><a href="#11-nl-命令" class="headerlink" title="11. nl 命令"></a>11. nl 命令</h3><p>输出的文件内容自动的加上行号！其默认的结果与 cat -n 有点不太一样， nl 可以将行号做比较多的显示设计，包括位数与是否自动补齐 0 等等的功能。</p>
<h3 id="命令格式-9"><a href="#命令格式-9" class="headerlink" title="命令格式"></a>命令格式</h3><p>nl [选项] [文件]</p>
<h3 id="常用参数-8"><a href="#常用参数-8" class="headerlink" title="常用参数"></a>常用参数</h3><ul>
<li>-b ：指定行号指定的方式，主要有两种：</li>
<li>-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)</li>
<li>-b t ：如果有空行，空的那一行不要列出行号(默认值)</li>
<li>-n ：列出行号表示的方法，主要有三种：</li>
<li>-n ln ：行号在萤幕的最左方显示</li>
<li>-n rn ：行号在自己栏位的最右方显示，且不加 0</li>
<li>-n rz ：行号在自己栏位的最右方显示，且加 0</li>
<li>-w ：行号栏位的占用的位数</li>
</ul>
<h3 id="使用实例-8"><a href="#使用实例-8" class="headerlink" title="使用实例"></a>使用实例</h3><ol>
<li>用 nl 列出 test.log 的内容。</li>
</ol>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">nl</span> <span class="keyword">test</span>.<span class="keyword">log</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ol>
<li>用 nl 列出 test.log 的内容，空本行也加上行号。</li>
</ol>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">nl</span> -b a <span class="keyword">test</span>.<span class="keyword">log</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="12-more-命令"><a href="#12-more-命令" class="headerlink" title="12.more 命令"></a>12.more 命令</h3><p>more 命令和 cat 的功能一样都是查看文件里的内容，但有所不同的是more可以按页来查看文件的内容，还支持直接跳转行等功能。</p>
<h3 id="命令格式-10"><a href="#命令格式-10" class="headerlink" title="命令格式"></a>命令格式</h3><p>more [-dlfpcsu ] [-num ] [+/ pattern] [+ linenum] [file … ]</p>
<h3 id="常用参数-9"><a href="#常用参数-9" class="headerlink" title="常用参数"></a>常用参数</h3><ul>
<li>+n 从笫n行开始显示</li>
<li>-n 定义屏幕大小为n行</li>
<li>+/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示</li>
<li>-c 从顶部清屏，然后显示</li>
<li>-d 提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能</li>
<li>-l 忽略Ctrl+l（换页）字符</li>
<li>-p 通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似</li>
<li>-s 把连续的多个空行显示为一行</li>
<li>-u 把文件内容中的下画线去掉</li>
</ul>
<h3 id="操作指令"><a href="#操作指令" class="headerlink" title="操作指令"></a>操作指令</h3><ul>
<li>Enter：向下n行，需要定义。默认为1行</li>
<li>Ctrl+F：向下滚动一屏</li>
<li>空格键：向下滚动一屏</li>
<li>Ctrl+B：返回上一屏</li>
<li>= ：输出当前行的行号</li>
<li>：f ：输出文件名和当前行的行号</li>
<li>V ：调用vi编辑器</li>
<li>!命令 ：调用Shell，并执行命令</li>
<li>q ：退出more</li>
</ul>
<h3 id="使用实例-9"><a href="#使用实例-9" class="headerlink" title="使用实例"></a>使用实例</h3><p>1.显示文件 test.log 第3行起内容。</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">more</span> +3 <span class="keyword">test</span>.<span class="keyword">log</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>2.从文件 test.log 查找第一个出现“day3”字符串的行，并从该处前2行开始显示输出。</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">more</span> +/day3 <span class="keyword">test</span>.<span class="keyword">log</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ol>
<li>设置每屏显示行数</li>
</ol>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">more</span> -5 <span class="keyword">test</span>.<span class="keyword">log</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="13-less-命令"><a href="#13-less-命令" class="headerlink" title="13. less 命令"></a>13. less 命令</h3><p>less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。</p>
<h3 id="命令格式-11"><a href="#命令格式-11" class="headerlink" title="命令格式"></a>命令格式</h3><p>less [参数] 文件</p>
<h3 id="常用参数-10"><a href="#常用参数-10" class="headerlink" title="常用参数"></a>常用参数</h3><ul>
<li>-b &lt;缓冲区大小&gt; 设置缓冲区的大小</li>
<li>-e 当文件显示结束后，自动离开</li>
<li>-f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件</li>
<li>-g 只标志最后搜索的关键词</li>
<li>-i 忽略搜索时的大小写</li>
<li>-m 显示类似more命令的百分比</li>
<li>-N 显示每行的行号</li>
<li>-o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来</li>
<li>-Q 不使用警告音</li>
<li>-s 显示连续空行为一行</li>
<li>-S 行过长时间将超出部分舍弃</li>
<li>-x &lt;数字&gt; 将“tab”键显示为规定的数字空格</li>
</ul>
<h3 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h3><ul>
<li>/字符串：向下搜索“字符串”的功能</li>
<li>?字符串：向上搜索“字符串”的功能</li>
<li>n：重复前一个搜索（与 / 或 ? 有关）</li>
<li>N：反向重复前一个搜索（与 / 或 ? 有关）</li>
<li>b 向后翻一页</li>
<li>d 向后翻半页</li>
<li>h 显示帮助界面</li>
<li>Q 退出less 命令</li>
<li>u 向前滚动半页</li>
<li>y 向前滚动一行</li>
<li>空格键 滚动一行</li>
<li>回车键 滚动一页</li>
<li>[pagedown]： 向下翻动一页</li>
<li>[pageup]： 向上翻动一页</li>
</ul>
<h3 id="使用实例-10"><a href="#使用实例-10" class="headerlink" title="使用实例"></a>使用实例</h3><p>1.查看文件 test.log。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">less</span> <span class="keyword">test</span>.log</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="14-head-命令"><a href="#14-head-命令" class="headerlink" title="14. head 命令"></a>14. head 命令</h3><p>head 用来显示档案的开头至标准输出中，默认 head 命令打印其相应文件的开头 10 行。</p>
<h3 id="命令格式-12"><a href="#命令格式-12" class="headerlink" title="命令格式"></a>命令格式</h3><p>head [参数] [文件]</p>
<h3 id="常用参数-11"><a href="#常用参数-11" class="headerlink" title="常用参数"></a>常用参数</h3><ul>
<li>-q 隐藏文件名</li>
<li>-v 显示文件名</li>
<li>-c&lt;字节&gt; 显示字节数</li>
<li>-n&lt;行数&gt; 显示的行数</li>
</ul>
<h3 id="使用实例-11"><a href="#使用实例-11" class="headerlink" title="使用实例"></a>使用实例</h3><p>1.显示文件 test.log 的前 5 行</p>
<figure class="highlight stan"><table><tr><td class="code"><pre><span class="line"><span class="built_in">head</span> -n <span class="number">5</span> test.<span class="built_in">log</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>2.显示文件 test.log 前 20 个字节</p>
<figure class="highlight stan"><table><tr><td class="code"><pre><span class="line"><span class="built_in">head</span> -c <span class="number">20</span> test.<span class="built_in">log</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="15-tail-命令"><a href="#15-tail-命令" class="headerlink" title="15.tail 命令"></a>15.tail 命令</h3><p>显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。</p>
<h3 id="命令格式-13"><a href="#命令格式-13" class="headerlink" title="命令格式"></a>命令格式</h3><p>tail [必要参数] [选择参数] [文件]</p>
<h3 id="常用参数-12"><a href="#常用参数-12" class="headerlink" title="常用参数"></a>常用参数</h3><ul>
<li>-f 循环读取</li>
<li>-q 不显示处理信息</li>
<li>-v 显示详细的处理信息</li>
<li>-c&lt;数目&gt; 显示的字节数</li>
<li>-n&lt;行数&gt; 显示行数</li>
<li>–pid=PID 与-f合用,表示在进程ID,PID死掉之后结束.</li>
<li>-q, –quiet, –silent 从不输出给出文件名的首部</li>
<li>-s, –sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒</li>
</ul>
<h3 id="使用实例-12"><a href="#使用实例-12" class="headerlink" title="使用实例"></a>使用实例</h3><p>1.显示文件 test.log 最后 5 行内容。</p>
<figure class="highlight stan"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tail</span> -n <span class="number">5</span> test.<span class="built_in">log</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>2.循环查看文件内容</p>
<figure class="highlight stan"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tail</span> -f test.<span class="built_in">log</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="二、文件查找"><a href="#二、文件查找" class="headerlink" title="二、文件查找"></a>二、文件查找</h2><h3 id="16-which-命令"><a href="#16-which-命令" class="headerlink" title="16.which 命令"></a>16.which 命令</h3><p>which指令会在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。</p>
<h3 id="命令格式-14"><a href="#命令格式-14" class="headerlink" title="命令格式"></a>命令格式</h3><p>which 可执行文件名称</p>
<h3 id="常用参数-13"><a href="#常用参数-13" class="headerlink" title="常用参数"></a>常用参数</h3><ul>
<li>-n  指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名</li>
<li>-p  与-n参数相同，但此处的包括了文件的路径</li>
<li>-w  指定输出时栏位的宽度</li>
<li>-V  显示版本信息</li>
</ul>
<h3 id="使用实例-13"><a href="#使用实例-13" class="headerlink" title="使用实例"></a>使用实例</h3><p>1.查找文件、显示命令路径。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">which</span> <span class="built_in">pwd</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ol>
<li>用 which 去找出 which</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">which</span> <span class="built_in">which</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="17-whereis-命令"><a href="#17-whereis-命令" class="headerlink" title="17.whereis 命令"></a>17.whereis 命令</h3><p>whereis命令是定位可执行文件、源代码文件、帮助文件在文件系统中的位置。</p>
<h3 id="命令格式-15"><a href="#命令格式-15" class="headerlink" title="命令格式"></a>命令格式</h3><p>whereis [-bmsu] [BMS 目录名 -f ] 文件名</p>
<h3 id="常用参数-14"><a href="#常用参数-14" class="headerlink" title="常用参数"></a>常用参数</h3><ul>
<li>-b 定位可执行文件</li>
<li>-m 定位帮助文件</li>
<li>-s 定位源代码文件</li>
<li>-u 搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件</li>
<li>-B 指定搜索可执行文件的路径</li>
<li>-M 指定搜索帮助文件的路径</li>
<li>-S 指定搜索源代码文件的路径</li>
</ul>
<h3 id="使用实例-14"><a href="#使用实例-14" class="headerlink" title="使用实例"></a>使用实例</h3><p>1.将和 svn 文件相关的文件都查找出来。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">whereis</span> svn</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>2.只将二进制文件查找出来。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">whereis</span> -<span class="keyword">b</span> svn</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="18-locate-命令"><a href="#18-locate-命令" class="headerlink" title="18.locate 命令"></a>18.locate 命令</h3><p>可以很快速的搜寻档案系统内是否有指定的档案。</p>
<h3 id="命令格式-16"><a href="#命令格式-16" class="headerlink" title="命令格式"></a>命令格式</h3><p>Locate [选择参数] [样式]</p>
<h3 id="常用参数-15"><a href="#常用参数-15" class="headerlink" title="常用参数"></a>常用参数</h3><ul>
<li>-e 将排除在寻找的范围之外。</li>
<li>-1 如果 是 1．则启动安全模式。在安全模式下，使用者不会看到权限无法看到 的档案。这会始速度减慢，因为 locate 必须至实际的档案系统中取得档案的 权限资料。</li>
<li>-f 将特定的档案系统排除在外，例如我们没有到理要把 proc 档案系统中的档案 放在资料库中。</li>
<li>-q 安静模式，不会显示任何错误讯息。</li>
<li>-n 至多显示 n个输出。</li>
<li>-r 使用正规运算式 做寻找的条件。</li>
<li>-o 指定资料库存的名称。</li>
<li>-d 指定资料库的路径</li>
</ul>
<h3 id="使用实例-15"><a href="#使用实例-15" class="headerlink" title="使用实例"></a>使用实例</h3><p>1.查找和 pwd 相关的所有文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">locate <span class="built_in">pwd</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ol>
<li>搜索etc 目录下，所有以 m 开头的文件。</li>
</ol>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">locate <span class="regexp">/etc/m</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="19-find-命令"><a href="#19-find-命令" class="headerlink" title="19. find 命令"></a>19. find 命令</h3><p>主要作用是沿着文件层次结构向下遍历，匹配符合条件的文件，并执行相应的操作。</p>
<h3 id="命令格式-17"><a href="#命令格式-17" class="headerlink" title="命令格式"></a>命令格式</h3><p>find [选项] [搜索路径] [表达式]</p>
<h3 id="常用参数-16"><a href="#常用参数-16" class="headerlink" title="常用参数"></a>常用参数</h3><ul>
<li>-print find 命令将匹配的文件输出到标准输出</li>
<li>-exec find 命令对匹配的文件执行该参数所给出的</li>
<li>shell 命令</li>
<li>-name 按照文件名查找文件</li>
<li>-type 查找某一类型的文件</li>
</ul>
<h3 id="使用实例-16"><a href="#使用实例-16" class="headerlink" title="使用实例"></a>使用实例</h3><p>1.打印当前目录文件目录列表。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">find</span> . -print</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>2.打印当前目录下所有不以.txt 结尾的文件名。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">find</span> . ! -name <span class="string">&quot;*.txt&quot;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>3.打印当前目录下所有权限为 777 的 php 文件。</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="built_in">find</span> . -<span class="built_in">type</span> f -<span class="built_in">name</span> <span class="string">&quot;*.php&quot;</span> -perm <span class="number">777</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>4.找到当前目录下所有 php 文件，并显示其详细信息。</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="built_in">find</span> . -<span class="built_in">name</span> <span class="string">&quot;*.php&quot;</span> -<span class="built_in">exec</span> ls -l &#123;&#125; \;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>5.查找当前目录下所有 c 代码文件，统计总行数。</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="built_in">find</span> . -<span class="built_in">type</span> f -<span class="built_in">name</span> <span class="string">&quot;*.c&quot;</span> | xargs wc -l</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<blockquote>
<p>xargs 命令可以从标准输入接收输入，并把输入转换为一个特定的参数列表。 命令格式: command | xargs [选项] [command] xargs 命令应该紧跟在管道操作符之后，因为它以标准输入作为主要的源数据流。 常用参数</p>
<ul>
<li>-n 指定每行最大的参数数量</li>
<li>-d 指定分隔符</li>
</ul>
</blockquote>
<h2 id="三、文件打包上传和下载"><a href="#三、文件打包上传和下载" class="headerlink" title="三、文件打包上传和下载"></a>三、文件打包上传和下载</h2><h3 id="20-tar-命令"><a href="#20-tar-命令" class="headerlink" title="20.tar 命令"></a>20.tar 命令</h3><p>用来压缩和解压文件。tar本身不具有压缩功能。他是调用压缩功能实现的。</p>
<h3 id="命令格式-18"><a href="#命令格式-18" class="headerlink" title="命令格式"></a>命令格式</h3><p>tar [必要参数] [选择参数] [文件]</p>
<h3 id="常用参数-17"><a href="#常用参数-17" class="headerlink" title="常用参数"></a>常用参数</h3><p>必要参数：</p>
<ul>
<li>-A 新增压缩文件到已存在的压缩</li>
<li>-B 设置区块大小</li>
<li>-c 建立新的压缩文件</li>
<li>-d 记录文件的差别</li>
<li>-r 添加文件到已经压缩的文件</li>
<li>-u 添加改变了和现有的文件到已经存在的压缩文件</li>
<li>-x 从压缩的文件中提取文件</li>
<li>-t 显示压缩文件的内容</li>
<li>-z 支持gzip解压文件</li>
<li>-j 支持bzip2解压文件</li>
<li>-Z 支持compress解压文件</li>
<li>-v 显示操作过程</li>
<li>-l 文件系统边界设置</li>
<li>-k 保留原有文件不覆盖</li>
<li>-m 保留文件不被覆盖</li>
<li>-W 确认压缩文件的正确性</li>
</ul>
<p>可选参数：</p>
<ul>
<li>-b 设置区块数目</li>
<li>-C 切换到指定目录</li>
<li>-f 指定压缩文件</li>
<li>–help 显示帮助信息</li>
<li>–version 显示版本信息</li>
</ul>
<h3 id="使用实例-17"><a href="#使用实例-17" class="headerlink" title="使用实例"></a>使用实例</h3><p>1.将文件打全部打包成tar包。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">tar -cvf <span class="keyword">test</span>.tar <span class="keyword">test</span>.log    <span class="comment"># 仅打包，不压缩！ </span></span><br><span class="line"></span><br><span class="line">tar -zcvf <span class="keyword">test</span>.tar.gz <span class="keyword">test</span>.log  <span class="comment"># 打包后，以 gzip 压缩 </span></span><br><span class="line"></span><br><span class="line">tar -zcvf <span class="keyword">test</span>.tar.bz2 <span class="keyword">test</span>.log <span class="comment"># 打包后，以 bzip2 压缩</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>2.将 tar 包解压缩</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">tar</span> <span class="selector-tag">-zxvf</span> <span class="selector-tag">test</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="21-gzip-命令"><a href="#21-gzip-命令" class="headerlink" title="21.gzip 命令"></a>21.gzip 命令</h3><p>使用广泛的压缩程序，文件经它压缩过后，其名称后面会多出”.gz”的扩展名。</p>
<h3 id="命令格式-19"><a href="#命令格式-19" class="headerlink" title="命令格式"></a>命令格式</h3><p>gzip [参数] [文件或者目录]</p>
<h3 id="常用参数-18"><a href="#常用参数-18" class="headerlink" title="常用参数"></a>常用参数</h3><ul>
<li>-a或–ascii  使用ASCII文字模式。</li>
<li>-c或–stdout或–to-stdout  把压缩后的文件输出到标准输出设备，不去更动原始文件。</li>
<li>-d或–decompress或—-uncompress  解开压缩文件。</li>
<li>-f或–force  强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接。</li>
<li>-h或–help  在线帮助。</li>
</ul>
<h3 id="使用实例-18"><a href="#使用实例-18" class="headerlink" title="使用实例"></a>使用实例</h3><p>1.把 test1 目录下的每个文件压缩成.gz 文件。</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">test6 <span class="variable">$ </span>gzip *</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="四、文件权限设置"><a href="#四、文件权限设置" class="headerlink" title="四、文件权限设置"></a>四、文件权限设置</h2><h3 id="22-chmod-命令"><a href="#22-chmod-命令" class="headerlink" title="22.chmod 命令"></a>22.chmod 命令</h3><p>用于改变linux系统文件或目录的访问权限。</p>
<h3 id="命令格式-20"><a href="#命令格式-20" class="headerlink" title="命令格式"></a>命令格式</h3><p>chmod [-cfvR] [–help] [–version] mode file</p>
<h3 id="常用参数-19"><a href="#常用参数-19" class="headerlink" title="常用参数"></a>常用参数</h3><p>必要参数：</p>
<ul>
<li>-c 当发生改变时，报告处理信息</li>
<li>-f 错误信息不输出</li>
<li>-R 处理指定目录以及其子目录下的所有文件</li>
<li>-v 运行时显示详细处理信息</li>
<li>选择参数：</li>
<li>–reference=&lt;目录或者文件&gt; 设置成具有指定目录或者文件具有相同的权限</li>
<li>–version 显示版本信息</li>
<li>&lt;权限范围&gt;+&lt;权限设置&gt; 使权限范围内的目录或者文件具有指定的权限</li>
<li>&lt;权限范围&gt;-&lt;权限设置&gt; 删除权限范围的目录或者文件的指定权限</li>
<li>&lt;权限范围&gt;=&lt;权限设置&gt; 设置权限范围内的目录或者文件的权限为指定的值</li>
</ul>
<p>权限范围：</p>
<ul>
<li>u ：目录或者文件的当前的用户</li>
<li>g ：目录或者文件的当前的群组</li>
<li>o ：除了目录或者文件的当前用户或群组之外的用户或者群组</li>
<li>a ：所有的用户及群组</li>
</ul>
<p>权限代号：</p>
<ul>
<li>r：读权限，用数字4表示</li>
<li>w：写权限，用数字2表示</li>
<li>x：执行权限，用数字1表示</li>
<li>-：删除权限，用数字0表示</li>
</ul>
<h3 id="使用实例-19"><a href="#使用实例-19" class="headerlink" title="使用实例"></a>使用实例</h3><p>1.增加文件所有用户组可执行权限</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">chmod <span class="keyword">a</span>+x test.<span class="built_in">log</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ol>
<li>删除所有用户的可执行权限</li>
</ol>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">chmod <span class="keyword">a</span>-x test.<span class="built_in">log</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="23-chgrp-命令"><a href="#23-chgrp-命令" class="headerlink" title="23.chgrp 命令"></a>23.chgrp 命令</h3><p>可采用群组名称或群组识别码的方式改变文件或目录的所属群组。</p>
<h3 id="命令格式-21"><a href="#命令格式-21" class="headerlink" title="命令格式"></a>命令格式</h3><p>chgrp [选项] [组] [文件]</p>
<h3 id="常用参数-20"><a href="#常用参数-20" class="headerlink" title="常用参数"></a>常用参数</h3><p>必要参数:</p>
<ul>
<li>-c 当发生改变时输出调试信息</li>
<li>-f 不显示错误信息</li>
<li>-R 处理指定目录以及其子目录下的所有文件</li>
<li>-v 运行时显示详细的处理信息</li>
<li>–dereference 作用于符号链接的指向，而不是符号链接本身</li>
<li>–no-dereference 作用于符号链接本身</li>
</ul>
<p>选择参数:</p>
<ul>
<li>–reference=&lt;文件或者目录&gt;</li>
<li>–help 显示帮助信息</li>
<li>–version 显示版本信息</li>
</ul>
<h3 id="使用实例-20"><a href="#使用实例-20" class="headerlink" title="使用实例"></a>使用实例</h3><p>1.改变文件的群组属性</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">chgrp -v bin <span class="keyword">test</span>.<span class="keyword">log</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>2.改变文件test1.log 的群组属性，使得文件test1.log的群组属性和参考文件test.log的群组属性相同</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">chgrp --<span class="keyword">reference</span>=test.<span class="keyword">log</span> test1.<span class="keyword">log</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="24-chown-命令"><a href="#24-chown-命令" class="headerlink" title="24.chown 命令"></a>24.chown 命令</h3><p>通过chown改变文件的拥有者和群组。</p>
<h3 id="命令格式-22"><a href="#命令格式-22" class="headerlink" title="命令格式"></a>命令格式</h3><p>chown [选项] [所有者] [:[组]] 文件</p>
<h3 id="常用参数-21"><a href="#常用参数-21" class="headerlink" title="常用参数"></a>常用参数</h3><p>必要参数:</p>
<ul>
<li>-c 显示更改的部分的信息</li>
<li>-f 忽略错误信息</li>
<li>-h 修复符号链接</li>
<li>-R 处理指定目录以及其子目录下的所有文件</li>
<li>-v 显示详细的处理信息</li>
<li>-deference 作用于符号链接的指向，而不是链接文件本身</li>
</ul>
<p>选择参数:</p>
<ul>
<li>–reference=&lt;目录或文件&gt; 把指定的目录/文件作为参考，把操作的文件/目录设置成参考文件/目录相同拥有者和群组</li>
<li>–from=&lt;当前用户：当前群组&gt; 只有当前用户和群组跟指定的用户和群组相同时才进行改变</li>
<li>–help 显示帮助信息</li>
<li>–version 显示版本信息</li>
</ul>
<h3 id="使用实例-21"><a href="#使用实例-21" class="headerlink" title="使用实例"></a>使用实例</h3><p>1.改变拥有者和群组</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">chown</span> <span class="selector-tag">mail</span><span class="selector-pseudo">:mail</span> <span class="selector-tag">test</span><span class="selector-class">.log</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="五、磁盘存储"><a href="#五、磁盘存储" class="headerlink" title="五、磁盘存储"></a>五、磁盘存储</h2><h3 id="25-df-命令"><a href="#25-df-命令" class="headerlink" title="25. df 命令"></a>25. df 命令</h3><p>显示指定磁盘文件的可用空间。</p>
<h3 id="命令格式-23"><a href="#命令格式-23" class="headerlink" title="命令格式"></a>命令格式</h3><p>df [选项] [文件]</p>
<h3 id="常用参数-22"><a href="#常用参数-22" class="headerlink" title="常用参数"></a>常用参数</h3><p>必要参数：</p>
<ul>
<li>-a 全部文件系统列表</li>
<li>-h 方便阅读方式显示</li>
<li>-H 等于“-h”，但是计算式，1K=1000，而不是1K=1024</li>
<li>-i 显示inode信息</li>
<li>-k 区块为1024字节</li>
<li>-l 只显示本地文件系统</li>
<li>-m 区块为1048576字节</li>
<li>–no-sync 忽略 sync 命令</li>
<li>-P 输出格式为POSIX</li>
<li>–sync 在取得磁盘信息前，先执行sync命令</li>
<li>-T 文件系统类型</li>
</ul>
<p>选择参数：</p>
<ul>
<li>–block-size=&lt;区块大小&gt; 指定区块大小</li>
<li>-t&lt;文件系统类型&gt; 只显示选定文件系统的磁盘信息</li>
<li>-x&lt;文件系统类型&gt; 不显示选定文件系统的磁盘信息</li>
<li>–help 显示帮助信息</li>
<li>–version 显示版本信息</li>
</ul>
<h3 id="使用实例-22"><a href="#使用实例-22" class="headerlink" title="使用实例"></a>使用实例</h3><p>1.显示指定磁盘使用情况</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">df -<span class="built_in">t</span> ext3</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="26-du-命令"><a href="#26-du-命令" class="headerlink" title="26. du 命令"></a>26. du 命令</h3><p>显示每个文件和目录的磁盘使用空间。</p>
<h3 id="命令格式-24"><a href="#命令格式-24" class="headerlink" title="命令格式"></a>命令格式</h3><p>du [选项] [文件]</p>
<h3 id="常用参数-23"><a href="#常用参数-23" class="headerlink" title="常用参数"></a>常用参数</h3><ul>
<li>-a或-all 显示目录中个别文件的大小。</li>
<li>-b或-bytes 显示目录或文件大小时，以byte为单位。 – -c或–total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。</li>
<li>-k或–kilobytes 以KB(1024bytes)为单位输出。</li>
<li>-m或–megabytes 以MB为单位输出。</li>
<li>-s或–summarize 仅显示总计，只列出最后加总的值。</li>
<li>-h或–human-readable 以K，M，G为单位，提高信息的可读性。</li>
<li>-x或–one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。</li>
<li>-L&lt;符号链接&gt;或–dereference&lt;符号链接&gt; 显示选项中所指定符号链接的源文件大小。</li>
<li>-S或–separate-dirs 显示个别目录的大小时，并不含其子目录的大小。</li>
<li>-X&lt;文件&gt;或–exclude-from=&lt;文件&gt; 在&lt;文件&gt;指定目录或文件。</li>
<li>–exclude=&lt;目录或文件&gt; 略过指定的目录或文件。</li>
<li>-D或–dereference-args 显示指定符号链接的源文件大小。</li>
<li>-H或–si 与-h参数相同，但是K，M，G是以1000为换算单位。</li>
<li>-l或–count-links 重复计算硬件链接的文件。</li>
</ul>
<h3 id="使用实例-23"><a href="#使用实例-23" class="headerlink" title="使用实例"></a>使用实例</h3><p>1.显示指定目录或文件所占空间</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">du <span class="keyword">test</span> <span class="comment"># 目录</span></span><br><span class="line">du <span class="keyword">test</span>.log <span class="comment"># 文件</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="六、性能监控和优化命令"><a href="#六、性能监控和优化命令" class="headerlink" title="六、性能监控和优化命令"></a>六、性能监控和优化命令</h2><h3 id="27-top-命令"><a href="#27-top-命令" class="headerlink" title="27.top 命令"></a>27.top 命令</h3><p>显示当前系统正在执行的进程的相关信息，包括进程ID、内存占用率、CPU占用率等。</p>
<h3 id="命令格式-25"><a href="#命令格式-25" class="headerlink" title="命令格式"></a>命令格式</h3><p>top [参数]</p>
<h3 id="常见参数"><a href="#常见参数" class="headerlink" title="常见参数"></a>常见参数</h3><ul>
<li>-b 批处理</li>
<li>-c 显示完整的治命令</li>
<li>-I 忽略失效过程</li>
<li>-s 保密模式</li>
<li>-S 累积模式</li>
<li>-i&lt;时间&gt; 设置间隔时间</li>
<li>-u&lt;用户名&gt; 指定用户名</li>
<li>-p&lt;进程号&gt; 指定进程</li>
<li>-n&lt;次数&gt; 循环显示的次数</li>
</ul>
<h3 id="使用实例-24"><a href="#使用实例-24" class="headerlink" title="使用实例"></a>使用实例</h3><ol>
<li>显示进程信息。</li>
</ol>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line"><span class="built_in">top</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="28-free-命令"><a href="#28-free-命令" class="headerlink" title="28.free 命令"></a>28.free 命令</h3><p>显示系统使用和空闲的内存情况，包括物理内存、交互区内存(swap)和内核缓冲区内存。</p>
<h3 id="命令格式-26"><a href="#命令格式-26" class="headerlink" title="命令格式"></a>命令格式</h3><p>free [参数]</p>
<h3 id="常见参数-1"><a href="#常见参数-1" class="headerlink" title="常见参数"></a>常见参数</h3><ul>
<li>-b  以Byte为单位显示内存使用情况</li>
<li>-k  以KB为单位显示内存使用情况</li>
<li>-m  以MB为单位显示内存使用情况</li>
<li>-g 以GB为单位显示内存使用情况</li>
<li>-o  不显示缓冲区调节列</li>
<li>-s&lt;间隔秒数&gt;  持续观察内存使用状况</li>
<li>-t  显示内存总和列。</li>
<li>-V  显示版本信息。</li>
</ul>
<h3 id="使用实例-25"><a href="#使用实例-25" class="headerlink" title="使用实例"></a>使用实例</h3><p>1.显示内存情况。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span></span><br><span class="line"><span class="built_in">free</span> -g #以GB为单位</span><br><span class="line"><span class="built_in">free</span> -m #以MB为单位</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="29-vmstat"><a href="#29-vmstat" class="headerlink" title="29. vmstat"></a>29. vmstat</h3><p>用来显示虚拟内存的信息。</p>
<h3 id="命令格式-27"><a href="#命令格式-27" class="headerlink" title="命令格式"></a>命令格式</h3><ul>
<li>vmstat [-a] [-n] [-S unit] [delay [ count]]</li>
<li>vmstat [-s] [-n] [-S unit]</li>
<li>vmstat [-m] [-n] [delay [ count]]</li>
<li>vmstat [-d] [-n] [delay [ count]]</li>
<li>vmstat [-p disk partition] [-n] [delay [ count]]</li>
<li>vmstat [-f]</li>
<li>vmstat [-V]</li>
</ul>
<h3 id="常见参数-2"><a href="#常见参数-2" class="headerlink" title="常见参数"></a>常见参数</h3><ul>
<li>-a：显示活跃和非活跃内存</li>
<li>-f：显示从系统启动至今的fork数量</li>
<li>-m：显示slabinfo</li>
<li>-n：只在开始时显示一次各字段名称</li>
<li>-s：显示内存相关统计信息及多种系统活动数量</li>
<li>delay：刷新时间间隔。如果不指定，只显示一条结果</li>
<li>count：刷新次数。如果不指定刷新次数，但指定了刷新时间间隔，这时刷新次数为无穷</li>
<li>-d：显示磁盘相关统计信息</li>
<li>-p：显示指定磁盘分区统计信息</li>
<li>-S：使用指定单位显示。参数有 k 、K 、m 、M ，分别代表1000、1024、1000000、1048576字节（byte）。默认单位为K（1024 bytes）</li>
</ul>
<h3 id="使用实例-26"><a href="#使用实例-26" class="headerlink" title="使用实例"></a>使用实例</h3><p>1.显示活跃和非活跃内存。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">vmstat -a <span class="number">5</span> <span class="number">5</span> # <span class="number">5</span>秒时间内进行<span class="number">5</span>次采样</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="30-lostat-命令"><a href="#30-lostat-命令" class="headerlink" title="30.lostat 命令"></a>30.lostat 命令</h3><p>通过iostat方便查看CPU、网卡、tty设备、磁盘、CD-ROM 等等设备的活动情况, 负载信息。</p>
<h3 id="命令格式-28"><a href="#命令格式-28" class="headerlink" title="命令格式"></a>命令格式</h3><p>iostat [参数] [时间] [次数]</p>
<h3 id="常见参数-3"><a href="#常见参数-3" class="headerlink" title="常见参数"></a>常见参数</h3><ul>
<li>-C 显示CPU使用情况</li>
<li>-d 显示磁盘使用情况</li>
<li>-k 以 KB 为单位显示</li>
<li>-m 以 M 为单位显示</li>
<li>-N 显示磁盘阵列(LVM) 信息</li>
<li>-n 显示NFS 使用情况</li>
<li>-p[磁盘] 显示磁盘和分区的情况</li>
<li>-t 显示终端和CPU的信息</li>
<li>-x 显示详细信息</li>
</ul>
<h3 id="使用实例-27"><a href="#使用实例-27" class="headerlink" title="使用实例"></a>使用实例</h3><p>1.定时显示所有信息。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">iostat <span class="number">2</span> <span class="number">3</span> #每隔 <span class="number">2</span>秒刷新显示，且显示<span class="number">3</span>次</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="31-lsof-命令"><a href="#31-lsof-命令" class="headerlink" title="31. lsof 命令"></a>31. lsof 命令</h3><p>用于查看你进程开打的文件，打开文件的进程，进程打开的端口(TCP、UDP)。</p>
<h3 id="命令格式-29"><a href="#命令格式-29" class="headerlink" title="命令格式"></a>命令格式</h3><p>lsof [参数] [文件]</p>
<h3 id="常见参数-4"><a href="#常见参数-4" class="headerlink" title="常见参数"></a>常见参数</h3><ul>
<li>-a 列出打开文件存在的进程</li>
<li>-c&lt;进程名&gt; 列出指定进程所打开的文件</li>
<li>-g 列出GID号进程详情</li>
<li>-d&lt;文件号&gt; 列出占用该文件号的进程</li>
<li>+d&lt;目录&gt; 列出目录下被打开的文件</li>
<li>+D&lt;目录&gt; 递归列出目录下被打开的文件</li>
<li>-n&lt;目录&gt; 列出使用NFS的文件</li>
<li>-i&lt;条件&gt; 列出符合条件的进程。（4、6、协议、:端口、 @ip ）</li>
<li>-p&lt;进程号&gt; 列出指定进程号所打开的文件</li>
<li>-u 列出UID号进程详情</li>
</ul>
<h3 id="使用实例-28"><a href="#使用实例-28" class="headerlink" title="使用实例"></a>使用实例</h3><p>1.查看谁正在使用bash文件，也就是说查找某个文件相关的进程。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">lsof <span class="regexp">/bin/</span>bash</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="七、网络命令"><a href="#七、网络命令" class="headerlink" title="七、网络命令"></a>七、网络命令</h2><h3 id="32-ipconfig-命令"><a href="#32-ipconfig-命令" class="headerlink" title="32.ipconfig 命令"></a>32.ipconfig 命令</h3><p>ifconfig 命令用来查看和配置网络设备。</p>
<h3 id="命令格式-30"><a href="#命令格式-30" class="headerlink" title="命令格式"></a>命令格式</h3><p>ifconfig [网络设备] [参数]</p>
<h3 id="常见参数-5"><a href="#常见参数-5" class="headerlink" title="常见参数"></a>常见参数</h3><ul>
<li>up 启动指定网络设备/网卡</li>
<li>down 关闭指定网络设备/网卡。</li>
<li>arp 设置指定网卡是否支持ARP协议</li>
<li>-promisc 设置是否支持网卡的promiscuous模式，如果选择此参数，网卡将接收网络中发给它所有的数据包</li>
<li>-allmulti 设置是否支持多播模式，如果选择此参数，网卡将接收网络中所有的多播数据包</li>
<li>-a 显示全部接口信息</li>
<li>-s 显示摘要信息（类似于 netstat -i）</li>
<li>add 给指定网卡配置IPv6地址</li>
<li>del 删除指定网卡的IPv6地址</li>
</ul>
<h3 id="使用实例-29"><a href="#使用实例-29" class="headerlink" title="使用实例"></a>使用实例</h3><p>1.启动关闭指定网卡</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">ifconfig</span> <span class="string">eth0 up</span></span><br><span class="line"><span class="attr">ifconfig</span> <span class="string">eth0 down</span></span><br><span class="line"><span class="attr">复制代码</span></span><br></pre></td></tr></table></figure>

<p>2.用ifconfig修改MAC地址</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ifconfig</span> <span class="selector-tag">eth0</span> <span class="selector-tag">hw</span> <span class="selector-tag">ether</span> 00<span class="selector-pseudo">:AA</span><span class="selector-pseudo">:BB</span><span class="selector-pseudo">:CC</span><span class="selector-pseudo">:DD</span><span class="selector-pseudo">:EE</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="33-route-命令"><a href="#33-route-命令" class="headerlink" title="33. route 命令"></a>33. route 命令</h3><p>Route命令是用于操作基于内核ip路由表，它的主要作用是创建一个静态路由让指定一个主机或者一个网络通过一个网络接口，如eth0。</p>
<h3 id="命令格式-31"><a href="#命令格式-31" class="headerlink" title="命令格式"></a>命令格式</h3><p>route [-f] [-p] [Command [Destination] [mask Netmask] [Gateway] [metric Metric]] [if Interface]]</p>
<h3 id="常见参数-6"><a href="#常见参数-6" class="headerlink" title="常见参数"></a>常见参数</h3><ul>
<li>-c 显示更多信息</li>
<li>-n 不解析名字</li>
<li>-v 显示详细的处理信息</li>
<li>-F 显示发送信息</li>
<li>-C 显示路由缓存</li>
<li>-f 清除所有网关入口的路由表。</li>
<li>-p 与 add 命令一起使用时使路由具有永久性。</li>
<li>add:添加一条新路由。</li>
<li>del:删除一条路由。</li>
<li>-net:目标地址是一个网络。</li>
<li>-host:目标地址是一个主机。</li>
<li>netmask:当添加一个网络路由时，需要使用网络掩码。</li>
<li>gw:路由数据包通过网关。注意，你指定的网关必须能够达到。</li>
<li>metric：设置路由跳数。</li>
<li>Command 指定您想运行的命令 (Add/Change/Delete/Print)。</li>
<li>Destination 指定该路由的网络目标。</li>
</ul>
<h3 id="使用实例-30"><a href="#使用实例-30" class="headerlink" title="使用实例"></a>使用实例</h3><p>1.显示当前路由</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">route </span><br><span class="line">route -n</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>2.添加网关/设置网关</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">route add -net <span class="number">224.0</span><span class="number">.0</span><span class="number">.0</span> netmask <span class="number">240.0</span><span class="number">.0</span><span class="number">.0</span> dev eth0</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="34-ping-命令"><a href="#34-ping-命令" class="headerlink" title="34. ping 命令"></a>34. ping 命令</h3><p>确定网络和各外部主机的状态；跟踪和隔离硬件和软件问题；测试、评估和管理网络。</p>
<h3 id="命令格式-32"><a href="#命令格式-32" class="headerlink" title="命令格式"></a>命令格式</h3><p>ping [参数] [主机名或IP地址]</p>
<h3 id="常见参数-7"><a href="#常见参数-7" class="headerlink" title="常见参数"></a>常见参数</h3><ul>
<li>-d 使用Socket的SO_DEBUG功能</li>
<li>-f 极限检测。大量且快速地送网络封包给一台机器，看它的回应</li>
<li>-n 只输出数值</li>
<li>-q 不显示任何传送封包的信息，只显示最后的结果</li>
<li>-r 忽略普通的Routing Table，直接将数据包送到远端主机上。通常是查看本机的网络接口是否有问题</li>
<li>-R 记录路由过程</li>
<li>-v 详细显示指令的执行过程</li>
<li>-c 数目：在发送指定数目的包后停止</li>
<li>-i 秒数：设定间隔几秒送一个网络封包给一台机器，预设值是一秒送一次 -I 网络界面：使用指定的网络界面送出数据包 -l 前置载入：设置在送出要求信息之前，先行发出的数据包 -p 范本样式：设置填满数据包的范本样式 -s 字节数：指定发送的数据字节数，预设值是56，加上8字节的ICMP头，一共是64ICMP数据字节 -t 存活数值：设置存活数值TTL的大小</li>
</ul>
<h3 id="使用实例-31"><a href="#使用实例-31" class="headerlink" title="使用实例"></a>使用实例</h3><ol>
<li>ping 网关</li>
</ol>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">ping -b <span class="number">192.168</span><span class="number">.120</span><span class="number">.1</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="35-traceroute-命令"><a href="#35-traceroute-命令" class="headerlink" title="35.traceroute 命令"></a>35.traceroute 命令</h3><p>让你追踪网络数据包的路由途径，预设数据包大小是40Bytes，用户可另行设置。</p>
<h3 id="命令格式-33"><a href="#命令格式-33" class="headerlink" title="命令格式"></a>命令格式</h3><p>traceroute [参数] [主机]</p>
<h3 id="常见参数-8"><a href="#常见参数-8" class="headerlink" title="常见参数"></a>常见参数</h3><ul>
<li>-d 使用Socket层级的排错功能</li>
<li>-f 设置第一个检测数据包的存活数值TTL的大小</li>
<li>-F 设置勿离断位</li>
<li>-g 设置来源路由网关，最多可设置8个</li>
<li>-i 使用指定的网络界面送出数据包</li>
<li>-I 使用ICMP回应取代UDP资料信息</li>
<li>-m 设置检测数据包的最大存活数值TTL的大小</li>
<li>-n 直接使用IP地址而非主机名称</li>
<li>-p 设置UDP传输协议的通信端口</li>
<li>-r 忽略普通的Routing Table，直接将数据包送到远端主机上</li>
<li>-s 设置本地主机送出数据包的IP地址</li>
<li>-t 设置检测数据包的TOS数值</li>
<li>-v 详细显示指令的执行过程</li>
<li>-w 设置等待远端主机回报的时间</li>
<li>-x 开启或关闭数据包的正确性检验</li>
</ul>
<h3 id="使用实例-32"><a href="#使用实例-32" class="headerlink" title="使用实例"></a>使用实例</h3><p>1.traceroute 用法简单、最常用的用法</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">traceroute</span> <span class="selector-tag">www</span><span class="selector-class">.baidu</span><span class="selector-class">.com</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ol>
<li>跳数设置</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">traceroute</span> <span class="selector-tag">-m</span> 10 <span class="selector-tag">www</span><span class="selector-class">.baidu</span><span class="selector-class">.com</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="36-netstat-命令"><a href="#36-netstat-命令" class="headerlink" title="36.netstat 命令"></a>36.netstat 命令</h3><p>用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。</p>
<h3 id="命令格式-34"><a href="#命令格式-34" class="headerlink" title="命令格式"></a>命令格式</h3><p>netstat [-acCeFghilMnNoprstuvVwx] [-A&lt;网络类型&gt;] [–ip]</p>
<h3 id="常见参数-9"><a href="#常见参数-9" class="headerlink" title="常见参数"></a>常见参数</h3><ul>
<li>-a或–all 显示所有连线中的Socket</li>
<li>-A&lt;网络类型&gt;或–&lt;网络类型&gt; 列出该网络类型连线中的相关地址</li>
<li>-c或–continuous 持续列出网络状态</li>
<li>-C或–cache 显示路由器配置的快取信息</li>
<li>-e或–extend 显示网络其他相关信息</li>
<li>-F或–fib 显示FIB</li>
<li>-g或–groups 显示多重广播功能群组组员名单</li>
<li>-h或–help 在线帮助</li>
<li>-i或–interfaces 显示网络界面信息表单</li>
<li>-l或–listening 显示监控中的服务器的Socket</li>
<li>-M或–masquerade 显示伪装的网络连线</li>
<li>-n或–numeric 直接使用IP地址，而不通过域名服务器</li>
<li>-N或–netlink或–symbolic 显示网络硬件外围设备的符号连接名称</li>
<li>-o或–timers 显示计时器</li>
<li>-p或–programs 显示正在使用Socket的程序识别码和程序名称</li>
<li>-r或–route 显示Routing Table</li>
<li>-s或–statistice 显示网络工作信息统计表</li>
<li>-t或–tcp 显示TCP传输协议的连线状况</li>
<li>-u或–udp 显示UDP传输协议的连线状况</li>
<li>-v或–verbose 显示指令执行过程</li>
<li>-V或–version 显示版本信息</li>
<li>-w或–raw 显示RAW传输协议的连线状况</li>
<li>-x或–unix 此参数的效果和指定”-A unix”参数相同</li>
<li>–ip或–inet 此参数的效果和指定”-A inet”参数相同</li>
</ul>
<h3 id="使用实例-33"><a href="#使用实例-33" class="headerlink" title="使用实例"></a>使用实例</h3><ol>
<li>列出所有端口</li>
</ol>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">netstat -<span class="keyword">a</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="37-telnet-命令"><a href="#37-telnet-命令" class="headerlink" title="37.telnet 命令"></a>37.telnet 命令</h3><p>执行telnet指令开启终端机阶段作业，并登入远端主机。</p>
<h3 id="命令格式-35"><a href="#命令格式-35" class="headerlink" title="命令格式"></a>命令格式</h3><p>telnet [参数] [主机]</p>
<h3 id="常见参数-10"><a href="#常见参数-10" class="headerlink" title="常见参数"></a>常见参数</h3><ul>
<li>-8 允许使用8位字符资料，包括输入与输出</li>
<li>-a 尝试自动登入远端系统</li>
<li>-b&lt;主机别名&gt; 使用别名指定远端主机名称</li>
<li>-c 不读取用户专属目录里的.telnetrc文件</li>
<li>-d 启动排错模式</li>
<li>-e&lt;脱离字符&gt; 设置脱离字符</li>
<li>-E 滤除脱离字符</li>
<li>-f 此参数的效果和指定”-F”参数相同</li>
</ul>
<h3 id="使用实例-34"><a href="#使用实例-34" class="headerlink" title="使用实例"></a>使用实例</h3><p>1.远程服务器无法访问</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">telnet <span class="number">192.168</span><span class="number">.120</span><span class="number">.206</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="八、其他命令"><a href="#八、其他命令" class="headerlink" title="八、其他命令"></a>八、其他命令</h2><h3 id="38-ln-命令"><a href="#38-ln-命令" class="headerlink" title="38.ln 命令"></a>38.ln 命令</h3><p>为某一个文件在另外一个位置建立一个同步的链接.当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。</p>
<h3 id="命令格式-36"><a href="#命令格式-36" class="headerlink" title="命令格式"></a>命令格式</h3><p>ln [参数] [源文件或目录] [目标文件或目录]</p>
<h3 id="常用参数-24"><a href="#常用参数-24" class="headerlink" title="常用参数"></a>常用参数</h3><p>必要参数:</p>
<ul>
<li>-b 删除，覆盖以前建立的链接</li>
<li>-d 允许超级用户制作目录的硬链接</li>
<li>-f 强制执行</li>
<li>-i 交互模式，文件存在则提示用户是否覆盖</li>
<li>-n 把符号链接视为一般目录</li>
<li>-s 软链接(符号链接)</li>
<li>-v 显示详细的处理过程</li>
</ul>
<p>选择参数:</p>
<ul>
<li>-S “-S&lt;字尾备份字符串&gt; ”或 “–suffix=&lt;字尾备份字符串&gt;”</li>
<li>-V “-V&lt;备份方式&gt;”或“–version-control=&lt;备份方式&gt;”</li>
</ul>
<h3 id="使用实例-35"><a href="#使用实例-35" class="headerlink" title="使用实例"></a>使用实例</h3><p>1.为 test.log文件创建软链接linktest。</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">ln -s <span class="keyword">test</span>.<span class="keyword">log</span> <span class="keyword">linktest</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>2.为 test.log创建硬链接lntest。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> test.<span class="built_in">log</span> lntest</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="39-diff-命令"><a href="#39-diff-命令" class="headerlink" title="39.diff 命令"></a>39.diff 命令</h3><p>比较单个文件或者目录内容。</p>
<h3 id="命令格式-37"><a href="#命令格式-37" class="headerlink" title="命令格式"></a>命令格式</h3><p>diff [参数] [文件1或目录1] [文件2或目录2]</p>
<h3 id="常用参数-25"><a href="#常用参数-25" class="headerlink" title="常用参数"></a>常用参数</h3><ul>
<li>-c 上下文模式，显示全部内文，并标出不同之处</li>
<li>-u 统一模式，以合并的方式来显示文件内容的不同</li>
<li>-a 只会逐行比较文本文件</li>
<li>-N 在比较目录时，若文件 A 仅出现在某个目录中，预设会显示：Only in 目录。若使用 -N 参数，则 diff 会将文件 A 与一个空白的文件比较</li>
<li>-r 递归比较目录下的文件</li>
</ul>
<h3 id="使用实例-36"><a href="#使用实例-36" class="headerlink" title="使用实例"></a>使用实例</h3><p>1.显示 test1.txt 和 test2.txt 两个文件差异。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">diff</span> <span class="selector-tag">test1</span><span class="selector-class">.txt</span> <span class="selector-tag">test2</span><span class="selector-class">.txt</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="40-grep-命令"><a href="#40-grep-命令" class="headerlink" title="40.grep 命令"></a>40.grep 命令</h3><p>一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来。</p>
<h3 id="命令格式-38"><a href="#命令格式-38" class="headerlink" title="命令格式"></a>命令格式</h3><p>grep [option] pattern file</p>
<h3 id="常用参数-26"><a href="#常用参数-26" class="headerlink" title="常用参数"></a>常用参数</h3><ul>
<li>-c 计算找到‘搜寻字符串’（即 pattern）的次数</li>
<li>-i 忽略大小写的不同，所以大小写视为相同</li>
<li>-n 输出行号</li>
<li>-v 反向选择，打印不匹配的行</li>
<li>-r 递归搜索</li>
<li>–color=auto 将找到的关键词部分加上颜色显示</li>
</ul>
<h3 id="使用实例-37"><a href="#使用实例-37" class="headerlink" title="使用实例"></a>使用实例</h3><p>1.将 /etc/passwd 文件中出现 root 的行取出来，关键词部分加上颜色显示。</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grep</span> <span class="string">&quot;root&quot;</span> <span class="regexp">/etc/</span>passwd --color=auto</span><br><span class="line">cat <span class="regexp">/etc/</span>passwd | <span class="keyword">grep</span> <span class="string">&quot;root&quot;</span> --color=auto</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>2.将 /etc/passwd 文件中没有出现 root 和 nologin 的行取出来。</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grep</span> -v <span class="string">&quot;root&quot;</span> <span class="regexp">/etc/</span>passwd | <span class="keyword">grep</span> -v <span class="string">&quot;nologin&quot;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="41-wc-命令"><a href="#41-wc-命令" class="headerlink" title="41.wc 命令"></a>41.wc 命令</h3><p>用来显示文件所包含的行、字和字节数。</p>
<h3 id="命令格式-39"><a href="#命令格式-39" class="headerlink" title="命令格式"></a>命令格式</h3><p>wc [选项] [文件]</p>
<h3 id="常用参数-27"><a href="#常用参数-27" class="headerlink" title="常用参数"></a>常用参数</h3><ul>
<li>-c 统计字节数</li>
<li>-l 统计行数</li>
<li>-m 统计字符数，这个标志不能与 -c 标志一起使用</li>
<li>-w 统计字数，一个字被定义为由空白、跳格或换行字符分隔的字符串</li>
<li>-L 打印最长行的长度</li>
</ul>
<h3 id="使用实例-38"><a href="#使用实例-38" class="headerlink" title="使用实例"></a>使用实例</h3><p>1.统计文件的字节数、行数和字符数。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">wc -c <span class="keyword">test</span>.txt</span><br><span class="line">wc -l <span class="keyword">test</span>.txt</span><br><span class="line">wc -m <span class="keyword">test</span>.txt</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>2.统计文件的字节数、行数和字符数，只打印数字，不打印文件名。</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cat</span> <span class="keyword">test</span>.txt | wc -c</span><br><span class="line"><span class="keyword">cat</span> <span class="keyword">test</span>.txt | wc -<span class="keyword">l</span></span><br><span class="line"><span class="keyword">cat</span> <span class="keyword">test</span>.txt | wc -<span class="keyword">m</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="42-ps-命令"><a href="#42-ps-命令" class="headerlink" title="42.ps 命令"></a>42.ps 命令</h3><p>用来显示当前进程的状态。</p>
<h3 id="命令格式-40"><a href="#命令格式-40" class="headerlink" title="命令格式"></a>命令格式</h3><p>ps[参数]</p>
<h3 id="常用参数-28"><a href="#常用参数-28" class="headerlink" title="常用参数"></a>常用参数</h3><ul>
<li>a 显示所有进程</li>
<li>-a 显示同一终端下的所有程序</li>
<li>-A 显示所有进程</li>
<li>c 显示进程的真实名称</li>
<li>-N 反向选择</li>
<li>-e 等于“-A”</li>
<li>e 显示环境变量</li>
<li>f 显示程序间的关系</li>
<li>-H 显示树状结构</li>
<li>r 显示当前终端的进程</li>
<li>T 显示当前终端的所有程序</li>
<li>u 指定用户的所有进程</li>
<li>-au 显示较详细的资讯</li>
<li>-aux 显示所有包含其他使用者的行程</li>
<li>-C&lt;命令&gt; 列出指定命令的状况</li>
<li>–lines&lt;行数&gt; 每页显示的行数</li>
<li>–width&lt;字符数&gt; 每页显示的字符数</li>
</ul>
<h3 id="使用实例-39"><a href="#使用实例-39" class="headerlink" title="使用实例"></a>使用实例</h3><p>1.显示所有进程信息。</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">ps -<span class="keyword">A</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ol>
<li>显示指定用户信息。</li>
</ol>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ps</span> -u root</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ol>
<li>显示所有进程信息，连同命令行。</li>
</ol>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ps</span> -ef</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="43-watch-命令"><a href="#43-watch-命令" class="headerlink" title="43.watch 命令"></a>43.watch 命令</h3><p>可以将命令的输出结果输出到标准输出设备，多用于周期性执行命令/定时执行命令。</p>
<h3 id="命令格式-41"><a href="#命令格式-41" class="headerlink" title="命令格式"></a>命令格式</h3><p>watch [参数] [命令]</p>
<h3 id="常用参数-29"><a href="#常用参数-29" class="headerlink" title="常用参数"></a>常用参数</h3><ul>
<li>-n或–interval watch缺省每2秒运行一下程序，可以用-n或-interval来指定间隔的时间。</li>
<li>-d或–differences 用-d或–differences 选项watch 会高亮显示变化的区域。 而-d=cumulative选项会把变动过的地方(不管最近的那次有没有变动)都高亮显示出来。</li>
<li>-t 或-no-title 会关闭watch命令在顶部的时间间隔,命令，当前时间的输出。</li>
<li>-h, –help 查看帮助文档</li>
</ul>
<h3 id="使用实例-40"><a href="#使用实例-40" class="headerlink" title="使用实例"></a>使用实例</h3><p>1.每隔一秒高亮显示网络链接数的变化情况</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">watch -n <span class="number">1</span> -d netstat -ant</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>2.每隔一秒高亮显示http链接数的变化情况</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">watch</span> -n <span class="number">1</span> -d <span class="string">&#x27;pstree|grep http&#x27;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="44-at-命令"><a href="#44-at-命令" class="headerlink" title="44.  at 命令"></a>44.  at 命令</h3><p>在一个指定的时间执行一个指定任务，只能执行一次。（需开启atd进程）</p>
<h3 id="命令格式-42"><a href="#命令格式-42" class="headerlink" title="命令格式"></a>命令格式</h3><p>at [参数] [时间]</p>
<h3 id="常用参数-30"><a href="#常用参数-30" class="headerlink" title="常用参数"></a>常用参数</h3><ul>
<li>-m 当指定的任务被完成之后，将给用户发送邮件，即使没有标准输出</li>
<li>-I atq的别名</li>
<li>-d atrm的别名</li>
<li>-v 显示任务将被执行的时间</li>
<li>-c 打印任务的内容到标准输出</li>
<li>-V 显示版本信息</li>
<li>-q&lt;列队&gt; 使用指定的列队</li>
<li>-f&lt;文件&gt; 从指定文件读入任务而不是从标准输入读入</li>
<li>-t&lt;时间参数&gt; 以时间参数的形式提交要运行的任务</li>
</ul>
<h3 id="使用实例-41"><a href="#使用实例-41" class="headerlink" title="使用实例"></a>使用实例</h3><p>1.3天后的下午5点执行/bin/ls</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="keyword">at</span> <span class="number">5</span>pm+<span class="number">3</span> days </span><br><span class="line"><span class="keyword">at</span>&gt; /bin/ls</span><br><span class="line"><span class="keyword">at</span>&gt; <span class="xml"><span class="tag">&lt;<span class="name">EOT</span>&gt;</span></span></span><br><span class="line"><span class="xml">复制代码</span></span><br></pre></td></tr></table></figure>

<h3 id="45-crontab-命令"><a href="#45-crontab-命令" class="headerlink" title="45.crontab 命令"></a>45.crontab 命令</h3><p>在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。(需开启crond服务)</p>
<h3 id="命令格式-43"><a href="#命令格式-43" class="headerlink" title="命令格式"></a>命令格式</h3><p>crontab [-u user] file 或</p>
<p>crontab [-u user] [ -e | -l | -r ]</p>
<h3 id="常用参数-31"><a href="#常用参数-31" class="headerlink" title="常用参数"></a>常用参数</h3><ul>
<li>-u user：用来设定某个用户的crontab服务，例如，“-u ixdba”表示设定ixdba用户的crontab服务，此参数一般有root用户来运行。</li>
<li>file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。</li>
<li>-e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。</li>
<li>-l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。</li>
<li>-r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。</li>
<li>-i：在删除用户的crontab文件时给确认提示。</li>
</ul>
<h3 id="使用实例-42"><a href="#使用实例-42" class="headerlink" title="使用实例"></a>使用实例</h3><p>1.列出 crontab 文件。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">crontab</span> -l</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>2.编辑crontab 文件。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">crontab</span> -e</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="Crontab-任务实例"><a href="#Crontab-任务实例" class="headerlink" title="Crontab 任务实例"></a>Crontab 任务实例</h3><p>1.每1分钟执行一次command</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span> <span class="emphasis">* *</span> <span class="emphasis">* *</span> command</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>2.每小时的第3和第15分钟执行</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span>,<span class="number">15</span> * * * * command</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>3.在上午8点到11点的第3和第15分钟执行</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span>,<span class="number">15</span> <span class="number">8</span><span class="number">-11</span> * * * command</span><br></pre></td></tr></table></figure>


<p>作者：实验楼<br>链接：<a href="https://juejin.im/post/6844903930166509581">https://juejin.im/post/6844903930166509581</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。间是与系统运行相关的。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>0124.二叉树的最大路径和</title>
    <url>/2020/11/03/0124.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        tracerse(root);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">tracerse</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = Math.max(<span class="number">0</span>, tracerse(node.left));</span><br><span class="line">        <span class="keyword">int</span> r = Math.max(<span class="number">0</span>, tracerse(node.right));</span><br><span class="line">        max = Math.max(max, l + r + node.val);</span><br><span class="line">        <span class="keyword">return</span> Math.max(l, r) + node.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</li>
<li>空间复杂度：O(n)。空间复杂度取决于递归的栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA 8 十大新特性</title>
    <url>/2020/11/03/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h1 id="一、接口的默认方法"><a href="#一、接口的默认方法" class="headerlink" title="一、接口的默认方法"></a>一、接口的默认方法</h1><p>Java 8允许我们给接口添加一个非抽象的方法实现，只需要使用 default关键字即可，这个特征又叫做扩展方法，示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Formula</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Formula接口在拥有calculate方法之外同时还定义了sqrt方法，实现了Formula接口的子类只需要实现一个calculate方法，默认方法sqrt将在子类上可以直接使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Formula formula = <span class="keyword">new</span> Formula() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqrt(a * <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">formula.calculate(<span class="number">100</span>);     <span class="comment">// 100.0</span></span><br><span class="line">formula.sqrt(<span class="number">16</span>);           <span class="comment">// 4.0</span></span><br></pre></td></tr></table></figure>

<p>文中的formula被实现为一个匿名类的实例，该代码非常容易理解，6行代码实现了计算 sqrt(a * 100)。在下一节中，我们将会看到实现单方法接口的更简单的做法。</p>
<p>译者注： 在Java中只有单继承，如果要让一个类赋予新的特性，通常是使用接口来实现，在C++中支持多继承，允许一个子类同时具有多个父类的接口与功能，在其他语言中，让一个类同时具有其他的可复用代码的方法叫做mixin。新的Java 8 的这个特新在编译器实现的角度上来说更加接近Scala的trait。 在C#中也有名为扩展方法的概念，允许给已存在的类型扩展方法，和Java 8的这个在语义上有差别。</p>
<h1 id="二、Lambda-表达式"><a href="#二、Lambda-表达式" class="headerlink" title="二、Lambda 表达式"></a>二、Lambda 表达式</h1><ul>
<li>Spring的三级缓存</li>
</ul>
<p>首先看看在老版本的Java中是如何排列字符串的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;peter&quot;</span>, <span class="string">&quot;anna&quot;</span>, <span class="string">&quot;mike&quot;</span>, <span class="string">&quot;xenia&quot;</span>);</span><br><span class="line"></span><br><span class="line">Collections.sort(names, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>只需要给静态方法 Collections.sort 传入一个List对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给sort方法。</p>
<p>在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>看到了吧，代码变得更段且更具有可读性，但是实际上还可以写得更短：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure>

<p>对于函数体只有一行代码的，你可以去掉大括号{}以及return关键字，但是你还可以写得更短点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(names, (a, b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure>

<p>Java编译器可以自动推导出参数类型，所以你可以不用再写一次类型。接下来我们看看lambda表达式还能作出什么更方便的东西来</p>
<h1 id="三、函数式接口"><a href="#三、函数式接口" class="headerlink" title="三、函数式接口"></a>三、函数式接口</h1><ul>
<li>Spring的ObjectFactory</li>
</ul>
<p>Lambda表达式是如何在java的类型系统中表示的呢？每一个lambda表达式都对应一个类型，通常是接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为 默认方法 不算抽象方法，所以你也可以给你的函数式接口添加默认方法。</p>
<p>我们可以将lambda表达式当作任意只包含一个抽象方法的接口类型，确保你的接口一定达到这个要求，你只需要给你的接口添加 @FunctionalInterface 注解，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">F</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">convert</span><span class="params">(F from)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);</span><br><span class="line">Integer converted = converter.convert(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">System.out.println(converted);    <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<p>需要注意如果@FunctionalInterface如果没有指定，上面的代码也是对的。</p>
<p>译者注 将lambda表达式映射到一个单方法的接口上，这种做法在Java 8之前就有别的语言实现，比如Rhino JavaScript解释器，如果一个函数参数接收一个单方法的接口而你传递的是一个function，Rhino 解释器会自动做一个单接口的实例到function的适配器，典型的应用场景有 org.w3c.dom.events.EventTarget 的addEventListener 第二个参数 EventListener。</p>
<h1 id="四、方法与构造函数引用"><a href="#四、方法与构造函数引用" class="headerlink" title="四、方法与构造函数引用"></a>四、方法与构造函数引用</h1><p>前一节中的代码还可以通过静态方法引用来表示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Converter&lt;String, Integer&gt; converter = Integer::valueOf;</span><br><span class="line">Integer converted = converter.convert(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">System.out.println(converted);   <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<p>Java 8 允许你使用 :: 关键字来传递方法或者构造函数引用，上面的代码展示了如何引用一个静态方法，我们也可以引用一个对象的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> converter = something::startsWith;</span><br><span class="line">String converted = converter.convert(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">System.out.println(converted);    <span class="comment">// &quot;J&quot;</span></span><br></pre></td></tr></table></figure>

<p>接下来看看构造函数是如何使用::关键字来引用的，首先我们定义一个包含多个构造函数的简单类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String firstName;</span><br><span class="line">    String lastName;</span><br><span class="line"></span><br><span class="line">    Person() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Person(String firstName, String lastName) &#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们指定一个用来创建Person对象的对象工厂接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonFactory</span>&lt;<span class="title">P</span> <span class="keyword">extends</span> <span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">P <span class="title">create</span><span class="params">(String firstName, String lastName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们使用构造函数引用来将他们关联起来，而不是实现一个完整的工厂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PersonFactory&lt;Person&gt; personFactory = Person::<span class="keyword">new</span>;</span><br><span class="line">Person person = personFactory.create(<span class="string">&quot;Peter&quot;</span>, <span class="string">&quot;Parker&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>我们只需要使用 Person::new 来获取Person类构造函数的引用，Java编译器会自动根据PersonFactory.create方法的签名来选择合适的构造函数。</p>
<h1 id="五、Lambda-作用域"><a href="#五、Lambda-作用域" class="headerlink" title="五、Lambda 作用域"></a>五、Lambda 作用域</h1><p>在lambda表达式中访问外层作用域和老版本的匿名对象中的方式很相似。你可以直接访问标记了final的外层局部变量，或者实例的字段以及静态变量。</p>
<h1 id="六、访问局部变量"><a href="#六、访问局部变量" class="headerlink" title="六、访问局部变量"></a>六、访问局部变量</h1><p>我们可以直接在lambda表达式中访问外层的局部变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter =</span><br><span class="line">        (from) -&gt; String.valueOf(from + num);</span><br><span class="line"></span><br><span class="line">stringConverter.convert(<span class="number">2</span>);     <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>但是和匿名对象不同的是，这里的变量num可以不用声明为final，该代码同样正确：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter =</span><br><span class="line">        (from) -&gt; String.valueOf(from + num);</span><br><span class="line"></span><br><span class="line">stringConverter.convert(<span class="number">2</span>);     <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>不过这里的num必须不可被后面的代码修改（即隐性的具有final的语义），例如下面的就无法编译：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter =</span><br><span class="line">        (from) -&gt; String.valueOf(from + num);</span><br><span class="line">num = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>在lambda表达式中试图修改num同样是不允许的。</p>
<h1 id="七、访问对象字段与静态变量"><a href="#七、访问对象字段与静态变量" class="headerlink" title="七、访问对象字段与静态变量"></a>七、访问对象字段与静态变量</h1><p>和本地变量不同的是，lambda内部对于实例的字段以及静态变量是即可读又可写。该行为和匿名对象是一致的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lambda4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> outerStaticNum;</span><br><span class="line">    <span class="keyword">int</span> outerNum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testScopes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; &#123;</span><br><span class="line">            outerNum = <span class="number">23</span>;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(from);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; &#123;</span><br><span class="line">            outerStaticNum = <span class="number">72</span>;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(from);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="八、访问接口的默认方法"><a href="#八、访问接口的默认方法" class="headerlink" title="八、访问接口的默认方法"></a>八、访问接口的默认方法</h1><p>还记得第一节中的formula例子么，接口Formula定义了一个默认方法sqrt可以直接被formula的实例包括匿名对象访问到，但是在lambda表达式中这个是不行的。<br>Lambda表达式中是无法访问到默认方法的，以下代码将无法编译：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Formula formula = (a) -&gt; sqrt( a * <span class="number">100</span>);</span><br><span class="line">Built-in Functional Interfaces</span><br></pre></td></tr></table></figure>

<p>JDK 1.8 API包含了很多内建的函数式接口，在老Java中常用到的比如Comparator或者Runnable接口，这些接口都增加了@FunctionalInterface注解以便能用在lambda上。<br>Java 8 API同样还提供了很多全新的函数式接口来让工作更加方便，有一些接口是来自Google Guava库里的，即便你对这些很熟悉了，还是有必要看看这些是如何扩展到lambda上使用的。</p>
<p><strong>Predicate接口</strong></p>
<p>Predicate 接口只有一个参数，返回<strong>boolean</strong>类型。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">Predicate&lt;<span class="built_in">String</span>&gt; predicate = (s) -&gt; s.length() &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">predicate.test(<span class="string">&quot;foo&quot;</span>);              <span class="comment">// true</span></span><br><span class="line">predicate.negate().test(<span class="string">&quot;foo&quot;</span>);     <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;</span><br><span class="line">Predicate&lt;Boolean&gt; isNull = Objects::isNull;</span><br><span class="line"></span><br><span class="line">Predicate&lt;<span class="built_in">String</span>&gt; isEmpty = <span class="built_in">String</span>::isEmpty;</span><br><span class="line">Predicate&lt;<span class="built_in">String</span>&gt; isNotEmpty = isEmpty.negate();</span><br></pre></td></tr></table></figure>

<p><strong>Function 接口</strong></p>
<p>Function 接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（compose, andThen）：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>&lt;<span class="built_in">String</span>, Integer&gt; toInteger = Integer::valueOf;</span><br><span class="line"><span class="built_in">Function</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; backToString = toInteger.andThen(<span class="built_in">String</span>::valueOf);</span><br><span class="line"></span><br><span class="line">backToString.apply(<span class="string">&quot;123&quot;</span>);     <span class="comment">// &quot;123&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>Supplier 接口</strong></p>
<p>Supplier 接口返回一个任意范型的值，和Function接口不同的是该接口没有任何参数</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Supplier&lt;Person&gt; personSupplier = Person::<span class="keyword">new</span>;</span><br><span class="line">personSupplier.<span class="keyword">get</span>();   <span class="comment">// new Person</span></span><br></pre></td></tr></table></figure>

<p><strong>Consumer 接口</strong></p>
<p>Consumer 接口表示执行在单个参数上的操作。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Consumer&lt;Person&gt; greeter = (p) -&gt; System.<span class="keyword">out</span>.println(<span class="string">&quot;Hello, &quot;</span> + p.firstName);</span><br><span class="line">greeter.accept(<span class="keyword">new</span> Person(<span class="string">&quot;Luke&quot;</span>, <span class="string">&quot;Skywalker&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><strong>Comparator 接口</strong></p>
<p>Comparator 是老Java中的经典接口， Java 8在此之上添加了多种默认方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);</span><br><span class="line"></span><br><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Doe&quot;</span>);</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Wonderland&quot;</span>);</span><br><span class="line"></span><br><span class="line">comparator.compare(p1, p2);             <span class="comment">// &gt; 0</span></span><br><span class="line">comparator.reversed().compare(p1, p2);  <span class="comment">// &lt; 0</span></span><br></pre></td></tr></table></figure>

<p><strong>Optional 接口</strong></p>
<p>Optional 不是函数是接口，这是个用来防止NullPointerException异常的辅助类型，这是下一届中将要用到的重要概念，现在先简单的看看这个接口能干什么：</p>
<p>Optional 被定义为一个简单的容器，其值可能是null或者不是null。在Java 8之前一般某个函数应该返回非空对象但是偶尔却可能返回了null，而在Java 8中，不推荐你返回null而是返回Optional。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Optional</span>&lt;<span class="type">String</span>&gt; <span class="keyword">optional</span> = <span class="type">Optional</span>.of(<span class="string">&quot;bam&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">optional</span>.isPresent();           <span class="comment">// true</span></span><br><span class="line"><span class="keyword">optional</span>.<span class="keyword">get</span>();                 <span class="comment">// &quot;bam&quot;</span></span><br><span class="line"><span class="keyword">optional</span>.orElse(<span class="string">&quot;fallback&quot;</span>);    <span class="comment">// &quot;bam&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">optional</span>.ifPresent((s) -&gt; <span class="type">System</span>.out.<span class="built_in">println</span>(s.charAt(<span class="number">0</span>)));     <span class="comment">// &quot;b&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>Stream 接口</strong></p>
<p>java.util.Stream 表示能应用在一组元素上一次执行的操作序列。Stream 操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样你就可以将多个操作依次串起来。Stream 的创建需要指定一个数据源，比如 java.util.Collection的子类，List或者Set， Map不支持。Stream的操作可以串行执行或者并行执行。</p>
<p>首先看看Stream是怎么用，首先创建实例代码的用到的数据List：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; stringCollection = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">stringCollection.<span class="keyword">add</span>(<span class="string">&quot;ddd2&quot;</span>);</span><br><span class="line">stringCollection.<span class="keyword">add</span>(<span class="string">&quot;aaa2&quot;</span>);</span><br><span class="line">stringCollection.<span class="keyword">add</span>(<span class="string">&quot;bbb1&quot;</span>);</span><br><span class="line">stringCollection.<span class="keyword">add</span>(<span class="string">&quot;aaa1&quot;</span>);</span><br><span class="line">stringCollection.<span class="keyword">add</span>(<span class="string">&quot;bbb3&quot;</span>);</span><br><span class="line">stringCollection.<span class="keyword">add</span>(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">stringCollection.<span class="keyword">add</span>(<span class="string">&quot;bbb2&quot;</span>);</span><br><span class="line">stringCollection.<span class="keyword">add</span>(<span class="string">&quot;ddd1&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>Java 8扩展了集合类，可以通过 Collection.stream() 或者 Collection.parallelStream() 来创建一个Stream。下面几节将详细解释常用的Stream操作：</p>
<p><strong>Filter 过滤</strong></p>
<p>过滤通过一个predicate接口来过滤并只保留符合条件的元素，该操作属于中间操作，所以我们可以在过滤后的结果来应用其他Stream操作（比如forEach）。forEach需要一个函数来对过滤后的元素依次执行。forEach是一个最终操作，所以我们不能在forEach之后来执行其他Stream操作。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .filter((s) -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">/<span class="regexp">/ &quot;aaa2&quot;, &quot;aaa1&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>Sort 排序</strong></p>
<p>排序是一个中间操作，返回的是排序好后的Stream。如果你不指定一个自定义的Comparator则会使用默认排序。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .sorted()</span><br><span class="line">    .filter((s) -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">/<span class="regexp">/ &quot;aaa1&quot;, &quot;aaa2&quot;</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，排序只创建了一个排列好后的Stream，而不会影响原有的数据源，排序之后原数据stringCollection是不会被修改的。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">System.<span class="keyword">out</span>.println(stringCollection);</span><br><span class="line"><span class="comment">// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1</span></span><br></pre></td></tr></table></figure>

<p><strong>Map 映射</strong><br>中间操作map会将元素根据指定的Function接口来依次将元素转成另外的对象，下面的示例展示了将字符串转换为大写字符串。你也可以通过map来讲对象转换成其他类型，map返回的Stream类型是根据你map传递进去的函数的返回值决定的。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .map(String::toUpperCase)</span><br><span class="line">    .sorted((a, b) -&gt; b.compareTo(a))</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">/<span class="regexp">/ &quot;DDD2&quot;, &quot;DDD1&quot;, &quot;CCC&quot;, &quot;BBB3&quot;, &quot;BBB2&quot;, &quot;AAA2&quot;, &quot;AAA1&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>Match 匹配</strong></p>
<p>Stream提供了多种匹配操作，允许检测指定的Predicate是否匹配整个Stream。所有的匹配操作都是最终操作，并返回一个boolean类型的值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">boolean anyStartsWithA = </span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .anyMatch((s) -&gt; s.<span class="built_in">startsWith</span>(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="type">System</span>.out.<span class="built_in">println</span>(anyStartsWithA);      <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">boolean allStartsWithA = </span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .allMatch((s) -&gt; s.<span class="built_in">startsWith</span>(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="type">System</span>.out.<span class="built_in">println</span>(allStartsWithA);      <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">boolean noneStartsWithZ = </span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .noneMatch((s) -&gt; s.<span class="built_in">startsWith</span>(<span class="string">&quot;z&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="type">System</span>.out.<span class="built_in">println</span>(noneStartsWithZ);      <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>Count 计数</strong><br>计数是一个最终操作，返回Stream中元素的个数，返回值类型是long。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">long startsWithB = </span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .<span class="built_in">filter</span>((s) -&gt; s.<span class="built_in">startsWith</span>(<span class="string">&quot;b&quot;</span>))</span><br><span class="line">        .<span class="built_in">count</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">System</span>.out.<span class="built_in">println</span>(startsWithB);    <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p><strong>Reduce 规约</strong></p>
<p>这是一个最终操作，允许通过指定的函数来讲stream中的多个元素规约为一个元素，规越后的结果是通过Optional接口表示的：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">Optional&lt;<span class="built_in">String</span>&gt; reduced =</span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .sorted()</span><br><span class="line">        .reduce((s1, s2) -&gt; s1 + <span class="string">&quot;#&quot;</span> + s2);</span><br><span class="line"></span><br><span class="line">reduced.ifPresent(System.out::println);</span><br><span class="line"><span class="comment">// &quot;aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>并行Streams</strong></p>
<p>前面提到过Stream有串行和并行两种，串行Stream上的操作是在一个线程中依次完成，而并行Stream则是在多个线程上同时执行。</p>
<p>下面的例子展示了是如何通过并行Stream来提升性能：</p>
<p>首先我们创建一个没有重复元素的大表</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> max = <span class="number">1000000</span>;</span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; values = <span class="keyword">new</span> ArrayList&lt;&gt;(max);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">    UUID uuid = UUID.randomUUID();</span><br><span class="line">    values.add(uuid.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们计算一下排序这个Stream要耗时多久，<br><strong>串行排序：</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> count = values.stream().sorted().count();</span><br><span class="line">System.<span class="keyword">out</span>.println(count);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);</span><br><span class="line">System.<span class="keyword">out</span>.println(String.format(<span class="string">&quot;sequential sort took: %d ms&quot;</span>, millis));</span><br></pre></td></tr></table></figure>

<p>// 串行耗时: 899 ms</p>
<p><strong>并行排序：</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> count = values.parallelStream().sorted().count();</span><br><span class="line">System.<span class="keyword">out</span>.println(count);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);</span><br><span class="line">System.<span class="keyword">out</span>.println(String.format(<span class="string">&quot;parallel sort took: %d ms&quot;</span>, millis));</span><br></pre></td></tr></table></figure>

<p>// 并行排序耗时: 472 ms<br>上面两个代码几乎是一样的，但是并行版的快了50%之多，唯一需要做的改动就是将stream()改为parallelStream()。</p>
<p><strong>Map</strong></p>
<p>前面提到过，Map类型不支持stream，不过Map提供了一些新的有用的方法来处理一些日常任务。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; <span class="keyword">map</span> = <span class="built_in">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">map</span>.putIfAbsent(i, <span class="string">&quot;val&quot;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">map</span>.forEach((id, val) -&gt; System.out.<span class="built_in">println</span>(val));</span><br></pre></td></tr></table></figure>

<p>以上代码很容易理解， putIfAbsent 不需要我们做额外的存在性检查，而forEach则接收一个Consumer接口来对map里的每一个键值对进行操作。</p>
<p>下面的例子展示了map上的其他有用的函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>.computeIfPresent(<span class="number">3</span>, (num, val) -&gt; val + num);</span><br><span class="line"><span class="built_in">map</span>.<span class="keyword">get</span>(<span class="number">3</span>);             <span class="comment">// val33</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>.computeIfPresent(<span class="number">9</span>, (num, val) -&gt; null);</span><br><span class="line"><span class="built_in">map</span>.containsKey(<span class="number">9</span>);     <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>.computeIfAbsent(<span class="number">23</span>, num -&gt; <span class="string">&quot;val&quot;</span> + num);</span><br><span class="line"><span class="built_in">map</span>.containsKey(<span class="number">23</span>);    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>.computeIfAbsent(<span class="number">3</span>, num -&gt; <span class="string">&quot;bam&quot;</span>);</span><br><span class="line"><span class="built_in">map</span>.<span class="keyword">get</span>(<span class="number">3</span>);             <span class="comment">// val33</span></span><br></pre></td></tr></table></figure>

<p>接下来展示如何在Map里删除一个键值全都匹配的项</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>.remove(<span class="number">3</span>, <span class="string">&quot;val3&quot;</span>);</span><br><span class="line"><span class="built_in">map</span>.<span class="keyword">get</span>(<span class="number">3</span>);             <span class="comment">// val33</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>.remove(<span class="number">3</span>, <span class="string">&quot;val33&quot;</span>);</span><br><span class="line"><span class="built_in">map</span>.<span class="keyword">get</span>(<span class="number">3</span>);             <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p>另外一个有用的方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>.getOrDefault(<span class="number">42</span>, <span class="string">&quot;not found&quot;</span>);  <span class="comment">// not found</span></span><br></pre></td></tr></table></figure>

<p>对Map的元素做合并也变得很容易了：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">map.merge(<span class="number">9</span>, <span class="string">&quot;val9&quot;</span>, (<span class="keyword">value</span>, newValue) -&gt; <span class="keyword">value</span>.concat(newValue));</span><br><span class="line">map.<span class="keyword">get</span>(<span class="number">9</span>);             <span class="comment">// val9</span></span><br><span class="line"></span><br><span class="line">map.merge(<span class="number">9</span>, <span class="string">&quot;concat&quot;</span>, (<span class="keyword">value</span>, newValue) -&gt; <span class="keyword">value</span>.concat(newValue));</span><br><span class="line">map.<span class="keyword">get</span>(<span class="number">9</span>);             <span class="comment">// val9concat</span></span><br></pre></td></tr></table></figure>

<p>Merge做的事情是如果键名不存在则插入，否则则对原键对应的值做合并操作并重新插入到map中。</p>
<h1 id="九、Date-API"><a href="#九、Date-API" class="headerlink" title="九、Date API"></a>九、Date API</h1><p>Java 8 在包java.time下包含了一组全新的时间日期API。新的日期API和开源的Joda-Time库差不多，但又不完全一样，下面的例子展示了这组新API里最重要的一些部分：</p>
<p><strong>Clock 时钟</strong></p>
<p>Clock类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代 System.currentTimeMillis() 来获取当前的微秒数。某一个特定的时间点也可以使用Instant类来表示，Instant类也可以用来创建老的java.util.Date对象。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Clock clock = Clock.systemDefaultZone();</span><br><span class="line"><span class="keyword">long</span> millis = clock.millis();</span><br><span class="line"></span><br><span class="line">Instant instant = clock.instant();</span><br><span class="line">Date legacyDate = Date.<span class="keyword">from</span>(instant);   <span class="comment">// legacy java.util.Date</span></span><br></pre></td></tr></table></figure>

<p><strong>Timezones 时区</strong></p>
<p>在新API中时区使用ZoneId来表示。时区可以很方便的使用静态方法of来获取到。 时区定义了到UTS时间的时间差，在Instant时间点对象到本地日期对象之间转换的时候是极其重要的。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">System.<span class="keyword">out</span>.println(ZoneId.getAvailableZoneIds());</span><br><span class="line"><span class="comment">// prints all available timezone ids</span></span><br><span class="line"></span><br><span class="line">ZoneId zone1 = ZoneId.of(<span class="string">&quot;Europe/Berlin&quot;</span>);</span><br><span class="line">ZoneId zone2 = ZoneId.of(<span class="string">&quot;Brazil/East&quot;</span>);</span><br><span class="line">System.<span class="keyword">out</span>.println(zone1.getRules());</span><br><span class="line">System.<span class="keyword">out</span>.println(zone2.getRules());</span><br><span class="line"></span><br><span class="line"><span class="comment">// ZoneRules[currentStandardOffset=+01:00]</span></span><br><span class="line"><span class="comment">// ZoneRules[currentStandardOffset=-03:00]</span></span><br></pre></td></tr></table></figure>

<p><strong>LocalTime 本地时间</strong></p>
<p>LocalTime 定义了一个没有时区信息的时间，例如 晚上10点，或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">LocalTime now1 = LocalTime.now(zone1);</span><br><span class="line">LocalTime now2 = LocalTime.now(zone2);</span><br><span class="line"></span><br><span class="line">System.<span class="keyword">out</span>.println(now1.isBefore(now2));  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> hoursBetween = ChronoUnit.HOURS.between(now1, now2);</span><br><span class="line"><span class="keyword">long</span> minutesBetween = ChronoUnit.MINUTES.between(now1, now2);</span><br><span class="line"></span><br><span class="line">System.<span class="keyword">out</span>.println(hoursBetween);       <span class="comment">// -3</span></span><br><span class="line">System.<span class="keyword">out</span>.println(minutesBetween);     <span class="comment">// -239</span></span><br></pre></td></tr></table></figure>

<p>LocalTime 提供了多种工厂方法来简化对象的创建，包括解析时间字符串。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">LocalTime late = LocalTime.of(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>);</span><br><span class="line">System.<span class="keyword">out</span>.println(late);       <span class="comment">// 23:59:59</span></span><br><span class="line"></span><br><span class="line">DateTimeFormatter germanFormatter =</span><br><span class="line">    DateTimeFormatter</span><br><span class="line">        .ofLocalizedTime(FormatStyle.SHORT)</span><br><span class="line">        .withLocale(Locale.GERMAN);</span><br><span class="line"></span><br><span class="line">LocalTime leetTime = LocalTime.parse(<span class="string">&quot;13:37&quot;</span>, germanFormatter);</span><br><span class="line">System.<span class="keyword">out</span>.println(leetTime);   <span class="comment">// 13:37</span></span><br></pre></td></tr></table></figure>

<p><strong>LocalDate 本地日期</strong></p>
<p>LocalDate 表示了一个确切的日期，比如 2014-03-11。该对象值是不可变的，用起来和LocalTime基本一致。下面的例子展示了如何给Date对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line">LocalDate tomorrow = today.plus(<span class="number">1</span>, ChronoUnit.DAYS);</span><br><span class="line">LocalDate yesterday = tomorrow.minusDays(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">LocalDate independenceDay = LocalDate.of(<span class="number">2014</span>, Month.JULY, <span class="number">4</span>);</span><br><span class="line">DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();</span><br><span class="line"></span><br><span class="line">System.<span class="keyword">out</span>.println(dayOfWeek);    <span class="comment">// FRIDAY</span></span><br></pre></td></tr></table></figure>

<p>从字符串解析一个LocalDate类型和解析LocalTime一样简单：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">DateTimeFormatter germanFormatter =</span><br><span class="line">    DateTimeFormatter</span><br><span class="line">        .ofLocalizedDate(FormatStyle.MEDIUM)</span><br><span class="line">        .withLocale(Locale.GERMAN);</span><br><span class="line"></span><br><span class="line">LocalDate xmas = LocalDate.parse(<span class="string">&quot;24.12.2014&quot;</span>, germanFormatter);</span><br><span class="line">System.<span class="keyword">out</span>.println(xmas);   <span class="comment">// 2014-12-24</span></span><br></pre></td></tr></table></figure>

<p><strong>LocalDateTime 本地日期时间</strong></p>
<p>LocalDateTime 同时表示了时间和日期，相当于前两节内容合并到一个对象上了。LocalDateTime和LocalTime还有LocalDate一样，都是不可变的。LocalDateTime提供了一些能访问具体字段的方法。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">LocalDateTime sylvester = LocalDateTime.of(<span class="number">2014</span>, Month.DECEMBER, <span class="number">31</span>, <span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>);</span><br><span class="line"></span><br><span class="line">DayOfWeek dayOfWeek = sylvester.getDayOfWeek();</span><br><span class="line">System.<span class="keyword">out</span>.println(dayOfWeek);      <span class="comment">// WEDNESDAY</span></span><br><span class="line"></span><br><span class="line">Month month = sylvester.getMonth();</span><br><span class="line">System.<span class="keyword">out</span>.println(month);          <span class="comment">// DECEMBER</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);</span><br><span class="line">System.<span class="keyword">out</span>.println(minuteOfDay);    <span class="comment">// 1439</span></span><br></pre></td></tr></table></figure>

<p>只要附加上时区信息，就可以将其转换为一个时间点Instant对象，Instant时间点对象可以很容易的转换为老式的java.util.Date。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Instant instant = sylvester</span><br><span class="line">        .atZone(ZoneId.systemDefault())</span><br><span class="line">        .toInstant();</span><br><span class="line"></span><br><span class="line">Date legacyDate = Date.<span class="keyword">from</span>(instant);</span><br><span class="line">System.<span class="keyword">out</span>.println(legacyDate);     <span class="comment">// Wed Dec 31 23:59:59 CET 2014</span></span><br></pre></td></tr></table></figure>

<p>格式化LocalDateTime和格式化时间和日期一样的，除了使用预定义好的格式外，我们也可以自己定义格式：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">DateTimeFormatter formatter =</span><br><span class="line">    DateTimeFormatter</span><br><span class="line">        .ofPattern(<span class="string">&quot;MMM dd, yyyy - HH:mm&quot;</span>);</span><br><span class="line"></span><br><span class="line">LocalDateTime parsed = LocalDateTime.parse(<span class="string">&quot;Nov 03, 2014 - 07:13&quot;</span>, formatter);</span><br><span class="line">String <span class="keyword">string</span> = formatter.format(parsed);</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="keyword">string</span>);     <span class="comment">// Nov 03, 2014 - 07:13</span></span><br></pre></td></tr></table></figure>

<p>和java.text.NumberFormat不一样的是新版的DateTimeFormatter是不可变的，所以它是线程安全的。<br>关于时间日期格式的详细信息：<a href="https://links.jianshu.com/go?to=http://download.java.net/jdk8/docs/api/java/time/format/DateTimeFormatter.html">http://download.java.net/jdk8/docs/api/java/time/format/DateTimeFormatter.html</a></p>
<h1 id="十、Annotation-注解"><a href="#十、Annotation-注解" class="headerlink" title="十、Annotation 注解"></a>十、Annotation 注解</h1><p>在Java 8中支持多重注解了，先看个例子来理解一下是什么意思。<br>首先定义一个包装类Hints注解用来放置一组具体的Hint注解：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@interface</span> Hints &#123;</span><br><span class="line">    <span class="selector-tag">Hint</span><span class="selector-attr">[]</span> <span class="selector-tag">value</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@Repeatable</span>(Hints.class)</span><br><span class="line"><span class="keyword">@interface</span> Hint &#123;</span><br><span class="line">    <span class="selector-tag">String</span> <span class="selector-tag">value</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 8允许我们把同一个类型的注解使用多次，只需要给该注解标注一下@Repeatable即可。</p>
<p>例 1: 使用包装类当容器来存多个注解（老方法）</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Hints(&#123;@Hint(<span class="meta-string">&quot;hint1&quot;</span>)</span>, <span class="meta">@Hint(<span class="meta-string">&quot;hint2&quot;</span>)</span>&#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>例 2：使用多重注解（新方法）</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Hint(<span class="meta-string">&quot;hint1&quot;</span>)</span></span><br><span class="line"><span class="meta">@Hint(<span class="meta-string">&quot;hint2&quot;</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>第二个例子里java编译器会隐性的帮你定义好@Hints注解，了解这一点有助于你用反射来获取这些信息：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Hint hint = Person.<span class="keyword">class</span>.getAnnotation(Hint.<span class="keyword">class</span>);</span><br><span class="line">System.<span class="keyword">out</span>.println(hint);                   <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line">Hints hints1 = Person.<span class="keyword">class</span>.getAnnotation(Hints.<span class="keyword">class</span>);</span><br><span class="line">System.<span class="keyword">out</span>.println(hints1.value().length);  <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">Hint[] hints2 = Person.<span class="keyword">class</span>.getAnnotationsByType(Hint.<span class="keyword">class</span>);</span><br><span class="line">System.<span class="keyword">out</span>.println(hints2.length);          <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>即便我们没有在Person类上定义@Hints注解，我们还是可以通过 getAnnotation(Hints.class) 来获取 @Hints注解，更加方便的方法是使用 getAnnotationsByType 可以直接获取到所有的@Hint注解。<br>另外Java 8的注解还增加到两种新的target上了：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@Target</span>(&#123;<span class="selector-tag">ElementType</span><span class="selector-class">.TYPE_PARAMETER</span>, <span class="selector-tag">ElementType</span><span class="selector-class">.TYPE_USE</span>&#125;)</span><br><span class="line"><span class="keyword">@interface</span> MyAnnotation &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>关于Java 8的新特性就写到这了，肯定还有更多的特性等待发掘。JDK 1.8里还有很多很有用的东西，比如Arrays.parallelSort, StampedLock和CompletableFuture等等。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring、SpringMVC、MyBatis用到的设计模式</title>
    <url>/2020/11/04/Spring%E3%80%81SpringMvc%E3%80%81MyBatis%E7%94%A8%E5%88%B0%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><ul>
<li>工厂模式：<br>  　　Spring使用工厂模式可以通过 BeanFactory 或 ApplicationContext 创建 bean 对象。<br>  　　BeanFactory ：延迟注入(getBean的时候才会注入),相比于BeanFactory来说会占用更<br>  　　少的内存，程序启动速度更快。<br>  　　ApplicationContext ：容器启动的时候，不管你用没用到，一次性创建所有 bean 。</li>
<li>单例模式：<br>  　　Spring 中 bean 的默认作用域就是 singleton(单例)的。 注解：@Scope(value = “singleton”)</li>
<li>代理模式：<br>  　　AOP中：JDK,CGLIB两种动态代理，</li>
<li>模板模式：<br>  　　jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类</li>
<li>装饰器模式wrapper：</li>
</ul>
<p>​         我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</p>
<ul>
<li>适配器模式 :Spring AOP 的增强或通知(Advice)使用到了适配器模式，与之相关的接口是<code>AdvisorAdapter</code>，Spring预定义的通知要通过对应的适配器，适配成 MethodInterceptor接口(方法拦截器)类型的对象。 spring MVC <code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code>，解析请求对应的 <code>Handler</code>。解析到对应的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器）后，开始由<code>HandlerAdapter</code> 适配器处理。<code>HandlerAdapter</code> 作为期望接口，具体的适配器实现类用于对目标类进行适配，<code>Controller</code> 作为需要适配的类。</li>
<li>观察者模式: Spring 事件驱动模型就是观察者模式很经典的一个应用。</li>
</ul>
<p>观察者模式：</p>
<p>　　　　是一种对象行为型模式。它表示的是一种对象与对象之间具有依赖关系，当一个对象发生改变的时候，这个对象所依赖的对象也会做出反应。Spring 事件驱动模型就是观察者模式很经典的一个应用。Spring 事件驱动模型非常有用，在很多场景都可以解耦我们的代码。比如我们每次添加商品的时候都需要重新更新商品索引，这个时候就可以利用观察者模式来解决这个问题。</p>
<p>　　Spring事件流程：</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line">定义一个事件: 实现一个继承自 <span class="variable">ApplicationEvent</span>，并且写相应的构造函数；</span><br><span class="line"></span><br><span class="line">定义一个事件监听者：实现 <span class="variable">ApplicationListener</span> 接口，重写 <span class="function"><span class="title">onApplicationEvent</span>() 方法；</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">使用事件发布者发布消息: 可以通过 <span class="variable">ApplicationEventPublisher</span> 的 <span class="title">publishEvent</span>() 方法发布消息。</span></span><br></pre></td></tr></table></figure>



<p><strong>Spring AOP 和 AspectJ AOP 有什么区别?</strong><br>　　Sprin.g AOP 属于运行时增强，而 AspectJ 是编译时增强。 Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p>
<p>　　Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。</p>
<p>　　</p>
<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><ul>
<li><p><strong>责任链模式：</strong>DispatcherServlet这个核心类中使用到了HandlerExecutionChain这个类，他就是责任链模式实行的具体类。</p>
</li>
<li><p><strong>组合模式：</strong>DelegatingWebMvcConfiguration类</p>
</li>
<li><p><strong>适配器模式：</strong>HandlerAdapter</p>
</li>
<li><p><strong>接口策略模式：</strong>DispatchServlet中的初始化组件中，用到了getDefaultStrategies方法，来决定不同组件的默认类型以实现组件的初始化操作。</p>
</li>
<li><p><strong>建造者模式：</strong>springMVC在构建UriComponents的内容时，就用到了建造者模式</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201104093309.png" alt="img"></p>
<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><p>首先看MyBatis执行流程：</p>
<p>（1）首先，SqlSessionFactoryBuilder 去读取 mybatis 的配置文件，然后 build 一个 DefaultSqlSessionFactory。</p>
<p>（2）当我们获取到 SqlSessionFactory 之后，就可以通过 SqlSessionFactory 去获取 SqlSession 对象</p>
<p>（3）拿到 SqlSession 对象以后就可以调用 SqlSession 中一系列的 select…, insert…, update…, delete…方法轻松自如的</p>
<p>进行 CRUD 操作了。</p>
<ul>
<li><strong>Builder模式</strong>，例如SqlSessionFactoryBuilder（加载mybatis配置文件时创建SqlSessionFactory）、XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuilder、CacheBuilder（在mybatis初始化mapper映射文件的过程中，为<cache>节点创建Cache对象）；</li>
<li><strong>工厂模式</strong>，例如SqlSessionFactory、ObjectFactory、MapperProxyFactory；</li>
<li><strong>单例模式</strong>，例如ErrorContext和LogFactory；</li>
<li><strong>代理模式</strong>，Mybatis实现的核心，比如MapperProxy、ConnectionLogger，用的jdk的动态代理；还有executor.loader包使用了cglib或者javassist达到延迟加载的效果；</li>
<li><strong>组合模式</strong>，例如SqlNode和各个子类ChooseSqlNode等；</li>
<li><strong>模板方法模式</strong>，例如BaseExecutor和SimpleExecutor，还有BaseTypeHandler和所有的子类例如IntegerTypeHandler；</li>
<li><strong>适配器模式</strong>，例如Log的Mybatis接口和它对jdbc、log4j等各种日志框架的适配实现；</li>
<li><strong>装饰者模式</strong>，Cache接口的实现有多个，但是大部分都是装饰器，只有PerpetualCache提供了Cache接口的基本实现，其他的装饰器都是在PerpetualCache的基础上提供了一些额外的功能，通过各种组合后满足一个特定的需求。；</li>
<li><strong>迭代器模式</strong>，例如迭代器模式PropertyTokenizer；</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>0496. 下一个更大元素 I</title>
    <url>/2020/11/10/0496.%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%20I/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/next-greater-element-i/">https://leetcode-cn.com/problems/next-greater-element-i/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums2.length; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; nums2[i] &gt; stack.peek())&#123;</span><br><span class="line">                map.put(stack.pop(), nums2[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            map.put(stack.pop(), -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.length; i++)&#123;</span><br><span class="line">            res[i] = map.get(nums1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(M+N)，其中 M 和 N 分别是数组 nums1 和 nums2 的长度。</li>
<li>空间复杂度：O(N)。我们在遍历 nums2 时，需要使用栈，以及哈希映射用来临时存储答案。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer49.丑数</title>
    <url>/2020/11/10/%E5%89%91%E6%8C%87Offer49.%E4%B8%91%E6%95%B0/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/chou-shu-lcof">https://leetcode-cn.com/problems/chou-shu-lcof</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmpa = dp[a] * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> tmpb = dp[b] * <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">int</span> tmpc = dp[c] * <span class="number">5</span>;</span><br><span class="line">            dp[i] = Math.min(tmpa, Math.min(tmpb, tmpc));</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == tmpa)   a++;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == tmpb)   b++;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == tmpc)   c++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度 O(N) ： 其中 N=n ，动态规划需遍历计算 dp 列表。</p>
</li>
<li><p>空间复杂度 O(N) ： 长度为 N 的 dp 列表使用 O(N) 的额外空间。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer50.第一个只出现一次的字符</title>
    <url>/2020/11/10/%E5%89%91%E6%8C%87Offer50.%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Character, Boolean&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] c = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch : c)&#123;</span><br><span class="line">            map.put(ch, !map.containsKey(ch));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch : c)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(ch))&#123;</span><br><span class="line">                <span class="keyword">return</span> ch;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度 O(N) ： NN 为字符串 s 的长度；需遍历 s 两轮，使用 O(N) ；HashMap 查找操作的复杂度为 O(1) ；</p>
</li>
<li><p>空间复杂度 O(1) ： 由于题目指出 s 只包含小写字母，因此最多有 26 个不同字符，HashMap 存储需占用 O(26)=O(1) 的额外空间。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 53 - I. 在排序数组中查找数字 I</title>
    <url>/2020/11/10/%E5%89%91%E6%8C%87Offer53-1.%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, target) - helper(nums, target - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m] &lt;= target)&#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度 O(log N) ：二分法为对数级别复杂度。</li>
<li>空间复杂度 O(1) ： 几个变量使用常数大小的额外空间。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 53 - II. 0～n-1中缺失的数字</title>
    <url>/2020/11/10/%E5%89%91%E6%8C%87Offer53-2.%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/">https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m] == m)&#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度 O(log N) ：二分法为对数级别复杂度。</li>
<li>空间复杂度 O(1) ： 几个变量使用常数大小的额外空间。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer52.两个链表的第一个公共节点.md</title>
    <url>/2020/11/10/%E5%89%91%E6%8C%87Offer52.%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode tempA = headA;</span><br><span class="line">        ListNode tempB = headB;</span><br><span class="line">        <span class="keyword">while</span>(tempA != tempB)&#123;</span><br><span class="line">            tempA = tempA == <span class="keyword">null</span> ? headB : tempA.next;</span><br><span class="line">            tempB = tempB == <span class="keyword">null</span> ? headA : tempB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tempA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：<em>O</em>(<em>M</em>+<em>N</em>)。</li>
<li>空间复杂度：O(1)。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>ListNode</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2020/11/05/JAVA/</url>
    <content><![CDATA[<h1 id="Java语法"><a href="#Java语法" class="headerlink" title="Java语法"></a>Java语法</h1><h2 id="Java特点"><a href="#Java特点" class="headerlink" title="Java特点"></a>Java特点</h2><ul>
<li><strong>面向对象：</strong><ul>
<li>类：类是现实世界在计算机中的反映，它将数据和对这些数据的操作封装在一起。</li>
<li>对象：类的实例。</li>
<li>抽象：在定义一个类的时候，实际上就是把一类事物的公有的属性和行为提取出来，形成一个物理模型，这种研究问题的方法称为抽象。</li>
<li>封装：把对象的属性和行为（数据）结合为一个独立的整体，并尽可能隐藏对象的内部实现细节。<ul>
<li>1、通过隐藏对象的属性来保护对象的内部状态</li>
<li>2、提高代码的可用性和可维护性</li>
<li>3、禁止对象之间的不良交互来提高模块化</li>
</ul>
</li>
<li>继承：继承是从已有的类中派生出新的类称为子类，子类继承父类的数据属性和行为，并能根据自己的需求扩展出新的行为，提高了代码的复用性。</li>
<li>多态：指允许不同的对象对同一消息做出相应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式（发送消息就是函数调用）。<ul>
<li>多态存在的三个必要条件<ul>
<li>继承</li>
<li>重写</li>
<li>父类引用指向子类对象</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>健壮性：</strong>吸收C/C++语言的优点，去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等），提供了一个相对安全的内存管理和访问机制。</li>
<li><strong>跨平台性：</strong>通过Java语言编写的应用程序在不同的系统平台上都可以运行【JVM】</li>
</ul>
<h2 id="JDK，-JRE和JVM的区别"><a href="#JDK，-JRE和JVM的区别" class="headerlink" title="JDK， JRE和JVM的区别"></a>JDK， JRE和JVM的区别</h2><ul>
<li>JDK（Java Development Kid，Java 开发开源工具包），是针对 Java 开发人员的产品，是整个 Java 的核心，包括了 Java 运行环境 JRE、Java 工具和 Java 基础类库。</li>
<li>JRE（Java Runtime Environment，Java 运行环境）是运行 JAVA 程序所必须的环境的集合，包含 JVM 标准实现及 Java 核心类库。</li>
<li>JVM（Java Virtual Machine，Java 虚拟机）是整个 Java 实现跨平台的最核心的部分，能够运行以 Java 语言写作的软件程序。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018090519.png"></p>
<h2 id="Java基本数据类型"><a href="#Java基本数据类型" class="headerlink" title="Java基本数据类型"></a>Java基本数据类型</h2><p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018095519.png" alt="image-20201018095515731"></p>
<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><ul>
<li><p>让基本类型也具有对象的特征</p>
</li>
<li><p><strong>装箱</strong>：由基本数据类型构造出一个包装类的对象。</p>
</li>
<li><p><strong>拆箱</strong>：由一个包装类对象转换到相应的基本数据类型。</p>
</li>
</ul>
<h3 id="基本类型和包装类的区别"><a href="#基本类型和包装类的区别" class="headerlink" title="基本类型和包装类的区别"></a>基本类型和包装类的区别</h3><ol>
<li>声明方式不同：基本类型不使用new关键字，而包装类型需要使用new关键字来在<strong>堆中分配存储空间</strong>；</li>
<li>存储方式及位置不同：基本类型是直接将变量值存储在栈中，而包装类型是将对象放在堆中，然后通过引用来使用；</li>
<li>初始值不同：基本类型的初始值如int为0，boolean为false，而包装类型的初始值为null；</li>
<li>使用方式不同：基本类型直接赋值直接使用就好，而包装类型在集合如Collection、Map时会使用到。</li>
</ol>
<h2 id="“-”-和-equals-的区别"><a href="#“-”-和-equals-的区别" class="headerlink" title="“==” 和 equals() 的区别"></a>“==” 和 equals() 的区别</h2><ul>
<li>对于基本数据类型的变量，只能使用 == 判断值是否相等，不能使用equals();</li>
<li>对于引用数据类型，<ul>
<li>如果没有对 equals() 进行重写，== 和equals() 比较的都是引用类型的变量所指向的对象的地址；</li>
<li>诸如String、Date等类对equals方法进行了重写的话，equals() 比较的是所指向的对象的内容。</li>
</ul>
</li>
</ul>
<h2 id="equals-与-hashcode-的区别"><a href="#equals-与-hashcode-的区别" class="headerlink" title="equals() 与 hashcode() 的区别"></a>equals() 与 hashcode() 的区别</h2><ul>
<li>equals()相等的两个对象他们的hashCode()肯定相等。</li>
<li>hashCode()相等的两个对象他们的equals()不一定相等。</li>
</ul>
<h2 id="String、StringBuilder、StringBuffer的区别"><a href="#String、StringBuilder、StringBuffer的区别" class="headerlink" title="String、StringBuilder、StringBuffer的区别"></a>String、StringBuilder、StringBuffer的区别</h2><table>
<thead>
<tr>
<th>String</th>
<th>StringBuffer</th>
<th>StringBuilder</th>
</tr>
</thead>
<tbody><tr>
<td>String的值是不可变的，这就导致每次对String的操作都会生成新的String对象，不仅效率低下，而且浪费大量优先的内存空间</td>
<td>StringBuffer是可变类，和线程安全的字符串操作类，任何对它指向的字符串的操作都不会产生新的对象。每个StringBuffer对象都有一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会自动增加容量</td>
<td>可变类，速度更快</td>
</tr>
<tr>
<td>不可变</td>
<td>可变</td>
<td>可变</td>
</tr>
<tr>
<td></td>
<td>线程安全</td>
<td>线程不安全</td>
</tr>
</tbody></table>
<h2 id="String-s-“hello”和String-s-new-String-“hello”-区别"><a href="#String-s-“hello”和String-s-new-String-“hello”-区别" class="headerlink" title="String s = “hello”和String s = new String(“hello”);区别"></a>String s = “hello”和String s = new String(“hello”);区别</h2><ul>
<li><p><code>String s = &quot;hello&quot;</code>，JVM会直接检查字符串常量池是否已有”hello”字符串对象，如没有，就分配一个内存存放”hello”，如果有，则直接将字符串常量池中的地址返回给栈。(没有new，没有堆的操作)</p>
</li>
<li><p><code>String s = new String(&quot;hello&quot;);</code>可能创建两个对象也可能创建一个对象。如果常量池中有<code>hello</code>字符串常量的话，则仅仅在堆中创建一个对象。如果常量池中没有<code>hello</code>对象，则堆上和常量池都需要创建。</p>
</li>
</ul>
<h2 id="static和final区别"><a href="#static和final区别" class="headerlink" title="static和final区别"></a>static和final区别</h2><table>
<thead>
<tr>
<th align="left">关键词</th>
<th align="left">修饰物</th>
<th align="left">影响</th>
</tr>
</thead>
<tbody><tr>
<td align="left">final</td>
<td align="left">变量</td>
<td align="left">分配到常量池中，程序不可改变其值（引用变量不能变，引用对象可以变）</td>
</tr>
<tr>
<td align="left">final</td>
<td align="left">方法</td>
<td align="left">子类中将不能被重写</td>
</tr>
<tr>
<td align="left">final</td>
<td align="left">类</td>
<td align="left">不能被继承</td>
</tr>
<tr>
<td align="left">static</td>
<td align="left">变量</td>
<td align="left">分配在内存堆上，引用都会指向这一个地址而不会重新分配内存</td>
</tr>
<tr>
<td align="left">static</td>
<td align="left">方法块</td>
<td align="left">虚拟机优先加载</td>
</tr>
<tr>
<td align="left">static</td>
<td align="left">类</td>
<td align="left">可以直接通过类来调用而不需要new</td>
</tr>
</tbody></table>
<h2 id="引用类型是占用几个字节？"><a href="#引用类型是占用几个字节？" class="headerlink" title="引用类型是占用几个字节？"></a>引用类型是占用几个字节？</h2><p>hotspot在64位平台上，占8个字节，在32位平台上占4个字节。</p>
<h3 id="java中的-switch-e-选择结构可以使用数据类型的数据-JDK1-8"><a href="#java中的-switch-e-选择结构可以使用数据类型的数据-JDK1-8" class="headerlink" title="java中的 switch(e) 选择结构可以使用数据类型的数据(JDK1.8)"></a>java中的 switch(e) 选择结构可以使用数据类型的数据(JDK1.8)</h3><ul>
<li><p>在switch（e）中，e只能是一个整数表达式或者枚举常量（更大字体），整数表达式可以是int基本类型或Integer包装类型，由于byte,short,char都可以隐含转换为int，所以，这些类型以及这些类型的包装类型也是可以的。显然，boolean、double和long类型都不符合switch的语法规定，并且不能被隐式转换成int类型，所以，它们不能作用于swtich语句中。</p>
</li>
<li><p>1.7后支持String。</p>
</li>
<li><p>基本类型中，没有<code>boolean</code>和<code>浮点类型</code>+<code>长类型long</code>及其相应的包装类型。外加<code>String</code>和<code>enum</code>。</p>
</li>
</ul>
<h2 id="标识符的构成规则"><a href="#标识符的构成规则" class="headerlink" title="标识符的构成规则"></a>标识符的构成规则</h2><ul>
<li>标识符由数字（0<del>9）和字母（A</del>Z 和 a~z）、美元符号（$）和下划线（_）组合构成。</li>
<li>标识符不能使用数字作为第一个字符。</li>
<li>标识符不能是java的关键字和保留字，但可以包含关键字和保留字，不能包含空格</li>
<li>标识符不允许单独使用下划线作为分隔符。</li>
</ul>
<h2 id="amp-和-amp-amp-的区别"><a href="#amp-和-amp-amp-的区别" class="headerlink" title="&amp;和&amp;&amp;的区别"></a>&amp;和&amp;&amp;的区别</h2><ul>
<li>逻辑与，用&amp;连接的两个条件的最后结果计算第一个表达式为false也会计算第二个表达式</li>
<li>短路与，如果第一个表达式为false整个表达式直接为false跳过第二个判断表达式</li>
</ul>
<h2 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h2><ul>
<li><p>重载 Overload：表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）。</p>
</li>
<li><p>重写 Override：表示子类中的方法覆盖父类中的方法</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018092249.png"></p>
<h2 id="final、finally、finalize的区别"><a href="#final、finally、finalize的区别" class="headerlink" title="final、finally、finalize的区别"></a>final、finally、finalize的区别</h2><ul>
<li>final用于声明属性、方法和类，分别表示属性不可变、方法不可覆盖、类不可被继承（不能再派生出新的子类）</li>
<li>finally作为异常处理的一部分，它只能用在try/catch语句中，并且附带着一个语句块，表示这段语句最终一定被执行，经常被用在需要释放资源的情况下。</li>
<li>finalize是Object类中的一个方法，一旦垃圾回收器准备好释放对象占用的空间，将首先调用其 finalize() 方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。</li>
</ul>
<h2 id="Java修饰符"><a href="#Java修饰符" class="headerlink" title="Java修饰符"></a>Java修饰符</h2><table>
<thead>
<tr>
<th><strong>访问级别</strong></th>
<th><strong>访问控制修饰符</strong></th>
<th><strong>同类</strong></th>
<th><strong>同包</strong></th>
<th><strong>子类(不同包)</strong></th>
<th><strong>不同包(其他类)</strong></th>
</tr>
</thead>
<tbody><tr>
<td>公共</td>
<td>public</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>受保护</td>
<td>protected</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
<td>✖</td>
</tr>
<tr>
<td>默认</td>
<td>default</td>
<td>✔</td>
<td>✔</td>
<td>✖</td>
<td>✖</td>
</tr>
<tr>
<td>私有</td>
<td>private</td>
<td>✔</td>
<td>✖</td>
<td>✖</td>
<td>✖</td>
</tr>
</tbody></table>
<h2 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h2><ul>
<li><p>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</p>
</li>
<li><p>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。</p>
</li>
<li><p>抽象类是可以有静态代码块和静态方法，接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)。</p>
</li>
<li><p>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p>
</li>
</ul>
<h2 id="泛型、反射和注解"><a href="#泛型、反射和注解" class="headerlink" title="泛型、反射和注解"></a>泛型、反射和注解</h2><ul>
<li>泛型类型是通过类型参数化的泛型类或接口。数据类型是数据的参数化，而泛型就是数据类型的参数化，来解决程序的通用性设计和实现的若干问题。</li>
<li>反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</li>
<li>注解的本质就是一个继承了 Annotation 接口的接口，注解是代码里的特殊标记，这些标记可以在编译，类加载，运行时被读取，并执行相应的处理。<ul>
<li>元注解：注解的注解，分别有@Retention、 @Target、 @Document、 @Inherited和@Repeatable（JDK1.8加入）五种。</li>
<li>JDK注解：<ul>
<li>@Override 它是用来描述当前方法是一个重写的方法，在编译阶段对方法进行检查 jdk1.5中它只能描述继承中的重写，jdk1.6中它可以描述接口实现的重写,也能描述类的继承的重写  </li>
<li>@Deprecated 它是用于描述当前方法是一个过时的方法 </li>
<li>@SuppressWarnings 对程序中的警告去除。 </li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018101623.png"></p>
<h3 id="Error和Exception的区别"><a href="#Error和Exception的区别" class="headerlink" title="Error和Exception的区别"></a>Error和Exception的区别</h3><ul>
<li><p>Error，指程序中无法处理的错误，表示运行应用程序中出现了严重的错误。</p>
</li>
<li><p>Exception，程序本身可以捕获并且可以处理的异常。</p>
<ul>
<li><p>运行时异常</p>
<ul>
<li><p><strong>定义</strong>：RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。</p>
</li>
<li><p><strong>特点</strong>：Java 编译器不会检查它。也就是说，当程序中可能出现这类异常时，倘若既”没有通过throws声明抛出它”，也”没有用try-catch语句捕获它”，还是会编译通过。</p>
</li>
</ul>
</li>
<li><p>编译时异常</p>
<ul>
<li><p><strong>定义</strong>: Exception 中除 RuntimeException 及其子类之外的异常。</p>
</li>
<li><p><strong>特点</strong>: Java 编译器会检查它。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="受检异常与非受检异常"><a href="#受检异常与非受检异常" class="headerlink" title="受检异常与非受检异常"></a>受检异常与非受检异常</h3><ul>
<li><p>受检异常</p>
<ul>
<li>编译器要求必须处理的异常。正确的程序在运行过程中，经常容易出现的、符合预期的异常情况。一旦发生此类异常，就必须采用某种方式进行处理。</li>
<li><strong>除 RuntimeException 及其子类外，其他的 Exception 异常都属于受检异常</strong>。</li>
</ul>
</li>
<li><p>非受检异常</p>
<ul>
<li>编译器不会进行检查并且不要求必须处理的异常。</li>
<li><strong>该类异常包括运行时异常（RuntimeException极其子类）和错误（Error）。</strong></li>
</ul>
</li>
</ul>
<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018103150.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018103200.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018103228.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201018103300.png"></p>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><ul>
<li><p><strong>拥有资源</strong></p>
<ul>
<li>进程是资源分配的基本单位，但是线程不拥有资源（除了一点必不可少的资源），线程可以访问隶属进程的系统资源</li>
<li>如果线程也拥有资源，则切换线程就需要较大的时空开销，线程的概念就没有意义了</li>
</ul>
</li>
<li><p>调度</p>
<ul>
<li>传统操作系统中拥有资源和独立调度的基本单位都是进程</li>
<li>引入线程后，线程是独立调度的基本单位，进程是拥有资源的基本单位</li>
<li>在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</li>
</ul>
</li>
<li><p><strong>系统开销</strong></p>
<ul>
<li>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。</li>
<li>类似地，在进行<strong>进程切换时</strong>，涉及当前<strong>执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置（即，Context）</strong>，而<strong>线程切换时</strong>只需<strong>保存和设置少量寄存器内容</strong>，开销很小</li>
<li>同一个进程内的多个线程共享进程的地址空间，因此这些线程间同步与通信非常容易，甚至无须操作系统的干预</li>
</ul>
</li>
<li><p>并发性：</p>
<ul>
<li>引入线程后，不仅进程间可以并发执行，而且多个线程之间也可以并发执行，提高了并发性和吞吐量</li>
</ul>
</li>
</ul>
<h2 id="进程状态的切换"><a href="#进程状态的切换" class="headerlink" title="进程状态的切换"></a>进程状态的切换</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1599655539465-7c6412b9-cf1c-41eb-98c2-631439893c16.png" alt="image.png"></p>
<ul>
<li>就绪状态（ready）：进程获取了除处理器以外的一切所需资源，等待被调度，多个处于就绪状态的进程拍成就绪队列</li>
<li>运行状态（running）：进程正在处理器上运行</li>
<li>阻塞状态（waiting）：等待某资源为可用</li>
<li>创建态（created）：进程正在被创建，尚未转到就绪态</li>
<li>结束态（terminated）：进程正从系统消失，可能是进程正常结束或其他原因中断退出运行</li>
</ul>
<p>应该注意以下内容：</p>
<ul>
<li>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li>
<li>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</li>
</ul>
<h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><h3 id="1-批处理系统"><a href="#1-批处理系统" class="headerlink" title="1. 批处理系统"></a>1. 批处理系统</h3><ul>
<li>批处理系统在很老的计算机时使用，没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）</li>
</ul>
<p><strong>1.1 先来先服务 first-come first-serverd（FCFS）</strong></p>
<ul>
<li>非抢占式的调度算法，按照请求的顺序进行调度</li>
<li><strong>有利于长作业，但不利于短作业</strong>，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长</li>
</ul>
<p><strong>1.2 短作业优先 shortest job first（SJF）</strong></p>
<ul>
<li>非抢占式的调度算法，按估计运行时间最短的顺序进行调度</li>
<li><strong>长作业有可能会饿死</strong>，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度</li>
</ul>
<p><strong>1.3 高响应比优先</strong> </p>
<ul>
<li>高响应比优先调度算法是FCFS和SJF的综合平衡，每次进行作业调度时，先计算后备作业队列中每个作业的响应比，从中选出响应比最高的作业投入运行</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1599725265351-ac1b4730-41f4-45af-ab73-a8e3bf6ae880.png" alt="image.png"></li>
<li>要求服务时间短，响应比高，有利于短作业</li>
<li>等待时间长，响应比高，不会出现长作业饿死的情况</li>
</ul>
<h3 id="2-交互式系统"><a href="#2-交互式系统" class="headerlink" title="2. 交互式系统"></a>2. 交互式系统</h3><p><strong>2.1 时间片轮转</strong></p>
<p><strong>2.2 优先级调度</strong></p>
<p><strong>2.3 多级反馈队列</strong></p>
<ul>
<li>多级队列是为这种需要连续执行多个时间片的进程考虑，<strong>设置了多个队列，每个队列时间片大小都不同</strong>，例如 1,2,4,8,..。<strong>进程在第一个队列没执行完，就会被移到下一个队列</strong>。这种方式下，之前的进程只需要交换 7 次</li>
<li><strong>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列中的进程</strong></li>
<li>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合</li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁、饥饿、死循环的区别"><a href="#死锁、饥饿、死循环的区别" class="headerlink" title="死锁、饥饿、死循环的区别"></a>死锁、饥饿、死循环的区别</h3><ul>
<li><p>死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。至少有两个进程或以上同时发生死锁。</p>
</li>
<li><p>饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。</p>
</li>
<li><p>死循环：某进程执行过程中一直跳不出某个循环的现象。</p>
</li>
</ul>
<h3 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h3><ul>
<li>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁（如哲学家的筷子、打印机设备）。</li>
<li>不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</li>
<li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。（有了一个，还想要另一个，但是自己原来那个不放手。）</li>
<li>循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</li>
</ul>
<h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><p>用Available向量表示系统当前的可用资源数。</p>
<p>试分配：</p>
<p>在某一时刻，进程提出资源申请，系统首先检查申请的资源数是否超过进程的最大需求量。</p>
<p>不超过，则检查是否超过当前可用的资源数。</p>
<p>如果都不超过，则试着分配给该进程。</p>
<p>然后用安全性算法检查此次分配是否会导致系统进入不安全状态。</p>
<p>安全性算法简单理解：系统当前剩余的资源数超过了某个进程的Need向量，就把该进程加入安全序列，并将Allocation添加到Available，不断循环此过程，看最终能否让所有进程都加入安全序列，如果可以，此次分配时安全的，系统开始分配。</p>
<p>注意：处于安全状态一定不会死锁，死锁一定处于不安全状态，处于不安全状态不一定会死锁。</p>
<h2 id="分页与分段的比较"><a href="#分页与分段的比较" class="headerlink" title="分页与分段的比较"></a>分页与分段的比较</h2><ul>
<li>对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段</li>
<li>地址空间的维度：分页是一维地址空间，分段是二维的</li>
<li>大小是否可以改变：页的大小不可变，段的大小可以动态改变</li>
<li>出现的原因：<strong>分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护</strong></li>
</ul>
<h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><p><strong>页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）</strong></p>
<ol>
<li><strong>最佳（OPT, Optimal replacement algorithm）</strong></li>
</ol>
<ul>
<li>所<strong>选择的被换出的页面在未来最长时间内不再被访问</strong>，通常可以保证获得最低的缺页率。</li>
<li>是一种<strong>理论上的算法</strong>，因为无法知道一个页面多长时间不再被访问。</li>
</ul>
<ol start="2">
<li><p><strong>最近最久未使用（LRU, Least Recently Used）</strong></p>
</li>
<li><p><strong>最近未使用（NRU, Not Recently Used）</strong></p>
</li>
</ol>
<ul>
<li><p>每个页面都有两个状态位：R 与 M，<strong>当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1</strong>。其中 R 位会定时被清零。可以将页面分成以下四类：</p>
</li>
<li><ul>
<li><p>R=0，M=0 </p>
<pre><code>- R=0，M=1
- R=1，M=0
- R=1，M=1</code></pre>
</li>
</ul>
</li>
<li><p>当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。</p>
</li>
<li><p><strong>NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）</strong>。</p>
</li>
</ul>
<ol start="4">
<li><strong>先进先出（FIFO, First In First Out）</strong></li>
</ol>
<ul>
<li>选择换出的页面是最先进入的页面。<ul>
<li><strong>该算法会将那些经常被访问的页面换出，导致缺页率升高</strong>。</li>
</ul>
</li>
</ul>
<ol start="5">
<li><strong>第二次机会算法</strong></li>
</ol>
<ul>
<li><strong>FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：</strong><ul>
<li><strong>当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。</strong></li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1597061941454-03800959-859a-4877-abfd-27c39e401945.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image.png"></li>
</ul>
</li>
</ul>
<ol start="6">
<li><strong>时钟（Clock）</strong></li>
</ol>
<ul>
<li>第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。<ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1597062565754-826091ad-7dc4-4c83-943d-343b7bd7bdac.png" alt="image.png"></li>
</ul>
</li>
</ul>
<h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><ul>
<li><p>读写一个磁盘块的时间的影响因素有：</p>
</li>
<li><ul>
<li>旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）<pre><code>- 寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）
- 实际的数据传输时间</code></pre>
</li>
</ul>
</li>
<li><p>其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p>
<ul>
<li><p>先来先服务（FCFS, First Come First Served） </p>
</li>
<li><p>最短寻道时间优先（SSTF, Shortest Seek Time First）</p>
</li>
<li><p>电梯算法（SCAN） </p>
<ul>
<li>电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</li>
<li>电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。</li>
<li>因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>0503. 下一个更大元素 II</title>
    <url>/2020/11/11/0503.%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%20II/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/next-greater-element-ii/">https://leetcode-cn.com/problems/next-greater-element-ii/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElements(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; nums[i] &gt; nums[stack.peek()])&#123;</span><br><span class="line">                res[stack.pop()] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; nums[i] &gt; nums[stack.peek()])&#123;</span><br><span class="line">                res[stack.pop()] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            res[stack.pop()] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(N)，其中 N 分别是数组 nums 的长度。</li>
<li>空间复杂度：O(N)，我们在遍历 nums 时，需要使用栈。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库调优</title>
    <url>/2020/11/12/0000.%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<h1 id="数据库调优"><a href="#数据库调优" class="headerlink" title="数据库调优"></a>数据库调优</h1><h2 id="基本优化法则"><a href="#基本优化法则" class="headerlink" title="基本优化法则"></a>基本优化法则</h2><p>​        根据当前计算机硬件的基本性能指标及其在数据库中主要操作内容，可以整理出如下图所示的性能基本优化法则：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201112095612.png" alt="1535812222155443"></p>
<p>这个优化法则归纳为5个层次：</p>
<p><strong>1、 减少数据访问（减少磁盘访问）</strong></p>
<p><strong>2、 返回更少数据（减少网络传输或磁盘访问）</strong></p>
<p><strong>3、 减少交互次数（减少网络传输）</strong></p>
<p><strong>4、 减少服务器CPU开销（减少CPU及内存开销）</strong></p>
<p><strong>5、 利用更多资源（增加资源）</strong></p>
<pre><code>    由于每一层优化法则都是解决其对应硬件的性能问题，所以带来的性能提升比例也不一样。传统数据库系统设计是也是尽可能对低速设备提供优化方法，因此针对低速设备问题的可优化手段也更多，优化成本也更低。我们任何一个SQL的性能优化都应该按这个规则由上到下来诊断问题并提出解决方案，而不应该首先想到的是增加资源解决问题。</code></pre>
<p>​    以下是每个优化法则层级对应优化效果及成本经验参考：</p>
<table>
<thead>
<tr>
<th><strong>优化法则</strong></th>
<th><strong>性能提升效果</strong></th>
<th><strong>优化成本</strong></th>
</tr>
</thead>
<tbody><tr>
<td>减少数据访问</td>
<td>1~1000</td>
<td>低</td>
</tr>
<tr>
<td>返回更少数据</td>
<td>1~100</td>
<td>低</td>
</tr>
<tr>
<td>减少交互次数</td>
<td>1~20</td>
<td>低</td>
</tr>
<tr>
<td>减少服务器CPU开销</td>
<td>1~5</td>
<td>低</td>
</tr>
<tr>
<td>利用更多资源</td>
<td>@~10</td>
<td>高</td>
</tr>
</tbody></table>
<h2 id="常用的优化手段"><a href="#常用的优化手段" class="headerlink" title="常用的优化手段"></a>常用的优化手段</h2><p><strong>a: 表的设计合理化(符合3NF)</strong></p>
<p><strong>b: 优化SQL语句（索引）</strong></p>
<p><strong>c: 分表技术(水平分割、垂直分割)、分区技术</strong></p>
<p><strong>d: 读写[写: update/delete/add]分离</strong></p>
<p><strong>e: 存储过程 [模块化编程，可以提高速度]</strong></p>
<p><strong>f: 对mysql配置优化 [配置最大并发数, 调整缓存大小 ]</strong></p>
<p><strong>g: mysql服务器硬件升级</strong></p>
<p><strong>h: 定时的去清除不需要的数据,定时进行碎片整理</strong></p>
<h3 id="1、表的设计合理化-符合3NF"><a href="#1、表的设计合理化-符合3NF" class="headerlink" title="1、表的设计合理化(符合3NF)"></a><strong>1、表的设计合理化(符合3NF)</strong></h3><ul>
<li><p>1NF（第一范式）</p>
<ul>
<li>数据库表中的所有字段值都是不可分解的原子值</li>
</ul>
</li>
<li><p>2NF（第二范式）</p>
<ul>
<li>所有的非键值字段均完全依赖于关键字段</li>
</ul>
</li>
<li><p>3NF（第三范式）</p>
<ul>
<li>一个非键值字段不能依赖于另一个非键值字段</li>
</ul>
</li>
</ul>
<blockquote>
<p>反3NF ：没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据</p>
</blockquote>
<h3 id="2、优化SQL语句"><a href="#2、优化SQL语句" class="headerlink" title="2、优化SQL语句"></a><strong>2、优化SQL语句</strong></h3><h4 id="（1）迅速的定位执行速度慢的语句"><a href="#（1）迅速的定位执行速度慢的语句" class="headerlink" title="（1）迅速的定位执行速度慢的语句"></a><strong>（1）迅速的定位执行速度慢的语句</strong></h4><ul>
<li><p>开启慢查询</p>
</li>
<li><p>设置慢查询时间</p>
</li>
<li><p>启用慢查询日志</p>
</li>
<li><p>通过mysqldumoslow工具对慢日志进行分类汇总</p>
</li>
</ul>
<h4 id="（2）分析SQL语句"><a href="#（2）分析SQL语句" class="headerlink" title="（2）分析SQL语句"></a><strong>（2）分析SQL语句</strong></h4><ul>
<li><p>通过explain分析查询 </p>
</li>
<li><p>通profiling可以得到更详细的信息</p>
</li>
</ul>
<h4 id="（3）SQL语句优化"><a href="#（3）SQL语句优化" class="headerlink" title="（3）SQL语句优化"></a>（3）SQL语句优化</h4><ul>
<li><p>创建索引(主键索引/唯一索引/全文索引/普通索引)</p>
</li>
<li><p>避免Select * (不查询多余的列与行)</p>
</li>
<li><p>Where中少用NOT、!=、&lt;&gt;、!&lt;、!&gt;、NOT EXISTS、NOT IN、NOT LIKE、OR，它们会忽略索引，引起全表扫描</p>
</li>
<li><p>用Where子句替代having子句,having只会在检索出所有记录之后才对结果集进行过滤</p>
</li>
<li><p>使用视图（经常被查询的列数据，并且这些数据不被经常的修改，删除）</p>
</li>
</ul>
<h3 id="3、分表技术、分区技术"><a href="#3、分表技术、分区技术" class="headerlink" title="3、分表技术、分区技术"></a><strong>3、分表技术、分区技术</strong></h3><h4 id="为什么要分表和分区？"><a href="#为什么要分表和分区？" class="headerlink" title="为什么要分表和分区？"></a>为什么要分表和分区？</h4><p>  如果遇到大表的情况下，SQL语句优化已经无法继续优化了，我们可以考虑分表和分区，目的就是减少数据库的负担，提高数据库的效率，通常点来讲就是提高表的增删改查效率。</p>
<p>什么是分表？</p>
<p>   分表是将一个大表按照一定的规则分解成多张具有独立存储空间的实体表，我们可以称为子表，每个表都对应三个文件，MYD数据文件，.MYI索引文件，.frm表结构文件。这些子表可以分布在同一块磁盘上，也可以在不同的机器上。app读写的时候根据事先定义好的规则得到对应的子表名，然后去操作它。</p>
<p>什么是分区？</p>
<p>​    分区和分表相似，都是按照规则分解表。不同在于分表将大表分解为若干个独立的实体表，而分区是将数据分段划分在多个位置存放，可以是同一块磁盘也可以在不同的机器。分区后，表面上还是一张表，但数据散列到多个位置了。app读写的时候操作的还是大表名字，db自动去组织分区的数据。</p>
<p>mysql分表和分区有什么联系呢？</p>
<p>（1）都能提高mysql的性能，在高并发状态下都有一个良好的表现。</p>
<p>（2）分表和分区不矛盾，可以相互配合的，对于那些大访问量，并且表数据比较多的表，我们可以采取分表和分区结合的方式，访问量不大，但是表数据很多的表，我们可以采取分区的方式等。</p>
<p>（3）分表技术是比较麻烦的，需要手动去创建子表，app服务端读写时候需要计算子表名。采用merge好一些，但也要创建子表和配置子表间的union关系。</p>
<p>（4）表分区相对于分表，操作方便，不需要创建子表。</p>
<p><strong>4、读写[写: update/delete/add]分离</strong></p>
<p>​    大型网站为了缓解大量的并发访问，除了在网站实现分布式负载均衡，远远不够。如果还是传统的数据结构，或者只是单单靠一台服务器扛，如此多的数据库连接操作，数据库必然会崩溃，数据丢失的话，后果更是不堪设想。这时候，我们会考虑如何减少数据库的联接，一方面采用优秀的代码框架，进行代码的优化，采用优秀的数据缓存技术如：memcached,如果资金丰厚的话，必然会想到架设服务器群，来分担主数据库的压力</p>
<p>​    因此，一般来说都是通过主从复制（Master-Slave）的方式来同步数据，再通过读写分离（MySQL-Proxy，是MySQL官方提供的MySQL中间件服务）来提升数据库的并发负载能力 这样的方案来进行部署与实施的</p>
<p>实现方式</p>
<p><strong>第一种：</strong>php程序上自己做逻辑判断，写php代码的时候，自己在程序上做逻辑判读写匹配。select，insert、update、delete做正则匹配，根据结果选择写服务器（主服务器）。如果是select操作则选择读服务器（从服务器器） mysql_connect(‘读写的区分’)</p>
<p><strong>第二种：</strong>MySQL中间件，基本的原理是让主数据库处理写操作（insert、update、delete），而从数据库处理查询操作（select）。而数据库的一致性则通过主从复制来实现。所以说主从复制是读写分离的基础。</p>
<p>   下面是一些常用的MySQL中间件的背景介绍</p>
<p><strong>5、**</strong>存储过程** </p>
<p>（1）为什么需要存储过程</p>
<p>   a 数据不安全，网络传送SQL代码，容易被未授权者截获</p>
<p>   b 每次提交SQL代码都要经过语法编译后在执行，影响应用程序的运行性能</p>
<p>   c 网络流量大，对于反复执行的SQL代码，在网络上多次传送，影响网络传输量</p>
<p>（2）什么是存储过程</p>
<p>​    存储过程是SQL语句和控制语句的预编译集合，保存在数据库中，可有应用程序调用执行，而且允许用户声明变量、逻辑控制语句及其他强大的编程功能。包含逻辑控制语句和数据操作语句，可以接收参数、输出参数、返回单个或多个结果值及返回值</p>
<p>（3）使用存储过程的优点</p>
<p>   a 模块化程序设计，只需创建一次，以后即可调用该存储过程任意次</p>
<p>   b 执行速度快，效率高</p>
<p>   c 减少网络流量</p>
<p>   d 具有良好的安全性</p>
<p><strong>6、对mysql配置优化</strong>  </p>
<p>  <strong>下面是一些配置的优化，具体参数的解释就不写了，请自行查找资料</strong></p>
<p><img src="https://s1.51cto.com/images/20180901/1535811137329241.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="image.png"></p>
<p><strong>7、mysql服务器硬件升级</strong></p>
<p>（1）磁盘 </p>
<p>MySQL每秒钟都在进行大量、复杂的查询操作，对磁盘的读写量可想而知。所以，通常认为磁盘I/O是制约MySQL性能的最大因素之一</p>
<p>解决方案： 使用RAID-10 、磁盘阵列设备SAN </p>
<p>（2）CPU 对于MySQL应用，推荐使用S.M.P.架构的多路对称CPU</p>
<p>（3）内存 越大越好</p>
<p>（4）网卡 至少两个网卡，均为1GBE。通常我会将这两个nics绑定在一起以提供冗余</p>
<p><strong>8、定时的去清除不需要的数据,定时进行碎片整理</strong></p>
<p>什么是磁盘碎片？</p>
<p>​    简单的说,删除数据必然会在数据文件中造成不连续的空白空间,而当插入数据时,这些空白空间则会被利用起来.于是造成了数据的存储位置不连续,以及物理存储顺序与理论上的排序顺序不同,这种是数据碎片.实际上数据碎片分为两种,一种是单行数据碎片,另一种是多行数据碎片.前者的意思就是一行数据,被分成N个片段,存储在N个位置.后者的就是多行数据并未按照逻辑上的顺序排列.</p>
<p>​    当有大量的删除和插入操作时,必然会产生很多未使用的空白空间,这些空间就是多出来的额外空间.索引也是文件数据,所以也会产生索引碎片,理由同上,大概就是顺序紊乱的问题.Engine 不同,OPTIMIZE 的操作也不一样的,MyISAM 因为索引和数据是分开的,所以 OPTIMIZE 可以整理数据文件,并重排索引。这样不但会浪费空间，并且查询速度也更慢。</p>
<p>解决方案：</p>
<p>（1）查看表碎片的方法</p>
<p>select ROW_FORMAT,TABLE_ROWS,DATA_LENGTH,INDEX_LENGTH,MAX_DATA_LENGTH,DATA_FREE,ENGINE from TABLES where TABLE_SCHEMA=’test_db’ and TABLE_NAME=’table_name’ limit 1;</p>
<p>（2）Innodb存储引擎清理碎片方法</p>
<p>ALTER TABLE tablename ENGINE=InnoDB</p>
<p>（3）Myisam存储引擎清理碎片方法</p>
<p>OPTIMIZE TABLE table_name</p>
<p>切记，一定要在夜里执行，表越大，越耗资源时间，不要频繁修复，可以几个月甚至一年修复一次，如果表频繁被更改，可以做个计划任务，按周/月来整理。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>快速理解 volatile 关键字</title>
    <url>/2020/11/23/%E5%BF%AB%E9%80%9F%E7%90%86%E8%A7%A3%20volatile%20%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h1 id="快速理解-volatile-关键字"><a href="#快速理解-volatile-关键字" class="headerlink" title="快速理解 volatile 关键字"></a>快速理解 volatile 关键字</h1><h2 id="volatile-特性"><a href="#volatile-特性" class="headerlink" title="volatile 特性"></a>volatile 特性</h2><p>在 JMM 中 volatile 的三大特性如下：</p>
<ol>
<li>保证可见性：当写一个 volatile 变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存，使其他线程立即可见。</li>
<li>保证有序性：当变量被修饰为 volatile 时，JMM 会禁止读写该变量前后语句的大部分重排序优化，以保证变量赋值操作的顺序与程序中的执行顺序一致。</li>
<li>部分原子性：对任意单个 volatile 变量的读/写具有原子性，但类似于 volatile++ 这种复合操作不具有原子性。</li>
</ol>
<h3 id="如何保证可见性"><a href="#如何保证可见性" class="headerlink" title="如何保证可见性"></a>如何保证可见性</h3><p>  volatile 变量可见性很多书上都喜欢放到 happens-before 原则中来讲：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">对一个<span class="keyword">volatile</span>域的写，happens-<span class="keyword">before</span>于任意后续对这个<span class="keyword">volatile</span>域的读。</span><br></pre></td></tr></table></figure>

<p>  其实我觉得这句话初看并不能很好的理解 volatile 的可见性，而且还会引入新的概念 happens-before 规则。换一种表述方式会容易理解的多，其在 JMM 中的写和读语义如下：</p>
<ol>
<li>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。</li>
<li>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</li>
</ol>
<p>  这就保证了 volatile 变量的可见性，也解释了 happens-before 中的 volatile 规则，而且需要注意的是：在写和读时操作的是整个工作内存中的共享变量，所以在读 volatile 变量时工作内存中的其他共享变量也是最新的。</p>
<h3 id="如何保证有序性"><a href="#如何保证有序性" class="headerlink" title="如何保证有序性"></a>如何保证有序性</h3><p>  volatile 的有序性可能比较晦涩，但是看完 JMM 针对编译器制定的 volatile 重排序规则表后就会很容易理解：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/3/30/169cc87ce4758e92?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>  由上图 1 可知，JMM 限制了大部分情况下 volatile 变量读写语句前后语句的重排序，结合图片来看看下个这个例子：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">OrderingExample</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> x = <span class="number">0</span>;</span><br><span class="line">    volatile <span class="built_in">bool</span>ean flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> writer() &#123;</span><br><span class="line">        x = <span class="number">42</span>; <span class="comment">//宇宙的终极答案</span></span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> reader() &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//x = ?</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  以上代码在并发编程前传 中讲有序性的时候也贴过，这里将 flag 定义成 volatile。如果线程 A 先执行完 writer()，线程 B 后执行到 reader() 中的 x= 的时候，x 一定等于 42（JDK 1.5 以后），原因如下：</p>
<p>  参考图 1，可以看出普通变量的写不能重排到 volatile 变量的写后面，所以便不存在有序性问题。 其他禁止重排序规则参考图 1 进行类推，整个规则让 JMM 在多线程环境下保证了 volatile 变量的有序性。在本规则中有以下两点需要注意：</p>
<ol>
<li><p>只要 volatile 变量与普通变量之间的重排序可能会破坏 volatile 的内存语义，这种重排序就会被编译器重排序规则和处理器内存屏障插入策略禁止。换句话说，如果没有破坏 volatile 的内存语义则可以重排序，参考图 1 空白格子对应的规则。</p>
</li>
<li><p>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序，细则如下：</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">在每个<span class="keyword">volatile</span>写操作的前面插入一StoreStore屏障。 </span><br><span class="line">在每个<span class="keyword">volatile</span>写操作的后面插入一个StoreLoad屏障。</span><br><span class="line">在每个<span class="keyword">volatile</span>读操作的后面插入一个LoadLoad屏障。</span><br><span class="line">在每个<span class="keyword">volatile</span>读操作的后面插入一个LoadStore屏障。</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="如何保证部分原子性"><a href="#如何保证部分原子性" class="headerlink" title="如何保证部分原子性"></a>如何保证部分原子性</h3><p>  同样拿并发编程前传中 dobule 和 long 的例子，double 和 long 变量的单个读/写在绝大部分商业虚拟机上都是原子的，但在在极端情况下并不具有原子性，而加了 volatile 后就一定能保证单个读/写原子性。这由 JMM 保证，其中底层原理有待深究，但底层应该是通过 cpu 指令来实现的。</p>
<p>  之所以说只能保证部分原子性，是因为 volatile 并不能保证 volatile 变量参与的复合语句的原子性，比如 i++; i+=1; 等这种看上去是单读和写，实质需要先读后写的语句。</p>
<h2 id="与-synchronized-的区别"><a href="#与-synchronized-的区别" class="headerlink" title="与 synchronized 的区别"></a>与 synchronized 的区别</h2><p>  由于 volatile 仅仅保证对单个 volatile 变量的读/写具有原子性，而锁的互斥执行的特性可以确保对整个临界区代码的执行具有原子性。在功能上，锁比 volatile 更强大；在可伸缩性和执行性能上，volatile 更有优势。如果读者想在程序中用volatile代替锁，请一定谨慎。即使是单个变量的语句，也只有以下三种情况下可以使用 volatile 代替锁：</p>
<ol>
<li>对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。</li>
<li>该变量不会与其他状态变量一起纳入不变性条件中。</li>
<li>在访问变量时不需要加锁。</li>
</ol>
<p>  对于 1 的前半句是指对变量的写之前不能还要去读它，比如类似 i++、i = i + 1 等语句。至于 1 的后半句类似于我们常见的一写多读模型，不存在多线程问题。</p>
<p>  对于 2 是指该变量不能与其他变量一起控制某个操作，比如 if( i &lt; j ){}，其中 i 和 j 都是共享变量，i 是 volatile 修饰的。又比如 while( i - j &gt; 2){} 等。i 与其他共享变量 j 一起参与了不变的条件控制，故存在问题。</p>
<p>  在《Java 并发编程实战》中列出了第 3 点，而《深入理解 Java 虚拟机》中直接删去了。可见对于 3 是不言而喻的。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot面试题</title>
    <url>/2020/11/12/0000.SpringBoot%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h3 id="什么是-Spring-Boot？"><a href="#什么是-Spring-Boot？" class="headerlink" title="什么是 Spring Boot？"></a>什么是 Spring Boot？</h3><p>​        Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。</p>
<h3 id="Spring-Boot-有哪些优点？"><a href="#Spring-Boot-有哪些优点？" class="headerlink" title="Spring Boot 有哪些优点？"></a>Spring Boot 有哪些优点？</h3><ol>
<li>容易上手，提升开发效率，为 Spring 开发提供一个更快、更广泛的入门体验。</li>
<li>开箱即用，远离繁琐的配置。</li>
<li>提供了一系列大型项目通用的非业务性功能，例如：内嵌服务器、安全管理、运行数据监控、运行状况检查和外部化配置等。</li>
<li>没有代码生成，也不需要XML配置。</li>
<li>避免大量的 Maven 导入和各种版本冲突。</li>
</ol>
<h3 id="Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？"><a href="#Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？" class="headerlink" title="Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？"></a>Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</h3><p>启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：</p>
<p><strong>@SpringBootConfiguration</strong>：组合了 @Configuration 注解，实现配置文件的功能。</p>
<p><strong>@EnableAutoConfiguration</strong>：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能： @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。</p>
<p><strong>@ComponentScan</strong>：Spring组件扫描。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="什么是-JavaConfig？"><a href="#什么是-JavaConfig？" class="headerlink" title="什么是 JavaConfig？"></a>什么是 JavaConfig？</h3><p>Spring JavaConfig 是 Spring 社区的产品，它提供了配置 Spring IoC 容器的纯Java 方法。因此它有助于避免使用 XML 配置。使用 JavaConfig 的优点在于：</p>
<p>（1）面向对象的配置。由于配置被定义为 JavaConfig 中的类，因此用户可以充分利用 Java 中的面向对象功能。一个配置类可以继承另一个，重写它的@Bean 方法等。</p>
<p>（2）减少或消除 XML 配置。基于依赖注入原则的外化配置的好处已被证明。但是，许多开发人员不希望在 XML 和 Java 之间来回切换。JavaConfig 为开发人员提供了一种纯 Java 方法来配置与 XML 配置概念相似的 Spring 容器。从技术角度来讲，只使用 JavaConfig 配置类来配置容器是可行的，但实际上很多人认为将JavaConfig 与 XML 混合匹配是理想的。</p>
<p>（3）类型安全和重构友好。JavaConfig 提供了一种类型安全的方法来配置 Spring容器。由于 Java 5.0 对泛型的支持，现在可以按类型而不是按名称检索 bean，不需要任何强制转换或基于字符串的查找。</p>
<h3 id="Spring-Boot-自动配置原理是什么？"><a href="#Spring-Boot-自动配置原理是什么？" class="headerlink" title="Spring Boot 自动配置原理是什么？"></a>Spring Boot 自动配置原理是什么？</h3><p>注解 @EnableAutoConfiguration, @Configuration, @ConditionalOnClass 就是自动配置的核心，</p>
<p>@EnableAutoConfiguration 给容器导入META-INF/spring.factories 里定义的自动配置类。</p>
<p>筛选有效的自动配置类。</p>
<p>每一个自动配置类结合对应的 xxxProperties.java 读取配置文件进行自动配置功能</p>
<h3 id="你如何理解-Spring-Boot-配置加载顺序？"><a href="#你如何理解-Spring-Boot-配置加载顺序？" class="headerlink" title="你如何理解 Spring Boot 配置加载顺序？"></a>你如何理解 Spring Boot 配置加载顺序？</h3><p>在 Spring Boot 里面，可以使用以下几种方式来加载配置。</p>
<p>1）properties文件；</p>
<p>2）YAML文件；</p>
<p>3）系统环境变量；</p>
<p>4）命令行参数；</p>
<p>等等……</p>
<h3 id="什么是-YAML？"><a href="#什么是-YAML？" class="headerlink" title="什么是 YAML？"></a>什么是 YAML？</h3><p>YAML 是一种人类可读的数据序列化语言。它通常用于配置文件。与属性文件相比，如果我们想要在配置文件中添加复杂的属性，YAML 文件就更加结构化，而且更少混淆。可以看出 YAML 具有分层配置数据。</p>
<h3 id="YAML-配置的优势在哪里"><a href="#YAML-配置的优势在哪里" class="headerlink" title="YAML 配置的优势在哪里 ?"></a>YAML 配置的优势在哪里 ?</h3><p>YAML 现在可以算是非常流行的一种配置文件格式了，无论是前端还是后端，都可以见到 YAML 配置。那么 YAML 配置和传统的 properties 配置相比到底有哪些优势呢？</p>
<ol>
<li>配置有序，在一些特殊的场景下，配置有序很关键</li>
<li>支持数组，数组中的元素可以是基本数据类型也可以是对象</li>
<li>简洁</li>
</ol>
<p>相比 properties 配置文件，YAML 还有一个缺点，就是不支持 @PropertySource 注解导入自定义的 YAML 配置。</p>
<h3 id="Spring-Boot-是否可以使用-XML-配置"><a href="#Spring-Boot-是否可以使用-XML-配置" class="headerlink" title="Spring Boot 是否可以使用 XML 配置 ?"></a>Spring Boot 是否可以使用 XML 配置 ?</h3><p>Spring Boot 推荐使用 Java 配置而非 XML 配置，但是 Spring Boot 中也可以使用 XML 配置，通过 @ImportResource 注解可以引入一个 XML 配置。</p>
<h3 id="spring-boot-核心配置文件是什么？bootstrap-properties-和-application-properties-有何区别"><a href="#spring-boot-核心配置文件是什么？bootstrap-properties-和-application-properties-有何区别" class="headerlink" title="spring boot 核心配置文件是什么？bootstrap.properties 和 application.properties 有何区别 ?"></a>spring boot 核心配置文件是什么？bootstrap.properties 和 application.properties 有何区别 ?</h3><p>单纯做 Spring Boot 开发，可能不太容易遇到 bootstrap.properties 配置文件，但是在结合 Spring Cloud 时，这个配置就会经常遇到了，特别是在需要加载一些远程配置文件的时侯。</p>
<p>spring boot 核心的两个配置文件：</p>
<ul>
<li>bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，配置在应用程序上下文的引导阶段生效。一般来说我们在 Spring Cloud Config 或者 Nacos 中会用到它。且 boostrap 里面的属性不能被覆盖；</li>
<li>application (. yml 或者 . properties)： 由ApplicatonContext 加载，用于 spring boot 项目的自动化配置。</li>
</ul>
<h3 id="什么是-Spring-Profiles？"><a href="#什么是-Spring-Profiles？" class="headerlink" title="什么是 Spring Profiles？"></a>什么是 Spring Profiles？</h3><p>Spring Profiles 允许用户根据配置文件（dev，test，prod 等）来注册 bean。因此，当应用程序在开发中运行时，只有某些 bean 可以加载，而在 PRODUCTION中，某些其他 bean 可以加载。假设我们的要求是 Swagger 文档仅适用于 QA 环境，并且禁用所有其他文档。这可以使用配置文件来完成。Spring Boot 使得使用配置文件非常简单。</p>
<h3 id="如何在自定义端口上运行-Spring-Boot-应用程序？"><a href="#如何在自定义端口上运行-Spring-Boot-应用程序？" class="headerlink" title="如何在自定义端口上运行 Spring Boot 应用程序？"></a>如何在自定义端口上运行 Spring Boot 应用程序？</h3><p>为了在自定义端口上运行 Spring Boot 应用程序，您可以在application.properties 中指定端口。server.port = 8090</p>
<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><h3 id="如何实现-Spring-Boot-应用程序的安全性？"><a href="#如何实现-Spring-Boot-应用程序的安全性？" class="headerlink" title="如何实现 Spring Boot 应用程序的安全性？"></a>如何实现 Spring Boot 应用程序的安全性？</h3><p>为了实现 Spring Boot 的安全性，我们使用 spring-boot-starter-security 依赖项，并且必须添加安全配置。它只需要很少的代码。配置类将必须扩展WebSecurityConfigurerAdapter 并覆盖其方法。</p>
<h3 id="比较一下-Spring-Security-和-Shiro-各自的优缺点"><a href="#比较一下-Spring-Security-和-Shiro-各自的优缺点" class="headerlink" title="比较一下 Spring Security 和 Shiro 各自的优缺点 ?"></a>比较一下 Spring Security 和 Shiro 各自的优缺点 ?</h3><p>由于 Spring Boot 官方提供了大量的非常方便的开箱即用的 Starter ，包括 Spring Security 的 Starter ，使得在 Spring Boot 中使用 Spring Security 变得更加容易，甚至只需要添加一个依赖就可以保护所有的接口，所以，如果是 Spring Boot 项目，一般选择 Spring Security 。当然这只是一个建议的组合，单纯从技术上来说，无论怎么组合，都是没有问题的。Shiro 和 Spring Security 相比，主要有如下一些特点：</p>
<ol>
<li>Spring Security 是一个重量级的安全管理框架；Shiro 则是一个轻量级的安全管理框架</li>
<li>Spring Security 概念复杂，配置繁琐；Shiro 概念简单、配置简单</li>
<li>Spring Security 功能强大；Shiro 功能简单</li>
</ol>
<h3 id="Spring-Boot-中如何解决跨域问题"><a href="#Spring-Boot-中如何解决跨域问题" class="headerlink" title="Spring Boot 中如何解决跨域问题 ?"></a>Spring Boot 中如何解决跨域问题 ?</h3><p>跨域可以在前端通过 JSONP 来解决，但是 JSONP 只可以发送 GET 请求，无法发送其他类型的请求，在 RESTful 风格的应用中，就显得非常鸡肋，因此我们推荐在后端通过 （CORS，Cross-origin resource sharing） 来解决跨域问题。这种解决方案并非 Spring Boot 特有的，在传统的 SSM 框架中，就可以通过 CORS 来解决跨域问题，只不过之前我们是在 XML 文件中配置 CORS ，现在可以通过实现WebMvcConfigurer接口然后重写addCorsMappings方法解决跨域问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                .allowedOrigins(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                .allowCredentials(<span class="keyword">true</span>)</span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>)</span><br><span class="line">                .maxAge(<span class="number">3600</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>

<p>项目中前后端分离部署，所以需要解决跨域的问题。<br>我们使用cookie存放用户登录的信息，在spring拦截器进行权限控制，当权限不符合时，直接返回给用户固定的json结果。<br>当用户登录以后，正常使用；当用户退出登录状态时或者token过期时，由于拦截器和跨域的顺序有问题，出现了跨域的现象。<br>我们知道一个http请求，先走filter，到达servlet后才进行拦截器的处理，如果我们把cors放在filter里，就可以优先于权限拦截器执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsFilter <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CorsConfiguration corsConfiguration = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">        corsConfiguration.addAllowedOrigin(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        corsConfiguration.addAllowedHeader(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        corsConfiguration.addAllowedMethod(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        corsConfiguration.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line">        UrlBasedCorsConfigurationSource urlBasedCorsConfigurationSource = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">        urlBasedCorsConfigurationSource.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, corsConfiguration);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsFilter(urlBasedCorsConfigurationSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516</span></span><br></pre></td></tr></table></figure>

<h3 id="什么是-CSRF-攻击？"><a href="#什么是-CSRF-攻击？" class="headerlink" title="什么是 CSRF 攻击？"></a>什么是 CSRF 攻击？</h3><p>CSRF 代表跨站请求伪造。这是一种攻击，迫使最终用户在当前通过身份验证的Web 应用程序上执行不需要的操作。CSRF 攻击专门针对状态改变请求，而不是数据窃取，因为攻击者无法查看对伪造请求的响应。</p>
<h2 id="监视器"><a href="#监视器" class="headerlink" title="监视器"></a>监视器</h2><h3 id="Spring-Boot-中的监视器是什么？"><a href="#Spring-Boot-中的监视器是什么？" class="headerlink" title="Spring Boot 中的监视器是什么？"></a>Spring Boot 中的监视器是什么？</h3><p>Spring boot actuator 是 spring 启动框架中的重要功能之一。Spring boot 监视器可帮助您访问生产环境中正在运行的应用程序的当前状态。有几个指标必须在生产环境中进行检查和监控。即使一些外部应用程序可能正在使用这些服务来向相关人员触发警报消息。监视器模块公开了一组可直接作为 HTTP URL 访问的REST 端点来检查状态。</p>
<h3 id="如何在-Spring-Boot-中禁用-Actuator-端点安全性？"><a href="#如何在-Spring-Boot-中禁用-Actuator-端点安全性？" class="headerlink" title="如何在 Spring Boot 中禁用 Actuator 端点安全性？"></a>如何在 Spring Boot 中禁用 Actuator 端点安全性？</h3><p>默认情况下，所有敏感的 HTTP 端点都是安全的，只有具有 ACTUATOR 角色的用户才能访问它们。安全性是使用标准的 HttpServletRequest.isUserInRole 方法实施的。 我们可以使用来禁用安全性。只有在执行机构端点在防火墙后访问时，才建议禁用安全性。</p>
<h3 id="我们如何监视所有-Spring-Boot-微服务？"><a href="#我们如何监视所有-Spring-Boot-微服务？" class="headerlink" title="我们如何监视所有 Spring Boot 微服务？"></a>我们如何监视所有 Spring Boot 微服务？</h3><p>Spring Boot 提供监视器端点以监控各个微服务的度量。这些端点对于获取有关应用程序的信息（如它们是否已启动）以及它们的组件（如数据库等）是否正常运行很有帮助。但是，使用监视器的一个主要缺点或困难是，我们必须单独打开应用程序的知识点以了解其状态或健康状况。想象一下涉及 50 个应用程序的微服务，管理员将不得不击中所有 50 个应用程序的执行终端。为了帮助我们处理这种情况，我们将使用位于的开源项目。 它建立在 Spring Boot Actuator 之上，它提供了一个 Web UI，使我们能够可视化多个应用程序的度量。</p>
<h2 id="整合第三方项目"><a href="#整合第三方项目" class="headerlink" title="整合第三方项目"></a>整合第三方项目</h2><h3 id="什么是-WebSockets？"><a href="#什么是-WebSockets？" class="headerlink" title="什么是 WebSockets？"></a>什么是 WebSockets？</h3><p>WebSocket 是一种计算机通信协议，通过单个 TCP 连接提供全双工通信信道。</p>
<p>1、WebSocket 是双向的 -使用 WebSocket 客户端或服务器可以发起消息发送。</p>
<p>2、WebSocket 是全双工的 -客户端和服务器通信是相互独立的。</p>
<p>3、单个 TCP 连接 -初始连接使用 HTTP，然后将此连接升级到基于套接字的连接。然后这个单一连接用于所有未来的通信</p>
<p>4、Light -与 http 相比，WebSocket 消息数据交换要轻得多。</p>
<h3 id="什么是-Spring-Data"><a href="#什么是-Spring-Data" class="headerlink" title="什么是 Spring Data ?"></a>什么是 Spring Data ?</h3><p>Spring Data 是 Spring 的一个子项目。用于简化数据库访问，支持NoSQL 和 关系数据存储。其主要目标是使数据库的访问变得方便快捷。Spring Data 具有如下特点：</p>
<p>SpringData 项目支持 NoSQL 存储：</p>
<ol>
<li>MongoDB （文档数据库）</li>
<li>Neo4j（图形数据库）</li>
<li>Redis（键/值存储）</li>
<li>Hbase（列族数据库）</li>
</ol>
<p>SpringData 项目所支持的关系数据存储技术：</p>
<ol>
<li>JDBC</li>
<li>JPA</li>
</ol>
<p>Spring Data Jpa 致力于减少数据访问层 (DAO) 的开发量. 开发者唯一要做的，就是声明持久层的接口，其他都交给 Spring Data JPA 来帮你完成！Spring Data JPA 通过规范方法的名字，根据符合规范的名字来确定方法需要实现什么样的逻辑。</p>
<h3 id="什么是-Spring-Batch？"><a href="#什么是-Spring-Batch？" class="headerlink" title="什么是 Spring Batch？"></a>什么是 Spring Batch？</h3><p>Spring Boot Batch 提供可重用的函数，这些函数在处理大量记录时非常重要，包括日志/跟踪，事务管理，作业处理统计信息，作业重新启动，跳过和资源管理。它还提供了更先进的技术服务和功能，通过优化和分区技术，可以实现极高批量和高性能批处理作业。简单以及复杂的大批量批处理作业可以高度可扩展的方式利用框架处理重要大量的信息。</p>
<h3 id="什么是-FreeMarker-模板？"><a href="#什么是-FreeMarker-模板？" class="headerlink" title="什么是 FreeMarker 模板？"></a>什么是 FreeMarker 模板？</h3><p>FreeMarker 是一个基于 Java 的模板引擎，最初专注于使用 MVC 软件架构进行动态网页生成。使用 Freemarker 的主要优点是表示层和业务层的完全分离。程序员可以处理应用程序代码，而设计人员可以处理 html 页面设计。最后使用freemarker 可以将这些结合起来，给出最终的输出页面。</p>
<h3 id="如何集成-Spring-Boot-和-ActiveMQ？"><a href="#如何集成-Spring-Boot-和-ActiveMQ？" class="headerlink" title="如何集成 Spring Boot 和 ActiveMQ？"></a>如何集成 Spring Boot 和 ActiveMQ？</h3><p>对于集成 Spring Boot 和 ActiveMQ，我们使用依赖关系。 它只需要很少的配置，并且不需要样板代码。</p>
<h3 id="什么是-Apache-Kafka？"><a href="#什么是-Apache-Kafka？" class="headerlink" title="什么是 Apache Kafka？"></a>什么是 Apache Kafka？</h3><p>Apache Kafka 是一个分布式发布 - 订阅消息系统。它是一个可扩展的，容错的发布 - 订阅消息系统，它使我们能够构建分布式应用程序。这是一个 Apache 顶级项目。Kafka 适合离线和在线消息消费。</p>
<h3 id="什么是-Swagger？你用-Spring-Boot-实现了它吗？"><a href="#什么是-Swagger？你用-Spring-Boot-实现了它吗？" class="headerlink" title="什么是 Swagger？你用 Spring Boot 实现了它吗？"></a>什么是 Swagger？你用 Spring Boot 实现了它吗？</h3><p>Swagger 广泛用于可视化 API，使用 Swagger UI 为前端开发人员提供在线沙箱。Swagger 是用于生成 RESTful Web 服务的可视化表示的工具，规范和完整框架实现。它使文档能够以与服务器相同的速度更新。当通过 Swagger 正确定义时，消费者可以使用最少量的实现逻辑来理解远程服务并与其进行交互。因此，Swagger消除了调用服务时的猜测。</p>
<h3 id="前后端分离，如何维护接口文档"><a href="#前后端分离，如何维护接口文档" class="headerlink" title="前后端分离，如何维护接口文档 ?"></a>前后端分离，如何维护接口文档 ?</h3><p>前后端分离开发日益流行，大部分情况下，我们都是通过 Spring Boot 做前后端分离开发，前后端分离一定会有接口文档，不然会前后端会深深陷入到扯皮中。一个比较笨的方法就是使用 word 或者 md 来维护接口文档，但是效率太低，接口一变，所有人手上的文档都得变。在 Spring Boot 中，这个问题常见的解决方案是 Swagger ，使用 Swagger 我们可以快速生成一个接口文档网站，接口一旦发生变化，文档就会自动更新，所有开发工程师访问这一个在线网站就可以获取到最新的接口文档，非常方便。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="如何重新加载-Spring-Boot-上的更改，而无需重新启动服务器？Spring-Boot项目如何热部署？"><a href="#如何重新加载-Spring-Boot-上的更改，而无需重新启动服务器？Spring-Boot项目如何热部署？" class="headerlink" title="如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？Spring Boot项目如何热部署？"></a>如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？Spring Boot项目如何热部署？</h3><p>这可以使用 DEV 工具来实现。通过这种依赖关系，您可以节省任何更改，嵌入式tomcat 将重新启动。Spring Boot 有一个开发工具（DevTools）模块，它有助于提高开发人员的生产力。Java 开发人员面临的一个主要挑战是将文件更改自动部署到服务器并自动重启服务器。开发人员可以重新加载 Spring Boot 上的更改，而无需重新启动服务器。这将消除每次手动部署更改的需要。Spring Boot 在发布它的第一个版本时没有这个功能。这是开发人员最需要的功能。DevTools 模块完全满足开发人员的需求。该模块将在生产环境中被禁用。它还提供 H2 数据库控制台以更好地测试应用程序。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">1234</span><br></pre></td></tr></table></figure>

<h3 id="您使用了哪些-starter-maven-依赖项？"><a href="#您使用了哪些-starter-maven-依赖项？" class="headerlink" title="您使用了哪些 starter maven 依赖项？"></a>您使用了哪些 starter maven 依赖项？</h3><p>使用了下面的一些依赖项</p>
<p>spring-boot-starter-activemq</p>
<p>spring-boot-starter-security</p>
<p>这有助于增加更少的依赖关系，并减少版本的冲突。</p>
<h3 id="Spring-Boot-中的-starter-到底是什么"><a href="#Spring-Boot-中的-starter-到底是什么" class="headerlink" title="Spring Boot 中的 starter 到底是什么 ?"></a>Spring Boot 中的 starter 到底是什么 ?</h3><p>首先，这个 Starter 并非什么新的技术点，基本上还是基于 Spring 已有功能来实现的。首先它提供了一个自动化配置类，一般命名为 <code>XXXAutoConfiguration</code> ，在这个配置类中通过条件注解来决定一个配置是否生效（条件注解就是 Spring 中原本就有的），然后它还会提供一系列的默认配置，也允许开发者根据实际情况自定义相关配置，然后通过类型安全的属性注入将这些配置属性注入进来，新注入的属性会代替掉默认属性。正因为如此，很多第三方框架，我们只需要引入依赖就可以直接使用了。当然，开发者也可以自定义 Starter</p>
<h3 id="spring-boot-starter-parent-有什么用"><a href="#spring-boot-starter-parent-有什么用" class="headerlink" title="spring-boot-starter-parent 有什么用 ?"></a>spring-boot-starter-parent 有什么用 ?</h3><p>我们都知道，新创建一个 Spring Boot 项目，默认都是有 parent 的，这个 parent 就是 spring-boot-starter-parent ，spring-boot-starter-parent 主要有如下作用：</p>
<ol>
<li>定义了 Java 编译版本为 1.8 。</li>
<li>使用 UTF-8 格式编码。</li>
<li>继承自 spring-boot-dependencies，这个里边定义了依赖的版本，也正是因为继承了这个依赖，所以我们在写依赖时才不需要写版本号。</li>
<li>执行打包操作的配置。</li>
<li>自动化的资源过滤。</li>
<li>自动化的插件配置。</li>
<li>针对 application.properties 和 application.yml 的资源过滤，包括通过 profile 定义的不同环境的配置文件，例如 application-dev.properties 和 application-dev.yml。</li>
</ol>
<h3 id="Spring-Boot-打成的-jar-和普通的-jar-有什么区别"><a href="#Spring-Boot-打成的-jar-和普通的-jar-有什么区别" class="headerlink" title="Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?"></a>Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?</h3><p>Spring Boot 项目最终打包成的 jar 是可执行 jar ，这种 jar 可以直接通过 <code>java -jar xxx.jar</code> 命令来运行，这种 jar 不可以作为普通的 jar 被其他项目依赖，即使依赖了也无法使用其中的类。</p>
<p>Spring Boot 的 jar 无法被其他项目依赖，主要还是他和普通 jar 的结构不同。普通的 jar 包，解压后直接就是包名，包里就是我们的代码，而 Spring Boot 打包成的可执行 jar 解压后，在 <code>\BOOT-INF\classes</code> 目录下才是我们的代码，因此无法被直接引用。如果非要引用，可以在 pom.xml 文件中增加配置，将 Spring Boot 项目打包成两个 jar ，一个可执行，一个可引用。</p>
<h3 id="运行-Spring-Boot-有哪几种方式？"><a href="#运行-Spring-Boot-有哪几种方式？" class="headerlink" title="运行 Spring Boot 有哪几种方式？"></a>运行 Spring Boot 有哪几种方式？</h3><p>1）打包用命令或者放到容器中运行</p>
<p>2）用 Maven/ Gradle 插件运行</p>
<p>3）直接执行 main 方法运行</p>
<h3 id="Spring-Boot-需要独立的容器运行吗？"><a href="#Spring-Boot-需要独立的容器运行吗？" class="headerlink" title="Spring Boot 需要独立的容器运行吗？"></a>Spring Boot 需要独立的容器运行吗？</h3><p>可以不需要，内置了 Tomcat/ Jetty 等容器。</p>
<h3 id="开启-Spring-Boot-特性有哪几种方式？"><a href="#开启-Spring-Boot-特性有哪几种方式？" class="headerlink" title="开启 Spring Boot 特性有哪几种方式？"></a>开启 Spring Boot 特性有哪几种方式？</h3><p>1）继承spring-boot-starter-parent项目</p>
<p>2）导入spring-boot-dependencies项目依赖</p>
<h3 id="如何使用-Spring-Boot-实现异常处理？"><a href="#如何使用-Spring-Boot-实现异常处理？" class="headerlink" title="如何使用 Spring Boot 实现异常处理？"></a>如何使用 Spring Boot 实现异常处理？</h3><p>Spring 提供了一种使用 ControllerAdvice 处理异常的非常有用的方法。 我们通过实现一个 ControlerAdvice 类，来处理控制器类抛出的所有异常。</p>
<h3 id="如何使用-Spring-Boot-实现分页和排序？"><a href="#如何使用-Spring-Boot-实现分页和排序？" class="headerlink" title="如何使用 Spring Boot 实现分页和排序？"></a>如何使用 Spring Boot 实现分页和排序？</h3><p>使用 Spring Boot 实现分页非常简单。使用 Spring Data-JPA 可以实现将可分页的传递给存储库方法。</p>
<h3 id="微服务中如何实现-session-共享"><a href="#微服务中如何实现-session-共享" class="headerlink" title="微服务中如何实现 session 共享 ?"></a>微服务中如何实现 session 共享 ?</h3><p>在微服务中，一个完整的项目被拆分成多个不相同的独立的服务，各个服务独立部署在不同的服务器上，各自的 session 被从物理空间上隔离开了，但是经常，我们需要在不同微服务之间共享 session ，常见的方案就是 Spring Session + Redis 来实现 session 共享。将所有微服务的 session 统一保存在 Redis 上，当各个微服务对 session 有相关的读写操作时，都去操作 Redis 上的 session 。这样就实现了 session 共享，Spring Session 基于 Spring 中的代理过滤器实现，使得 session 的同步操作对开发人员而言是透明的，非常简便。</p>
<h3 id="Spring-Boot-中如何实现定时任务"><a href="#Spring-Boot-中如何实现定时任务" class="headerlink" title="Spring Boot 中如何实现定时任务 ?"></a>Spring Boot 中如何实现定时任务 ?</h3><p>定时任务也是一个常见的需求，Spring Boot 中对于定时任务的支持主要还是来自 Spring 框架。</p>
<p>在 Spring Boot 中使用定时任务主要有两种不同的方式，一个就是使用 Spring 中的 @Scheduled 注解，另一个则是使用第三方框架 Quartz。</p>
<p>使用 Spring 中的 @Scheduled 的方式主要通过 @Scheduled 注解来实现。</p>
<p>使用 Quartz ，则按照 Quartz 的方式，定义 Job 和 Trigger 即可。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK源码</title>
    <url>/2020/12/23/0000.Java%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<h1 id="第1章-基础"><a href="#第1章-基础" class="headerlink" title="第1章 基础"></a><strong>第1章 基础</strong></h1><h2 id="01-开篇词：为什么学习本专栏"><a href="#01-开篇词：为什么学习本专栏" class="headerlink" title="01 开篇词：为什么学习本专栏"></a><strong>01 开篇词：为什么学习本专栏</strong></h2><h3 id="不为了源码而读源码，只为了更好的实践"><a href="#不为了源码而读源码，只为了更好的实践" class="headerlink" title="不为了源码而读源码，只为了更好的实践"></a>不为了源码而读源码，只为了更好的实践</h3><p>你好，我是文贺，Java 技术专家，DDD 和业务中台的资深实践者，一周面试 2～3 次的面试官。</p>
<p>说起自己开始阅读 Java 源码的契机，还是在第一年换工作的时候，被大厂的技术面虐的体无完肤，后来总结大厂的面试套路，发现很喜欢问 Java 底层实现，即 Java 源码，于是我花了半年时间，啃下了 Java 源码，终于进了网易。</p>
<p>以我个人经历来说，<strong>阅读源码真的可以帮助你顺利过技术面，找到更好的工作</strong>。</p>
<p>阅读源码还可以帮忙我们增加个人自信，学习其优良设计思想，总结出最优使用姿势，避免踩坑，甚至针对工作中的痛点进行创新改造。</p>
<p>而在实际工作中，你可能遇到过这些尴尬：</p>
<ol>
<li>很多 API 的使用，需要先百度，然后再复制粘贴；</li>
<li>针对不同的场景，不知道如何设计不同类型的线程池，对 API 的使用没有太多的场景经验总结；</li>
<li>代码 review 的时候，提不出意见，自己的代码却常常被别人吐槽；</li>
<li>对于工作中 API 使用不方便的地方，想优化，但不知其内部实现原理，不敢动手。</li>
</ol>
<p>通过调查发现，能绕过以上尴尬的同学，多数都是阅读过 Java 源码、对 Java 底层的构造了如指掌的。这些同学能写团队核心代码，能轻易看出代码漏洞，能总结出 Java 的设计思想，并运用到日常工作中。</p>
<p><strong>所以说阅读 Java 源码，还能让我们结合场景熟练的使用 API，基于工作中使用痛点做一些源码创新，是成为团队核心的技术基础。</strong></p>
<p>我现在陆续阅读过 Java 7、8 的源码几遍，一开始很难坚持，因为源码比较枯燥。首先不知道源码的整体架构，然后细节之处不知道为什么这么写，但最终还是啃下来了，甚至喜欢了阅读源码，于是我在想，是不是可以把我的源码阅读经验和一线工作经验结合，使本课程成为源码的阅读指南、面试指南和场景实战指南。</p>
<p>为了大家更易阅读，在接下来的 40 课中，<strong>我们会先从实际的案例场景出发，对 Java 中 30+ 个核心类进行图文源码解析，并从中总结出设计思想、最优使用姿势和坑，最终以连环面试题进行巩固</strong>。</p>
<p>我们对于每个源码类的文章套路为：</p>
<ol>
<li>怎么用：用场景来说明类的重要方法的使用技巧；</li>
<li>为什么：源码解析其底层实现源码，复杂的源码会有动图解析；</li>
<li>总结：总结出设计思想、最优使用姿势和坑，看看能否为工作中所用；</li>
<li>面试题：总结出最新连环面试题，一题接着一题深入，可以作为面试官和面试者的面试指南。</li>
</ol>
<p>本课程涉及到的 Java 知识非常齐全，主要有基础类、集合类、并发集合类、队列、线程、锁、线程池、Lambda 流等内容，内容几乎涵盖了工作和面试的核心，如果你对这些源码都了如指掌，面试题再千变万化，你也能应对自如。</p>
<p>源码解析主要以 Java 8 为主，对版本变动较大的类会做 Java 7、8 版本的比较。</p>
<p>学习本课程门槛较低，只需要你有一颗肯学习进步，希望成为 Java 技术专家的信心和决心即可。</p>
<p>本课程会有源码的 GitHub，欢迎喜欢阅读源码的同学来创建自己的分支，一起来结伴阅读源码，写上自己的感悟互相交流。</p>
<p>总之，我一定会把专栏写的通俗易懂，也希望面前的你通过阅读本课程，找到更好的工作，走上 Java 专家之路，成为更专业，更资深，更有影响力的技术实践创新者。</p>
<h2 id="02-String、Long-源码解析和面试题"><a href="#02-String、Long-源码解析和面试题" class="headerlink" title="02 String、Long 源码解析和面试题"></a><strong>02 String、Long 源码解析和面试题</strong></h2><h3 id="引导语"><a href="#引导语" class="headerlink" title="引导语"></a>引导语</h3><p>String 和 Long 大家都很熟悉，本小节主要结合实际的工作场景，来一起看下 String 和 Long 的底层源码实现，看看平时我们使用时，有无需要注意的点，总结一下这些 API 都适用于哪些场景。</p>
<h3 id="1-String"><a href="#1-String" class="headerlink" title="1 String"></a>1 String</h3><h4 id="1-1-不变性"><a href="#1-1-不变性" class="headerlink" title="1.1 不变性"></a>1.1 不变性</h4><p>我们常常听人说，HashMap 的 key 建议使用不可变类，比如说 String 这种不可变类。这里说的不可变指的是类值一旦被初始化，就不能再被改变了，如果被修改，将会是新的类，我们写个 demo 来演示一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s =<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">s =<span class="string">&quot;world&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>从代码上来看，s 的值好像被修改了，但从 debug 的日志来看，其实是 s 的内存地址已经被修改了，也就说 s =“world” 这个看似简单的赋值，其实已经把 s 的引用指向了新的 String，debug 的截图显示内存地址已经被修改，两张截图如下：</p>
<p><img src="http://img.mukewang.com/5d5fc04a0001c6a508840096.png" alt="图片描述"><img src="http://img.mukewang.com/5d5fc06400019cc210540090.png" alt="图片描述">我们从源码上查看一下原因：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>我们可以看出来两点：</p>
<ol>
<li>String 被 final 修饰，说明 String 类绝不可能被继承了，也就是说任何对 String 的操作方法，都不会被继承覆写；</li>
<li>String 中保存数据的是一个 char 的数组 value。我们发现 value 也是被 final 修饰的，也就是说 value 一旦被赋值，内存地址是绝对无法修改的，而且 value 的权限是 private 的，外部绝对访问不到，String 也没有开放出可以对 value 进行赋值的方法，所以说 value 一旦产生，内存地址就根本无法被修改。</li>
</ol>
<p>以上两点就是 String 不变性的原因，充分利用了 final 关键字的特性，如果你自定义类时，希望也是不可变的，也可以模仿 String 的这两点操作。</p>
<p>因为 String 具有不变性，所以 String 的大多数操作方法，都会返回新的 String，如下面这种写法是不对的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str =<span class="string">&quot;hello world !!&quot;</span>;</span><br><span class="line"><span class="comment">// 这种写法是替换不掉的，必须接受 replace 方法返回的参数才行，这样才行：str = str.replace(&quot;l&quot;,&quot;dd&quot;);</span></span><br><span class="line">str.replace(<span class="string">&quot;l&quot;</span>,<span class="string">&quot;dd&quot;</span>);</span><br></pre></td></tr></table></figure>



<h4 id="1-2-字符串乱码"><a href="#1-2-字符串乱码" class="headerlink" title="1.2 字符串乱码"></a>1.2 字符串乱码</h4><p>在生活中，我们经常碰到这样的场景，进行二进制转化操作时，本地测试的都没有问题，到其它环境机器上时，有时会出现字符串乱码的情况，这个主要是因为在二进制转化操作时，并没有强制规定文件编码，而不同的环境默认的文件编码不一致导致的。</p>
<p>我们也写了一个 demo 来模仿一下字符串乱码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str  =<span class="string">&quot;nihao 你好 喬亂&quot;</span>;</span><br><span class="line"><span class="comment">// 字符串转化成 byte 数组</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = str.getBytes(<span class="string">&quot;ISO-8859-1&quot;</span>);</span><br><span class="line"><span class="comment">// byte 数组转化成字符串</span></span><br><span class="line">String s2 = <span class="keyword">new</span> String(bytes);</span><br><span class="line">log.info(s2);</span><br><span class="line"><span class="comment">// 结果打印为：</span></span><br><span class="line">nihao ?? ??</span><br></pre></td></tr></table></figure>

<p>打印的结果为？？，这就是常见的乱码表现形式。这时候有同学说，是不是我把代码修改成 <code>String s2 = new String(bytes,&quot;ISO-8859-1&quot;);</code> 就可以了？这是不行的。主要是因为 ISO-8859-1 这种编码对中文的支持有限，导致中文会显示乱码。唯一的解决办法，就是在所有需要用到编码的地方，都统一使用 UTF-8，对于 String 来说，getBytes 和 new String 两个方法都会使用到编码，我们把这两处的编码替换成 UTF-8 后，打印出的结果就正常了。</p>
<h4 id="1-3-首字母大小写"><a href="#1-3-首字母大小写" class="headerlink" title="1.3 首字母大小写"></a>1.3 首字母大小写</h4><p>如果我们的项目被 Spring 托管的话，有时候我们会通过 <code>applicationContext.getBean(className);</code> 这种方式得到 SpringBean，这时 className 必须是要满足首字母小写的，除了该场景，在反射场景下面，我们也经常要使类属性的首字母小写，这时候我们一般都会这么做：</p>
<p><code>name.substring(0, 1).toLowerCase() + name.substring(1);</code>，使用 substring 方法，该方法主要是为了截取字符串连续的一部分，substring 有两个方法：</p>
<ol>
<li><code>public String substring(int beginIndex, int endIndex)</code> beginIndex：开始位置，endIndex：结束位置；</li>
<li><code>public String substring(int beginIndex)</code>beginIndex：开始位置，结束位置为文本末尾。</li>
</ol>
<p>substring 方法的底层使用的是字符数组范围截取的方法 ：<code>Arrays.copyOfRange(字符数组, 开始位置, 结束位置);</code> 从字符数组中进行一段范围的拷贝。</p>
<p>相反的，如果要修改成首字母大写，只需要修改成 <code>name.substring(0, 1).toUpperCase() + name.substring(1)</code> 即可。</p>
<h4 id="1-4-相等判断"><a href="#1-4-相等判断" class="headerlink" title="1.4 相等判断"></a>1.4 相等判断</h4><p>我们判断相等有两种办法，equals 和 equalsIgnoreCase。后者判断相等时，会忽略大小写，近期看见一些面试题在问：如果让你写判断两个 String 相等的逻辑，应该如何写，我们来一起看下 equals 的源码，整理一下思路：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断内存地址是否相同</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 待比较的对象是否是 String，如果不是 String，直接返回不相等</span></span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="comment">// 两个字符串的长度是否相等，不等则直接返回不相等</span></span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 依次比较每个字符是否相等，若有一个不等，直接返回不相等</span></span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 equals 的源码可以看出，逻辑非常清晰，完全是根据 String 底层的结构来编写出相等的代码。这也提供了一种思路给我们：如果有人问如何判断两者是否相等时，我们可以从两者的底层结构出发，这样可以迅速想到一种贴合实际的思路和方法，就像 String 底层的数据结构是 char 的数组一样，判断相等时，就挨个比较 char 数组中的字符是否相等即可。</p>
<h4 id="1-5-替换、删除"><a href="#1-5-替换、删除" class="headerlink" title="1.5 替换、删除"></a>1.5 替换、删除</h4><p>替换在工作中也经常使用，有 replace 替换所有字符、replaceAll 批量替换字符串、replaceFirst 替换遇到的第一个字符串三种场景。</p>
<p>其中在使用 replace 时需要注意，replace 有两个方法，一个入参是 char，一个入参是 String，前者表示替换所有字符，如：<code>name.replace(&#39;a&#39;,&#39;b&#39;)</code>，后者表示替换所有字符串，如：<code>name.replace(&quot;a&quot;,&quot;b&quot;)</code>，两者就是单引号和多引号的区别。</p>
<p>需要注意的是， replace 并不只是替换一个，是替换所有匹配到的字符或字符串哦。</p>
<p>写了一个 demo 演示一下三种场景：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReplace</span><span class="params">()</span></span>&#123;</span><br><span class="line">  String str =<span class="string">&quot;hello word !!&quot;</span>;</span><br><span class="line">  log.info(<span class="string">&quot;替换之前 :&#123;&#125;&quot;</span>,str);</span><br><span class="line">  str = str.replace(<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;d&#x27;</span>);</span><br><span class="line">  log.info(<span class="string">&quot;替换所有字符 :&#123;&#125;&quot;</span>,str);</span><br><span class="line">  str = str.replaceAll(<span class="string">&quot;d&quot;</span>,<span class="string">&quot;l&quot;</span>);</span><br><span class="line">  log.info(<span class="string">&quot;替换全部 :&#123;&#125;&quot;</span>,str);</span><br><span class="line">  str = str.replaceFirst(<span class="string">&quot;l&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">  log.info(<span class="string">&quot;替换第一个 l :&#123;&#125;&quot;</span>,str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出的结果是：</span></span><br><span class="line">替换之前 :hello word !!</span><br><span class="line">替换所有字符 :heddo word !!</span><br><span class="line">替换全部 :hello worl !!</span><br><span class="line">替换第一个 :helo worl !!</span><br></pre></td></tr></table></figure>

<p>当然我们想要删除某些字符，也可以使用 replace 方法，把想删除的字符替换成 “” 即可。</p>
<h4 id="1-6-拆分和合并"><a href="#1-6-拆分和合并" class="headerlink" title="1.6 拆分和合并"></a>1.6 拆分和合并</h4><p>拆分我们使用 split 方法，该方法有两个入参数。第一个参数是我们拆分的标准字符，第二个参数是一个 int 值，叫 limit，来限制我们需要拆分成几个元素。如果 limit 比实际能拆分的个数小，按照 limit 的个数进行拆分，我们演示一个 demo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s =<span class="string">&quot;boo:and:foo&quot;</span>;</span><br><span class="line"><span class="comment">// 我们对 s 进行了各种拆分，演示的代码和结果是：</span></span><br><span class="line">s.split(<span class="string">&quot;:&quot;</span>) 结果:[<span class="string">&quot;boo&quot;</span>,<span class="string">&quot;and&quot;</span>,<span class="string">&quot;foo&quot;</span>]</span><br><span class="line">s.split(<span class="string">&quot;:&quot;</span>,<span class="number">2</span>) 结果:[<span class="string">&quot;boo&quot;</span>,<span class="string">&quot;and:foo&quot;</span>]</span><br><span class="line">s.split(<span class="string">&quot;:&quot;</span>,<span class="number">5</span>) 结果:[<span class="string">&quot;boo&quot;</span>,<span class="string">&quot;and&quot;</span>,<span class="string">&quot;foo&quot;</span>]</span><br><span class="line">s.split(<span class="string">&quot;:&quot;</span>,-<span class="number">2</span>) 结果:[<span class="string">&quot;boo&quot;</span>,<span class="string">&quot;and&quot;</span>,<span class="string">&quot;foo&quot;</span>]</span><br><span class="line">s.split(<span class="string">&quot;o&quot;</span>) 结果:[<span class="string">&quot;b&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;:and:f&quot;</span>]</span><br><span class="line">s.split(<span class="string">&quot;o&quot;</span>,<span class="number">2</span>) 结果:[<span class="string">&quot;b&quot;</span>,<span class="string">&quot;o:and:foo&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>从演示的结果来看，limit 对拆分的结果，是具有限制作用的，还有就是拆分结果里面不会出现被拆分的字段。</p>
<p>那如果字符串里面有一些空值呢，拆分的结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a =<span class="string">&quot;,a,,b,&quot;</span>;</span><br><span class="line">a.split(<span class="string">&quot;,&quot;</span>) 结果:[<span class="string">&quot;&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;b&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>从拆分结果中，我们可以看到，空值是拆分不掉的，仍然成为结果数组的一员，如果我们想删除空值，只能自己拿到结果后再做操作，但 Guava（Google 开源的技术工具） 提供了一些可靠的工具类，可以帮助我们快速去掉空值，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a =<span class="string">&quot;,a, ,  b  c ,&quot;</span>;</span><br><span class="line"><span class="comment">// Splitter 是 Guava 提供的 API </span></span><br><span class="line">List&lt;String&gt; list = Splitter.on(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    .trimResults()<span class="comment">// 去掉空格</span></span><br><span class="line">    .omitEmptyStrings()<span class="comment">// 去掉空值</span></span><br><span class="line">    .splitToList(a);</span><br><span class="line">log.info(<span class="string">&quot;Guava 去掉空格的分割方法：&#123;&#125;&quot;</span>,JSON.toJSONString(list));</span><br><span class="line"><span class="comment">// 打印出的结果为：</span></span><br><span class="line">[<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b  c&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>从打印的结果中，可以看到去掉了空格和空值，这正是我们工作中常常期望的结果，所以推荐使用 Guava 的 API 对字符串进行分割。</p>
<p>合并我们使用 join 方法，此方法是静态的，我们可以直接使用。方法有两个入参，参数一是合并的分隔符，参数二是合并的数据源，数据源支持数组和 List，在使用的时候，我们发现有两个不太方便的地方：</p>
<ol>
<li>不支持依次 join 多个字符串，比如我们想依次 join 字符串 s 和 s1，如果你这么写的话 <code>String.join(&quot;,&quot;,s).join(&quot;,&quot;,s1)</code> 最后得到的是 s1 的值，第一次 join 的值被第二次 join 覆盖了；</li>
<li>如果 join 的是一个 List，无法自动过滤掉 null 值。</li>
</ol>
<p>而 Guava 正好提供了 API，解决上述问题，我们来演示一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 依次 join 多个字符串，Joiner 是 Guava 提供的 API</span></span><br><span class="line">Joiner joiner = Joiner.on(<span class="string">&quot;,&quot;</span>).skipNulls();</span><br><span class="line">String result = joiner.join(<span class="string">&quot;hello&quot;</span>,<span class="keyword">null</span>,<span class="string">&quot;china&quot;</span>);</span><br><span class="line">log.info(<span class="string">&quot;依次 join 多个字符串:&#123;&#125;&quot;</span>,result);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list = Lists.newArrayList(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;china&quot;</span>,<span class="keyword">null</span>&#125;);</span><br><span class="line">log.info(<span class="string">&quot;自动删除 list 中空值:&#123;&#125;&quot;</span>,joiner.join(list));</span><br><span class="line"><span class="comment">// 输出的结果为；</span></span><br><span class="line">依次 join 多个字符串:hello,china</span><br><span class="line">自动删除 list 中空值:hello,china</span><br></pre></td></tr></table></figure>

<p>从结果中，我们可以看到 Guava 不仅仅支持多个字符串的合并，还帮助我们去掉了 List 中的空值，这就是我们在工作中常常需要得到的结果。</p>
<h3 id="2-Long"><a href="#2-Long" class="headerlink" title="2 Long"></a>2 Long</h3><table>
<thead>
<tr>
<th align="left">包装类型</th>
<th align="left">缓存范围</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Integer</td>
<td align="left">-128~127</td>
</tr>
<tr>
<td align="left">Byte</td>
<td align="left">-128~127</td>
</tr>
<tr>
<td align="left">Short</td>
<td align="left">-128~127</td>
</tr>
<tr>
<td align="left">Long</td>
<td align="left">-128~127</td>
</tr>
<tr>
<td align="left">Character</td>
<td align="left">0~128</td>
</tr>
</tbody></table>
<h4 id="2-1-缓存"><a href="#2-1-缓存" class="headerlink" title="2.1 缓存"></a>2.1 缓存</h4><p>Long 最被我们关注的就是 Long 的缓存问题，Long 自己实现了一种缓存机制，缓存了从 -128 到 127 内的所有 Long 值，如果是这个范围内的 Long 值，就不会初始化，而是从缓存中拿，缓存初始化源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LongCache</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LongCache</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 缓存，范围从 -128 到 127，+1 是因为有个 0</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Long cache[] = <span class="keyword">new</span> Long[-(-<span class="number">128</span>) + <span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器初始化时，进行加载</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 缓存 Long 值，注意这里是 i - 128 ，所以再拿的时候就需要 + 128</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">            cache[i] = <span class="keyword">new</span> Long(i - <span class="number">128</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-面试题"><a href="#3-面试题" class="headerlink" title="3 面试题"></a>3 面试题</h3><h4 id="3-1-为什么使用-Long-时，大家推荐多使用-valueOf-方法，少使用-parseLong-方法"><a href="#3-1-为什么使用-Long-时，大家推荐多使用-valueOf-方法，少使用-parseLong-方法" class="headerlink" title="3.1 为什么使用 Long 时，大家推荐多使用 valueOf 方法，少使用 parseLong 方法"></a>3.1 为什么使用 Long 时，大家推荐多使用 valueOf 方法，少使用 parseLong 方法</h4><p>答：因为 Long 本身有缓存机制，缓存了 -128 到 127 范围内的 Long，valueOf 方法会从缓存中去拿值，如果命中缓存，会减少资源的开销，parseLong 方法就没有这个机制。</p>
<h4 id="3-2-如何解决-String-乱码的问题"><a href="#3-2-如何解决-String-乱码的问题" class="headerlink" title="3.2 如何解决 String 乱码的问题"></a>3.2 如何解决 String 乱码的问题</h4><p>答：乱码的问题的根源主要是两个：字符集不支持复杂汉字、二进制进行转化时字符集不匹配，所以在 String 乱码时我们可以这么做：</p>
<ol>
<li>所有可以指定字符集的地方强制指定字符集，比如 new String 和 getBytes 这两个地方；</li>
<li>我们应该使用 UTF-8 这种能完整支持复杂汉字的字符集。</li>
</ol>
<h4 id="3-3-为什么大家都说-String-是不可变的"><a href="#3-3-为什么大家都说-String-是不可变的" class="headerlink" title="3.3 为什么大家都说 String 是不可变的"></a>3.3 为什么大家都说 String 是不可变的</h4><p>答：主要是因为 String 和保存数据的 char 数组，都被 final 关键字所修饰，所以是不可变的，具体细节描述可以参考上文。</p>
<h4 id="3-4-String-一些常用操作问题，如问如何分割、合并、替换、删除、截取等等问题"><a href="#3-4-String-一些常用操作问题，如问如何分割、合并、替换、删除、截取等等问题" class="headerlink" title="3.4 String 一些常用操作问题，如问如何分割、合并、替换、删除、截取等等问题"></a>3.4 String 一些常用操作问题，如问如何分割、合并、替换、删除、截取等等问题</h4><p>答：这些都属于问 String 的基本操作题目，考察我们平时对 String 的使用熟练程度，可以参考上文。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>String 和 Long 在我们工作中使用频率很高，在面试的过程中，考官也喜欢问一些关于实际操作的问题，来考察我们的使用熟练度，所以本文中列举的一些 demo，大家可以试试手，完整的代码可以去 GitHub 上面去拉取。</p>
<h2 id="03-Java-常用关键字理解"><a href="#03-Java-常用关键字理解" class="headerlink" title="03 Java 常用关键字理解"></a><strong>03 Java 常用关键字理解</strong></h2><h3 id="引导语-1"><a href="#引导语-1" class="headerlink" title="引导语"></a>引导语</h3><p>Java 中的关键字很多，大约有 50+，在命名上我们不能和这些关键字冲突的，编译会报错，每个关键字都代表着不同场景下的不同含义，接下来我们挑选 6 个比较重要的关键字，深入学习一下。</p>
<h3 id="1-static"><a href="#1-static" class="headerlink" title="1 static"></a>1 static</h3><p>意思是静态的、全局的，一旦被修饰，说明被修饰的东西在一定范围内是共享的，谁都可以访问，这时候需要注意并发读写的问题。</p>
<h4 id="1-1-修饰的对象"><a href="#1-1-修饰的对象" class="headerlink" title="1.1 修饰的对象"></a>1.1 修饰的对象</h4><p>static 只能修饰类变量、方法和方法块。</p>
<p><strong>当 static 修饰类变量时</strong>，如果该变量是 public 的话，表示该变量任何类都可以直接访问，而且无需初始化类，直接使用 <strong>类名.static 变量</strong> 这种形式访问即可。</p>
<p>这时候我们非常需要注意的一点就是线程安全的问题了，因为当多个线程同时对共享变量进行读写时，很有可能会出现并发问题，如我们定义了：<code>public static List list = new ArrayList();</code>这样的共享变量。这个 list 如果同时被多个线程访问的话，就有线程安全的问题，这时候一般有两个解决办法：</p>
<ol>
<li>把线程不安全的 ArrayList 换成 线程安全的 CopyOnWriteArrayList；</li>
<li>每次访问时，手动加锁。</li>
</ol>
<p>所以在使用 static 修饰类变量时，如何保证线程安全是我们常常需要考虑的。</p>
<p><strong>当 static 修饰方法时</strong>，代表该方法和当前类是无关的，任意类都可以直接访问（如果权限是 public 的话）。</p>
<p>有一点需要注意的是，该方法内部只能调用同样被 static 修饰的方法，不能调用普通方法，我们常用的 util 类里面的各种方法，我们比较喜欢用 static 修饰方法，好处就是调用特别方便。</p>
<p>static 方法内部的变量在执行时是没有线程安全问题的。方法执行时，数据运行在栈里面，栈的数据每个线程都是隔离开的，所以不会有线程安全的问题，所以 util 类的各个 static 方法，我们是可以放心使用的。</p>
<p><strong>当 static 修饰方法块时</strong>，我们叫做静态块，静态块常常用于在类启动之前，初始化一些值，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="comment">// 进行一些初始化的工作</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码演示了静态块做一些初始化的工作，但需要注意的是，静态块只能调用同样被 static 修饰的变量，并且 static 的变量需要写在静态块的前面，不然编译也会报错。</p>
<h4 id="1-2-初始化时机"><a href="#1-2-初始化时机" class="headerlink" title="1.2 初始化时机"></a>1.2 初始化时机</h4><p>对于被 static 修饰的类变量、方法块和静态方法的初始化时机，我们写了一个测试 demo，如下图：<br><img src="http://img.mukewang.com/5d5fc0be000136a322560976.png" alt="图片描述">打印出来的结果是：</p>
<p>父类静态变量初始化<br>父类静态块初始化<br>子类静态变量初始化<br>子类静态块初始化<br>main 方法执行<br>父类构造器初始化<br>子类构造器初始化</p>
<p>从结果中，我们可以看出两点：</p>
<ol>
<li>父类的静态变量和静态块比子类优先初始化；</li>
<li>静态变量和静态块比类构造器优先初始化。</li>
</ol>
<p>被 static 修饰的方法，在类初始化的时候并不会初始化，只有当自己被调用时，才会被执行。</p>
<h3 id="2-final"><a href="#2-final" class="headerlink" title="2 final"></a>2 final</h3><p>final 的意思是不变的，一般来说用于以下三种场景：</p>
<ol>
<li>被 final 修饰的类，表明该类是无法继承的；</li>
<li>被 final 修饰的方法，表明该方法是无法覆写的；</li>
<li>被 final 修饰的变量，说明该变量在声明的时候，就必须初始化完成，而且以后也不能修改其内存地址。</li>
</ol>
<p>第三点注意下，我们说的是无法修改其内存地址，并没有说无法修改其值。因为对于 List、Map 这些集合类来说，被 final 修饰后，是可以修改其内部值的，但却无法修改其初始化时的内存地址。</p>
<p>例子我们就不举了，1-1 小节 String 的不变性就是一个很好的例子。</p>
<h3 id="3-try、catch、finally"><a href="#3-try、catch、finally" class="headerlink" title="3 try、catch、finally"></a>3 try、catch、finally</h3><p>这三个关键字常用于我们捕捉异常的一整套流程，try 用来确定代码执行的范围，catch 捕捉可能会发生的异常，finally 用来执行一定要执行的代码块，除了这些，我们还需要清楚，每个地方如果发生异常会怎么办，我们举一个例子来演示一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCatchFinally</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;try is run&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;try exception&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.info(<span class="string">&quot;catch is run&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;catch exception&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;finally is run&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码演示了在 try、catch 中都遇到了异常，代码的执行顺序为：try -&gt; catch -&gt; finally，输出的结果如下：<br><img src="http://img.mukewang.com/5d5fc0d40001ede717880302.png" alt="图片描述">可以看到两点：</p>
<ol>
<li>finally 先执行后，再抛出 catch 的异常；</li>
<li>最终捕获的异常是 catch 的异常，try 抛出来的异常已经被 catch 吃掉了，所以当我们遇见 catch 也有可能会抛出异常时，我们可以先打印出 try 的异常，这样 try 的异常在日志中就会有所体现。</li>
</ol>
<h3 id="4-volatile"><a href="#4-volatile" class="headerlink" title="4 volatile"></a>4 volatile</h3><p>volatile 的意思是可见的，常用来修饰某个共享变量，意思是当共享变量的值被修改后，会及时通知到其它线程上，其它线程就能知道当前共享变量的值已经被修改了。</p>
<p>我们再说原理之前，先说下基础知识。就是在多核 CPU 下，为了提高效率，线程在拿值时，是直接和 CPU 缓存打交道的，而不是内存。主要是因为 CPU 缓存执行速度更快，比如线程要拿值 C，会直接从 CPU 缓存中拿， CPU 缓存中没有，就会从内存中拿，所以线程读的操作永远都是拿 CPU 缓存的值。</p>
<p>这时候会产生一个问题，CPU 缓存中的值和内存中的值可能并不是时刻都同步，导致线程计算的值可能不是最新的，共享变量的值有可能已经被其它线程所修改了，但此时修改是机器内存的值，CPU 缓存的值还是老的，导致计算会出现问题。</p>
<p>这时候有个机制，就是内存会主动通知 CPU 缓存。当前共享变量的值已经失效了，你需要重新来拉取一份，CPU 缓存就会重新从内存中拿取一份最新的值。</p>
<p>volatile 关键字就会触发这种机制，加了 volatile 关键字的变量，就会被识别成共享变量，内存中值被修改后，会通知到各个 CPU 缓存，使 CPU 缓存中的值也对应被修改，从而保证线程从 CPU 缓存中拿取出来的值是最新的。</p>
<p>我们画了一个图来说明一下：<br><img src="http://img.mukewang.com/5d5fc0ea000100a312740736.png" alt="图片描述">从图中我们可以看到，线程 1 和线程 2 一开始都读取了 C 值，CPU 1 和 CPU 2 缓存中也都有了 C 值，然后线程 1 把 C 值修改了，这时候内存的值和 CPU 2 缓存中的 C 值就不等了，内存这时发现 C 值被 volatile 关键字修饰，发现其是共享变量，就会使 CPU 2 缓存中的 C 值状态置为无效，CPU 2 会从内存中重新拉取最新的值，这时候线程 2 再来读取 C 值时，读取的已经是内存中最新的值了。</p>
<h3 id="5-transient"><a href="#5-transient" class="headerlink" title="5 transient"></a>5 transient</h3><p>transient 关键字我们常用来修饰类变量，意思是当前变量是无需进行序列化的。在序列化时，就会忽略该变量，这些在序列化工具底层，就已经对 transient 进行了支持。</p>
<h3 id="6-default"><a href="#6-default" class="headerlink" title="6 default"></a>6 default</h3><p>default 关键字一般会用在接口的方法上，意思是对于该接口，子类是无需强制实现的，但自己必须有默认实现，我们举个例子如下：<br><img src="http://img.mukewang.com/5d5fc4460001f3cb17220650.png" alt="图片描述">default 关键字被很多源码使用，我们后面会说。</p>
<h3 id="7-面试题"><a href="#7-面试题" class="headerlink" title="7 面试题"></a>7 面试题</h3><h4 id="7-1-如何证明-static-静态变量和类无关？"><a href="#7-1-如何证明-static-静态变量和类无关？" class="headerlink" title="7.1 如何证明 static 静态变量和类无关？"></a>7.1 如何证明 static 静态变量和类无关？</h4><p>答：从三个方面就可以看出静态变量和类无关。</p>
<ol>
<li>我们不需要初始化类就可直接使用静态变量；</li>
<li>我们在类中写个 main 方法运行，即便不写初始化类的代码，静态变量都会自动初始化；</li>
<li>静态变量只会初始化一次，初始化完成之后，不管我再 new 多少个类出来，静态变量都不会再初始化了。</li>
</ol>
<p>不仅仅是静态变量，静态方法块也和类无关。</p>
<h4 id="7-2-常常看见变量和方法被-static-和-final-两个关键字修饰，为什么这么做？"><a href="#7-2-常常看见变量和方法被-static-和-final-两个关键字修饰，为什么这么做？" class="headerlink" title="7.2 常常看见变量和方法被 static 和 final 两个关键字修饰，为什么这么做？"></a>7.2 常常看见变量和方法被 static 和 final 两个关键字修饰，为什么这么做？</h4><p>答：这么做有两个目的：</p>
<ol>
<li>变量和方法于类无关，可以直接使用，使用比较方便；</li>
<li>强调变量内存地址不可变，方法不可继承覆写，强调了方法内部的稳定性。</li>
</ol>
<h4 id="7-3-catch-中发生了未知异常，finally-还会执行么？"><a href="#7-3-catch-中发生了未知异常，finally-还会执行么？" class="headerlink" title="7.3 catch 中发生了未知异常，finally 还会执行么？"></a>7.3 catch 中发生了未知异常，finally 还会执行么？</h4><p>答：会的，catch 发生了异常，finally 还会执行的，并且是 finally 执行完成之后，才会抛出 catch 中的异常。</p>
<p>不过 catch 会吃掉 try 中抛出的异常，为了避免这种情况，在一些可以预见 catch 中会发生异常的地方，先把 try 抛出的异常打印出来，这样从日志中就可以看到完整的异常了。</p>
<h4 id="7-4-volatile-关键字的作用和原理"><a href="#7-4-volatile-关键字的作用和原理" class="headerlink" title="7.4 volatile 关键字的作用和原理"></a>7.4 volatile 关键字的作用和原理</h4><p>答：这个上文说的比较清楚，可以参考上文。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Java 的关键字属于比较基础的内容，我们需要清晰明确其含义，才能在后续源码阅读和工作中碰到这些关键字时了然于心，才能明白为什么会在这里使用这样的关键字。比如 String 源码是如何使用 final 关键字达到起不变性的，比如 Java 8 集合中 Map 是如何利用 default 关键字新增各种方法的，这些我们在后续内容都会提到。</p>
<h2 id="04-Arrays、Collections、Objects-常用方法源码解析"><a href="#04-Arrays、Collections、Objects-常用方法源码解析" class="headerlink" title="04 Arrays、Collections、Objects 常用方法源码解析"></a><strong>04 Arrays、Collections、Objects 常用方法源码解析</strong></h2><h3 id="引导语-2"><a href="#引导语-2" class="headerlink" title="引导语"></a>引导语</h3><p>我们在工作中都会写工具类，但如何才能使写出来的工具类更好用，也是有一些技巧的。本章内容以三种平时工作中经常使用的工具类为例，从使用案例出发，再看看底层源码的实现，看看能否学习到一些工具类的技巧，以及三种工具类的实际使用场景。</p>
<blockquote>
<p>下方是本专栏 GitHub 地址：<br>源码解析：<a href="https://github.com/luanqiu/java8">https://github.com/luanqiu/java8</a><br>文章 demo：<a href="https://github.com/luanqiu/java8_demo">https://github.com/luanqiu/java8_demo</a><br>同学们有需要可以对照着来看 ：）</p>
</blockquote>
<h3 id="1-工具类通用的特征"><a href="#1-工具类通用的特征" class="headerlink" title="1 工具类通用的特征"></a>1 工具类通用的特征</h3><p>再看细节之前，我们先总结一下好的工具类都有哪些通用的特征写法：</p>
<ol>
<li>构造器必须是私有的。这样的话，工具类就无法被 new 出来，因为工具类在使用的时候，无需初始化，直接使用即可，所以不会开放出构造器出来。</li>
<li>工具类的工具方法必须被 static、final 关键字修饰。这样的话就可以保证方法不可变，并且可以直接使用，非常方便。</li>
</ol>
<p>我们需要注意的是，尽量不在工具方法中，对共享变量有做修改的操作访问（如果必须要做的话，必须加锁），因为会有线程安全的问题。除此之外，工具类方法本身是没有线程安全问题的，可以放心使用。</p>
<h3 id="2-Arrays"><a href="#2-Arrays" class="headerlink" title="2 Arrays"></a>2 Arrays</h3><p>Arrays 主要对数组提供了一些高效的操作，比如说排序、查找、填充、拷贝、相等判断等等。我们选择其中两三看下，对其余操作感兴趣的同学可以到 GitHub 上查看源码解析。</p>
<h4 id="2-1-排序"><a href="#2-1-排序" class="headerlink" title="2.1 排序"></a>2.1 排序</h4><p>Arrays.sort 方法主要用于排序，入参支持 int、long、double 等各种基本类型的数组，也支持自定义类的数组，下面我们写个 demo 来演示一下自定义类数组的排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="comment">// 自定义类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortDTO</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String sortTarget;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SortDTO</span><span class="params">(String sortTarget)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sortTarget = sortTarget;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">  List&lt;SortDTO&gt; list = ImmutableList.of(</span><br><span class="line">      <span class="keyword">new</span> SortDTO(<span class="string">&quot;300&quot;</span>),</span><br><span class="line">      <span class="keyword">new</span> SortDTO(<span class="string">&quot;50&quot;</span>),</span><br><span class="line">      <span class="keyword">new</span> SortDTO(<span class="string">&quot;200&quot;</span>),</span><br><span class="line">      <span class="keyword">new</span> SortDTO(<span class="string">&quot;220&quot;</span>)</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// 我们先把数组的大小初始化成 list 的大小，保证能够正确执行 toArray</span></span><br><span class="line">  SortDTO[] array = <span class="keyword">new</span> SortDTO[list.size()];</span><br><span class="line">  list.toArray(array);</span><br><span class="line"></span><br><span class="line">  log.info(<span class="string">&quot;排序之前：&#123;&#125;&quot;</span>, JSON.toJSONString(array));</span><br><span class="line">  Arrays.sort(array, Comparator.comparing(SortDTO::getSortTarget));</span><br><span class="line">  log.info(<span class="string">&quot;排序之后：&#123;&#125;&quot;</span>, JSON.toJSONString(array));</span><br><span class="line">&#125;</span><br><span class="line">输出结果为：</span><br><span class="line">排序之前：[&#123;<span class="string">&quot;sortTarget&quot;</span>:<span class="string">&quot;300&quot;</span>&#125;,&#123;<span class="string">&quot;sortTarget&quot;</span>:<span class="string">&quot;50&quot;</span>&#125;,&#123;<span class="string">&quot;sortTarget&quot;</span>:<span class="string">&quot;200&quot;</span>&#125;,&#123;<span class="string">&quot;sortTarget&quot;</span>:<span class="string">&quot;220&quot;</span>&#125;]</span><br><span class="line">排序之后：[&#123;<span class="string">&quot;sortTarget&quot;</span>:<span class="string">&quot;200&quot;</span>&#125;,&#123;<span class="string">&quot;sortTarget&quot;</span>:<span class="string">&quot;220&quot;</span>&#125;,&#123;<span class="string">&quot;sortTarget&quot;</span>:<span class="string">&quot;300&quot;</span>&#125;,&#123;<span class="string">&quot;sortTarget&quot;</span>:<span class="string">&quot;50&quot;</span>&#125;]</span><br></pre></td></tr></table></figure>

<p>从输出的结果中可以看到，排序之后的数组已经是有顺序的了，也可以看到 sort 方法支持两个入参：要排序的数组和外部排序器。</p>
<p>大家都说 sort 方法排序的性能较高，主要原因是 sort 使用了双轴快速排序算法，具体算法就不细说了。</p>
<h4 id="2-1-二分查找法"><a href="#2-1-二分查找法" class="headerlink" title="2.1 二分查找法"></a>2.1 二分查找法</h4><p>Arrays.binarySearch 方法主要用于快速从数组中查找出对应的值。其支持的入参类型非常多，如 byte、int、long 各种类型的数组。返回参数是查找到的对应数组下标的值，如果查询不到，则返回负数。<br><img src="http://img.mukewang.com/5d5fc4a400010d4106820685.png" alt="图片描述">我们写了一个 demo 如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;SortDTO&gt; list = ImmutableList.of(</span><br><span class="line">    <span class="keyword">new</span> SortDTO(<span class="string">&quot;300&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span> SortDTO(<span class="string">&quot;50&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span> SortDTO(<span class="string">&quot;200&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span> SortDTO(<span class="string">&quot;220&quot;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">SortDTO[] array = <span class="keyword">new</span> SortDTO[list.size()];</span><br><span class="line">list.toArray(array);</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">&quot;搜索之前：&#123;&#125;&quot;</span>, JSON.toJSONString(array));</span><br><span class="line">Arrays.sort(array, Comparator.comparing(SortDTO::getSortTarget));</span><br><span class="line">log.info(<span class="string">&quot;先排序，结果为：&#123;&#125;&quot;</span>, JSON.toJSONString(array));</span><br><span class="line"><span class="keyword">int</span> index = Arrays.binarySearch(array, <span class="keyword">new</span> SortDTO(<span class="string">&quot;200&quot;</span>),</span><br><span class="line">                    Comparator.comparing(SortDTO::getSortTarget));</span><br><span class="line"><span class="keyword">if</span>(index&lt;<span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;没有找到 200&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">log.info(<span class="string">&quot;搜索结果：&#123;&#125;&quot;</span>, JSON.toJSONString(array[index]));</span><br><span class="line"></span><br><span class="line">输出的结果为：</span><br><span class="line">搜索之前：[&#123;<span class="string">&quot;sortTarget&quot;</span>:<span class="string">&quot;300&quot;</span>&#125;,&#123;<span class="string">&quot;sortTarget&quot;</span>:<span class="string">&quot;50&quot;</span>&#125;,&#123;<span class="string">&quot;sortTarget&quot;</span>:<span class="string">&quot;200&quot;</span>&#125;,&#123;<span class="string">&quot;sortTarget&quot;</span>:<span class="string">&quot;220&quot;</span>&#125;]</span><br><span class="line">先排序，结果为：[&#123;<span class="string">&quot;sortTarget&quot;</span>:<span class="string">&quot;200&quot;</span>&#125;,&#123;<span class="string">&quot;sortTarget&quot;</span>:<span class="string">&quot;220&quot;</span>&#125;,&#123;<span class="string">&quot;sortTarget&quot;</span>:<span class="string">&quot;300&quot;</span>&#125;,&#123;<span class="string">&quot;sortTarget&quot;</span>:<span class="string">&quot;50&quot;</span>&#125;]</span><br><span class="line">搜索结果：&#123;<span class="string">&quot;sortTarget&quot;</span>:<span class="string">&quot;200&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>从上述代码中我们需要注意两点：</p>
<ol>
<li>如果被搜索的数组是无序的，一定要先排序，否则二分搜索很有可能搜索不到，我们 demo 里面也先对数组进行了排序；</li>
<li>搜索方法返回的是数组的下标值。如果搜索不到，返回的下标值就会是负数，这时我们需要判断一下正负。如果是负数，还从数组中获取数据的话，会报数组越界的错误。demo 中对这种情况进行了判断，如果是负数，会提前抛出明确的异常。</li>
</ol>
<p>接下来，我们来看下二分法底层代码的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a：我们要搜索的数组，fromIndex：从那里开始搜索，默认是0； toIndex：搜索到何时停止，默认是数组大小</span></span><br><span class="line"><span class="comment">// key：我们需要搜索的值 c：外部比较器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">int</span> <span class="title">binarySearch0</span><span class="params">(T[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     T key, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果比较器 c 是空的，直接使用 key 的 Comparable.compareTo 方法进行排序</span></span><br><span class="line">    <span class="comment">// 假设 key 类型是 String 类型，String 默认实现了 Comparable 接口，就可以直接使用 compareTo 方法进行排序</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 这是另外一个方法，使用内部排序器进行比较的方法</span></span><br><span class="line">        <span class="keyword">return</span> binarySearch0(a, fromIndex, toIndex, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> low = fromIndex;</span><br><span class="line">    <span class="keyword">int</span> high = toIndex - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 开始位置小于结束位置，就会一直循环搜索</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="comment">// 假设 low =0，high =10，那么 mid 就是 5，所以说二分的意思主要在这里，每次都是计算索引的中间值</span></span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        T midVal = a[mid];</span><br><span class="line">        <span class="comment">// 比较数组中间值和给定的值的大小关系</span></span><br><span class="line">        <span class="keyword">int</span> cmp = c.compare(midVal, key);</span><br><span class="line">        <span class="comment">// 如果数组中间值小于给定的值，说明我们要找的值在中间值的右边</span></span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 我们要找的值在中间值的左边</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 找到了</span></span><br><span class="line">            <span class="keyword">return</span> mid; <span class="comment">// key found</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回的值是负数，表示没有找到</span></span><br><span class="line">    <span class="keyword">return</span> -(low + <span class="number">1</span>);  <span class="comment">// key not found.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二分的主要意思是每次查找之前，都找到中间值，然后拿我们要比较的值和中间值比较，根据结果修改比较的上限或者下限，通过循环最终找到相等的位置索引，以上代码实现比较简洁，大家可以在自己理解的基础上，自己复写一遍。</p>
<h4 id="2-2-拷贝"><a href="#2-2-拷贝" class="headerlink" title="2.2 拷贝"></a>2.2 拷贝</h4><p>数组拷贝我们经常遇到，有时需要拷贝整个数组，有时需要拷贝部分，比如 ArrayList 在 add（扩容） 或 remove（删除元素不是最后一个） 操作时，会进行一些拷贝。拷贝整个数组我们可以使用 copyOf 方法，拷贝部分我们可以使用 copyOfRange 方法，以 copyOfRange 为例，看下底层源码的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// original 原始数组数据</span></span><br><span class="line"><span class="comment">// from 拷贝起点</span></span><br><span class="line"><span class="comment">// to 拷贝终点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span>[] copyOfRange(<span class="keyword">char</span>[] original, <span class="keyword">int</span> from, <span class="keyword">int</span> to) &#123;</span><br><span class="line">    <span class="comment">// 需要拷贝的长度</span></span><br><span class="line">    <span class="keyword">int</span> newLength = to - from;</span><br><span class="line">    <span class="keyword">if</span> (newLength &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(from + <span class="string">&quot; &gt; &quot;</span> + to);</span><br><span class="line">    <span class="comment">// 初始化新数组</span></span><br><span class="line">    <span class="keyword">char</span>[] copy = <span class="keyword">new</span> <span class="keyword">char</span>[newLength];</span><br><span class="line">    <span class="comment">// 调用 native 方法进行拷贝，参数的意思分别是：</span></span><br><span class="line">    <span class="comment">// 被拷贝的数组、从数组那里开始、目标数组、从目的数组那里开始拷贝、拷贝的长度</span></span><br><span class="line">    System.arraycopy(original, from, copy, <span class="number">0</span>,</span><br><span class="line">                     Math.min(original.length - from, newLength));</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中，我们发现，Arrays 的拷贝方法，实际上底层调用的是 System.arraycopy 这个 native 方法，如果你自己对底层拷贝方法比较熟悉的话，也可以直接使用。</p>
<h3 id="3-Collections"><a href="#3-Collections" class="headerlink" title="3 Collections"></a>3 Collections</h3><p>Collections 是为了方便使用集合而产生的工具类，Arrays 方便数组使用，Collections 是方便集合使用。</p>
<p>Collections 也提供了 sort 和 binarySearch 方法，sort 底层使用的就是 Arrays.sort 方法，binarySearch 底层是自己重写了二分查找算法，实现的逻辑和 Arrays 的二分查找算法完全一致，这两个方法上 Collections 和 Arrays 的内部实现很类似，接下来我们来看下 Collections 独有的特性。</p>
<h4 id="3-1-求集合中最大、小值"><a href="#3-1-求集合中最大、小值" class="headerlink" title="3.1 求集合中最大、小值"></a>3.1 求集合中最大、小值</h4><p>提供了 max 方法来取得集合中的最大值，min 方法来取得集合中的最小值，max 和 min 方法很相似的，我们以 max 方法为例来说明一下，max 提供了两种类型的方法，一个需要传外部排序器，一个不需要传排序器，但需要集合中的元素强制实现 Comparable 接口，后者的泛型定义很有意思，我们来看下（从右往左看）：<br><img src="http://img.mukewang.com/5d5fc50a0001220c19701126.png" alt="图片描述">从这段源码中，我们可以学习到两点：</p>
<ol>
<li>max 方法泛型 T 定义得非常巧妙，意思是泛型必须继承 Object 并且实现 Comparable 的接口。一般让我们来定义的话，我们可以会在方法里面去判断有无实现 Comparable 的接口，这种是在运行时才能知道结果。而这里泛型直接定义了必须实现 Comparable 接口，在编译的时候就可告诉使用者，当前类没有实现 Comparable 接口，使用起来很友好；</li>
<li>给我们提供了实现两种排序机制的好示例：自定义类实现 Comparable 接口和传入外部排序器。两种排序实现原理类似，但实现有所差别，我们在工作中如果需要些排序的工具类时，可以效仿。</li>
</ol>
<h4 id="3-2-多种类型的集合"><a href="#3-2-多种类型的集合" class="headerlink" title="3.2 多种类型的集合"></a>3.2 多种类型的集合</h4><p>Collections 对原始集合类进行了封装，提供了更好的集合类给我们，一种是线程安全的集合，一种是不可变的集合，针对 List、Map、Set 都有提供，我们先来看下线程安全的集合：</p>
<h5 id="3-2-1-线程安全的集合"><a href="#3-2-1-线程安全的集合" class="headerlink" title="3.2.1 线程安全的集合"></a>3.2.1 线程安全的集合</h5><p>线程安全的集合方法都是 synchronized 打头的，如下：<br><img src="http://img.mukewang.com/5d5fc5230001a8ba11460942.png" alt="图片描述">从方法命名我们都可以看出来，底层是通过 synchronized 轻量锁来实现的，我们以 synchronizedList 为例来说明下底层的实现：<br><img src="http://img.mukewang.com/5d5fc55a0001a96b14201306.png" alt="图片描述">可以看到 List 的所有操作方法都被加上了 synchronized 锁，所以多线程对集合同时进行操作，是线程安全的。</p>
<h5 id="3-2-1-不可变的集合"><a href="#3-2-1-不可变的集合" class="headerlink" title="3.2.1 不可变的集合"></a>3.2.1 不可变的集合</h5><p>得到不可变集合的方法都是以 unmodifiable 开头的。这类方法的意思是，我们会从原集合中，得到一个不可变的新集合，新集合只能访问，无法修改；一旦修改，就会抛出异常。这主要是因为只开放了查询方法，其余任何修改操作都会抛出异常，我们以 unmodifiableList 为例来看下底层实现机制：<br><img src="http://img.mukewang.com/5d5fc56c000106c613981318.png" alt="图片描述"></p>
<h5 id="3-2-2-小结"><a href="#3-2-2-小结" class="headerlink" title="3.2.2 小结"></a>3.2.2 小结</h5><p>以上两种 List 其实解决了工作中的一些困惑，比如说 ArrayList 是线程不安全的，然后其内部数组很容易被修改，有的时候，我们希望 List 一旦生成后，就不能被修改，Collections 对 List 重新进行了封装，提供了两种类型的集合封装形式，从而解决了工作中的一些烦恼，如果你平时使用 List 时有一些烦恼，也可以学习此种方式，自己对原始集合进行封装，来解决 List 使用过程中的不方便。</p>
<h3 id="4-Objects"><a href="#4-Objects" class="headerlink" title="4 Objects"></a>4 Objects</h3><p>对于 Objects，我们经常使用的就是两个场景，相等判断和判空。</p>
<h4 id="4-1-相等判断"><a href="#4-1-相等判断" class="headerlink" title="4.1 相等判断"></a>4.1 相等判断</h4><p>Objects 有提供 equals 和 deepEquals 两个方法来进行相等判断，前者是判断基本类型和自定义类的，后者是用来判断数组的，我们来看下底层的源码实现：<br><img src="http://img.mukewang.com/5d5fc5830001b26a23601336.png" alt="图片描述">从源码中，可以看出 Objects 对基本类型和复杂类型的对象，都有着比较细粒度的判断，可以放心使用。</p>
<h4 id="4-2-为空判断"><a href="#4-2-为空判断" class="headerlink" title="4.2 为空判断"></a>4.2 为空判断</h4><p><img src="http://img.mukewang.com/5d5fc59b00010ebc10820386.png" alt="图片描述">Objects 提供了各种关于空的一些判断，isNull 和 nonNull 对于对象是否为空返回 Boolean 值，requireNonNull 方法更加严格，如果一旦为空，会直接抛出异常，我们需要根据生活的场景选择使用。</p>
<h3 id="5-面试题"><a href="#5-面试题" class="headerlink" title="5 面试题"></a>5 面试题</h3><h4 id="5-1-工作中有没有遇到特别好用的工具类，如何写好一个工具类"><a href="#5-1-工作中有没有遇到特别好用的工具类，如何写好一个工具类" class="headerlink" title="5.1 工作中有没有遇到特别好用的工具类，如何写好一个工具类"></a>5.1 工作中有没有遇到特别好用的工具类，如何写好一个工具类</h4><p>答：有的，像 Arrays 的排序、二分查找、Collections 的不可变、线程安全集合类、Objects 的判空相等判断等等工具类，好的工具类肯定很好用，比如说使用 static final 关键字对方法进行修饰，工具类构造器必须是私有等等手段来写好工具类。</p>
<h4 id="5-2-写一个二分查找算法的实现"><a href="#5-2-写一个二分查找算法的实现" class="headerlink" title="5.2 写一个二分查找算法的实现"></a>5.2 写一个二分查找算法的实现</h4><p>答：可以参考 Arrays 的 binarySearch 方法的源码实现。</p>
<h4 id="5-3-如果我希望-ArrayList-初始化之后，不能被修改，该怎么办"><a href="#5-3-如果我希望-ArrayList-初始化之后，不能被修改，该怎么办" class="headerlink" title="5.3 如果我希望 ArrayList 初始化之后，不能被修改，该怎么办"></a>5.3 如果我希望 ArrayList 初始化之后，不能被修改，该怎么办</h4><p>答：可以使用 Collections 的 unmodifiableList 的方法，该方法会返回一个不能被修改的内部类集合，这些集合类只开放查询的方法，对于调用修改集合的方法会直接抛出异常。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>从三大工具类中，我们不仅学习到了如何写好一个工具类，还熟悉了三大工具类的具体使用姿势，甚至了解了其底层的源码实现，有兴趣的话，可以自己也可以仿照写个好用的工具类加深学习。</p>
<h1 id="第2章-集合"><a href="#第2章-集合" class="headerlink" title="第2章 集合"></a><strong>第2章 集合</strong></h1><h2 id="05-ArrayList-源码解析和设计思路"><a href="#05-ArrayList-源码解析和设计思路" class="headerlink" title="05 ArrayList 源码解析和设计思路"></a><strong>05 ArrayList 源码解析和设计思路</strong></h2><h3 id="引导语-3"><a href="#引导语-3" class="headerlink" title="引导语"></a>引导语</h3><p>ArrayList 我们几乎每天都会使用到，但真正面试的时候，发现还是有不少人对源码细节说不清楚，给面试官留下比较差的印象，本小节就和大家一起看看面试中和 ArrayList 相关的源码。</p>
<h3 id="1-整体架构"><a href="#1-整体架构" class="headerlink" title="1 整体架构"></a>1 整体架构</h3><p>ArrayList 整体架构比较简单，就是一个数组结构，比较简单，如下图：<br><img src="http://img.mukewang.com/5d5fc5f80001e20e15080238.png" alt="图片描述">图中展示是长度为 10 的数组，从 1 开始计数，index 表示数组的下标，从 0 开始计数，elementData 表示数组本身，源码中除了这两个概念，还有以下三个基本概念：</p>
<ul>
<li>DEFAULT_CAPACITY 表示数组的初始大小，默认是 10，这个数字要记住；</li>
<li>size 表示当前数组的大小，类型 int，没有使用 volatile 修饰，非线程安全的；</li>
<li>modCount 统计当前数组被修改的版本次数，数组结构有变动，就会 +1。</li>
</ul>
<p><strong>类注释</strong></p>
<p>看源码，首先要看类注释，我们看看类注释上面都说了什么，如下：</p>
<ul>
<li>允许 put null 值，会自动扩容；</li>
<li>size、isEmpty、get、set、add 等方法时间复杂度都是 O (1)；</li>
<li>是非线程安全的，多线程情况下，推荐使用线程安全类：Collections#synchronizedList；</li>
<li>增强 for 循环，或者使用迭代器迭代过程中，如果数组大小被改变，会快速失败，抛出异常。</li>
</ul>
<p>除了上述注释中提到的 4 点，初始化、扩容的本质、迭代器等问题也经常被问，接下来我们从源码出发，一一解析。</p>
<h3 id="2-源码解析"><a href="#2-源码解析" class="headerlink" title="2 源码解析"></a>2 源码解析</h3><h4 id="2-1-初始化"><a href="#2-1-初始化" class="headerlink" title="2.1 初始化"></a>2.1 初始化</h4><p>我们有三种初始化办法：无参数直接初始化、指定大小初始化、指定初始数据初始化，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无参数直接初始化，数组大小为空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定初始数据初始化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//elementData 是保存数组的容器，默认为 null</span></span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="comment">//如果给定的集合（c）数据有值</span></span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="comment">//如果集合元素类型不是 Object 类型，我们会转成 Object</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class) &#123;</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 给定集合（c）无值，则默认空数组</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了源码的中文注释，我们补充两点：</p>
<p>1：ArrayList 无参构造器初始化时，默认大小是空数组，并不是大家常说的 10，10 是在第一次 add 的时候扩容的数组值。</p>
<p>2：指定初始数据初始化时，我们发现一个这样子的注释 see 6260652，这是 Java 的一个 bug，意思是当给定集合内的元素不是 Object 类型时，我们会转化成 Object 的类型。一般情况下都不会触发此 bug，只有在下列场景下才会触发：ArrayList 初始化之后（ArrayList 元素非 Object 类型），再次调用 toArray 方法，得到 Object 数组，并且往 Object 数组赋值时，才会触发此 bug，代码和原因如图：<br><img src="http://img.mukewang.com/5d5fc6100001109518100714.png" alt="图片描述">官方查看文档地址：<a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6260652%EF%BC%8C%E9%97%AE%E9%A2%98%E5%9C%A8">https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6260652，问题在</a> Java 9 中被解决。</p>
<h4 id="2-2-新增和扩容实现"><a href="#2-2-新增和扩容实现" class="headerlink" title="2.2 新增和扩容实现"></a>2.2 新增和扩容实现</h4><p>新增就是往数组中添加元素，主要分成两步：</p>
<ul>
<li>判断是否需要扩容，如果需要执行扩容操作；</li>
<li>直接赋值。</li>
</ul>
<p>两步源码体现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//确保数组大小是否足够，不够执行扩容，size 为当前数组的大小</span></span><br><span class="line">  ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">  <span class="comment">//直接赋值，线程不安全的</span></span><br><span class="line">  elementData[size++] = e;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先看下扩容（ensureCapacityInternal）的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//如果初始化数组大小时，有给定初始值，以给定的大小为准，不走 if 逻辑</span></span><br><span class="line">  <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">    minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//确保容积足够</span></span><br><span class="line">  ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//记录数组被修改</span></span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="comment">// 如果我们期望的最小容量大于目前数组的长度，那么就扩容</span></span><br><span class="line">  <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">    grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扩容，并把现有数据拷贝到新的数组里面去</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">  <span class="comment">// oldCapacity &gt;&gt; 1 是把 oldCapacity 除以 2 的意思</span></span><br><span class="line">  <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果扩容后的值 &lt; 我们的期望值，扩容后的值就等于我们的期望值</span></span><br><span class="line">  <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = minCapacity;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果扩容后的值 &gt; jvm 所能分配的数组的最大值，那么就用 Integer 的最大值</span></span><br><span class="line">  <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = hugeCapacity(minCapacity);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 通过复制进行扩容</span></span><br><span class="line">  elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解应该比较详细，我们需要注意的四点是：</p>
<ul>
<li>扩容的规则并不是翻倍，是原来容量大小 + 容量大小的一半，直白来说，扩容后的大小是原来容量的 1.5 倍；</li>
<li>ArrayList 中的数组的最大值是 Integer.MAX_VALUE，超过这个值，JVM 就不会给数组分配内存空间了。</li>
<li>新增时，并没有对值进行严格的校验，所以 ArrayList 是允许 null 值的。</li>
</ul>
<p>从新增和扩容源码中，下面这点值得我们借鉴：</p>
<ul>
<li>源码在扩容的时候，有数组大小溢出意识，就是说扩容后数组的大小下界不能小于 0，上界不能大于 Integer 的最大值，这种意识我们可以学习。</li>
</ul>
<p>扩容完成之后，赋值是非常简单的，直接往数组上添加元素即可：elementData [size++] = e。也正是通过这种简单赋值，没有任何锁控制，所以这里的操作是线程不安全的，对于新增和扩容的实现，画了一个动图，如下：<br><img src="http://img.mukewang.com/5d5fc62e000112c203600240.gif" alt="图片描述"></p>
<h4 id="2-3-扩容的本质"><a href="#2-3-扩容的本质" class="headerlink" title="2.3 扩容的本质"></a>2.3 扩容的本质</h4><p>扩容是通过这行代码来实现的：<code>Arrays.copyOf(elementData, newCapacity);</code>，这行代码描述的本质是数组之间的拷贝，扩容是会先新建一个符合我们预期容量的新数组，然后把老数组的数据拷贝过去，我们通过 System.arraycopy 方法进行拷贝，此方法是 native 的方法，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> src     被拷贝的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> srcPos  从数组那里开始</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dest    目标数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> destPos 从目标数组那个索引位置开始拷贝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length  拷贝的长度 </span></span><br><span class="line"><span class="comment"> * 此方法是没有返回值的，通过 dest 的引用进行传值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src, <span class="keyword">int</span> srcPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Object dest, <span class="keyword">int</span> destPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure>

<p>我们可以通过下面这行代码进行调用，newElementData 表示新的数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.arraycopy(elementData, <span class="number">0</span>, newElementData, <span class="number">0</span>,Math.min(elementData.length,newCapacity))</span><br></pre></td></tr></table></figure>



<h4 id="2-4-删除"><a href="#2-4-删除" class="headerlink" title="2.4 删除"></a>2.4 删除</h4><p>ArrayList 删除元素有很多种方式，比如根据数组索引删除、根据值删除或批量删除等等，原理和思路都差不多，我们选取根据值删除方式来进行源码说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果要删除的值是 null，找到第一个值是 null 的删除</span></span><br><span class="line">  <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">      <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        fastRemove(index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果要删除的值不为 null，找到第一个和要删除的值相等的删除</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">      <span class="comment">// 这里是根据  equals 来判断值相等的，相等后再根据索引位置进行删除</span></span><br><span class="line">      <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">        fastRemove(index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们需要注意的两点是：</p>
<ul>
<li>新增的时候是没有对 null 进行校验的，所以删除的时候也是允许删除 null 值的；</li>
<li>找到值在数组中的索引位置，是通过 equals 来判断的，如果数组元素不是基本类型，需要我们关注 equals 的具体实现。</li>
</ul>
<p>上面代码已经找到要删除元素的索引位置了，下面代码是根据索引位置进行元素的删除：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 记录数组的结构要发生变动了</span></span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="comment">// numMoved 表示删除 index 位置的元素后，需要从 index 后移动多少个元素到前面去</span></span><br><span class="line">  <span class="comment">// 减 1 的原因，是因为 size 从 1 开始算起，index 从 0开始算起</span></span><br><span class="line">  <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 从 index +1 位置开始被拷贝，拷贝的起始位置是 index，长度是 numMoved</span></span><br><span class="line">    System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">  <span class="comment">//数组最后一个位置赋值 null，帮助 GC</span></span><br><span class="line">  elementData[--size] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中，我们可以看出，某一个元素被删除后，为了维护数组结构，我们都会把数组后面的元素往前移动，下面动图也演示了其过程：<br><img src="http://img.mukewang.com/5d5fc643000142a403600240.gif" alt="图片描述"></p>
<h4 id="2-5-迭代器"><a href="#2-5-迭代器" class="headerlink" title="2.5 迭代器"></a>2.5 迭代器</h4><p>如果要自己实现迭代器，实现 java.util.Iterator 类就好了，ArrayList 也是这样做的，我们来看下迭代器的几个总要的参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cursor;<span class="comment">// 迭代过程中，下一个元素的位置，默认从 0 开始。</span></span><br><span class="line"><span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// 新增场景：表示上一次迭代过程中，索引的位置；删除场景：为 -1。</span></span><br><span class="line"><span class="keyword">int</span> expectedModCount = modCount;<span class="comment">// expectedModCount 表示迭代过程中，期望的版本号；modCount 表示数组实际的版本号。</span></span><br></pre></td></tr></table></figure>

<p>迭代器一般来说有三个方法：</p>
<ul>
<li>hasNext 还有没有值可以迭代</li>
<li>next 如果有值可以迭代，迭代的值是多少</li>
<li>remove 删除当前迭代的值</li>
</ul>
<p>我们来分别看下三个方法的源码：</p>
<p><strong>hasNext</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> cursor != size;<span class="comment">//cursor 表示下一个元素的位置，size 表示实际大小，如果两者相等，说明已经没有元素可以迭代了，如果不等，说明还可以迭代</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>next</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//迭代过程中，判断版本号有无被修改，有被修改，抛 ConcurrentModificationException 异常</span></span><br><span class="line">  checkForComodification();</span><br><span class="line">  <span class="comment">//本次迭代过程中，元素的索引位置</span></span><br><span class="line">  <span class="keyword">int</span> i = cursor;</span><br><span class="line">  <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">  Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">  <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">  <span class="comment">// 下一次迭代时，元素的位置，为下一次迭代做准备</span></span><br><span class="line">  cursor = i + <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 返回元素值</span></span><br><span class="line">  <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 版本号比较</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中可以看到，next 方法就干了两件事情，第一是检验能不能继续迭代，第二是找到迭代的值，并为下一次迭代做准备（cursor+1）。</p>
<p><strong>remove</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果上一次操作时，数组的位置已经小于 0 了，说明数组已经被删除完了</span></span><br><span class="line">  <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">  <span class="comment">//迭代过程中，判断版本号有无被修改，有被修改，抛 ConcurrentModificationException 异常</span></span><br><span class="line">  checkForComodification();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">    cursor = lastRet;</span><br><span class="line">    <span class="comment">// -1 表示元素已经被删除，这里也防止重复删除</span></span><br><span class="line">    lastRet = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 删除元素时 modCount 的值已经发生变化，在此赋值给 expectedModCount</span></span><br><span class="line">    <span class="comment">// 这样下次迭代时，两者的值是一致的了</span></span><br><span class="line">    expectedModCount = modCount;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们需要注意的两点是：</p>
<ul>
<li>lastRet = -1 的操作目的，是防止重复删除操作</li>
<li>删除元素成功，数组当前 modCount 就会发生变化，这里会把 expectedModCount 重新赋值，下次迭代时两者的值就会一致了</li>
</ul>
<h4 id="2-6-时间复杂度"><a href="#2-6-时间复杂度" class="headerlink" title="2.6 时间复杂度"></a>2.6 时间复杂度</h4><p>从我们上面新增或删除方法的源码解析，对数组元素的操作，只需要根据数组索引，直接新增和删除，所以时间复杂度是 O (1)。</p>
<h4 id="2-7-线程安全"><a href="#2-7-线程安全" class="headerlink" title="2.7 线程安全"></a>2.7 线程安全</h4><p>我们需要强调的是，只有当 ArrayList 作为共享变量时，才会有线程安全问题，当 ArrayList 是方法内的局部变量时，是没有线程安全的问题的。</p>
<p>ArrayList 有线程安全问题的本质，是因为 ArrayList 自身的 elementData、size、modConut 在进行各种操作时，都没有加锁，而且这些变量的类型并非是可见（volatile）的，所以如果多个线程对这些变量进行操作时，可能会有值被覆盖的情况。</p>
<p>类注释中推荐我们使用 Collections#synchronizedList 来保证线程安全，SynchronizedList 是通过在每个方法上面加上锁来实现，虽然实现了线程安全，但是性能大大降低，具体实现源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;<span class="comment">// synchronized 是一种轻量锁，mutex 表示一个当前 SynchronizedList</span></span><br><span class="line">        <span class="keyword">return</span> c.add(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>本文从 ArrayList 整体架构出发，落地到初始化、新增、扩容、删除、迭代等核心源码实现，我们发现 ArrayList 其实就是围绕底层数组结构，各个 API 都是对数组的操作进行封装，让使用者无需感知底层实现，只需关注如何使用即可。</p>
<h2 id="06-LinkedList-源码解析"><a href="#06-LinkedList-源码解析" class="headerlink" title="06 LinkedList 源码解析"></a><strong>06 LinkedList 源码解析</strong></h2><h3 id="引导语-4"><a href="#引导语-4" class="headerlink" title="引导语"></a>引导语</h3><p>LinkedList 适用于集合元素先入先出和先入后出的场景，在队列源码中被频繁使用，面试也经常问到，本小节让我们通过源码来加深对 LinkedList 的了解。</p>
<h3 id="1-整体架构-1"><a href="#1-整体架构-1" class="headerlink" title="1 整体架构"></a>1 整体架构</h3><p>LinkedList 底层数据结构是一个双向链表，整体结构如下图所示：<br><img src="http://img.mukewang.com/5d5fc67a0001f59212400288.png" alt="图片描述">上图代表了一个双向链表结构，链表中的每个节点都可以向前或者向后追溯，我们有几个概念如下：</p>
<ul>
<li>链表每个节点我们叫做 Node，Node 有 prev 属性，代表前一个节点的位置，next 属性，代表后一个节点的位置；</li>
<li>first 是双向链表的头节点，它的前一个节点是 null。</li>
<li>last 是双向链表的尾节点，它的后一个节点是 null；</li>
<li>当链表中没有数据时，first 和 last 是同一个节点，前后指向都是 null；</li>
<li>因为是个双向链表，只要机器内存足够强大，是没有大小限制的。</li>
</ul>
<p>链表中的元素叫做 Node，我们看下 Node 的组成部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;<span class="comment">// 节点值</span></span><br><span class="line">    Node&lt;E&gt; next; <span class="comment">// 指向的下一个节点</span></span><br><span class="line">    Node&lt;E&gt; prev; <span class="comment">// 指向的前一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化参数顺序分别是：前一个节点、本身节点值、后一个节点</span></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-源码解析-1"><a href="#2-源码解析-1" class="headerlink" title="2 源码解析"></a>2 源码解析</h3><h4 id="2-1-追加（新增）"><a href="#2-1-追加（新增）" class="headerlink" title="2.1 追加（新增）"></a>2.1 追加（新增）</h4><p>追加节点时，我们可以选择追加到链表头部，还是追加到链表尾部，add 方法默认是从尾部开始追加，addFirst 方法是从头部开始追加，我们分别来看下两种不同的追加方式：</p>
<p><strong>从尾部追加（add）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从尾部开始追加节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 把尾节点数据暂存</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">// 新建新的节点，初始化入参含义：</span></span><br><span class="line">    <span class="comment">// l 是新节点的前一个节点，当前值是尾节点值</span></span><br><span class="line">    <span class="comment">// e 表示当前新增节点，当前新增节点后一个节点是 null</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 新建节点追加到尾部</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">//如果链表为空（l 是尾节点，尾节点为空，链表即空），头部和尾部是同一个节点，都是新建的节点</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;![图片描述](<span class="comment">//img.mukewang.com/5d5fc69600013e4803600240.gif)</span></span><br><span class="line">    <span class="comment">//否则把前尾节点的下一个节点，指向当前尾节点。</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    <span class="comment">//大小和版本更改</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码上来看，尾部追加节点比较简单，只需要简单地把指向位置修改下即可，我们做个动图来描述下整个过程：<br><img src="http://img.mukewang.com/5d5fc6a300013e4803600240.gif" alt="图片描述"><br><strong>从头部追加（addFirst）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从头部追加</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 头节点赋值给临时变量</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="comment">// 新建节点，前一个节点指向null，e 是新建节点，f 是新建节点的下一个节点，目前值是头节点的值</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">    <span class="comment">// 新建节点成为头节点</span></span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="comment">// 头节点为空，就是链表为空，头尾节点是一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="comment">//上一个头节点的前一个节点指向当前节点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>头部追加节点和尾部追加节点非常类似，只是前者是移动头节点的 prev 指向，后者是移动尾节点的 next 指向。</p>
<h4 id="2-2-节点删除"><a href="#2-2-节点删除" class="headerlink" title="2.2 节点删除"></a>2.2 节点删除</h4><p>节点删除的方式和追加类似，我们可以选择从头部删除，也可以选择从尾部删除，删除操作会把节点的值，前后指向节点都置为 null，帮助 GC 进行回收。</p>
<p><strong>从头部删除</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从头删除节点 f 是链表头节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 拿出头节点的值，作为方法的返回值</span></span><br><span class="line">    <span class="keyword">final</span> E element = f.item;</span><br><span class="line">    <span class="comment">// 拿出头节点的下一个节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">    <span class="comment">//帮助 GC 回收头节点</span></span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    f.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 头节点的下一个节点成为头节点</span></span><br><span class="line">    first = next;</span><br><span class="line">    <span class="comment">//如果 next 为空，表明链表为空</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//链表不为空，头节点的前一个节点指向 null</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        next.prev = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//修改链表大小和版本</span></span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从尾部删除节点代码也是类似的，就不贴了。</p>
<p><strong>从源码中我们可以了解到，链表结构的节点新增、删除都非常简单，仅仅把前后节点的指向修改下就好了，所以 LinkedList 新增和删除速度很快。</strong></p>
<h4 id="2-3-节点查询"><a href="#2-3-节点查询" class="headerlink" title="2.3 节点查询"></a>2.3 节点查询</h4><p>链表查询某一个节点是比较慢的，需要挨个循环查找才行，我们看看 LinkedList 的源码是如何寻找节点的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据链表索引位置查询节点</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果 index 处于队列的前半部分，从头开始找，size &gt;&gt; 1 是 size 除以 2 的意思。</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="comment">// 直到 for 循环到 index 的前一个 node 停止</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果 index 处于队列的后半部分，从尾开始找</span></span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="comment">// 直到 for 循环到 index 的后一个 node 停止</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中我们可以发现，LinkedList 并没有采用从头循环到尾的做法，而是采取了简单二分法，首先看看 index 是在链表的前半部分，还是后半部分。如果是前半部分，就从头开始寻找，反之亦然。通过这种方式，使循环的次数至少降低了一半，提高了查找的性能，这种思想值得我们借鉴。</p>
<h4 id="2-4-方法对比"><a href="#2-4-方法对比" class="headerlink" title="2.4 方法对比"></a>2.4 方法对比</h4><p>LinkedList 实现了 Queue 接口，在新增、删除、查询等方面增加了很多新的方法，这些方法在平时特别容易混淆，在链表为空的情况下，返回值也不太一样，我们列一个表格，方便大家记录：</p>
<table>
<thead>
<tr>
<th align="left">方法含义</th>
<th align="left">返回异常</th>
<th align="left">返回特殊值</th>
<th align="left">底层实现</th>
</tr>
</thead>
<tbody><tr>
<td align="left">新增</td>
<td align="left">add(e)</td>
<td align="left">offer(e)</td>
<td align="left">底层实现相同</td>
</tr>
<tr>
<td align="left">删除</td>
<td align="left">remove()</td>
<td align="left">poll(e)</td>
<td align="left">链表为空时，remove 会抛出异常，poll 返回 null。</td>
</tr>
<tr>
<td align="left">查找</td>
<td align="left">element()</td>
<td align="left">peek()</td>
<td align="left">链表为空时，element 会抛出异常，peek 返回 null。</td>
</tr>
</tbody></table>
<p>PS：Queue 接口注释建议 add 方法操作失败时抛出异常，但 LinkedList 实现的 add 方法一直返回 true。<br>LinkedList 也实现了 Deque 接口，对新增、删除和查找都提供从头开始，还是从尾开始两种方向的方法，比如 remove 方法，Deque 提供了 removeFirst 和 removeLast 两种方向的使用方式，但当链表为空时的表现都和 remove 方法一样，都会抛出异常。</p>
<h4 id="2-5-迭代器-1"><a href="#2-5-迭代器-1" class="headerlink" title="2.5 迭代器"></a>2.5 迭代器</h4><p>因为 LinkedList 要实现双向的迭代访问，所以我们使用 Iterator 接口肯定不行了，因为 Iterator 只支持从头到尾的访问。Java 新增了一个迭代接口，叫做：ListIterator，这个接口提供了向前和向后的迭代方法，如下所示：</p>
<table>
<thead>
<tr>
<th align="left">迭代顺序</th>
<th align="left">方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">从尾到头迭代方法</td>
<td align="left">hasPrevious、previous、previousIndex</td>
</tr>
<tr>
<td align="left">从头到尾迭代方法</td>
<td align="left">hasNext、next、nextIndex</td>
</tr>
</tbody></table>
<p>LinkedList 实现了 ListIterator 接口，如下图所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双向迭代器</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; lastReturned;<span class="comment">//上一次执行 next() 或者 previos() 方法时的节点位置</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; next;<span class="comment">//下一个节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> nextIndex;<span class="comment">//下一个节点的位置</span></span><br><span class="line">    <span class="comment">//expectedModCount：期望版本号；modCount：目前最新版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    …………</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先来看下从头到尾方向的迭代：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断还有没有下一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextIndex &lt; size;<span class="comment">// 下一个节点的索引小于链表的大小，就有</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取下一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查期望版本号有无发生变化</span></span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="keyword">if</span> (!hasNext())<span class="comment">//再次检查</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="comment">// next 是当前节点，在上一次执行 next() 方法时被赋值的。</span></span><br><span class="line">    <span class="comment">// 第一次执行时，是在初始化迭代器的时候，next 被赋值的</span></span><br><span class="line">    lastReturned = next;</span><br><span class="line">    <span class="comment">// next 是下一个节点了，为下次迭代做准备</span></span><br><span class="line">    next = next.next;</span><br><span class="line">    nextIndex++;</span><br><span class="line">    <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述源码的思路就是直接取当前节点的下一个节点，而从尾到头迭代稍微复杂一点，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果上次节点索引位置大于 0，就还有节点可以迭代</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextIndex &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取前一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="keyword">if</span> (!hasPrevious())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="comment">// next 为空场景：1:说明是第一次迭代，取尾节点(last);2:上一次操作把尾节点删除掉了</span></span><br><span class="line">    <span class="comment">// next 不为空场景：说明已经发生过迭代了，直接取前一个节点即可(next.prev)</span></span><br><span class="line">    lastReturned = next = (next == <span class="keyword">null</span>) ? last : next.prev;</span><br><span class="line">    <span class="comment">// 索引位置变化</span></span><br><span class="line">    nextIndex--;</span><br><span class="line">    <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里复杂点体现在需要判断 next 不为空和为空的场景，代码注释中有详细的描述。</p>
<p><strong>迭代器删除</strong></p>
<p>LinkedList 在删除元素时，也推荐通过迭代器进行删除，删除过程如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="comment">// lastReturned 是本次迭代需要删除的值，分以下空和非空两种情况：</span></span><br><span class="line">    <span class="comment">// lastReturned 为空，说明调用者没有主动执行过 next() 或者 previos()，直接报错</span></span><br><span class="line">    <span class="comment">// lastReturned 不为空，是在上次执行 next() 或者 previos()方法时赋的值</span></span><br><span class="line">    <span class="keyword">if</span> (lastReturned == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    Node&lt;E&gt; lastNext = lastReturned.next;</span><br><span class="line">    <span class="comment">//删除当前节点</span></span><br><span class="line">    unlink(lastReturned);</span><br><span class="line">    <span class="comment">// next == lastReturned 的场景分析：从尾到头递归顺序，并且是第一次迭代，并且要删除最后一个元素的情况下</span></span><br><span class="line">    <span class="comment">// 这种情况下，previous() 方法里面设置了 lastReturned = next = last,所以 next 和 lastReturned会相等</span></span><br><span class="line">    <span class="keyword">if</span> (next == lastReturned)</span><br><span class="line">        <span class="comment">// 这时候 lastReturned 是尾节点，lastNext 是 null，所以 next 也是 null，这样在 previous() 执行时，发现 next 是 null，就会把尾节点赋值给 next</span></span><br><span class="line">        next = lastNext;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        nextIndex--;</span><br><span class="line">    lastReturned = <span class="keyword">null</span>;</span><br><span class="line">    expectedModCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>LinkedList 适用于要求有顺序、并且会按照顺序进行迭代的场景，主要是依赖于底层的链表结构，在面试中的频率还是蛮高的，相信理清楚上面的源码后，应对面试应该没有问题。</p>
<h2 id="07-List-源码会问哪些面试题"><a href="#07-List-源码会问哪些面试题" class="headerlink" title="07 List 源码会问哪些面试题"></a><strong>07 List 源码会问哪些面试题</strong></h2><h3 id="引导语-5"><a href="#引导语-5" class="headerlink" title="引导语"></a>引导语</h3><p>List 作为工作中最常见的集合类型，在面试过程中，也是经常会被问到各种各样的面试题，一般来说，只要你看过源码，心中对 List 的总体结构和细节有所了解的话，基本问题都不大。</p>
<h3 id="1-面试题"><a href="#1-面试题" class="headerlink" title="1 面试题"></a>1 面试题</h3><h4 id="1-1-说说你自己对-ArrayList-的理解？"><a href="#1-1-说说你自己对-ArrayList-的理解？" class="headerlink" title="1.1 说说你自己对 ArrayList 的理解？"></a>1.1 说说你自己对 ArrayList 的理解？</h4><p>很多面试官喜欢这样子开头，考察面试同学对 ArrayList 有没有总结经验，介于 ArrayList 内容很多，建议先回答总体架构，再从某个细节出发作为突破口，比如这样：<br>ArrayList 底层数据结构是个数组，其 API 都做了一层对数组底层访问的封装，比如说 add 方法的过程是……（这里可以引用我们在 ArrayList 源码解析中 add 的过程）。</p>
<p>一般面试官看你回答得井井有条，并且没啥漏洞的话，基本就不会深究了，这样面试的主动权就掌握在自己手里面了，如果你回答得支支吾吾，那么面试官可能就会开启自己面试的套路了。</p>
<p>说说你自己对 LinkedList 的理解也是同样套路。</p>
<h4 id="1-2-扩容类问题"><a href="#1-2-扩容类问题" class="headerlink" title="1.2 扩容类问题"></a>1.2 扩容类问题</h4><h5 id="1-2-1-ArrayList-无参数构造器构造，现在-add-一个值进去，此时数组的大小是多少，下一次扩容前最大可用大小是多少？"><a href="#1-2-1-ArrayList-无参数构造器构造，现在-add-一个值进去，此时数组的大小是多少，下一次扩容前最大可用大小是多少？" class="headerlink" title="1.2.1 ArrayList 无参数构造器构造，现在 add 一个值进去，此时数组的大小是多少，下一次扩容前最大可用大小是多少？"></a>1.2.1 ArrayList 无参数构造器构造，现在 add 一个值进去，此时数组的大小是多少，下一次扩容前最大可用大小是多少？</h5><p>答：此处数组的大小是 1，下一次扩容前最大可用大小是 10，因为 ArrayList 第一次扩容时，是有默认值的，默认值是 10，在第一次 add 一个值进去时，数组的可用大小被扩容到 10 了。</p>
<h5 id="1-2-2-如果我连续往-list-里面新增值，增加到第-11-个的时候，数组的大小是多少？"><a href="#1-2-2-如果我连续往-list-里面新增值，增加到第-11-个的时候，数组的大小是多少？" class="headerlink" title="1.2.2 如果我连续往 list 里面新增值，增加到第 11 个的时候，数组的大小是多少？"></a>1.2.2 如果我连续往 list 里面新增值，增加到第 11 个的时候，数组的大小是多少？</h5><p>答：这里的考查点就是扩容的公式，当增加到 11 的时候，此时我们希望数组的大小为 11，但实际上数组的最大容量只有 10，不够了就需要扩容，扩容的公式是：oldCapacity + (oldCapacity&gt;&gt; 1)，oldCapacity 表示数组现有大小，目前场景计算公式是：10 + 10 ／2 = 15，然后我们发现 15 已经够用了，所以数组的大小会被扩容到 15。</p>
<h5 id="1-2-3-数组初始化，被加入一个值后，如果我使用-addAll-方法，一下子加入-15-个值，那么最终数组的大小是多少？"><a href="#1-2-3-数组初始化，被加入一个值后，如果我使用-addAll-方法，一下子加入-15-个值，那么最终数组的大小是多少？" class="headerlink" title="1.2.3 数组初始化，被加入一个值后，如果我使用 addAll 方法，一下子加入 15 个值，那么最终数组的大小是多少？"></a>1.2.3 数组初始化，被加入一个值后，如果我使用 addAll 方法，一下子加入 15 个值，那么最终数组的大小是多少？</h5><p>答：第一题中我们已经计算出来数组在加入一个值后，实际大小是 1，最大可用大小是 10 ，现在需要一下子加入 15 个值，那我们期望数组的大小值就是 16，此时数组最大可用大小只有 10，明显不够，需要扩容，扩容后的大小是：10 + 10 ／2 = 15，这时候发现扩容后的大小仍然不到我们期望的值 16，这时候源码中有一种策略如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// newCapacity 本次扩容的大小，minCapacity 我们期望的数组最小大小</span></span><br><span class="line"><span class="comment">// 如果扩容后的值 &lt; 我们的期望值，我们的期望值就等于本次扩容的大小</span></span><br><span class="line"><span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = minCapacity;</span><br></pre></td></tr></table></figure>

<p>所以最终数组扩容后的大小为 16。</p>
<h5 id="1-2-4-现在我有一个很大的数组需要拷贝，原数组大小是-5k，请问如何快速拷贝？"><a href="#1-2-4-现在我有一个很大的数组需要拷贝，原数组大小是-5k，请问如何快速拷贝？" class="headerlink" title="1.2.4 现在我有一个很大的数组需要拷贝，原数组大小是 5k，请问如何快速拷贝？"></a>1.2.4 现在我有一个很大的数组需要拷贝，原数组大小是 5k，请问如何快速拷贝？</h5><p>答：因为原数组比较大，如果新建新数组的时候，不指定数组大小的话，就会频繁扩容，频繁扩容就会有大量拷贝的工作，造成拷贝的性能低下，所以回答说新建数组时，指定新数组的大小为 5k 即可。</p>
<h5 id="1-2-5-为什么说扩容会消耗性能？"><a href="#1-2-5-为什么说扩容会消耗性能？" class="headerlink" title="1.2.5 为什么说扩容会消耗性能？"></a>1.2.5 为什么说扩容会消耗性能？</h5><p>答：扩容底层使用的是 System.arraycopy 方法，会把原数组的数据全部拷贝到新数组上，所以性能消耗比较严重。</p>
<h5 id="1-2-6-源码扩容过程有什么值得借鉴的地方？"><a href="#1-2-6-源码扩容过程有什么值得借鉴的地方？" class="headerlink" title="1.2.6 源码扩容过程有什么值得借鉴的地方？"></a>1.2.6 源码扩容过程有什么值得借鉴的地方？</h5><p>答：有两点：</p>
<ul>
<li>是扩容的思想值得学习，通过自动扩容的方式，让使用者不用关心底层数据结构的变化，封装得很好，1.5 倍的扩容速度，可以让扩容速度在前期缓慢上升，在后期增速较快，大部分工作中要求数组的值并不是很大，所以前期增长缓慢有利于节省资源，在后期增速较快时，也可快速扩容。</li>
<li>扩容过程中，有数组大小溢出的意识，比如要求扩容后的数组大小，不能小于 0，不能大于 Integer 的最大值。</li>
</ul>
<p>这两点在我们平时设计和写代码时都可以借鉴。</p>
<h3 id="2-删除类问题"><a href="#2-删除类问题" class="headerlink" title="2 删除类问题"></a>2 删除类问题</h3><h5 id="2-1-有一个-ArrayList，数据是-2、3、3、3、4，中间有三个-3，现在我通过-for-int-i-0-i-lt-list-size-i-的方式，想把值是-3-的元素删除，请问可以删除干净么？最终删除的结果是什么，为什么？删除代码如下："><a href="#2-1-有一个-ArrayList，数据是-2、3、3、3、4，中间有三个-3，现在我通过-for-int-i-0-i-lt-list-size-i-的方式，想把值是-3-的元素删除，请问可以删除干净么？最终删除的结果是什么，为什么？删除代码如下：" class="headerlink" title="2.1 有一个 ArrayList，数据是 2、3、3、3、4，中间有三个 3，现在我通过 for (int i=0;i&lt;list.size ();i++) 的方式，想把值是 3 的元素删除，请问可以删除干净么？最终删除的结果是什么，为什么？删除代码如下："></a>2.1 有一个 ArrayList，数据是 2、3、3、3、4，中间有三个 3，现在我通过 for (int i=0;i&lt;list.size ();i++) 的方式，想把值是 3 的元素删除，请问可以删除干净么？最终删除的结果是什么，为什么？删除代码如下：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;() &#123;&#123;</span><br><span class="line">  add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">  add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">  add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">  add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">  add(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (list.get(i).equals(<span class="string">&quot;3&quot;</span>)) &#123;</span><br><span class="line">    list.remove(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答：不能删除干净，最终删除的结果是 2、3、4，有一个 3 删除不掉，原因我们看下图：<br><img src="http://img.mukewang.com/5d5fc748000129db13361068.png" alt="图片描述">从图中我们可以看到，每次删除一个元素后，该元素后面的元素就会往前移动，而此时循环的 i 在不断地增长，最终会使每次删除 3 的后一个 3 被遗漏，导致删除不掉。</p>
<h5 id="2-2-还是上面的-ArrayList-数组，我们通过增强-for-循环进行删除，可以么？"><a href="#2-2-还是上面的-ArrayList-数组，我们通过增强-for-循环进行删除，可以么？" class="headerlink" title="2.2 还是上面的 ArrayList 数组，我们通过增强 for 循环进行删除，可以么？"></a>2.2 还是上面的 ArrayList 数组，我们通过增强 for 循环进行删除，可以么？</h5><p>答：不可以，会报错。因为增强 for 循环过程其实调用的就是迭代器的 next () 方法，当你调用 list#remove () 方法进行删除时，modCount 的值会 +1，而这时候迭代器中的 expectedModCount 的值却没有变，导致在迭代器下次执行 next () 方法时，expectedModCount != modCount 就会报 ConcurrentModificationException 的错误。</p>
<h5 id="2-3-还是上面的数组，如果删除时使用-Iterator-remove-方法可以删除么，为什么？"><a href="#2-3-还是上面的数组，如果删除时使用-Iterator-remove-方法可以删除么，为什么？" class="headerlink" title="2.3 还是上面的数组，如果删除时使用 Iterator.remove () 方法可以删除么，为什么？"></a>2.3 还是上面的数组，如果删除时使用 Iterator.remove () 方法可以删除么，为什么？</h5><p>答：可以的，因为 Iterator.remove () 方法在执行的过程中，会把最新的 modCount 赋值给 expectedModCount，这样在下次循环过程中，modCount 和 expectedModCount 两者就会相等。</p>
<h5 id="2-4-以上三个问题对于-LinkedList-也是同样的结果么？"><a href="#2-4-以上三个问题对于-LinkedList-也是同样的结果么？" class="headerlink" title="2.4 以上三个问题对于 LinkedList 也是同样的结果么？"></a>2.4 以上三个问题对于 LinkedList 也是同样的结果么？</h5><p>答：是的，虽然 LinkedList 底层结构是双向链表，但对于上述三个问题，结果和 ArrayList 是一致的。</p>
<h3 id="3-对比类问题"><a href="#3-对比类问题" class="headerlink" title="3 对比类问题"></a>3 对比类问题</h3><h5 id="3-1-ArrayList-和-LinkedList-有何不同？"><a href="#3-1-ArrayList-和-LinkedList-有何不同？" class="headerlink" title="3.1 ArrayList 和 LinkedList 有何不同？"></a>3.1 ArrayList 和 LinkedList 有何不同？</h5><p>答：可以先从底层数据结构开始说起，然后以某一个方法为突破口深入，比如：最大的不同是两者底层的数据结构不同，ArrayList 底层是数组，LinkedList 底层是双向链表，两者的数据结构不同也导致了操作的 API 实现有所差异，拿新增实现来说，ArrayList 会先计算并决定是否扩容，然后把新增的数据直接赋值到数组上，而 LinkedList 仅仅只需要改变插入节点和其前后节点的指向位置关系即可。</p>
<h5 id="3-2-ArrayList-和-LinkedList-应用场景有何不同"><a href="#3-2-ArrayList-和-LinkedList-应用场景有何不同" class="headerlink" title="3.2 ArrayList 和 LinkedList 应用场景有何不同"></a>3.2 ArrayList 和 LinkedList 应用场景有何不同</h5><p>答：ArrayList 更适合于快速的查找匹配，不适合频繁新增删除，像工作中经常会对元素进行匹配查询的场景比较合适，LinkedList 更适合于经常新增和删除，对查询反而很少的场景。</p>
<h5 id="3-3-ArrayList-和-LinkedList-两者有没有最大容量"><a href="#3-3-ArrayList-和-LinkedList-两者有没有最大容量" class="headerlink" title="3.3 ArrayList 和 LinkedList 两者有没有最大容量"></a>3.3 ArrayList 和 LinkedList 两者有没有最大容量</h5><p>答：ArrayList 有最大容量的，为 Integer 的最大值，大于这个值 JVM 是不会为数组分配内存空间的，LinkedList 底层是双向链表，理论上可以无限大。但源码中，LinkedList 实际大小用的是 int 类型，这也说明了 LinkedList 不能超过 Integer 的最大值，不然会溢出。</p>
<h5 id="3-4-ArrayList-和-LinkedList-是如何对-null-值进行处理的"><a href="#3-4-ArrayList-和-LinkedList-是如何对-null-值进行处理的" class="headerlink" title="3.4 ArrayList 和 LinkedList 是如何对 null 值进行处理的"></a>3.4 ArrayList 和 LinkedList 是如何对 null 值进行处理的</h5><p>答：ArrayList 允许 null 值新增，也允许 null 值删除。删除 null 值时，是从头开始，找到第一值是 null 的元素删除；LinkedList 新增删除时对 null 值没有特殊校验，是允许新增和删除的。</p>
<h5 id="3-5-ArrayList-和-LinedList-是线程安全的么，为什么？"><a href="#3-5-ArrayList-和-LinedList-是线程安全的么，为什么？" class="headerlink" title="3.5 ArrayList 和 LinedList 是线程安全的么，为什么？"></a>3.5 ArrayList 和 LinedList 是线程安全的么，为什么？</h5><p>答：当两者作为非共享变量时，比如说仅仅是在方法里面的局部变量时，是没有线程安全问题的，只有当两者是共享变量时，才会有线程安全问题。主要的问题点在于多线程环境下，所有线程任何时刻都可对数组和链表进行操作，这会导致值被覆盖，甚至混乱的情况。</p>
<p>如果有线程安全问题，在迭代的过程中，会频繁报 ConcurrentModificationException 的错误，意思是在我当前循环的过程中，数组或链表的结构被其它线程修改了。</p>
<h5 id="3-6-如何解决线程安全问题？"><a href="#3-6-如何解决线程安全问题？" class="headerlink" title="3.6 如何解决线程安全问题？"></a>3.6 如何解决线程安全问题？</h5><p>Java 源码中推荐使用 Collections#synchronizedList 进行解决，Collections#synchronizedList 的返回值是 List 的每个方法都加了 synchronized 锁，保证了在同一时刻，数组和链表只会被一个线程所修改，或者采用 CopyOnWriteArrayList 并发 List 来解决，这个类我们后面会说。</p>
<h3 id="4-其它类型题目"><a href="#4-其它类型题目" class="headerlink" title="4 其它类型题目"></a>4 其它类型题目</h3><h5 id="4-1-你能描述下双向链表么？"><a href="#4-1-你能描述下双向链表么？" class="headerlink" title="4.1 你能描述下双向链表么？"></a>4.1 你能描述下双向链表么？</h5><p>答：如果和面试官面对面沟通的话，你可以去画一下，可以把 《LinkedList 源码解析》中的 LinkedList 的结构画出来，如果是电话面试，可以这么描述：双向链表中双向的意思是说前后节点之间互相有引用，链表的节点我们称为 Node。Node 有三个属性组成：其前一个节点，本身节点的值，其下一个节点，假设 A、B 节点相邻，A 节点的下一个节点就是 B，B 节点的上一个节点就是 A，两者互相引用，在链表的头部节点，我们称为头节点。头节点的前一个节点是 null，尾部称为尾节点，尾节点的后一个节点是 null，如果链表数据为空的话，头尾节点是同一个节点，本身是 null，指向前后节点的值也是 null。</p>
<h5 id="4-2-描述下双向链表的新增和删除"><a href="#4-2-描述下双向链表的新增和删除" class="headerlink" title="4.2 描述下双向链表的新增和删除"></a>4.2 描述下双向链表的新增和删除</h5><p>答：如果是面对面沟通，最好可以直接画图，如果是电话面试，可以这么描述：</p>
<p>新增：我们可以选择从链表头新增，也可以选择从链表尾新增，如果是从链表尾新增的话，直接把当前节点追加到尾节点之后，本身节点自动变为尾节点。</p>
<p>删除：把删除节点的后一个节点的 prev 指向其前一个节点，把删除节点的前一个节点的 next 指向其后一个节点，最后把删除的节点置为 null 即可。</p>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p>List 在工作中经常遇到，熟读源码不仅仅是为了应对面试，也为了在工作中使用起来得心应手，如果想更深入了解 List，可以看一遍 ArrayList 源码之后，自己重新实现一个 List。这样的话，就会对 List 底层的数据结构和操作细节理解更深。</p>
<h2 id="08-HashMap-源码解析"><a href="#08-HashMap-源码解析" class="headerlink" title="08 HashMap 源码解析"></a><strong>08 HashMap 源码解析</strong></h2><h3 id="引导语-6"><a href="#引导语-6" class="headerlink" title="引导语"></a>引导语</h3><p>HashMap 源码很长，面试的问题也非常多，但这些面试问题，基本都是从源码中衍生出来的，所以我们只需要弄清楚其底层实现原理，回答这些问题就会游刃有余。</p>
<h3 id="1-整体架构-2"><a href="#1-整体架构-2" class="headerlink" title="1 整体架构"></a>1 整体架构</h3><p>HashMap 底层的数据结构主要是：数组 + 链表 + 红黑树。其中当链表的长度大于等于 8 时，链表会转化成红黑树，当红黑树的大小小于等于 6 时，红黑树会转化成链表，整体的数据结构如下：<br><img src="http://img.mukewang.com/5d5fc7cc0001ec3211040928.png" alt="图片描述">图中左边竖着的是 HashMap 的数组结构，数组的元素可能是单个 Node，也可能是个链表，也可能是个红黑树，比如数组下标索引为 2 的位置就是一个链表，下标索引为 9 的位置对应的就是红黑树，具体细节我们下文再说。</p>
<h4 id="1-1-类注释"><a href="#1-1-类注释" class="headerlink" title="1.1 类注释"></a>1.1 类注释</h4><p>从 HashMap 的类注释中，我们可以得到如下信息：</p>
<ul>
<li>允许 null 值，不同于 HashTable ，是线程不安全的；</li>
<li>load factor（影响因子） 默认值是 0.75， 是均衡了时间和空间损耗算出来的值，较高的值会减少空间开销（扩容减少，数组大小增长速度变慢），但增加了查找成本（hash 冲突增加，链表长度变长），不扩容的条件：数组容量 &gt; 需要的数组大小 /load factor；</li>
<li>如果有很多数据需要储存到 HashMap 中，建议 HashMap 的容量一开始就设置成足够的大小，这样可以防止在其过程中不断的扩容，影响性能；</li>
<li>HashMap 是非线程安全的，我们可以自己在外部加锁，或者通过 Collections#synchronizedMap 来实现线程安全，Collections#synchronizedMap 的实现是在每个方法上加上了 synchronized 锁；</li>
<li>在迭代过程中，如果 HashMap 的结构被修改，会快速失败。</li>
</ul>
<h4 id="1-2-常见属性"><a href="#1-2-常见属性" class="headerlink" title="1.2 常见属性"></a>1.2 常见属性</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始容量为 16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//负载因子默认值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//桶上的链表长度大于等于8时，链表转化成红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//桶上的红黑树大小小于等于6时，红黑树转化成链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当数组容量大于 64 时，链表才会转化成红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录迭代过程中 HashMap 结构是否发生变化，如果有变化，迭代时会 fail-fast</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HashMap 的实际大小，可能不准(因为当你拿到这个值的时候，可能又发生了变化)</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存放数据的数组</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容的门槛，有两种情况</span></span><br><span class="line"><span class="comment">// 如果初始化时，给定数组大小的话，通过 tableSizeFor 方法计算，数组大小永远接近于 2 的幂次方，比如你给定初始化大小 19，实际上初始化大小为 32，为 2 的 5 次方。</span></span><br><span class="line"><span class="comment">// 如果是通过 resize 方法进行扩容，大小 = 数组容量 * 0.75</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表的节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//红黑树的节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br></pre></td></tr></table></figure>



<h3 id="2-新增"><a href="#2-新增" class="headerlink" title="2 新增"></a>2 新增</h3><p>新增 key，value 大概的步骤如下：</p>
<ol>
<li>空数组有无初始化，没有的话初始化；</li>
<li>如果通过 key 的 hash 能够直接找到值，跳转到 6，否则到 3；</li>
<li>如果 hash 冲突，两种解决方案：链表 or 红黑树；</li>
<li>如果是链表，递归循环，把新元素追加到队尾；</li>
<li>如果是红黑树，调用红黑树新增的方法；</li>
<li>通过 2、4、5 将新元素追加成功，再根据 onlyIfAbsent 判断是否需要覆盖；</li>
<li>判断是否需要扩容，需要扩容进行扩容，结束。</li>
</ol>
<p>我们来画一张示意图来描述下：<br><img src="http://img.mukewang.com/5d5fc7e200016af809121188.jpg" alt="图片描述">代码细节如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 入参 hash：通过 hash 算法计算出来的值。</span></span><br><span class="line"><span class="comment">// 入参 onlyIfAbsent：false 表示即使 key 已经存在了，仍然会用新值覆盖原来的值，默认为 false</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// n 表示数组的长度，i 为数组索引下标，p 为 i 下标位置的 Node 值</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">//如果数组为空，使用 resize 方法初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 如果当前索引位置是空的，直接生成新的节点在当前索引位置上</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 如果当前索引位置有值的处理方法，即我们常说的如何解决 hash 冲突</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// e 当前节点的临时变量</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 如果 key 的 hash 和值都相等，直接把当前下标位置的 Node 值赋值给临时变量</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 如果是红黑树，使用红黑树的方式新增</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 是个链表，把新节点放到链表的尾端</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 自旋</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// e = p.next 表示从头开始，遍历链表</span></span><br><span class="line">                <span class="comment">// p.next == null 表明 p 是链表的尾节点</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 把新节点放到链表的尾部 </span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 当链表的长度大于等于 8 时，链表转红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 链表遍历过程中，发现有元素和新增的元素相等，结束循环</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//更改循环的当前元素，使 p 在遍历过程中，一直往后移动。</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 说明新节点的新增位置已经找到了</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">// 当 onlyIfAbsent 为 false 时，才会覆盖值 </span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回老值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录 HashMap 的数据结构发生了变化</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//如果 HashMap 的实际大小大于扩容的门槛，开始扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新增的流程上面应该已经表示很清楚了，接下来我们来看看链表和红黑树新增的细节：</p>
<h4 id="2-1-链表的新增"><a href="#2-1-链表的新增" class="headerlink" title="2.1 链表的新增"></a>2.1 链表的新增</h4><p>链表的新增比较简单，就是把当前节点追加到链表的尾部，和 LinkedList 的追加实现一样的。</p>
<p>当链表长度大于等于 8 时，此时的链表就会转化成红黑树，转化的方法是：treeifyBin，此方法有一个判断，当链表长度大于等于 8，并且整个数组大小大于 64 时，才会转成红黑树，当数组大小小于 64 时，只会触发扩容，不会转化成红黑树，转化成红黑树的过程也比较简单，具体转化的过程源码可以去 github：<a href="https://github.com/luanqiu/java8">https://github.com/luanqiu/java8</a> 上面去查看。</p>
<p>可能面试的时候，有人问你为什么是 8，这个答案在源码中注释有说，中文翻译过来大概的意思是：</p>
<p>链表查询的时间复杂度是 O (n)，红黑树的查询复杂度是 O (log (n))。在链表数据不多的时候，使用链表进行遍历也比较快，只有当链表数据比较多的时候，才会转化成红黑树，但红黑树需要的占用空间是链表的 2 倍，考虑到转化时间和空间损耗，所以我们需要定义出转化的边界值。</p>
<p>在考虑设计 8 这个值的时候，我们参考了泊松分布概率函数，由泊松分布中得出结论，链表各个长度的命中概率为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* <span class="number">0</span>:    <span class="number">0.60653066</span></span><br><span class="line">* <span class="number">1</span>:    <span class="number">0.30326533</span></span><br><span class="line">* <span class="number">2</span>:    <span class="number">0.07581633</span></span><br><span class="line">* <span class="number">3</span>:    <span class="number">0.01263606</span></span><br><span class="line">* <span class="number">4</span>:    <span class="number">0.00157952</span></span><br><span class="line">* <span class="number">5</span>:    <span class="number">0.00015795</span></span><br><span class="line">* <span class="number">6</span>:    <span class="number">0.00001316</span></span><br><span class="line">* <span class="number">7</span>:    <span class="number">0.00000094</span></span><br><span class="line">* <span class="number">8</span>:    <span class="number">0.00000006</span></span><br></pre></td></tr></table></figure>

<p>意思是，当链表的长度是 8 的时候，出现的概率是 0.00000006，不到千万分之一，所以说正常情况下，链表的长度不可能到达 8 ，而一旦到达 8 时，肯定是 hash 算法出了问题，所以在这种情况下，为了让 HashMap 仍然有较高的查询性能，所以让链表转化成红黑树，我们正常写代码，使用 HashMap 时，几乎不会碰到链表转化成红黑树的情况，毕竟概念只有千万分之一。</p>
<h4 id="2-2-红黑树新增节点过程"><a href="#2-2-红黑树新增节点过程" class="headerlink" title="2.2 红黑树新增节点过程"></a>2.2 红黑树新增节点过程</h4><ol>
<li><p>首先判断新增的节点在红黑树上是不是已经存在，判断手段有如下两种：</p>
<p>1.1. 如果节点没有实现 Comparable 接口，使用 equals 进行判断；</p>
<p>1.2. 如果节点自己实现了 Comparable 接口，使用 compareTo 进行判断。</p>
</li>
<li><p>新增的节点如果已经在红黑树上，直接返回；不在的话，判断新增节点是在当前节点的左边还是右边，左边值小，右边值大；</p>
</li>
<li><p>自旋递归 1 和 2 步，直到当前节点的左边或者右边的节点为空时，停止自旋，当前节点即为我们新增节点的父节点；</p>
</li>
<li><p>把新增节点放到当前节点的左边或右边为空的地方，并于当前节点建立父子节点关系；</p>
</li>
<li><p>进行着色和旋转，结束。</p>
</li>
</ol>
<p>具体源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//入参 h：key 的hash值</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//找到根节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">        <span class="comment">// p hash 值大于 h，说明 p 在 h 的右边</span></span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            dir = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// p hash 值小于 h，说明 p 在 h 的左边</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            dir = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//要放进去key在当前树中已经存在了(equals来判断)</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="comment">//自己实现的Comparable的话，不能用hashcode比较了，需要用compareTo</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                  <span class="comment">//得到key的Class类型，如果key没有实现Comparable就是null</span></span><br><span class="line">                  (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                  <span class="comment">//当前节点pk和入参k不等</span></span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                searched = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                    ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">            dir = tieBreakOrder(k, pk);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">        <span class="comment">//找到和当前hashcode值相近的节点(当前节点的左右子节点其中一个为空即可)</span></span><br><span class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">            <span class="comment">//生成新的节点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">            <span class="comment">//把新节点放在当前子节点为空的位置上</span></span><br><span class="line">            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                xp.left = x;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                xp.right = x;</span><br><span class="line">            <span class="comment">//当前节点和新节点建立父子，前后关系</span></span><br><span class="line">            xp.next = x;</span><br><span class="line">            x.parent = x.prev = xp;</span><br><span class="line">            <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">            <span class="comment">//balanceInsertion 对红黑树进行着色或旋转，以达到更多的查找效率，着色或旋转的几种场景如下</span></span><br><span class="line">            <span class="comment">//着色：新节点总是为红色；如果新节点的父亲是黑色，则不需要重新着色；如果父亲是红色，那么必须通过重新着色或者旋转的方法，再次达到红黑树的5个约束条件</span></span><br><span class="line">            <span class="comment">//旋转： 父亲是红色，叔叔是黑色时，进行旋转</span></span><br><span class="line">            <span class="comment">//如果当前节点是父亲的右节点，则进行左旋</span></span><br><span class="line">            <span class="comment">//如果当前节点是父亲的左节点，则进行右旋</span></span><br><span class="line">          </span><br><span class="line">            <span class="comment">//moveRootToFront 方法是把算出来的root放到根节点上</span></span><br><span class="line">            moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>红黑树的新增，要求大家对红黑树的数据结构有一定的了解。面试的时候，一般只会问到新增节点到红黑树上大概是什么样的一个过程，着色和旋转的细节不会问，因为很难说清楚，但我们要清楚着色指的是给红黑树的节点着上红色或黑色，旋转是为了让红黑树更加平衡，提高查询的效率，总的来说都是为了满足红黑树的 5 个原则：</p>
<ol>
<li>节点是红色或黑色</li>
<li>根是黑色</li>
<li>所有叶子都是黑色</li>
<li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点</li>
<li>从每个叶子到根的所有路径上不能有两个连续的红色节点</li>
</ol>
<h3 id="3-查找"><a href="#3-查找" class="headerlink" title="3 查找"></a>3 查找</h3><p>HashMap 的查找主要分为以下三步：</p>
<ul>
<li>根据 hash 算法定位数组的索引位置，equals 判断当前节点是否是我们需要寻找的 key，是的话直接返回，不是的话往下。</li>
<li>判断当前节点有无 next 节点，有的话判断是链表类型，还是红黑树类型。</li>
<li>分别走链表和红黑树不同类型的查找方法。</li>
</ul>
<p>链表查找的关键代码是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 采用自旋方式从链表中查找 key，e 初始为为链表的头节点</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 如果当前节点 hash 等于 key 的 hash，并且 equals 相等，当前节点就是我们要找的节点</span></span><br><span class="line">    <span class="comment">// 当 hash 冲突时，同一个 hash 值上是一个链表的时候，我们是通过 equals 方法来比较 key 是否相等的</span></span><br><span class="line">    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="comment">// 否则，把当前节点的下一个节点拿出来继续寻找</span></span><br><span class="line">&#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p>红黑树查找的代码很多，我们大概说下思路，实际步骤比较复杂，可以去 github 上面去查看源码：</p>
<ol>
<li>从根节点递归查找；</li>
<li>根据 hashcode，比较查找节点，左边节点，右边节点之间的大小，根本红黑树左小右大的特性进行判断；</li>
<li>判断查找节点在第 2 步有无定位节点位置，有的话返回，没有的话重复 2，3 两步；</li>
<li>一直自旋到定位到节点位置为止。</li>
</ol>
<p>如果红黑树比较平衡的话，每次查找的次数就是树的深度。</p>
<h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p>HashMap 的内容虽然较多，但大多数 api 都只是对数组 + 链表 + 红黑树这种数据结构进行封装而已，本小节我们从新增和查找两个角度进行了源码的深入分析，分析了是如何对数组、链表和红黑树进行操作的。想了解更多，可以前往 github 上查看更多源码。</p>
<h2 id="09-TreeMap-和-LinkedHashMap-核心源码解析"><a href="#09-TreeMap-和-LinkedHashMap-核心源码解析" class="headerlink" title="09 TreeMap 和 LinkedHashMap 核心源码解析"></a><strong>09 TreeMap 和 LinkedHashMap 核心源码解析</strong></h2><h3 id="引导语-7"><a href="#引导语-7" class="headerlink" title="引导语"></a>引导语</h3><p>在熟悉 HashMap 之后，本小节我们来看下 TreeMap 和 LinkedHashMap，看看 TreeMap 是如何根据 key 进行排序的，LinkedHashMap 是如何用两种策略进行访问的。</p>
<h3 id="1-知识储备"><a href="#1-知识储备" class="headerlink" title="1 知识储备"></a>1 知识储备</h3><p>在了解 TreeMap 之前，我们来看下日常工作中排序的两种方式，作为我们学习的基础储备，两种方式的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMapDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Data</span></span><br><span class="line">  <span class="comment">// DTO 为我们排序的对象</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">DTO</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">DTO</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DTO</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(DTO o)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//默认从小到大排序</span></span><br><span class="line">      <span class="keyword">return</span> id - o.getId();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTwoComparable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一种排序，从小到大排序，实现 Comparable 的 compareTo 方法进行排序</span></span><br><span class="line">    List&lt;DTO&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">      list.add(<span class="keyword">new</span> DTO(i));</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.sort(list);</span><br><span class="line">    log.info(JSON.toJSONString(list));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种排序，从大到小排序，利用外部排序器 Comparator 进行排序</span></span><br><span class="line">    Comparator comparator = (Comparator&lt;DTO&gt;) (o1, o2) -&gt; o2.getId() - o1.getId();</span><br><span class="line">    List&lt;DTO&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">      list2.add(<span class="keyword">new</span> DTO(i));</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.sort(list,comparator);</span><br><span class="line">    log.info(JSON.toJSONString(list2));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一种排序输出的结果从小到大，结果是：[{“id”:1},{“id”:2},{“id”:3},{“id”:4},{“id”:5}]；</p>
<p>第二种输出的结果恰好相反，结果是：[{“id”:5},{“id”:4},{“id”:3},{“id”:2},{“id”:1}]。</p>
<p>以上两种就是分别通过 Comparable 和 Comparator 两者进行排序的方式，而 TreeMap 利用的也是此原理，从而实现了对 key 的排序，我们一起来看下。</p>
<h3 id="2-TreeMap-整体架构"><a href="#2-TreeMap-整体架构" class="headerlink" title="2 TreeMap 整体架构"></a>2 TreeMap 整体架构</h3><p>TreeMap 底层的数据结构就是红黑树，和 HashMap 的红黑树结构一样。</p>
<p>不同的是，TreeMap 利用了红黑树左节点小，右节点大的性质，根据 key 进行排序，使每个元素能够插入到红黑树大小适当的位置，维护了 key 的大小关系，适用于 key 需要排序的场景。</p>
<p>因为底层使用的是平衡红黑树的结构，所以 containsKey、get、put、remove 等方法的时间复杂度都是 log(n)。</p>
<h4 id="2-1-属性"><a href="#2-1-属性" class="headerlink" title="2.1 属性"></a>2.1 属性</h4><p>TreeMap 常见的属性有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//比较器，如果外部有传进来 Comparator 比较器，首先用外部的</span></span><br><span class="line"><span class="comment">//如果外部比较器为空，则使用 key 自己实现的 Comparable#compareTo 方法</span></span><br><span class="line"><span class="comment">//比较手段和上面日常工作中的比较 demo 是一致的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator;</span><br><span class="line"></span><br><span class="line"><span class="comment">//红黑树的根节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root;</span><br><span class="line"></span><br><span class="line"><span class="comment">//红黑树的已有元素大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树结构变化的版本号，用于迭代过程中的快速失败场景</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//红黑树的节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-新增节点"><a href="#2-2-新增节点" class="headerlink" title="2.2 新增节点"></a>2.2 新增节点</h4><p>我们来看下 TreeMap 新增节点的步骤：</p>
<ol>
<li><p>判断红黑树的节点是否为空，为空的话，新增的节点直接作为根节点，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Entry&lt;K,V&gt; t = root;</span><br><span class="line"><span class="comment">//红黑树根节点为空，直接新建</span></span><br><span class="line"><span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// compare 方法限制了 key 不能为 null</span></span><br><span class="line">    compare(key, key); <span class="comment">// type (and possibly null) check</span></span><br><span class="line">    <span class="comment">// 成为根节点</span></span><br><span class="line">    root = <span class="keyword">new</span> Entry&lt;&gt;(key, value, <span class="keyword">null</span>);</span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据红黑树左小右大的特性，进行判断，找到应该新增节点的父节点，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line"><span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//自旋找到 key 应该新增的位置，就是应该挂载那个节点的头上</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//一次循环结束时，parent 就是上次比过的对象</span></span><br><span class="line">        parent = t;</span><br><span class="line">        <span class="comment">// 通过 compare 来比较 key 的大小</span></span><br><span class="line">        cmp = cpr.compare(key, t.key);</span><br><span class="line">        <span class="comment">//key 小于 t，把 t 左边的值赋予 t，因为红黑树左边的值比较小，循环再比</span></span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            t = t.left;</span><br><span class="line">        <span class="comment">//key 大于 t，把 t 右边的值赋予 t，因为红黑树右边的值比较大，循环再比</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            t = t.right;</span><br><span class="line">        <span class="comment">//如果相等的话，直接覆盖原值</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        <span class="comment">// t 为空，说明已经到叶子节点了</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在父节点的左边或右边插入新增节点，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//cmp 代表最后一次对比的大小，小于 0 ，代表 e 在上一节点的左边</span></span><br><span class="line"><span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">    parent.left = e;</span><br><span class="line"><span class="comment">//cmp 代表最后一次对比的大小，大于 0 ，代表 e 在上一节点的右边，相等的情况第二步已经处理了。</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    parent.right = e;</span><br></pre></td></tr></table></figure>
</li>
<li><p>着色旋转，达到平衡，结束。</p>
</li>
</ol>
<p>从源码中，我们可以看到：</p>
<ol>
<li>新增节点时，就是利用了红黑树左小右大的特性，从根节点不断往下查找，直到找到节点是 null 为止，节点为 null 说明到达了叶子结点；</li>
<li>查找过程中，发现 key 值已经存在，直接覆盖；</li>
<li>TreeMap 是禁止 key 是 null 值的。</li>
</ol>
<p>类似的，TreeMap 查找也是类似的原理，有兴趣的同学可以去 github 上面去查看源码。</p>
<h4 id="2-3-小结"><a href="#2-3-小结" class="headerlink" title="2.3 小结"></a>2.3 小结</h4><p>TreeMap 相对来说比较简单，红黑树和 HashMap 比较类似，比较关键的是通过 compare 来比较 key 的大小，然后利用红黑树左小右大的特性，为每个 key 找到自己的位置，从而维护了 key 的大小排序顺序。</p>
<h3 id="3-LinkedHashMap-整体架构"><a href="#3-LinkedHashMap-整体架构" class="headerlink" title="3 LinkedHashMap 整体架构"></a>3 LinkedHashMap 整体架构</h3><p>HashMap 是无序的，TreeMap 可以按照 key 进行排序，那有木有 Map 是可以维护插入的顺序的呢？接下来我们一起来看下 LinkedHashMap。</p>
<p>LinkedHashMap 本身是继承 HashMap 的，所以它拥有 HashMap 的所有特性，再此基础上，还提供了两大特性：</p>
<ul>
<li>按照插入顺序进行访问；</li>
<li>实现了访问最少最先删除功能，其目的是把很久都没有访问的 key 自动删除。</li>
</ul>
<p>接着我们来看下上述两大特性。</p>
<h4 id="3-1-按照插入顺序访问"><a href="#3-1-按照插入顺序访问" class="headerlink" title="3.1 按照插入顺序访问"></a>3.1 按照插入顺序访问</h4><h5 id="3-1-1-LinkedHashMap-链表结构"><a href="#3-1-1-LinkedHashMap-链表结构" class="headerlink" title="3.1.1 LinkedHashMap 链表结构"></a>3.1.1 LinkedHashMap 链表结构</h5><p>我们看下 LinkedHashMap 新增了哪些属性，以达到了链表结构的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链表头</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表尾</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承 Node，为数组的每个元素增加了 before 和 after 属性</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制两种访问模式的字段，默认 false</span></span><br><span class="line"><span class="comment">// true 按照访问顺序，会把经常访问的 key 放到队尾</span></span><br><span class="line"><span class="comment">// false 按照插入顺序提供访问</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure>

<p>从上述 Map 新增的属性可以看到，LinkedHashMap 的数据结构很像是把 LinkedList 的每个元素换成了 HashMap 的 Node，像是两者的结合体，也正是因为增加了这些结构，从而能把 Map 的元素都串联起来，形成一个链表，而链表就可以保证顺序了，就可以维护元素插入进来的顺序。</p>
<h5 id="3-1-2-如何按照顺序新增"><a href="#3-1-2-如何按照顺序新增" class="headerlink" title="3.1.2 如何按照顺序新增"></a>3.1.2 如何按照顺序新增</h5><p>LinkedHashMap 初始化时，默认 accessOrder 为 false，就是会按照插入顺序提供访问，插入方法使用的是父类 HashMap 的 put 方法，不过覆写了 put 方法执行中调用的 newNode/newTreeNode 和 afterNodeAccess 方法。</p>
<p>newNode/newTreeNode 方法，控制新增节点追加到链表的尾部，这样每次新节点都追加到尾部，即可保证插入顺序了，我们以 newNode 源码为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新增节点，并追加到链表的尾部</span></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 新增节点</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    <span class="comment">// 追加到链表的尾部</span></span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// link at the end of list</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    <span class="comment">// 新增节点等于位节点</span></span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="comment">// last 为空，说明链表为空，首尾节点相等</span></span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">        head = p;</span><br><span class="line">    <span class="comment">// 链表有数据，直接建立新增节点和上个尾节点之间的前后关系即可</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LinkedHashMap 通过新增头节点、尾节点，给每个节点增加 before、after 属性，每次新增时，都把节点追加到尾节点等手段，在新增的时候，就已经维护了按照插入顺序的链表结构了。</p>
<h5 id="3-1-3-按照顺序访问"><a href="#3-1-3-按照顺序访问" class="headerlink" title="3.1.3 按照顺序访问"></a>3.1.3 按照顺序访问</h5><p>LinkedHashMap 只提供了单向访问，即按照插入的顺序从头到尾进行访问，不能像 LinkedList 那样可以双向访问。</p>
<p>我们主要通过迭代器进行访问，迭代器初始化的时候，默认从头节点开始访问，在迭代的过程中，不断访问当前节点的 after 节点即可。</p>
<p>Map 对 key、value 和 entity（节点） 都提供出了迭代的方法，假设我们需要迭代 entity，就可使用 <code>LinkedHashMap.entrySet().iterator()</code> 这种写法直接返回 LinkedHashIterator ，LinkedHashIterator 是迭代器，我们调用迭代器的 nextNode 方法就可以得到下一个节点，迭代器的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化时，默认从头节点开始访问</span></span><br><span class="line">LinkedHashIterator() &#123;</span><br><span class="line">    <span class="comment">// 头节点作为第一个访问的节点</span></span><br><span class="line">    next = head;</span><br><span class="line">    expectedModCount = modCount;</span><br><span class="line">    current = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> LinkedHashMap.<span class="function">Entry&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; e = next;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)<span class="comment">// 校验</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    current = e;</span><br><span class="line">    next = e.after; <span class="comment">// 通过链表的 after 结构，找到下一个迭代的节点</span></span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在新增节点时，我们就已经维护了元素之间的插入顺序了，所以迭代访问时非常简单，只需要不断的访问当前节点的下一个节点即可。</p>
<h4 id="3-2-访问最少删除策略"><a href="#3-2-访问最少删除策略" class="headerlink" title="3.2 访问最少删除策略"></a>3.2 访问最少删除策略</h4><h5 id="3-2-1-demo"><a href="#3-2-1-demo" class="headerlink" title="3.2.1 demo"></a>3.2.1 demo</h5><p>这种策略也叫做 LRU（Least recently used,最近最少使用），大概的意思就是经常访问的元素会被追加到队尾，这样不经常访问的数据自然就靠近队头，然后我们可以通过设置删除策略，比如当 Map 元素个数大于多少时，把头节点删除，我们写个 demo 方便大家理解。demo 如下，完整代码可到 github 上查看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAccessOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 新建 LinkedHashMap</span></span><br><span class="line">  LinkedHashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;Integer, Integer&gt;(<span class="number">4</span>,<span class="number">0.75f</span>,<span class="keyword">true</span>) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      put(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">      put(<span class="number">9</span>, <span class="number">9</span>);</span><br><span class="line">      put(<span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line">      put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 覆写了删除策略的方法，我们设定当节点个数大于 3 时，就开始删除头节点</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;Integer, Integer&gt; eldest)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> size() &gt; <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  log.info(<span class="string">&quot;初始化：&#123;&#125;&quot;</span>,JSON.toJSONString(map));</span><br><span class="line">  Assert.assertNotNull(map.get(<span class="number">9</span>));</span><br><span class="line">  log.info(<span class="string">&quot;map.get(9)：&#123;&#125;&quot;</span>,JSON.toJSONString(map));</span><br><span class="line">  Assert.assertNotNull(map.get(<span class="number">20</span>));</span><br><span class="line">  log.info(<span class="string">&quot;map.get(20)：&#123;&#125;&quot;</span>,JSON.toJSONString(map));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印出来的结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">初始化：&#123;<span class="number">9</span>:<span class="number">9</span>,<span class="number">20</span>:<span class="number">20</span>,<span class="number">1</span>:<span class="number">1</span>&#125;</span><br><span class="line">map.get(<span class="number">9</span>)：&#123;<span class="number">20</span>:<span class="number">20</span>,<span class="number">1</span>:<span class="number">1</span>,<span class="number">9</span>:<span class="number">9</span>&#125;</span><br><span class="line">map.get(<span class="number">20</span>)：&#123;<span class="number">1</span>:<span class="number">1</span>,<span class="number">9</span>:<span class="number">9</span>,<span class="number">20</span>:<span class="number">20</span>&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，map 初始化的时候，我们放进去四个元素，但结果只有三个元素，10 不见了，这个主要是因为我们覆写了 removeEldestEntry 方法，我们实现了如果 map 中元素个数大于 3 时，我们就把队头的元素删除，当 put(1, 1) 执行的时候，正好把队头的 10 删除，这个体现了达到我们设定的删除策略时，会自动的删除头节点。</p>
<p>当我们调用 map.get(9) 方法时，元素 9 移动到队尾，调用 map.get(20) 方法时， 元素 20 被移动到队尾，这个体现了经常被访问的节点会被移动到队尾。</p>
<p>这个例子就很好的说明了访问最少删除策略，接下来我们看下原理。</p>
<h5 id="3-2-2-元素被转移到队尾"><a href="#3-2-2-元素被转移到队尾" class="headerlink" title="3.2.2 元素被转移到队尾"></a>3.2.2 元素被转移到队尾</h5><p>我们先来看下为什么 get 时，元素会被移动到队尾：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 调用 HashMap  get 方法</span></span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 如果设置了 LRU 策略</span></span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">    <span class="comment">// 这个方法把当前 key 移动到队尾</span></span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述源码中，可以看到，通过 afterNodeAccess 方法把当前访问节点移动到了队尾，其实不仅仅是 get 方法，执行 getOrDefault、compute、computeIfAbsent、computeIfPresent、merge 方法时，也会这么做，通过不断的把经常访问的节点移动到队尾，那么靠近队头的节点，自然就是很少被访问的元素了。</p>
<h5 id="3-2-3-删除策略"><a href="#3-2-3-删除策略" class="headerlink" title="3.2.3 删除策略"></a>3.2.3 删除策略</h5><p>上述 demo 我们在执行 put 方法时，发现队头元素被删除了，LinkedHashMap 本身是没有 put 方法实现的，调用的是 HashMap 的 put 方法，但 LinkedHashMap 实现了 put 方法中的调用 afterNodeInsertion 方法，这个方式实现了删除，我们看下源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除很少被访问的元素，被 HashMap 的 put 方法所调用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 得到元素头节点</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="comment">// removeEldestEntry 来控制删除策略，如果队列不为空，并且删除策略允许删除的情况下，删除头节点</span></span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        <span class="comment">// removeNode 删除头节点</span></span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-3-小结"><a href="#3-3-小结" class="headerlink" title="3.3 小结"></a>3.3 小结</h5><p>LinkedHashMap 提供了两个很有意思的功能：按照插入顺序访问和删除最少访问元素策略，简单地通过链表的结构就实现了，设计得非常巧妙。</p>
<h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><p>本小节主要说了 TreeMap 和 LinkedHashMap 的的数据结构，分析了两者的核心内容源码，我们发现两者充分利用了底层数据结构的特性，TreeMap 利用了红黑树左小右大的特性进行排序，LinkedHashMap 在 HashMap 的基础上简单地加了链表结构，就形成了节点的顺序，非常巧妙，很有意思，大家可以在看源码的过程中，可以多想想设计思路，说不定会有不一样的感悟。</p>
<h2 id="10-Map源码会问哪些面试题"><a href="#10-Map源码会问哪些面试题" class="headerlink" title="10 Map源码会问哪些面试题"></a><strong>10 Map源码会问哪些面试题</strong></h2><h3 id="引导语-8"><a href="#引导语-8" class="headerlink" title="引导语"></a>引导语</h3><p>Map 在面试中，占据了很大一部分的面试题目，其中以 HashMap 为主，这些面试题目有的可以说得清楚，有的很难说清楚，如果是面对面面试的话，建议画一画。</p>
<h3 id="1-Map-整体数据结构类问题"><a href="#1-Map-整体数据结构类问题" class="headerlink" title="1 Map 整体数据结构类问题"></a>1 Map 整体数据结构类问题</h3><h4 id="1-1-说一说-HashMap-底层数据结构"><a href="#1-1-说一说-HashMap-底层数据结构" class="headerlink" title="1.1 说一说 HashMap 底层数据结构"></a>1.1 说一说 HashMap 底层数据结构</h4><p>答：HashMap 底层是数组 + 链表 + 红黑树的数据结构，数组的主要作用是方便快速查找，时间复杂度是 O(1)，默认大小是 16，数组的下标索引是通过 key 的 hashcode 计算出来的，数组元素叫做 Node，当多个 key 的 hashcode 一致，但 key 值不同时，单个 Node 就会转化成链表，链表的查询复杂度是 O(n)，当链表的长度大于等于 8 并且数组的大小超过 64 时，链表就会转化成红黑树，红黑树的查询复杂度是 O(log(n))，简单来说，最坏的查询次数相当于红黑树的最大深度。</p>
<h4 id="1-2-HashMap、TreeMap、LinkedHashMap-三者有啥相同点，有啥不同点？"><a href="#1-2-HashMap、TreeMap、LinkedHashMap-三者有啥相同点，有啥不同点？" class="headerlink" title="1.2 HashMap、TreeMap、LinkedHashMap 三者有啥相同点，有啥不同点？"></a>1.2 HashMap、TreeMap、LinkedHashMap 三者有啥相同点，有啥不同点？</h4><p>答：相同点：</p>
<ol>
<li>三者在特定的情况下，都会使用红黑树；</li>
<li>底层的 hash 算法相同；</li>
<li>在迭代的过程中，如果 Map 的数据结构被改动，都会报 ConcurrentModificationException 的错误。</li>
</ol>
<p>不同点：</p>
<ol>
<li>HashMap 数据结构以数组为主，查询非常快，TreeMap 数据结构以红黑树为主，利用了红黑树左小右大的特点，可以实现 key 的排序，LinkedHashMap 在 HashMap 的基础上增加了链表的结构，实现了插入顺序访问和最少访问删除两种策略;</li>
<li>由于三种 Map 底层数据结构的差别，导致了三者的使用场景的不同，TreeMap 适合需要根据 key 进行排序的场景，LinkedHashMap 适合按照插入顺序访问，或需要删除最少访问元素的场景，剩余场景我们使用 HashMap 即可，我们工作中大部分场景基本都在使用 HashMap；</li>
<li>由于三种 map 的底层数据结构的不同，导致上层包装的 api 略有差别。</li>
</ol>
<h4 id="1-3-说一下-Map-的-hash-算法"><a href="#1-3-说一下-Map-的-hash-算法" class="headerlink" title="1.3 说一下 Map 的 hash 算法"></a>1.3 说一下 Map 的 hash 算法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line">key 在数组中的位置公式：tab[(n - <span class="number">1</span>) &amp; hash]</span><br></pre></td></tr></table></figure>

<p>如上代码是 HashMap 的hash 算法。</p>
<p>这其实是一个数学问题，源码中就是通过以上代码来计算 hash 的，首先计算出 key 的 hashcode，因为 key 是 Object，所以会根据 key 的不同类型进行 hashcode 的计算，接着计算 h ^ (h &gt;&gt;&gt; 16) ，这么做的好处是使大多数场景下，算出来的 hash 值比较分散。</p>
<p>一般来说，hash 值算出来之后，要计算当前 key 在数组中的索引下标位置时，可以采用取模的方式，就是索引下标位置 = hash 值 % 数组大小，这样做的好处，就是可以保证计算出来的索引下标值可以均匀的分布在数组的各个索引位置上，但取模操作对于处理器的计算是比较慢的，数学上有个公式，当 b 是 2 的幂次方时，a % b = a &amp;（b-1），所以此处索引位置的计算公式我们可以更换为： (n-1) &amp; hash。</p>
<p>此问题可以延伸出三个小问题：</p>
<p>1：为什么不用 key % 数组大小，而是需要用 key 的 hash 值 % 数组大小。</p>
<p>答：如果 key 是数字，直接用 key % 数组大小是完全没有问题的，但我们的 key 还有可能是字符串，是复杂对象，这时候用 字符串或复杂对象 % 数组大小是不行的，所以需要先计算出 key 的 hash 值。</p>
<p>2：计算 hash 值时，为什么需要右移 16 位？</p>
<p>答：hash 算法是 h ^ (h &gt;&gt;&gt; 16)，为了使计算出的 hash 值更分散，所以选择先将 h 无符号右移 16 位，然后再于 h 异或时，就能达到 h 的高 16 位和低 16 位都能参与计算，减少了碰撞的可能性。</p>
<p>3：为什么把取模操作换成了 &amp; 操作？</p>
<p>答：key.hashCode() 算出来的 hash 值还不是数组的索引下标，为了随机的计算出索引的下表位置，我们还会用 hash 值和数组大小进行取模，这样子计算出来的索引下标比较均匀分布。</p>
<p>取模操作处理器计算比较慢，处理器对 &amp; 操作就比较擅长，换成了 &amp; 操作，是有数学上证明的支撑，为了提高了处理器处理的速度。</p>
<p>4：为什么提倡数组大小是 2 的幂次方？</p>
<p>答：因为只有大小是 2 的幂次方时，才能使 hash 值 % n(数组大小) == (n-1) &amp; hash 公式成立。</p>
<h4 id="1-4-为解决-hash-冲突，大概有哪些办法。"><a href="#1-4-为解决-hash-冲突，大概有哪些办法。" class="headerlink" title="1.4 为解决 hash 冲突，大概有哪些办法。"></a>1.4 为解决 hash 冲突，大概有哪些办法。</h4><p>答：1：好的 hash 算法，细问的话复述一下上题的 hash 算法;</p>
<p>2：自动扩容，当数组大小快满的时候，采取自动扩容，可以减少 hash 冲突;</p>
<p>3：hash 冲突发生时，采用链表来解决;</p>
<p>4：hash 冲突严重时，链表会自动转化成红黑树，提高遍历速度。</p>
<p>网上列举的一些其它办法，如开放定址法，尽量不要说，因为这些方法资料很少，实战用过的人更少，如果你没有深入研究的话，面试官让你深入描述一下很难说清楚，反而留下不好的印象，说 HashMap 现有的措施就足够了。</p>
<h3 id="2-HashMap-源码细节类问题"><a href="#2-HashMap-源码细节类问题" class="headerlink" title="2 HashMap 源码细节类问题"></a>2 HashMap 源码细节类问题</h3><h4 id="2-1-HashMap-是如何扩容的？"><a href="#2-1-HashMap-是如何扩容的？" class="headerlink" title="2.1 HashMap 是如何扩容的？"></a>2.1 HashMap 是如何扩容的？</h4><p>答：扩容的时机：</p>
<ol>
<li>put 时，发现数组为空，进行初始化扩容，默认扩容大小为 16;</li>
<li>put 成功后，发现现有数组大小大于扩容的门阀值时，进行扩容，扩容为老数组大小的 2 倍;</li>
</ol>
<p>扩容的门阀是 threshold，每次扩容时 threshold 都会被重新计算，门阀值等于数组的大小 * 影响因子（0.75）。</p>
<p>新数组初始化之后，需要将老数组的值拷贝到新数组上，链表和红黑树都有自己拷贝的方法。</p>
<h4 id="2-2-hash-冲突时怎么办？"><a href="#2-2-hash-冲突时怎么办？" class="headerlink" title="2.2 hash 冲突时怎么办？"></a>2.2 hash 冲突时怎么办？</h4><p>答：hash 冲突指的是 key 值的 hashcode 计算相同，但 key 值不同的情况。</p>
<p>如果桶中元素原本只有一个或已经是链表了，新增元素直接追加到链表尾部；</p>
<p>如果桶中元素已经是链表，并且链表个数大于等于 8 时，此时有两种情况：</p>
<ol>
<li>如果此时数组大小小于 64，数组再次扩容，链表不会转化成红黑树;</li>
<li>如果数组大小大于 64 时，链表就会转化成红黑树。</li>
</ol>
<p>这里不仅仅判断链表个数大于等于 8，还判断了数组大小，数组容量小于 64 没有立即转化的原因，猜测主要是因为红黑树占用的空间比链表大很多，转化也比较耗时，所以数组容量小的情况下冲突严重，我们可以先尝试扩容，看看能否通过扩容来解决冲突的问题。</p>
<h4 id="2-3-为什么链表个数大于等于-8-时，链表要转化成红黑树了？"><a href="#2-3-为什么链表个数大于等于-8-时，链表要转化成红黑树了？" class="headerlink" title="2.3 为什么链表个数大于等于 8 时，链表要转化成红黑树了？"></a>2.3 为什么链表个数大于等于 8 时，链表要转化成红黑树了？</h4><p>答：当链表个数太多了，遍历可能比较耗时，转化成红黑树，可以使遍历的时间复杂度降低，但转化成红黑树，有空间和转化耗时的成本，我们通过泊松分布公式计算，正常情况下，链表个数出现 8 的概念不到千万分之一，所以说正常情况下，链表都不会转化成红黑树，这样设计的目的，是为了防止非正常情况下，比如 hash 算法出了问题时，导致链表个数轻易大于等于 8 时，仍然能够快速遍历。</p>
<p>延伸问题：红黑树什么时候转变成链表。</p>
<p>答：当节点的个数小于等于 6 时，红黑树会自动转化成链表，主要还是考虑红黑树的空间成本问题，当节点个数小于等于 6 时，遍历链表也很快，所以红黑树会重新变成链表。</p>
<h4 id="2-4-HashMap-在-put-时，如果数组中已经有了这个-key，我不想把-value-覆盖怎么办？取值时，如果得到的-value-是空时，想返回默认值怎么办？"><a href="#2-4-HashMap-在-put-时，如果数组中已经有了这个-key，我不想把-value-覆盖怎么办？取值时，如果得到的-value-是空时，想返回默认值怎么办？" class="headerlink" title="2.4 HashMap 在 put 时，如果数组中已经有了这个 key，我不想把 value 覆盖怎么办？取值时，如果得到的 value 是空时，想返回默认值怎么办？"></a>2.4 HashMap 在 put 时，如果数组中已经有了这个 key，我不想把 value 覆盖怎么办？取值时，如果得到的 value 是空时，想返回默认值怎么办？</h4><p>答：如果数组有了 key，但不想覆盖 value ，可以选择 putIfAbsent 方法，这个方法有个内置变量 onlyIfAbsent，内置是 true ，就不会覆盖，我们平时使用的 put 方法，内置 onlyIfAbsent 为 false，是允许覆盖的。</p>
<p>取值时，如果为空，想返回默认值，可以使用 getOrDefault 方法，方法第一参数为 key，第二个参数为你想返回的默认值，如 map.getOrDefault(“2”,“0”)，当 map 中没有 key 为 2 的值时，会默认返回 0，而不是空。</p>
<h4 id="2-5-通过以下代码进行删除，是否可行？"><a href="#2-5-通过以下代码进行删除，是否可行？" class="headerlink" title="2.5 通过以下代码进行删除，是否可行？"></a>2.5 通过以下代码进行删除，是否可行？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;String,String &gt; map = Maps.newHashMap();</span><br><span class="line">map.put(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;2&quot;</span>);</span><br><span class="line">map.forEach((s, s2) -&gt; map.remove(<span class="string">&quot;1&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>答：不行，会报错误 ConcurrentModificationException，原因如下图：</p>
<p><img src="http://img.mukewang.com/5d763e330001e64710380560.png" alt="图片描述"><br>建议使用迭代器的方式进行删除，原理同 ArrayList 迭代器原理，我们在《List 源码会问那些面试题》中有说到。</p>
<h4 id="2-6-描述一下-HashMap-get、put-的过程"><a href="#2-6-描述一下-HashMap-get、put-的过程" class="headerlink" title="2.6 描述一下 HashMap get、put 的过程"></a>2.6 描述一下 HashMap get、put 的过程</h4><p>答：我们在源码解析中有说，可以详细描述下源码的实现路径，说不清楚的话，可以画一画。</p>
<h3 id="3-其它-Map-面试题"><a href="#3-其它-Map-面试题" class="headerlink" title="3 其它 Map 面试题"></a>3 其它 Map 面试题</h3><h4 id="3-1-DTO-作为-Map-的-key-时，有无需要注意的点？"><a href="#3-1-DTO-作为-Map-的-key-时，有无需要注意的点？" class="headerlink" title="3.1 DTO 作为 Map 的 key 时，有无需要注意的点？"></a>3.1 DTO 作为 Map 的 key 时，有无需要注意的点？</h4><p>答：DTO 就是一个数据载体，可以看做拥有很多属性的 Java 类，我们可以对这些属性进行 get、set 操作。</p>
<p>看是什么类型的 Map，如果是 HashMap 的话，一定需要覆写 equals 和 hashCode 方法，因为在 get 和 put 的时候，需要通过 equals 方法进行相等的判断；如果是 TreeMap 的话，DTO 需要实现 Comparable 接口，因为 TreeMap 会使用 Comparable 接口进行判断 key 的大小；如果是 LinkedHashMap 的话，和 HashMap 一样的。</p>
<h4 id="3-2-LinkedHashMap-中的-LRU-是什么意思，是如何实现的。"><a href="#3-2-LinkedHashMap-中的-LRU-是什么意思，是如何实现的。" class="headerlink" title="3.2 LinkedHashMap 中的 LRU 是什么意思，是如何实现的。"></a>3.2 LinkedHashMap 中的 LRU 是什么意思，是如何实现的。</h4><p>答：LRU ，英文全称：Least recently used，中文叫做最近最少访问，在 LinkedHashMap 中，也叫做最少访问删除策略，我们可以通过 removeEldestEntry 方法设定一定的策略，使最少被访问的元素，在适当的时机被删除，原理是在 put 方法执行的最后，LinkedHashMap 会去检查这种策略，如果满足策略，就删除头节点。</p>
<p>保证头节点就是最少访问的元素的原理是：LinkedHashMap 在 get 的时候，都会把当前访问的节点，移动到链表的尾部，慢慢的，就会使头部的节点都是最少被访问的元素。</p>
<h4 id="3-3-为什么推荐-TreeMap-的元素最好都实现-Comparable-接口？但-key-是-String-的时候，我们却没有额外的工作呢？"><a href="#3-3-为什么推荐-TreeMap-的元素最好都实现-Comparable-接口？但-key-是-String-的时候，我们却没有额外的工作呢？" class="headerlink" title="3.3 为什么推荐 TreeMap 的元素最好都实现 Comparable 接口？但 key 是 String 的时候，我们却没有额外的工作呢？"></a>3.3 为什么推荐 TreeMap 的元素最好都实现 Comparable 接口？但 key 是 String 的时候，我们却没有额外的工作呢？</h4><p>答：因为 TreeMap 的底层就是通过排序来比较两个 key 的大小的，所以推荐 key 实现 Comparable 接口，是为了往你希望的排序顺序上发展， 而 String 本身已经实现了 Comparable 接口，所以使用 String 时，我们不需要额外的工作，不仅仅是 String ，其他包装类型也都实现了 Comparable 接口，如 Long、Double、Short 等等。</p>
<h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><p>Map 的面试题主要是 HashMap 为主，会问很多源码方面的东西，TreeMap 和 LinkedHashMap 主要以功能和场景为主，作为加分项。<br>Map 的面试题型很多，但只要弄懂原理，题目再多变化，回答起来都会比较简单。</p>
<h2 id="11-HashSet、TreeSet-源码解析"><a href="#11-HashSet、TreeSet-源码解析" class="headerlink" title="11 HashSet、TreeSet 源码解析"></a><strong>11 HashSet、TreeSet 源码解析</strong></h2><h3 id="引导语-9"><a href="#引导语-9" class="headerlink" title="引导语"></a>引导语</h3><p>HashSet、TreeSet 两个类是在 Map 的基础上组装起来的类，我们学习的侧重点，主要在于 Set 是如何利用 Map 现有的功能，来达成自己的目标的，也就是说如何基于现有的功能进行创新，然后再看看一些改变的小细节是否值得我们学习。</p>
<h3 id="1-HashSet"><a href="#1-HashSet" class="headerlink" title="1 HashSet"></a>1 HashSet</h3><h4 id="1-1-类注释-1"><a href="#1-1-类注释-1" class="headerlink" title="1.1 类注释"></a>1.1 类注释</h4><p>看源码先看类注释上，我们可以得到的信息有：</p>
<ol>
<li>底层实现基于 HashMap，所以迭代时不能保证按照插入顺序，或者其它顺序进行迭代；</li>
<li>add、remove、contanins、size 等方法的耗时性能，是不会随着数据量的增加而增加的，这个主要跟 HashMap 底层的数组数据结构有关，不管数据量多大，不考虑 hash 冲突的情况下，时间复杂度都是 O (1)；</li>
<li>线程不安全的，如果需要安全请自行加锁，或者使用 Collections.synchronizedSet；</li>
<li>迭代过程中，如果数据结构被改变，会快速失败的，会抛出 ConcurrentModificationException 异常。</li>
</ol>
<p>我们之前也看过 List、Map 的类注释，我们发现 2、3、4 点信息在类注释中都有提到，所以如果有人问 List、Map、 Set 三者的共同点，那么就可以说 2、3、4 三点。</p>
<h4 id="1-2-HashSet-是如何组合-HashMap-的"><a href="#1-2-HashSet-是如何组合-HashMap-的" class="headerlink" title="1.2 HashSet 是如何组合 HashMap 的"></a>1.2 HashSet 是如何组合 HashMap 的</h4><p>刚才是从类注释 1 中看到，HashSet 的实现是基于 HashMap 的，在 Java 中，要基于基础类进行创新实现，有两种办法：</p>
<ul>
<li>继承基础类，覆写基础类的方法，比如说继承 HashMap , 覆写其 add 的方法；</li>
<li>组合基础类，通过调用基础类的方法，来复用基础类的能力。</li>
</ul>
<p>HashSet 使用的就是组合 HashMap，其优点如下：</p>
<ol>
<li>继承表示父子类是同一个事物，而 Set 和 Map 本来就是想表达两种事物，所以继承不妥，而且 Java 语法限制，子类只能继承一个父类，后续难以扩展。</li>
<li>组合更加灵活，可以任意的组合现有的基础类，并且可以在基础类方法的基础上进行扩展、编排等，而且方法命名可以任意命名，无需和基础类的方法名称保持一致。</li>
</ol>
<p>我们在工作中，如果碰到类似问题，我们的原则也是尽量多用组合，少用继承。</p>
<p>组合就是把 HashMap 当作自己的一个局部变量，以下是 HashSet 的组合实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把 HashMap 组合进来，key 是 Hashset 的 key，value 是下面的 PRESENT</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"><span class="comment">// HashMap 中的 value</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>

<p>从这两行代码中，我们可以看出两点：</p>
<ol>
<li>我们在使用 HashSet 时，比如 add 方法，只有一个入参，但组合的 Map 的 add 方法却有 key，value 两个入参，相对应上 Map 的 key 就是我们 add 的入参，value 就是第二行代码中的 PRESENT，此处设计非常巧妙，用一个默认值 PRESENT 来代替 Map 的 Value；</li>
<li>如果 HashSet 是被共享的，当多个线程访问的时候，就会有线程安全问题，因为在后续的所有操作中，并没有加锁。</li>
</ol>
<p>HashSet 在以 HashMap 为基础进行实现的时候，首先选择组合的方式，接着使用默认值来代替了 Map 中的 Value 值，设计得非常巧妙，给使用者的体验很好，使用起来简单方便，我们在工作中也可以借鉴这种思想，可以把底层复杂实现包装一下，一些默认实现可以自己吃掉，使吐出去的接口尽量简单好用。</p>
<h4 id="1-2-1-初始化"><a href="#1-2-1-初始化" class="headerlink" title="1.2.1 初始化"></a>1.2.1 初始化</h4><p>HashSet 的初始化比较简单，直接 new HashMap 即可，比较有意思的是，当有原始集合数据进行初始化的情况下，会对 HashMap 的初始容量进行计算，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对 HashMap 的容量进行了计算</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中：Math.max ((int) (c.size ()/.75f) + 1, 16)，就是对 HashMap 的容量进行了计算，翻译成中文就是 取括号中两个数的最大值（期望的值 / 0.75+1，默认值 16），从计算中，我们可以看出 HashSet 的实现者对 HashMap 的底层实现是非常清楚的，主要体现在两个方面：</p>
<ol>
<li>和 16 比较大小的意思是说，如果给定 HashMap 初始容量小于 16 ，就按照 HashMap 默认的 16 初始化好了，如果大于 16，就按照给定值初始化。</li>
<li>HashMap 扩容的伐值的计算公式是：Map 的容量 * 0.75f，一旦达到阀值就会扩容，此处用 (int) (c.size ()/.75f) + 1 来表示初始化的值，这样使我们期望的大小值正好比扩容的阀值还大 1，就不会扩容，符合 HashMap 扩容的公式。</li>
</ol>
<p>从简单的构造器中，我们就可以看出要很好的组合 api 接口，并没有那么简单，我们可能需要去了解一下被组合的 api 底层的实现，这样才能用好 api。</p>
<p>同时这种写法，也提供了一种思路给我们，如果有人问你，往 HashMap 拷贝大集合时，如何给 HashMap 初始化大小时，完全可以借鉴这种写法：取最大值（期望的值 / 0.75 + 1，默认值 16）。</p>
<p>至于 HashSet 的其他方法就比较简单了，就是对 Map 的 api 进行了一些包装，如下的 add 方法实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 直接使用 HashMap 的 put 方法，进行一些简单的逻辑判断</span></span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 add 方法中，我们就可以看到组合的好处，方法的入参、名称、返回值都可以自定义，如果是继承的话就不行了。</p>
<h4 id="1-2-2-小结"><a href="#1-2-2-小结" class="headerlink" title="1.2.2 小结"></a>1.2.2 小结</h4><p>HashSet 具体实现值得我们借鉴的地方主要有如下地方，我们平时写代码的时候，完全可以参考参考：</p>
<ol>
<li>对组合还是继承的分析和把握；</li>
<li>对复杂逻辑进行一些包装，使吐出去的接口尽量简单好用；</li>
<li>组合其他 api 时，尽量多对组合的 api 多些了解，这样才能更好的使用 api；</li>
<li>HashMap 初始化大小值的模版公式：取括号内两者的最大值（期望的值 / 0.75+1，默认值 16）。</li>
</ol>
<h3 id="2-TreeSet"><a href="#2-TreeSet" class="headerlink" title="2 TreeSet"></a>2 TreeSet</h3><p>TreeSet 大致的结构和 HashSet 相似，底层组合的是 TreeMap，所以继承了 TreeMap key 能够排序的功能，迭代的时候，也可以按照 key 的排序顺序进行迭代，我们主要来看复用 TreeMap 时，复用的两种思路：</p>
<h5 id="2-1-复用-TreeMap-的思路一"><a href="#2-1-复用-TreeMap-的思路一" class="headerlink" title="2.1 复用 TreeMap 的思路一"></a>2.1 复用 TreeMap 的思路一</h5><p>场景一： TreeSet 的 add 方法，我们来看下其源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，底层直接使用的是 HashMap 的 put 的能力，直接拿来用就好了。</p>
<h5 id="2-2-复用-TreeMap-的思路二"><a href="#2-2-复用-TreeMap-的思路二" class="headerlink" title="2.2 复用 TreeMap 的思路二"></a>2.2 复用 TreeMap 的思路二</h5><p>场景二：需要迭代 TreeSet 中的元素，那应该也是像 add 那样，直接使用 HashMap 已有的迭代能力，比如像下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模仿思路一的方式实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">descendingIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 直接使用 HashMap.keySet 的迭代能力</span></span><br><span class="line">    <span class="keyword">return</span> m.keySet().iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种是思路一的实现方式，TreeSet 组合 TreeMap，直接选择 TreeMap 的底层能力进行包装，但 TreeSet 实际执行的思路却完全相反，我们看源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NavigableSet 接口，定义了迭代的一些规范，和一些取值的特殊方法</span></span><br><span class="line"><span class="comment">// TreeSet 实现了该方法，也就是说 TreeSet 本身已经定义了迭代的规范</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NavigableSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">SortedSet</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">lower</span><span class="params">(E e)</span></span>;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// m.navigableKeySet() 是 TreeMap 写了一个子类实现了 NavigableSet</span></span><br><span class="line"><span class="comment">// 接口，实现了 TreeSet 定义的迭代规范</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.navigableKeySet().iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TreeMap 中对 NavigableSet 接口的实现源码截图如下：</p>
<p><img src="http://img.mukewang.com/5d763f6e00018e0114461250.png" alt="图片描述">从截图中（截图是在 TreeMap 中），我们可以看出 TreeMap 实现了 TreeSet 定义的各种特殊方法。</p>
<p>我们可以看到，这种思路是 TreeSet 定义了接口的规范，TreeMap 负责去实现，实现思路和思路一是相反的。</p>
<p>我们总结下 TreeSet 组合 TreeMap 实现的两种思路：</p>
<ol>
<li>TreeSet 直接使用 TreeMap 的某些功能，自己包装成新的 api。</li>
<li>TreeSet 定义自己想要的 api，自己定义接口规范，让 TreeMap 去实现。</li>
</ol>
<p>方案 1 和 2 的调用关系，都是 TreeSet 调用 TreeMap，但功能的实现关系完全相反，第一种是功能的定义和实现都在 TreeMap，TreeSet 只是简单的调用而已，第二种 TreeSet 把接口定义出来后，让 TreeMap 去实现内部逻辑，TreeSet 负责接口定义，TreeMap 负责具体实现，这样子的话因为接口是 TreeSet 定义的，所以实现一定是 TreeSet 最想要的，TreeSet 甚至都不用包装，可以直接把返回值吐出去都行。</p>
<p>我们思考下这两种复用思路的原因：</p>
<ol>
<li>像 add 这些简单的方法，我们直接使用的是思路 1，主要是 add 这些方法实现比较简单，没有复杂逻辑，所以 TreeSet 自己实现起来比较简单；</li>
<li>思路 2 主要适用于复杂场景，比如说迭代场景，TreeSet 的场景复杂，比如要能从头开始迭代，比如要能取第一个值，比如要能取最后一个值，再加上 TreeMap 底层结构比较复杂，TreeSet 可能并不清楚 TreeMap 底层的复杂逻辑，这时候让 TreeSet 来实现如此复杂的场景逻辑，TreeSet 就搞不定了，不如接口让 TreeSet 来定义，让 TreeMap 去负责实现，TreeMap 对底层的复杂结构非常清楚，实现起来既准确又简单。</li>
</ol>
<h5 id="2-3-小结-1"><a href="#2-3-小结-1" class="headerlink" title="2.3 小结"></a>2.3 小结</h5><p>TreeSet 对 TreeMap 的两种不同复用思路，很重要，在工作中经常会遇到，特别是思路二，比如说 dubbo 的泛化调用，DDD 中的依赖倒置等等，原理都是 TreeSet 第二种的复用思想。</p>
<h3 id="3-面试题-1"><a href="#3-面试题-1" class="headerlink" title="3 面试题"></a>3 面试题</h3><p>HashSet 和 TreeSet 的面试概率比不上 List 和 Map，但只要有机会，并把本文的内容表达出来，绝对是加分项，因为现在 List 和 Map 面试题太多，面试官认为你能答的出来是应该的，但只要你有机会对 HashSet 和 TreeSet 说出本文见解，并且说自己是看源码时领悟到的，绝对肯定是加分项，这些就是你超过面试官预期的惊喜，以下是一些常用的题目：</p>
<h4 id="3-1-TreeSet-有用过么，平时都在什么场景下使用？"><a href="#3-1-TreeSet-有用过么，平时都在什么场景下使用？" class="headerlink" title="3.1 TreeSet 有用过么，平时都在什么场景下使用？"></a>3.1 TreeSet 有用过么，平时都在什么场景下使用？</h4><p>答：有木有用过如实回答就好了，我们一般都是在需要把元素进行排序的时候使用 TreeSet，使用时需要我们注意元素最好实现 Comparable 接口，这样方便底层的 TreeMap 根据 key 进行排序。</p>
<h4 id="3-2-追问，如果我想实现根据-key-的新增顺序进行遍历怎么办？"><a href="#3-2-追问，如果我想实现根据-key-的新增顺序进行遍历怎么办？" class="headerlink" title="3.2 追问，如果我想实现根据 key 的新增顺序进行遍历怎么办？"></a>3.2 追问，如果我想实现根据 key 的新增顺序进行遍历怎么办？</h4><p>答：要按照 key 的新增顺序进行遍历，首先想到的应该就是 LinkedHashMap，而 LinkedHashSet 正好是基于 LinkedHashMap 实现的，所以我们可以选择使用 LinkedHashSet。</p>
<h4 id="3-3-追问，如果我想对-key-进行去重，有什么好的办法么？"><a href="#3-3-追问，如果我想对-key-进行去重，有什么好的办法么？" class="headerlink" title="3.3 追问，如果我想对 key 进行去重，有什么好的办法么？"></a>3.3 追问，如果我想对 key 进行去重，有什么好的办法么？</h4><p>答：我们首先想到的是 TreeSet，TreeSet 底层使用的是 TreeMap，TreeMap 在 put 的时候，如果发现 key 是相同的，会把 value 值进行覆盖，所有不会产生重复的 key ，利用这一特性，使用 TreeSet 正好可以去重。</p>
<h4 id="3-4-说说-TreeSet-和-HashSet-两个-Set-的内部实现结构和原理？"><a href="#3-4-说说-TreeSet-和-HashSet-两个-Set-的内部实现结构和原理？" class="headerlink" title="3.4 说说 TreeSet 和 HashSet 两个 Set 的内部实现结构和原理？"></a>3.4 说说 TreeSet 和 HashSet 两个 Set 的内部实现结构和原理？</h4><p>答： HashSet 底层对 HashMap 的能力进行封装，比如说 add 方法，是直接使用 HashMap 的 put 方法，比较简单，但在初始化的时候，我看源码有一些感悟：说一下 HashSet 小结的四小点。</p>
<p>TreeSet 主要是对 TreeMap 底层能力进行封装复用，我发现了两种非常有意思的复用思路，重复 TreeSet 两种复用思路。</p>
<h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h3><p>本小节主要说了 Set 源码中两处亮点：</p>
<ol>
<li>HashSet 对组合的 HashMap 类扩容的门阀值的深入了解和设计，值得我们借鉴；</li>
<li>TreeSet 对 TreeMap 两种复用思路，值得我们学习，特别是第二种复用思路。</li>
</ol>
<p>HashSet 和 TreeSet 不会是面试的重点，但通过以上两点，可以让我们给面试官一种精益求精的感觉，成为加分项。</p>
<h2 id="12-彰显细节：看集合源码对我们实际工作的帮助和应用"><a href="#12-彰显细节：看集合源码对我们实际工作的帮助和应用" class="headerlink" title="12 彰显细节：看集合源码对我们实际工作的帮助和应用"></a><strong>12 彰显细节：看集合源码对我们实际工作的帮助和应用</strong></h2><p>本节中，我们先跳出源码的视角，来看看集合类的类图，看看在设计层面上，是否有可疑借鉴之处，接着通过源码来找找工作中的集合坑，提前扫雷。</p>
<h3 id="1-集合类图"><a href="#1-集合类图" class="headerlink" title="1 集合类图"></a>1 集合类图</h3><p><img src="http://img.mukewang.com/5d7ef50d00018a8315460536.png" alt="图片描述">上图是目前我们已学的集合类图，大概可以看出以下几点：</p>
<ol>
<li>每个接口做的事情非常明确，比如 Serializable，只负责序列化，Cloneable 只负责拷贝，Map 只负责定义 Map 的接口，整个图看起来虽然接口众多，但职责都很清晰；</li>
<li>复杂功能通过接口的继承来实现，比如 ArrayList 通过实现了 Serializable、Cloneable、RandomAccess、AbstractList、List 等接口，从而拥有了序列化、拷贝、对数组各种操作定义等各种功能；</li>
<li>上述类图只能看见继承的关系，组合的关系还看不出来，比如说 Set 组合封装 Map 的底层能力等。</li>
</ol>
<p>上述设计的最大好处是，每个接口能力职责单一，众多的接口变成了接口能力的积累，假设我们想再实现一个数据结构类，我们就可以从这些已有的能力接口中，挑选出能满足需求的能力接口，进行一些简单的组装，从而加快开发速度。</p>
<p>这种思想在平时的工作中也经常被使用，我们会把一些通用的代码块抽象出来，沉淀成代码块池，碰到不同的场景的时候，我们就从代码块池中，把我们需要的代码块提取出来，进行简单的编排和组装，从而实现我们需要的场景功能。</p>
<h3 id="2-集合工作中一些注意事项"><a href="#2-集合工作中一些注意事项" class="headerlink" title="2 集合工作中一些注意事项"></a>2 集合工作中一些注意事项</h3><h4 id="2-1-线程安全"><a href="#2-1-线程安全" class="headerlink" title="2.1 线程安全"></a>2.1 线程安全</h4><p>我们说集合都是非线程安全的，这里说的非线程安全指的是集合类作为共享变量，被多线程读写的时候，才是不安全的，如果要实现线程安全的集合，在类注释中，JDK 统一推荐我们使用 Collections.synchronized* 类， Collections 帮我们实现了 List、Set、Map 对应的线程安全的方法， 如下图：<br><img src="http://img.mukewang.com/5d7ef4d400018def13540844.png" alt="图片描述">图中实现了各种集合类型的线程安全的方法，我们以 synchronizedList 为例，从源码上来看下，Collections 是如何实现线程安全的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mutex 就是我们需要锁住的对象</span></span><br><span class="line"><span class="keyword">final</span> Object mutex;  </span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">SynchronizedCollection</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">7754090372962971524L</span>;</span><br><span class="line">        <span class="comment">// 这个 List 就是我们需要保证线程安全的类</span></span><br><span class="line">        <span class="keyword">final</span> List&lt;E&gt; list;</span><br><span class="line">        SynchronizedList(List&lt;E&gt; list, Object mutex) &#123;</span><br><span class="line">            <span class="keyword">super</span>(list, mutex);</span><br><span class="line">            <span class="keyword">this</span>.list = list;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">// 我们可以看到，List 的所有操作都使用了 synchronized 关键字，来进行加锁</span></span><br><span class="line">				<span class="comment">// synchronized 是一种悲观锁，能够保证同一时刻，只能有一个线程能够获得锁</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> list.get(index);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> list.set(index, element);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;list.add(index, element);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">…………</span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure>

<p>从源码中我们可以看到 Collections 是通过 synchronized 关键字给 List 操作数组的方法加上锁，来实现线程安全的。</p>
<h4 id="2-2-集合性能"><a href="#2-2-集合性能" class="headerlink" title="2.2 集合性能"></a>2.2 集合性能</h4><p>集合的单个操作，一般都没有性能问题，性能问题主要出现的批量操作上。</p>
<h5 id="2-2-1-批量新增"><a href="#2-2-1-批量新增" class="headerlink" title="2.2.1 批量新增"></a>2.2.1 批量新增</h5><p>在 List 和 Map 大量数据新增的时候，我们不要使用 for 循环 + add/put 方法新增，这样子会有很大的扩容成本，我们应该尽量使用 addAll 和 putAll 方法进行新增，以 ArrayList 为例写了一个 demo 如下，演示了两种方案的性能对比：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBatchInsert</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 准备拷贝数据</span></span><br><span class="line">  ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3000000</span>;i++)&#123;</span><br><span class="line">    list.add(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// for 循环 + add</span></span><br><span class="line">  ArrayList&lt;Integer&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">long</span> start1 = System.currentTimeMillis();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">    list2.add(list.get(i));</span><br><span class="line">  &#125;</span><br><span class="line">  log.info(<span class="string">&quot;单个 for 循环新增 300 w 个，耗时&#123;&#125;&quot;</span>,System.currentTimeMillis()-start1);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 批量新增</span></span><br><span class="line">  ArrayList&lt;Integer&gt; list3 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">long</span> start2 = System.currentTimeMillis();</span><br><span class="line">  list3.addAll(list);</span><br><span class="line">  log.info(<span class="string">&quot;批量新增 300 w 个，耗时&#123;&#125;&quot;</span>,System.currentTimeMillis()-start2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后打印出来的日志为：</p>
<p>16:52:59.865 [main] INFO demo.one.ArrayListDemo - 单个 for 循环新增 300 w 个，耗时1518<br>16:52:59.880 [main] INFO demo.one.ArrayListDemo - 批量新增 300 w 个，耗时8</p>
<p>可以看到，批量新增方法性能是单个新增方法性能的 189 倍，主要原因在于批量新增，只会扩容一次，大大缩短了运行时间，而单个新增，每次到达扩容阀值时，都会进行扩容，在整个过程中就会不断的扩容，浪费了很多时间，我们来看下批量新增的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">  Object[] a = c.toArray();</span><br><span class="line">  <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">  <span class="comment">// 确保容量充足，整个过程只会扩容一次</span></span><br><span class="line">  ensureCapacityInternal(size + numNew); </span><br><span class="line">  <span class="comment">// 进行数组的拷贝</span></span><br><span class="line">  System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">  size += numNew;</span><br><span class="line">  <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是 ArrayList 批量新增的演示，我们可以看到，整个批量新增的过程中，只扩容了一次，HashMap 的 putAll 方法也是如此，整个新增过程只会扩容一次，大大缩短了批量新增的时间，提高了性能。</p>
<p>所以如果有人问你当碰到集合批量拷贝，批量新增场景，如何提高新增性能的时候 ，就可以从目标集合初始化方面应答。</p>
<p>这里也提醒了我们，在容器初始化的时候，最好能给容器赋上初始值，这样可以防止在 put 的过程中不断的扩容，从而缩短时间，上章 HashSet 的源码给我们演示了，给 HashMap 赋初始值的公式为：取括号内两者的最大值（期望的值/0.75+1，默认值 16）。</p>
<h5 id="2-2-2-批量删除"><a href="#2-2-2-批量删除" class="headerlink" title="2.2.2 批量删除"></a>2.2.2 批量删除</h5><p>批量删除 ArrayList 提供了 removeAll 的方法，HashMap 没有提供批量删除的方法，我们一起来看下 removeAll 的源码实现，是如何提高性能的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 批量删除，removeAll 方法底层调用的是 batchRemove 方法</span></span><br><span class="line"><span class="comment">// complement 参数默认是 false,false 的意思是数组中不包含 c 中数据的节点往头移动</span></span><br><span class="line"><span class="comment">// true 意思是数组中包含 c 中数据的节点往头移动，这个是根据你要删除数据和原数组大小的比例来决定的</span></span><br><span class="line"><span class="comment">// 如果你要删除的数据很多，选择 false 性能更好，当然 removeAll 方法默认就是 false。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Object[] elementData = <span class="keyword">this</span>.elementData;</span><br><span class="line">  <span class="comment">// r 表示当前循环的位置、w 位置之前都是不需要被删除的数据，w 位置之后都是需要被删除的数据</span></span><br><span class="line">  <span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 从 0 位置开始判断，当前数组中元素是不是要被删除的元素，不是的话移到数组头</span></span><br><span class="line">    <span class="keyword">for</span> (; r &lt; size; r++)</span><br><span class="line">      <span class="keyword">if</span> (c.contains(elementData[r]) == complement)</span><br><span class="line">        elementData[w++] = elementData[r];</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// r 和 size 不等，说明在 try 过程中发生了异常，在 r 处断开</span></span><br><span class="line">    <span class="comment">// 把 r 位置之后的数组移动到 w 位置之后(r 位置之后的数组数据都是没有判断过的数据，这样不会影响没有判断的数据，判断过的数据可以被删除)</span></span><br><span class="line">    <span class="keyword">if</span> (r != size) &#123;</span><br><span class="line">      System.arraycopy(elementData, r,</span><br><span class="line">                       elementData, w,</span><br><span class="line">                       size - r);</span><br><span class="line">      w += size - r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// w != size 说明数组中是有数据需要被删除的</span></span><br><span class="line">    <span class="comment">// 如果 w、size 相等，说明没有数据需要被删除</span></span><br><span class="line">    <span class="keyword">if</span> (w != size) &#123;</span><br><span class="line">      <span class="comment">// w 之后都是需要删除的数据，赋值为空，帮助 gc。</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &lt; size; i++)</span><br><span class="line">        elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">      modCount += size - w;</span><br><span class="line">      size = w;</span><br><span class="line">      modified = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到 ArrayList 在批量删除时，如果程序执行正常，只有一次 for 循环，如果程序执行异常，才会加一次拷贝，而单个 remove 方法，每次执行的时候都会进行数组的拷贝（当删除的元素正好是数组最后一个元素时除外），当数组越大，需要删除的数据越多时，批量删除的性能会越差，所以在 ArrayList 批量删除时，强烈建议使用 removeAll 方法进行删除。</p>
<h4 id="2-3-集合的一些坑"><a href="#2-3-集合的一些坑" class="headerlink" title="2.3 集合的一些坑"></a>2.3 集合的一些坑</h4><ol>
<li>当集合的元素是自定义类时，自定义类强制实现 equals 和 hashCode 方法，并且两个都要实现。</li>
</ol>
<p>在集合中，除了 TreeMap 和 TreeSet 是通过比较器比较元素大小外，其余的集合类在判断索引位置和相等时，都会使用到 equals 和 hashCode 方法，这个在之前的源码解析中，我们有说到，所以当集合的元素是自定义类时，我们强烈建议覆写 equals 和 hashCode 方法，我们可以直接使用 IDEA 工具覆写这两个方法，非常方便；</p>
<ol>
<li>所有集合类，在 for 循环进行删除时，如果直接使用集合类的 remove 方法进行删除，都会快速失败，报 ConcurrentModificationException 的错误，所以在任意循环删除的场景下，都建议使用迭代器进行删除；</li>
<li>我们把数组转化成集合时，常使用 Arrays.asList(array)，这个方法有两个坑，代码演示坑为：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testArrayToList</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Integer[] array = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">  List&lt;Integer&gt; list = Arrays.asList(array);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 坑1：修改数组的值，会直接影响原 list</span></span><br><span class="line">  log.info(<span class="string">&quot;数组被修改之前，集合第一个元素为：&#123;&#125;&quot;</span>,list.get(<span class="number">0</span>));</span><br><span class="line">  array[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">  log.info(<span class="string">&quot;数组被修改之前，集合第一个元素为：&#123;&#125;&quot;</span>,list.get(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 坑2：使用 add、remove 等操作 list 的方法时，</span></span><br><span class="line">  <span class="comment">// 会报 UnsupportedOperationException 异常</span></span><br><span class="line">  list.add(<span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line">坑 <span class="number">1</span>：数组被修改后，会直接影响到新 List 的值。</span><br><span class="line">坑 <span class="number">2</span>：不能对新 List 进行 add、remove 等操作，否则运行时会报 UnsupportedOperationException 错误。</span><br></pre></td></tr></table></figure>

<p>我们来看下 Arrays.asList 的源码实现，就能知道问题所在了，源码如下图：</p>
<p><img src="http://img.mukewang.com/5d7ef4ad0001a58020880820.png" alt="图片描述">从上图中，我们可以发现，Arrays.asList 方法返回的 List 并不是 java.util.ArrayList，而是自己内部的一个静态类，该静态类直接持有数组的引用，并且没有实现 add、remove 等方法，这些就是坑 1 和 2 的原因。</p>
<ol>
<li>集合 List 转化成数组，我们通常使用 toArray 这个方法，这个方法很危险，稍微不注意，就踩进大坑，我们示例代码如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testListToArray</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;()&#123;&#123;</span><br><span class="line">      add(<span class="number">1</span>);</span><br><span class="line">      add(<span class="number">2</span>);</span><br><span class="line">      add(<span class="number">3</span>);</span><br><span class="line">      add(<span class="number">4</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这行被注释的代码这么写是无法转化成数组的，无参 toArray 返回的是 Object[],</span></span><br><span class="line">    <span class="comment">// 无法向下转化成 List&lt;Integer&gt;，编译都无法通过</span></span><br><span class="line">    <span class="comment">// List&lt;Integer&gt; list2 = list.toArray();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示有参 toArray 方法，数组大小不够时，得到数组为 null 情况</span></span><br><span class="line">    Integer[] array0 = <span class="keyword">new</span> Integer[<span class="number">2</span>];</span><br><span class="line">    list.toArray(array0);</span><br><span class="line">    log.info(<span class="string">&quot;toArray 数组大小不够，array0 数组[0] 值是&#123;&#125;,数组[1] 值是&#123;&#125;,&quot;</span>,array0[<span class="number">0</span>],array0[<span class="number">1</span>]);</span><br><span class="line">		</span><br><span class="line">    <span class="comment">// 演示数组初始化大小正好，正好转化成数组</span></span><br><span class="line">    Integer[] array1 = <span class="keyword">new</span> Integer[list.size()];</span><br><span class="line">    list.toArray(array1);</span><br><span class="line">    log.info(<span class="string">&quot;toArray 数组大小正好，array1 数组[3] 值是&#123;&#125;&quot;</span>,array1[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示数组初始化大小大于实际所需大小，也可以转化成数组</span></span><br><span class="line">    Integer[] array2 = <span class="keyword">new</span> Integer[list.size()+<span class="number">2</span>];</span><br><span class="line">    list.toArray(array2);</span><br><span class="line">    log.info(<span class="string">&quot;toArray 数组大小多了，array2 数组[3] 值是&#123;&#125;，数组[4] 值是&#123;&#125;&quot;</span>,array2[<span class="number">3</span>],array2[<span class="number">4</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="number">19</span>:<span class="number">33</span>:<span class="number">07</span>.<span class="number">687</span> [main] INFO demo.one.ArrayListDemo - toArray 数组大小不够，array0 数组[<span class="number">0</span>] 值是<span class="keyword">null</span>,数组[<span class="number">1</span>] 值是<span class="keyword">null</span>,</span><br><span class="line"><span class="number">19</span>:<span class="number">33</span>:<span class="number">07</span>.<span class="number">697</span> [main] INFO demo.one.ArrayListDemo - toArray 数组大小正好，array1 数组[<span class="number">3</span>] 值是<span class="number">4</span></span><br><span class="line"><span class="number">19</span>:<span class="number">33</span>:<span class="number">07</span>.<span class="number">697</span> [main] INFO demo.one.ArrayListDemo - toArray 数组大小多了，array2 数组[<span class="number">3</span>] 值是<span class="number">4</span>，数组[<span class="number">4</span>] 值是<span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<p>toArray 的无参方法，无法强转成具体类型，这个编译的时候，就会有提醒，我们一般都会去使用带有参数的 toArray 方法，这时就有一个坑，如果参数数组的大小不够，这时候返回的数组值竟然是空，上述代码中的 array0 的返回值就体现了这点，但我们去看 toArray 源码，发现源码中返回的是 4 个大小值的数据，返回的并不是空，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// List 转化成数组</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">  <span class="comment">// 如果数组长度不够，按照 List 的大小进行拷贝，return 的时候返回的都是正确的数组</span></span><br><span class="line">  <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">    <span class="comment">// Make a new array of a&#x27;s runtime type, but my contents:</span></span><br><span class="line">    <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">  System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">  <span class="comment">// 数组长度大于 List 大小的，赋值为 null</span></span><br><span class="line">  <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">    a[size] = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中，我们丝毫看不出为什么 array0 的元素值为什么是 null，最后我们去看方法的注释，发现是这样子描述的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">If the list fits in the specified array, it is returned therein.  Otherwise, a <span class="keyword">new</span> array is</span><br><span class="line"> allocated with the runtime type of the specified array and the size of <span class="keyword">this</span> list。</span><br></pre></td></tr></table></figure>

<p>翻译过来的意思就是说：如果返回的数组大小和申明的数组大小一致，那么就会正常返回，否则，一个新数组就会被分配返回。</p>
<p>所以我们在使用有参 toArray 方法时，申明的数组大小一定要大于等于 List 的大小，如果小于的话，你会得到一个空数组。</p>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h3><p>本小节，我们详细描述了集合的线程安全、性能优化和日常工作中一些坑，这些问题我们在工作中经常会碰到，稍不留神就会引发线上故障，面试的时候也经常会通过这些问题，来考察大家的工作经验，所以阅读本章时，建议大家自己动手试一试，加深印象。</p>
<h2 id="13-差异对比：集合在-Java-7-和-8-有何不同和改进"><a href="#13-差异对比：集合在-Java-7-和-8-有何不同和改进" class="headerlink" title="13 差异对比：集合在 Java 7 和 8 有何不同和改进"></a><strong>13 差异对比：集合在 Java 7 和 8 有何不同和改进</strong></h2><h3 id="引导语-10"><a href="#引导语-10" class="headerlink" title="引导语"></a>引导语</h3><p>Java 8 在 Java 7 的基础上，做了一些改进和优化，但我们在平时工作中，或者直接升级到 Java 8 的过程中，我们好像无需做任何兼容逻辑，那么 Java 8 底层是如何处理的呢，在改进的同时，是如何优雅兼容 Java 老版本，让使用者无需感知，接下来我们通过对比 Java 7 和 8 的差异，来展示 Java 8 是如何优雅升级的。</p>
<h3 id="1-通用区别"><a href="#1-通用区别" class="headerlink" title="1 通用区别"></a>1 通用区别</h3><h4 id="1-1-所有集合都新增了forEach-方法"><a href="#1-1-所有集合都新增了forEach-方法" class="headerlink" title="1.1 所有集合都新增了forEach 方法"></a>1.1 所有集合都新增了forEach 方法</h4><p>List、Set、Map 在 Java 8 版本中都增加了 forEach 的方法，方法的入参是 Consumer，Consumer 是一个函数式接口，可以简单理解成允许一个入参，但没有返回值的函数式接口，我们以 ArrayList 的 forEach 的源码为例，来看下方法是如何实现的 ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 判断非空</span></span><br><span class="line">  Objects.requireNonNull(action);</span><br><span class="line">  <span class="comment">// modCount的原始值被拷贝</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">  <span class="keyword">final</span> E[] elementData = (E[]) <span class="keyword">this</span>.elementData;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">  <span class="comment">// 每次循环都会判断数组有没有被修改，一旦被修改，停止循环</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">    <span class="comment">// 执行循环内容，action 代表我们要干的事情</span></span><br><span class="line">    action.accept(elementData[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 数组如果被修改了，抛异常</span></span><br><span class="line">  <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这段源码中，很容易产生两个问题：</p>
<p>1、action.accept 到底是个啥？</p>
<p>action.accept 就是你在 for 循环中要干的事情，你可以进行任何事情，比如我们打印一句话，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testForEach</span><span class="params">()</span></span>&#123;</span><br><span class="line">  List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;()&#123;&#123;</span><br><span class="line">    add(<span class="number">1</span>);</span><br><span class="line">    add(<span class="number">3</span>);</span><br><span class="line">    add(<span class="number">2</span>);</span><br><span class="line">    add(<span class="number">4</span>);</span><br><span class="line">  &#125;&#125;;</span><br><span class="line">  <span class="comment">// value 是每次循环的入参，就是 list 中的每个元素</span></span><br><span class="line">  list.forEach( value-&gt;log.info(<span class="string">&quot;当前值为：&#123;&#125;&quot;</span>,value));</span><br><span class="line">&#125;</span><br><span class="line">输出为：</span><br><span class="line">当前值为：<span class="number">1</span></span><br><span class="line">当前值为：<span class="number">3</span></span><br><span class="line">当前值为：<span class="number">2</span></span><br><span class="line">当前值为：<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>log.info(“当前值为：{}”,value) 就是我们要干的事情，就是 action。</p>
<p>2.、forEach 方法上打了 @Override 注解，说明该方法是被继承实现的，该方法是被定义在 Iterable 接口上的，Java 7 和 8 的 ArrayList 都实现了该接口，但我们在 Java 7 的 ArrayList 并没有发现有实现该方法，编译器也木有报错，这个主要是因为 Iterable 接口的 forEach 方法被加上了 default 关键字，这个关键字只会出现在接口类中，被该关键字修饰的方法无需强制要求子类继承，但需要自己实现默认实现，我们看下源码：<br><img src="http://img.mukewang.com/5d70798d00010b6111940364.png" alt="图片描述"><br>不仅仅是 forEach 这一个方法是这么干的，List、Set、Map 接口中很多新增的方法都是这么干的，通过 default 关键字，可以让 Java 7 的集合子类无需实现 Java 8 中新增的方法。</p>
<p>如果想在接口中新增一个方法，但又不想子类强制实现该方法时，可以给该方法加上 default 关键字，这个在实际工作中，也经常使用到，算是重构的小技巧吧。</p>
<h3 id="1-2-List-区别"><a href="#1-2-List-区别" class="headerlink" title="1.2 List 区别"></a>1.2 List 区别</h3><h4 id="1-2-1-ArrayList"><a href="#1-2-1-ArrayList" class="headerlink" title="1.2.1 ArrayList"></a>1.2.1 ArrayList</h4><ol>
<li>ArrayList 无参初始化时，Java 7 是直接初始化 10 的大小，Java 8 去掉了这个逻辑，初始化时是空数组，在第一次 add 时才开始按照 10 进行扩容，下图是源码的差异对比图：<br><img src="http://img.mukewang.com/5d7079470001ebfd20080254.png" alt="图片描述">List 其它方面 java7 和 8 并没有改动。</li>
</ol>
<h3 id="1-3-Map-区别"><a href="#1-3-Map-区别" class="headerlink" title="1.3 Map 区别"></a>1.3 Map 区别</h3><h4 id="1-3-1-HashMap"><a href="#1-3-1-HashMap" class="headerlink" title="1.3.1 HashMap"></a>1.3.1 HashMap</h4><ol>
<li>和 ArrayList 一样，Java 8 中 HashMap 在无参构造器中，丢弃了 Java 7 中直接把数组初始化 16 的做法，而是采用在第一次新增的时候，才开始扩容数组大小；</li>
<li>hash 算法计算公式不同，Java 8 的 hash 算法更加简单，代码更加简洁；</li>
<li>Java 8 的 HashMap 增加了红黑树的数据结构，这个是 Java 7 中没有的，Java 7 只有数组 + 链表的结构，Java 8 中提出了数组 + 链表 + 红黑树的结构，一般 key 是 Java 的 API 时，比如说 String 这些 hashcode 实现很好的 API，很少出现链表转化成红黑树的情况，因为 String 这些 API 的 hash 算法够好了，只有当 key 是我们自定义的类，而且我们覆写的 hashcode 算法非常糟糕时，才会真正使用到红黑树，提高我们的检索速度。</li>
</ol>
<p>也是因为 Java 8 新增了红黑树，所以几乎所有操作数组的方法的实现，都发生了变动，比如说 put、remove 等操作，可以说 Java 8 的 HashMap 几乎重写了一遍，所以 Java 7 的很多问题都被 Java 8 解决了，比如扩容时极小概率死锁，丢失数据等等。</p>
<ol>
<li>新增了一些好用的方法，比如 getOrDefault，我们看下源码，非常简单：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果 key 对应的值不存在，返回期望的默认值 defaultValue</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? defaultValue : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有 putIfAbsent(K key, V value) 方法，意思是，如果 map 中存在 key 了，那么 value 就不会覆盖，如果不存在 key ，新增成功。</p>
<p>还有 compute 方法，意思是允许我们把 key 和 value 的值进行计算后，再 put 到 map 中，为防止 key 值不存在造成未知错误，map 还提供了 computeIfPresent 方法，表示只有在 key 存在的时候，才执行计算，demo 如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span></span>&#123;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; map = Maps.newHashMap();</span><br><span class="line">    map.put(<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">    log.info(<span class="string">&quot;compute 之前值为：&#123;&#125;&quot;</span>,map.get(<span class="number">10</span>));</span><br><span class="line">    map.compute(<span class="number">10</span>,(key,value) -&gt; key * value);</span><br><span class="line">    log.info(<span class="string">&quot;compute 之后值为：&#123;&#125;&quot;</span>,map.get(<span class="number">10</span>));</span><br><span class="line">    <span class="comment">// 还原测试值</span></span><br><span class="line">    map.put(<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果为 11 的 key 不存在的话，需要注意 value 为空的情况，下面这行代码就会报空指针</span></span><br><span class="line">    <span class="comment">//  map.compute(11,(key,value) -&gt; key * value);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为了防止 key 不存在时导致的未知异常，我们一般有两种办法</span></span><br><span class="line">    <span class="comment">// 1：自己判断空指针</span></span><br><span class="line">    map.compute(<span class="number">11</span>,(key,value) -&gt; <span class="keyword">null</span> == value ? <span class="keyword">null</span> : key * value);</span><br><span class="line">    <span class="comment">// 2：computeIfPresent 方法里面判断</span></span><br><span class="line">    map.computeIfPresent(<span class="number">11</span>,(key,value) -&gt; key * value);</span><br><span class="line">    log.info(<span class="string">&quot;computeIfPresent 之后值为：&#123;&#125;&quot;</span>,map.get(<span class="number">11</span>));</span><br><span class="line">  &#125;</span><br><span class="line">结果是：</span><br><span class="line">compute 之前值为：<span class="number">10</span></span><br><span class="line">compute 之后值为：<span class="number">100</span></span><br><span class="line">computeIfPresent 之后值为：<span class="keyword">null</span>（这个结果中，可以看出，使用 computeIfPresent 避免了空指针）</span><br></pre></td></tr></table></figure>

<p>上述 Java 8 新增的几种方法非常好用，在实际工作中，可以大大减少我们的代码量，computeIfPresent 的源码就不贴了，有兴趣可以去 github 上面查看，主要的实现原理如下：</p>
<ul>
<li>找到 key 对应的老值，会分别从数组、链表、红黑树中找；</li>
<li>根据 key 和老值进行计算，得到新值；</li>
<li>用新值替换掉老值，可能是普通替换、链表替换或红黑树替换。</li>
</ul>
<h4 id="1-3-2-LinkedHashMap"><a href="#1-3-2-LinkedHashMap" class="headerlink" title="1.3.2 LinkedHashMap"></a>1.3.2 LinkedHashMap</h4><p>由于 Java 8 的底层数据有变动，导致 HashMap 操作数据的方法几乎重写，也使 LinkedHashMap 的实现名称上有所差异，原理上都相同，我们看下面的图，左边是 Java 7，右边是 Java 8。<br><img src="http://img.mukewang.com/5d7078fe0001a6b724721322.png" alt="图片描述">从图中，我们发现 LinkedHashMap 的方法名有所修改，底层的实现逻辑其实都差不多的。</p>
<h3 id="1-4-其他区别"><a href="#1-4-其他区别" class="headerlink" title="1.4 其他区别"></a>1.4 其他区别</h3><h4 id="1-4-1-Arrays-提供了很多-parallel-开头的方法。"><a href="#1-4-1-Arrays-提供了很多-parallel-开头的方法。" class="headerlink" title="1.4.1 Arrays 提供了很多 parallel 开头的方法。"></a>1.4.1 Arrays 提供了很多 parallel 开头的方法。</h4><p>Java 8 的 Arrays 提供了一些 parallel 开头的方法，这些方法支持并行的计算，在数据量大的时候，会充分利用 CPU ，提高计算效率，比如说 parallelSort 方法，方法底层有判断，只有数据量大于 8192 时，才会真正走并行的实现，在实际的实验中，并行计算的确能够快速的提高计算速度。</p>
<h3 id="1-5-面试题"><a href="#1-5-面试题" class="headerlink" title="1.5 面试题"></a>1.5 面试题</h3><ol>
<li>Java 8 在 List、Map 接口上新增了很多方法，为什么 Java 7 中这些接口的实现者不需要强制实现这些方法呢？</li>
</ol>
<p>答：主要是因为这些新增的方法被 default 关键字修饰了，default 一旦修饰接口上的方法，我们需要在接口的方法中写默认实现，并且子类无需强制实现这些方法，所以 Java 7 接口的实现者无需感知。</p>
<ol>
<li>Java 8 中有新增很多实用的方法，你在平时工作中有使用过么？</li>
</ol>
<p>答：有的，比如说 getOrDefault、putIfAbsent、computeIfPresent 方法等等，具体使用细节参考上文。</p>
<ol>
<li>说说 computeIfPresent 方法的使用姿势？</li>
</ol>
<p>答：computeIfPresent 是可以对 key 和 value 进行计算后，把计算的结果重新赋值给 key，并且如果 key 不存在时，不会报空指针，会返回 null 值。</p>
<ol>
<li>Java 8 集合新增了 forEach 方法，和普通的 for 循环有啥不同？</li>
</ol>
<p>答：新增的 forEach 方法的入参是函数式的接口，比如说 Consumer 和 BiConsumer，这样子做的好处就是封装了 for 循环的代码，让使用者只需关注实现每次循环的业务逻辑，简化了重复的 for 循环代码，使代码更加简洁，普通的 for 循环，每次都需要写重复的 for 循环代码，forEach 把这种重复的计算逻辑吃掉了，使用起来更加方便。</p>
<ol>
<li>HashMap 8 和 7 有啥区别？</li>
</ol>
<p>答：HashMap 8 和 7 的差别太大了，新增了红黑树，修改了底层数据逻辑，修改了 hash 算法，几乎所有底层数组变动的方法都重写了一遍，可以说 Java 8 的 HashMap 几乎重新了一遍。</p>
<h3 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h3><p>总体来说，List 方面是小改动，HashMap 几乎重写了一套，所有的集合都新增了函数式的方法，比如说 forEach，也新增了很多好用的函数，比如说 getOrDefault，这些函数可以大大减少我们的代码量，让我们把关注点聚焦在业务逻辑的实现上，这其实是一种思想，把繁琐重复的计算逻辑抽取出来，从计算逻辑中扩展出业务逻辑的口子，让使用者只专心关注业务逻辑的实现即可。</p>
<p>想要了解更多差异，也可直接前往 JDK 8 新特性查看，地址为：<a href="http://openjdk.java.net/projects/jdk8/features#103%E3%80%82">http://openjdk.java.net/projects/jdk8/features#103。</a></p>
<h2 id="14-简化工作：Guava-Lists-Maps-实际工作运用和源码"><a href="#14-简化工作：Guava-Lists-Maps-实际工作运用和源码" class="headerlink" title="14 简化工作：Guava Lists Maps 实际工作运用和源码"></a><strong>14 简化工作：Guava Lists Maps 实际工作运用和源码</strong></h2><h3 id="引导语-11"><a href="#引导语-11" class="headerlink" title="引导语"></a>引导语</h3><p>在日常工作中，我们经常会使用一些三方的 API 来简化我们的工作，Guava 就是其中一种，Guava 是 Google 开源的技术框架，使用率高，社区活跃度也很高。</p>
<p>本小节我们从工作中对 Guava 集合的使用入手，然后深入的看下其底层的实现，最后总结其设计思想，感兴趣的同学也可以下载源码学习，GitHub 地址：<a href="https://github.com/google/guava%EF%BC%8C%E6%BA%90%E7%A0%81%E4%B8%AD">https://github.com/google/guava，源码中</a> guava 的文件夹为其源码。</p>
<h3 id="1-运用工厂模式进行初始化"><a href="#1-运用工厂模式进行初始化" class="headerlink" title="1 运用工厂模式进行初始化"></a>1 运用工厂模式进行初始化</h3><p>在集合类初始化方面，Guava 比 Java 原生的 API 更加好用，还发明了很多新的功能，比如说在 JDK 7 之前，我们新建集合类时，声明和初始化都必须写上泛型说明，像这样：<code>List&lt;泛型&gt; list = new ArrayList&lt;泛型&gt;();</code> ， JDK 7 之后有所改变，我们只需要在声明处写上泛型说明，像这样：<code>List&lt;泛型&gt; list = new ArrayList&lt;&gt;();</code>。</p>
<p>Guava 提供了更加方便的使用姿势，采用了工厂模式，把集合创建的逻辑交给了工厂，开发者无需关注工厂底层是如何创建的，只需要关心，工厂能产生什么，代码于是变成了这样：<code>List&lt;泛型&gt; list = Lists.newArrayList();</code>，Lists 就是 Guava 提供出来的，方便操作 List 的工具类。</p>
<p>这种写法其实就是一种简单的工厂模式，只需要定义好工厂的入参和出参，就能对外隐藏其内部的创建逻辑，提供更加方便的使用体验。</p>
<p>当然除了 Lists，Guava 还提供了很多其他实用工具，如 Maps、Sets，接下来我们分别来看下这些常用工具的使用和原理。</p>
<h3 id="2-Lists"><a href="#2-Lists" class="headerlink" title="2 Lists"></a>2 Lists</h3><h4 id="2-1-初始化-1"><a href="#2-1-初始化-1" class="headerlink" title="2.1 初始化"></a>2.1 初始化</h4><p>Lists 最大的功能是能帮助我们进行 List 的初始化，比如我们刚说的 newArrayList 这种：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Lists.newArrayList();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">ArrayList&lt;E&gt; <span class="title">newArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这种底层是帮助我们写好了泛型，E 代表泛型，表示当前返回的泛型类型和声明的一致即可，在编译的时候，会把泛型 E 转化成我们声明的 String。</span></span><br></pre></td></tr></table></figure>

<p>如果你清楚 List 的大小，我们也可以这样做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以预估 list 的大小为 20</span></span><br><span class="line">List&lt;String&gt; list = Lists.newArrayListWithCapacity(<span class="number">20</span>);</span><br><span class="line"><span class="comment">// 不太肯定 list 大小是多少，但期望是大小是 20 上下。</span></span><br><span class="line">List&lt;String&gt; list = Lists.newArrayListWithExpectedSize(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<p>newArrayListWithCapacity(20) 方法内部实现是：<code>new ArrayList&lt;&gt;(20);</code>，而 newArrayListWithExpectedSize 方法内部实现是对 List 大小有一个计算公式的，计算公式为：<code>5L + arraySize + (arraySize / 10)</code> ，arraySize 表示传进来的值，公式简化下就是 5 + 11/10 * arraySize，因为这个方法表示期望的大小，所以这里取的约是期望值的十分之十一，比传进来的值约大十分之一，所以根据 20 最终计算出来的值是 27。</p>
<p>Lists 在初始化的时候，还支持传迭代器的入参（只适合小数据量的迭代器的入参），源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">ArrayList&lt;E&gt; <span class="title">newArrayList</span><span class="params">(Iterator&lt;? extends E&gt; elements)</span> </span>&#123;</span><br><span class="line">  ArrayList&lt;E&gt; list = newArrayList();</span><br><span class="line">  <span class="comment">// addAll 方法底层其实通过迭代器进行 for 循环添加</span></span><br><span class="line">  Iterators.addAll(list, elements);</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 Lists 对 List 初始化进行包装的底层源码来看，底层源码非常简单的，但我们还是愿意使用这种方式的包装，主要是因为这种工厂模式的包装，使我们的使用姿势更加优雅，使用起来更加方便。</p>
<h4 id="2-2-分组和反转排序"><a href="#2-2-分组和反转排序" class="headerlink" title="2.2 分组和反转排序"></a>2.2 分组和反转排序</h4><p>除了初始化之外，Lists 还提供了两个比较实用的功能，分组和反转排序功能，我们分别来演示一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 演示反转排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReverse</span><span class="params">()</span></span>&#123;</span><br><span class="line">  List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;()&#123;&#123;</span><br><span class="line">    add(<span class="string">&quot;10&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;20&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;30&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;40&quot;</span>);</span><br><span class="line">  &#125;&#125;;</span><br><span class="line">  log.info(<span class="string">&quot;反转之前：&quot;</span>+JSON.toJSONString(list));</span><br><span class="line">  list = Lists.reverse(list);</span><br><span class="line">  log.info(<span class="string">&quot;反转之后：&quot;</span>+JSON.toJSONString(list));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印出来的结果为：</span></span><br><span class="line">反转之前：[<span class="string">&quot;10&quot;</span>,<span class="string">&quot;20&quot;</span>,<span class="string">&quot;30&quot;</span>,<span class="string">&quot;40&quot;</span>]</span><br><span class="line">反转之后：[<span class="string">&quot;40&quot;</span>,<span class="string">&quot;30&quot;</span>,<span class="string">&quot;20&quot;</span>,<span class="string">&quot;10&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>reverse 方法底层实现非常巧妙，底层覆写了 List 原生的 get(index) 方法，会把传进来的 index 进行 (size - 1) - index 的计算，使计算得到的索引位置和 index 位置正好相反，这样当我们 get 时，数组索引位置的 index 已经是相反的位置了，达到了反转排序的效果，其实底层并没有进行反转排序，只是在计算相反的索引位置，通过计算相反的索引位置这样简单的设计，得到了反转排序的效果，很精妙。</p>
<p>在工作中，有时候我们需要把一个大的 list 进行切分，然后再把每份丢给线程池去运行，最后将每份运行的结果汇总，Lists 工具类就提供了一个对 list 进行切分分组的方法，演示 demo 如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPartition</span><span class="params">()</span></span>&#123;</span><br><span class="line">  List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;()&#123;&#123;</span><br><span class="line">    add(<span class="string">&quot;10&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;20&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;30&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;40&quot;</span>);</span><br><span class="line">  &#125;&#125;;</span><br><span class="line">  log.info(<span class="string">&quot;分组之前：&quot;</span>+JSON.toJSONString(list));</span><br><span class="line">   List&lt;List&lt;String&gt;&gt; list2 = Lists.partition(list,<span class="number">3</span>);</span><br><span class="line">  log.info(<span class="string">&quot;分组之后：&quot;</span>+JSON.toJSONString(list2));</span><br><span class="line">&#125;</span><br><span class="line">输出结果为：</span><br><span class="line">分组之前：[<span class="string">&quot;10&quot;</span>,<span class="string">&quot;20&quot;</span>,<span class="string">&quot;30&quot;</span>,<span class="string">&quot;40&quot;</span>]</span><br><span class="line">分组之后：[[<span class="string">&quot;10&quot;</span>,<span class="string">&quot;20&quot;</span>,<span class="string">&quot;30&quot;</span>],[<span class="string">&quot;40&quot;</span>]]</span><br></pre></td></tr></table></figure>

<p>partition 方法的第二个参数的意思，你想让分组后的 List 包含几个元素，这个方法的底层实现其实就是 subList 方法。</p>
<p>有一点需要我们注意的是这两个方法返回的 List 并不是 ArrayList，是自定义的 List，所以对于 ArrayList 的有些功能可能并不支持，使用的时候最好能看下源码，看看底层有无支持。</p>
<h4 id="2-3-小结-2"><a href="#2-3-小结-2" class="headerlink" title="2.3 小结"></a>2.3 小结</h4><p>Lists 上述的方法大大的方便了我们进行开发，简化了使用姿势，但其内部实现却非常简单巧妙，比如说 reverse 方法可以输出相反排序的 List，但底层并没有实现排序，只是计算了索引位置的相反值而已，这点值得我们学习。</p>
<h3 id="3-Maps"><a href="#3-Maps" class="headerlink" title="3 Maps"></a>3 Maps</h3><h4 id="3-1-初始化"><a href="#3-1-初始化" class="headerlink" title="3.1 初始化"></a>3.1 初始化</h4><p>Maps 也是有着各种初始化 Map 的各种方法，原理不说了，和 Lists 类似，我们演示下如何使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String,String&gt; hashMap = Maps.newHashMap();</span><br><span class="line">Map&lt;String,String&gt; linkedHashMap = Maps.newLinkedHashMap();</span><br><span class="line"><span class="comment">// 这里 Map 的初始化大小公式和 HashSet 初始化公式类似，还记得 HashSet 初始化 HashMap 时，经典的计算初始大小的公式么：取最大值（期望的值 / 0.75 + 1，默认值 16），newHashMapWithExpectedSize 方法底层也是这么算的初始化大小的</span></span><br><span class="line">Map&lt;String,String&gt; withExpectedSizeHashMap = Maps.newHashMapWithExpectedSize(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>



<h4 id="3-2-difference"><a href="#3-2-difference" class="headerlink" title="3.2 difference"></a>3.2 difference</h4><p>Maps 提供了一个特别有趣也很实用的方法：difference，此方法的目的是比较两个 Map 的差异，入参就是两个 Map，比较之后能够返回四种差异：</p>
<ol>
<li>左边 Map 独有 key。</li>
<li>右边 Map 独有 key。</li>
<li>左右边 Map 都有 key，并且 value 相等。</li>
<li>左右边 Map 都有 key，但是 value 不等。</li>
</ol>
<p>我们用代码来演示一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ImmutableMap.of 也是 Guava 提供初始化 Map 的方法，入参格式为 k1,v1,k2,v2,k3,v3……</span></span><br><span class="line">Map&lt;String,String&gt; leftMap = ImmutableMap.of(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;3&quot;</span>);</span><br><span class="line">Map&lt;String,String&gt; rightMap = ImmutableMap.of(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;30&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;4&quot;</span>);</span><br><span class="line">MapDifference difference = Maps.difference(leftMap, rightMap);</span><br><span class="line">log.info(<span class="string">&quot;左边 map 独有 key：&#123;&#125;&quot;</span>,difference.entriesOnlyOnLeft());</span><br><span class="line">log.info(<span class="string">&quot;右边 map 独有 key：&#123;&#125;&quot;</span>,difference.entriesOnlyOnRight());</span><br><span class="line">log.info(<span class="string">&quot;左右边 map 都有 key，并且 value 相等：&#123;&#125;&quot;</span>,difference.entriesInCommon());</span><br><span class="line">log.info(<span class="string">&quot;左右边 map 都有 key，但 value 不等：&#123;&#125;&quot;</span>,difference.entriesDiffering());</span><br><span class="line">最后打印结果为：</span><br><span class="line">左边 map 独有 key：&#123;<span class="number">1</span>=<span class="number">1</span>&#125;</span><br><span class="line">右边 map 独有 key：&#123;<span class="number">4</span>=<span class="number">4</span>&#125;</span><br><span class="line">左右边 map 都有 key，并且 value 相等：&#123;<span class="number">2</span>=<span class="number">2</span>&#125;</span><br><span class="line">左右边 map 都有 key，但 value 不等：&#123;<span class="number">3</span>=(<span class="number">3</span>, <span class="number">30</span>)&#125;</span><br></pre></td></tr></table></figure>

<p>从这个 demo 我们可以看到此方法的强大威力，我们在工作中经常遇到 Map 或者 List 间比较差异的任务，我们就可以直接使用该方法进行对比，List 可以先转化成 Map。</p>
<p>而且 difference 底层的实现也算是最优的实现了，只需要循环一遍，就可得到上述四种差异结果，源码解析如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对比两个 map 的差异</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;K, V&gt; <span class="function"><span class="keyword">void</span> <span class="title">doDifference</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Map&lt;? extends K, ? extends V&gt; left,</span></span></span><br><span class="line"><span class="function"><span class="params">    Map&lt;? extends K, ? extends V&gt; right,</span></span></span><br><span class="line"><span class="function"><span class="params">    Equivalence&lt;? <span class="keyword">super</span> V&gt; valueEquivalence,</span></span></span><br><span class="line"><span class="function"><span class="params">    // key 只在左边 map 出现</span></span></span><br><span class="line"><span class="function"><span class="params">    Map&lt;K, V&gt; onlyOnLeft,</span></span></span><br><span class="line"><span class="function"><span class="params">    // key 只在右边 map 出现，调用 doDifference 方法前已经包含了全部右边的值</span></span></span><br><span class="line"><span class="function"><span class="params">    Map&lt;K, V&gt; onlyOnRight,</span></span></span><br><span class="line"><span class="function"><span class="params">    // key 在左右 map 中都出现过，并且 value 都相等</span></span></span><br><span class="line"><span class="function"><span class="params">    Map&lt;K, V&gt; onBoth,</span></span></span><br><span class="line"><span class="function"><span class="params">    // key 在左右 map 中都出现过，但 value 不等</span></span></span><br><span class="line"><span class="function"><span class="params">    Map&lt;K, MapDifference.ValueDifference&lt;V&gt;&gt; differences)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 以左边 map 为基准进行循环</span></span><br><span class="line">  <span class="keyword">for</span> (Entry&lt;? extends K, ? extends V&gt; entry : left.entrySet()) &#123;</span><br><span class="line">    K leftKey = entry.getKey();</span><br><span class="line">    V leftValue = entry.getValue();</span><br><span class="line">    <span class="comment">// 右边 map 包含左边的 key</span></span><br><span class="line">    <span class="keyword">if</span> (right.containsKey(leftKey)) &#123;</span><br><span class="line">      <span class="comment">// onlyOnRight 已经包含全部右边的值 所以需要删除当前 key</span></span><br><span class="line">      V rightValue = onlyOnRight.remove(leftKey);</span><br><span class="line">      <span class="comment">// key 相等，并且 value 值也相等</span></span><br><span class="line">      <span class="keyword">if</span> (valueEquivalence.equivalent(leftValue, rightValue)) &#123;</span><br><span class="line">        onBoth.put(leftKey, leftValue);</span><br><span class="line">      <span class="comment">// key 相等，但 value 值不等</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        differences.put(leftKey, ValueDifferenceImpl.create(leftValue, rightValue));</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// 右边 map 不包含左边的 key，就是左边 map 独有的 key</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      onlyOnLeft.put(leftKey, leftValue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一种比较优秀的，快速比对的算法，可以好好看下上面的源码，然后把这种算法背下来，或者自己再次实现一次。</p>
<p>Sets 的使用方式和 Lists 和 Maps 很类似，没有太大的亮点，我们就不说了。</p>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h3><p>这一小节主要都是实战内容，在实际工作中可以用起来。</p>
<p>在 Guava 对集合的设计中，有两个大点是非常值得我们学习的：</p>
<ol>
<li>Lists、Maps 的出现给我们提供了更方便的使用姿势和方法，我们在实际工作中，如果碰到特别繁琐，或者特别难用的 API，我们也可以进行一些包装，使更好用，这个是属于在解决目前的痛点的问题上进行创新，是非常值得提倡的一件事情，往往可以帮助你拿到更好的绩效。</li>
<li>如果有人问你，List 或者 Map 高效的差异排序算法，完全可以参考 Maps.difference 的内部实现，该方法只使用了一次循环，就可得到所有的相同或不同结果，这种算法在我们工作中也经常被使用。</li>
</ol>
<p>了解更多，可以直接前往 Guava 的代码库查看：<a href="https://github.com/google/guava">https://github.com/google/guava</a></p>
<h1 id="第3章-并发集合类"><a href="#第3章-并发集合类" class="headerlink" title="第3章 并发集合类"></a><strong>第3章 并发集合类</strong></h1><h2 id="15-CopyOnWriteArrayList-源码解析和设计思路"><a href="#15-CopyOnWriteArrayList-源码解析和设计思路" class="headerlink" title="15 CopyOnWriteArrayList 源码解析和设计思路"></a><strong>15 CopyOnWriteArrayList 源码解析和设计思路</strong></h2><h3 id="引导语-12"><a href="#引导语-12" class="headerlink" title="引导语"></a>引导语</h3><p>在 ArrayList 的类注释上，JDK 就提醒了我们，如果要把 ArrayList 作为共享变量的话，是线程不安全的，推荐我们自己加锁或者使用 Collections.synchronizedList 方法，其实 JDK 还提供了另外一种线程安全的 List，叫做 CopyOnWriteArrayList，这个 List 具有以下特征：</p>
<ol>
<li>线程安全的，多线程环境下可以直接使用，无需加锁；</li>
<li>通过锁 + 数组拷贝 + volatile 关键字保证了线程安全；</li>
<li>每次数组操作，都会把数组拷贝一份出来，在新数组上进行操作，操作成功之后再赋值回去。</li>
</ol>
<h3 id="1-整体架构-3"><a href="#1-整体架构-3" class="headerlink" title="1 整体架构"></a>1 整体架构</h3><p>从整体架构上来说，CopyOnWriteArrayList 数据结构和 ArrayList 是一致的，底层是个数组，只不过 CopyOnWriteArrayList 在对数组进行操作的时候，基本会分四步走：</p>
<ol>
<li>加锁；</li>
<li>从原数组中拷贝出新数组；</li>
<li>在新数组上进行操作，并把新数组赋值给数组容器；</li>
<li>解锁。</li>
</ol>
<p>除了加锁之外，CopyOnWriteArrayList 的底层数组还被 volatile 关键字修饰，意思是一旦数组被修改，其它线程立马能够感知到，代码如下：</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">Object</span>[] array;</span><br></pre></td></tr></table></figure>

<p>整体上来说，CopyOnWriteArrayList 就是利用锁 + 数组拷贝 + volatile 关键字保证了 List 的线程安全。</p>
<h4 id="1-1-类注释-2"><a href="#1-1-类注释-2" class="headerlink" title="1.1 类注释"></a>1.1 类注释</h4><p>我们看看从 CopyOnWriteArrayList 的类注释上能得到哪些信息：</p>
<ol>
<li>所有的操作都是线程安全的，因为操作都是在新拷贝数组上进行的；</li>
<li>数组的拷贝虽然有一定的成本，但往往比一般的替代方案效率高；</li>
<li>迭代过程中，不会影响到原来的数组，也不会抛出 ConcurrentModificationException 异常。</li>
</ol>
<p>接着我们来看下 CopyOnWriteArrayList 的核心方法源码。</p>
<h3 id="2-新增-1"><a href="#2-新增-1" class="headerlink" title="2 新增"></a>2 新增</h3><p>新增有很多种情况，比如说：新增到数组尾部、新增到数组某一个索引位置、批量新增等等，操作的思路还是我们开头说的四步，我们拿新增到数组尾部的方法举例，来看看底层源码的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加元素到数组尾部</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 得到所有的原数组</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">// 拷贝到新数组里面，新数组的长度是 + 1 的，因为新增会多一个元素</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 在新数组中进行赋值，新元素直接放在数组的尾部</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">// 替换掉原来的数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// finally 里面释放锁，保证即使 try 发生了异常，仍然能够释放锁   </span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中，我们发现整个 add 过程都是在持有锁的状态下进行的，通过加锁，来保证同一时刻只能有一个线程能够对同一个数组进行 add 操作。</p>
<p>除了加锁之外，还会从老数组中创建出一个新数组，然后把老数组的值拷贝到新数组上，这时候就有一个问题：都已经加锁了，为什么需要拷贝数组，而不是在原来数组上面进行操作呢，原因主要为：</p>
<ol>
<li>volatile 关键字修饰的是数组，如果我们简单的在原来数组上修改其中某几个元素的值，是无法触发可见性的，我们必须通过修改数组的内存地址才行，也就说要对数组进行重新赋值才行。</li>
<li>在新的数组上进行拷贝，对老数组没有任何影响，只有新数组完全拷贝完成之后，外部才能访问到，降低了在赋值过程中，老数组数据变动的影响。</li>
</ol>
<p>简单 add 操作是直接添加到数组的尾部，接着我们来看下指定位置添加元素的关键源码（部分源码）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// len：数组的长度、index：插入的位置</span></span><br><span class="line"><span class="keyword">int</span> numMoved = len - index;</span><br><span class="line"><span class="comment">// 如果要插入的位置正好等于数组的末尾，直接拷贝数组即可</span></span><br><span class="line"><span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">    newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果要插入的位置在数组的中间，就需要拷贝 2 次</span></span><br><span class="line"><span class="comment">// 第一次从 0 拷贝到 index。</span></span><br><span class="line"><span class="comment">// 第二次从 index+1 拷贝到末尾。</span></span><br><span class="line">    newElements = <span class="keyword">new</span> Object[len + <span class="number">1</span>];</span><br><span class="line">    System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">    System.arraycopy(elements, index, newElements, index + <span class="number">1</span>,</span><br><span class="line">         numMoved);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// index 索引位置的值是空的，直接赋值即可。</span></span><br><span class="line">newElements[index] = element;</span><br><span class="line"><span class="comment">// 把新数组的值赋值给数组的容器中</span></span><br><span class="line">setArray(newElements);</span><br></pre></td></tr></table></figure>

<p>从源码中可以看到，当插入的位置正好处于末尾时，只需要拷贝一次，当插入的位置处于中间时，此时我们会把原数组一分为二，进行两次拷贝操作。</p>
<p>最后还有个批量新增操作，源码我们就不贴了，底层也是拷贝数组的操作。</p>
<h4 id="2-1-小结"><a href="#2-1-小结" class="headerlink" title="2.1 小结"></a>2.1 小结</h4><p>从 add 系列方法可以看出，CopyOnWriteArrayList 通过加锁 + 数组拷贝+ volatile 来保证了线程安全，每一个要素都有着其独特的含义：</p>
<ol>
<li>加锁：保证同一时刻数组只能被一个线程操作；</li>
<li>数组拷贝：保证数组的内存地址被修改，修改后触发 volatile 的可见性，其它线程可以立马知道数组已经被修改；</li>
<li>volatile：值被修改后，其它线程能够立马感知最新值。</li>
</ol>
<p>3 个要素缺一不可，比如说我们只使用 1 和 3 ，去掉 2，这样当我们修改数组中某个值时，并不会触发 volatile 的可见特性的，只有当数组内存地址被修改后，才能触发把最新值通知给其他线程的特性。</p>
<h3 id="3-删除"><a href="#3-删除" class="headerlink" title="3 删除"></a>3 删除</h3><p>接着我们来看下指定数组索引位置删除的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除某个索引位置的数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">// 先得到老值</span></span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line">        <span class="keyword">int</span> numMoved = len - index - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果要删除的数据正好是数组的尾部，直接删除</span></span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            setArray(Arrays.copyOf(elements, len - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果删除的数据在数组的中间，分三步走</span></span><br><span class="line">            <span class="comment">// 1. 设置新数组的长度减一，因为是减少一个元素</span></span><br><span class="line">            <span class="comment">// 2. 从 0 拷贝到数组新位置</span></span><br><span class="line">            <span class="comment">// 3. 从新位置拷贝到数组尾部</span></span><br><span class="line">            Object[] newElements = <span class="keyword">new</span> Object[len - <span class="number">1</span>];</span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            System.arraycopy(elements, index + <span class="number">1</span>, newElements, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤分为三步：</p>
<ol>
<li>加锁；</li>
<li>判断删除索引的位置，从而进行不同策略的拷贝；</li>
<li>解锁。</li>
</ol>
<p>代码整体的结构风格也比较统一：锁 + try finally +数组拷贝，锁被 final 修饰的，保证了在加锁过程中，锁的内存地址肯定不会被修改，finally 保证锁一定能够被释放，数组拷贝是为了删除其中某个位置的元素。</p>
<h3 id="4-批量删除"><a href="#4-批量删除" class="headerlink" title="4 批量删除"></a>4 批量删除</h3><p>数组的批量删除很有意思，接下来我们来看下 CopyOnWriteArrayList 的批量删除的实现过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 批量删除包含在 c 中的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">// 说明数组有值，数组无值直接返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (len != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// newlen 表示新数组的索引位置，新数组中存在不包含在 c 中的元素</span></span><br><span class="line">            <span class="keyword">int</span> newlen = <span class="number">0</span>;</span><br><span class="line">            Object[] temp = <span class="keyword">new</span> Object[len];</span><br><span class="line">            <span class="comment">// 循环，把不包含在 c 里面的元素，放到新数组中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">                Object element = elements[i];</span><br><span class="line">                <span class="comment">// 不包含在 c 中的元素，从 0 开始放到新数组中</span></span><br><span class="line">                <span class="keyword">if</span> (!c.contains(element))</span><br><span class="line">                    temp[newlen++] = element;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 拷贝新数组，变相的删除了不包含在 c 中的元素</span></span><br><span class="line">            <span class="keyword">if</span> (newlen != len) &#123;</span><br><span class="line">                setArray(Arrays.copyOf(temp, newlen));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中，我们可以看到，我们并不会直接对数组中的元素进行挨个删除，而是先对数组中的值进行循环判断，把我们不需要删除的数据放到临时数组中，最后临时数组中的数据就是我们不需要删除的数据。</p>
<p>不知道大家有木有似曾相识的感觉，ArrayList 的批量删除的思想也是和这个类似的，所以我们在需要删除多个元素的时候，最好都使用这种批量删除的思想，而不是采用在 for 循环中使用单个删除的方法，单个删除的话，在每次删除的时候都会进行一次数组拷贝(删除最后一个元素时不会拷贝)，很消耗性能，也耗时，会导致加锁时间太长，并发大的情况下，会造成大量请求在等待锁，这也会占用一定的内存。</p>
<h3 id="5-其它方法"><a href="#5-其它方法" class="headerlink" title="5 其它方法"></a>5 其它方法</h3><h4 id="5-1-indexOf"><a href="#5-1-indexOf" class="headerlink" title="5.1 indexOf"></a>5.1 indexOf</h4><p>indexOf 方法的主要用处是查找元素在数组中的下标位置，如果元素存在就返回元素的下标位置，元素不存在的话返回 -1，不但支持 null 值的搜索，还支持正向和反向的查找，我们以正向查找为例，通过源码来说明一下其底层的实现方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// o：我们需要搜索的元素</span></span><br><span class="line"><span class="comment">// elements：我们搜索的目标数组</span></span><br><span class="line"><span class="comment">// index：搜索的开始位置</span></span><br><span class="line"><span class="comment">// fence：搜索的结束位置</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o, Object[] elements,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> index, <span class="keyword">int</span> fence)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 支持对 null 的搜索</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; fence; i++)</span><br><span class="line">            <span class="comment">// 找到第一个 null 值，返回下标索引的位置</span></span><br><span class="line">            <span class="keyword">if</span> (elements[i] == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 通过 equals 方法来判断元素是否相等</span></span><br><span class="line">        <span class="comment">// 如果相等，返回元素的下标位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; fence; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elements[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>indexOf 方法在 CopyOnWriteArrayList 内部使用也比较广泛，比如在判断元素是否存在时（contains），在删除元素方法中校验元素是否存在时，都会使用到 indexOf 方法，indexOf 方法通过一次 for 循环来查找元素，我们在调用此方法时，需要注意如果找不到元素时，返回的是 -1，所以有可能我们会对这个特殊值进行判断。</p>
<h4 id="5-2-迭代"><a href="#5-2-迭代" class="headerlink" title="5.2 迭代"></a>5.2 迭代</h4><p>在 CopyOnWriteArrayList 类注释中，明确说明了，在其迭代过程中，即使数组的原值被改变，也不会抛出 ConcurrentModificationException 异常，其根源在于数组的每次变动，都会生成新的数组，不会影响老数组，这样的话，迭代过程中，根本就不会发生迭代数组的变动，我们截几个图说明一下：</p>
<ol>
<li>迭代是直接持有原有数组的引用，也就是说迭代过程中，一旦原有数组的值内存地址发生变化，必然会影响到迭代过程，下图源码演示的是 CopyOnWriteArrayList 的迭代方法，我们可以看到迭代器是直接持有原数组的引用：<br><img src="http://img.mukewang.com/5d88354300010c5111460592.png" alt="图片描述"></li>
<li>我们写了一个 demo，在 CopyOnWriteArrayList 迭代之后，往 CopyOnWriteArrayList 里面新增值，从下图中可以看到在 CopyOnWriteArrayList 迭代之前，数组的内存地址是 962，请记住这个数字：<br><img src="http://img.mukewang.com/5d8835800001ffca14040700.png" alt="图片描述"></li>
<li>CopyOnWriteArrayList 迭代之后，我们使用 add(“50”) 代码给数组新增一个数据后，数组内存地址发生了变化，内存地址从原来的 962 变成了 968，这是因为 CopyOnWriteArrayList 的 add 操作，会生成新的数组，所以数组的内存地址发生了变化：<br><img src="http://img.mukewang.com/5d8835ac0001af7d13980550.png" alt="图片描述"></li>
<li>迭代继续进行时，我们发现迭代器中的地址仍然是迭代之前引用的地址，是 962，而不是新的数组的内存地址：<br><img src="http://img.mukewang.com/5d8835c20001596615780740.png" alt="图片描述"></li>
</ol>
<p>从上面 4 张截图，我们可以得到迭代过程中，即使 CopyOnWriteArrayList 的结构发生变动了，也不会抛出 ConcurrentModificationException 异常的原因：CopyOnWriteArrayList 迭代持有的是老数组的引用，而 CopyOnWriteArrayList 每次的数据变动，都会产生新的数组，对老数组的值不会产生影响，所以迭代也可以正常进行。</p>
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h3><p>当我们需要在线程不安全场景下使用 List 时，建议使用 CopyOnWriteArrayList，CopyOnWriteArrayList 通过锁 + 数组拷贝 + volatile 之间的相互配合，实现了 List 的线程安全，我们抛弃 Java 的这种实现，如果让我们自己实现，你又将如何实现呢？</p>
<h2 id="16-ConcurrentHashMap-源码解析和设计思路"><a href="#16-ConcurrentHashMap-源码解析和设计思路" class="headerlink" title="16 ConcurrentHashMap 源码解析和设计思路"></a><strong>16 ConcurrentHashMap 源码解析和设计思路</strong></h2><h3 id="引导语-13"><a href="#引导语-13" class="headerlink" title="引导语"></a>引导语</h3><p>当我们碰到线程不安全场景下，需要使用 Map 的时候，我们第一个想到的 API 估计就是 ConcurrentHashMap，ConcurrentHashMap 内部封装了锁和各种数据结构来保证访问 Map 是线程安全的，接下来我们一一来看下，和 HashMap 相比，多了哪些数据结构，又是如何保证线程安全的。</p>
<h3 id="1-类注释"><a href="#1-类注释" class="headerlink" title="1 类注释"></a>1 类注释</h3><p>我们从类注释上大概可以得到如下信息：</p>
<ol>
<li>所有的操作都是线程安全的，我们在使用时，无需再加锁；</li>
<li>多个线程同时进行 put、remove 等操作时并不会阻塞，可以同时进行，和 HashTable 不同，HashTable 在操作时，会锁住整个 Map；</li>
<li>迭代过程中，即使 Map 结构被修改，也不会抛 ConcurrentModificationException 异常；</li>
<li>除了数组 + 链表 + 红黑树的基本结构外，新增了转移节点，是为了保证扩容时的线程安全的节点；</li>
<li>提供了很多 Stream 流式方法，比如说：forEach、search、reduce 等等。</li>
</ol>
<p>从类注释中，我们可以看出 ConcurrentHashMap 和 HashMap 相比，新增了转移节点的数据结构，至于底层如何实现线程安全，转移节点的具体细节，暂且看不出来，接下来我们细看源码。</p>
<h3 id="2-结构"><a href="#2-结构" class="headerlink" title="2 结构"></a>2 结构</h3><p>虽然 ConcurrentHashMap 的底层数据结构，和方法的实现细节和 HashMap 大体一致，但两者在类结构上却没有任何关联，我们看下 ConcurrentHashMap 的类图：<br><img src="http://img.mukewang.com/5d883afd0001a01a04670199.png" alt="图片描述"><br>看 ConcurrentHashMap 源码，我们会发现很多方法和代码和 HashMap 很相似，有的同学可能会问，为什么不继承 HashMap 呢？继承的确是个好办法，但尴尬的是，ConcurrentHashMap 都是在方法中间进行一些加锁操作，也就是说加锁把方法切割了，继承就很难解决这个问题。</p>
<p>ConcurrentHashMap 和 HashMap 两者的相同之处：</p>
<ol>
<li>数组、链表结构几乎相同，所以底层对数据结构的操作思路是相同的（只是思路相同，底层实现不同）；</li>
<li>都实现了 Map 接口，继承了 AbstractMap 抽象类，所以大多数的方法也都是相同的，HashMap 有的方法，ConcurrentHashMap 几乎都有，所以当我们需要从 HashMap 切换到 ConcurrentHashMap 时，无需关心两者之间的兼容问题。</li>
</ol>
<p>不同之处：</p>
<ol>
<li>红黑树结构略有不同，HashMap 的红黑树中的节点叫做 TreeNode，TreeNode 不仅仅有属性，还维护着红黑树的结构，比如说查找，新增等等；ConcurrentHashMap 中红黑树被拆分成两块，TreeNode 仅仅维护的属性和查找功能，新增了 TreeBin，来维护红黑树结构，并负责根节点的加锁和解锁；</li>
<li>新增 ForwardingNode （转移）节点，扩容的时候会使用到，通过使用该节点，来保证扩容时的线程安全。</li>
</ol>
<h3 id="3-put"><a href="#3-put" class="headerlink" title="3 put"></a>3 put</h3><p>ConcurrentHashMap 在 put 方法上的整体思路和 HashMap 相同，但在线程安全方面写了很多保障的代码，我们先来看下大体思路：</p>
<ol>
<li>如果数组为空，初始化，初始化完成之后，走 2；</li>
<li>计算当前槽点有没有值，没有值的话，cas 创建，失败继续自旋（for 死循环），直到成功，槽点有值的话，走 3；</li>
<li>如果槽点是转移节点(正在扩容)，就会一直自旋等待扩容完成之后再新增，不是转移节点走 4；</li>
<li>槽点有值的，先锁定当前槽点，保证其余线程不能操作，如果是链表，新增值到链表的尾部，如果是红黑树，使用红黑树新增的方法新增；</li>
<li>新增完成之后 check 需不需要扩容，需要的话去扩容。</li>
</ol>
<p>具体源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//计算hash</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">//table是空的，进行初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">//如果当前索引位置没有值，直接创建</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//cas 在 i 位置创建新的元素，当 i 位置是空时，即能创建成功，结束for自循，否则继续自旋</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果当前槽点是转移节点，表示该槽点正在扩容，就会一直等待扩容完成</span></span><br><span class="line">        <span class="comment">//转移节点的 hash 值是固定的，都是 MOVED</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="comment">//槽点上有值的</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//锁定当前槽点，其余线程不能操作，保证了安全</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">//这里再次判断 i 索引位置的数据没有被修改</span></span><br><span class="line">                <span class="comment">//binCount 被赋值的话，说明走到了修改表的过程里面</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//链表</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">//值有的话，直接返回</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="comment">//把新增的元素赋值到链表的最后，退出自旋</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//红黑树，这里没有使用 TreeNode,使用的是 TreeBin，TreeNode 只是红黑树的一个节点</span></span><br><span class="line">                    <span class="comment">//TreeBin 持有红黑树的引用，并且会对其加锁，保证其操作的线程安全</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">//满足if的话，把老的值给oldVal</span></span><br><span class="line">                        <span class="comment">//在putTreeVal方法里面，在给红黑树重新着色旋转的时候</span></span><br><span class="line">                        <span class="comment">//会锁住红黑树的根节点</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//binCount不为空，并且 oldVal 有值的情况，说明已经新增成功了</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 链表是否需要转化成红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="comment">//这一步几乎走不到。槽点已经上锁，只有在红黑树或者链表新增失败的时候</span></span><br><span class="line">                <span class="comment">//才会走到这里，这两者新增都是自旋的，几乎不会失败</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//check 容器是否需要扩容，如果需要去扩容，调用 transfer 方法去扩容</span></span><br><span class="line">    <span class="comment">//如果已经在扩容中了，check有无完成</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码中都有非常详细的注释，就不解释了，我们重点说一下，ConcurrentHashMap 在 put 过程中，采用了哪些手段来保证线程安全。</p>
<h4 id="3-1-数组初始化时的线程安全"><a href="#3-1-数组初始化时的线程安全" class="headerlink" title="3.1 数组初始化时的线程安全"></a>3.1 数组初始化时的线程安全</h4><p>数组初始化时，首先通过自旋来保证一定可以初始化成功，然后通过 CAS 设置 SIZECTL 变量的值，来保证同一时刻只能有一个线程对数组进行初始化，CAS 成功之后，还会再次判断当前数组是否已经初始化完成，如果已经初始化完成，就不会再次初始化，通过自旋 + CAS + 双重 check 等手段保证了数组初始化时的线程安全，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化 table，通过对 sizeCtl 的变量赋值来保证数组只能被初始化一次</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="comment">//通过自旋保证初始化成功</span></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 小于 0 代表有线程正在初始化，释放当前 CPU 的调度权，重新发起锁的竞争</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="comment">// CAS 赋值保证当前只有一个线程在初始化，-1 代表当前只有一个线程能初始化</span></span><br><span class="line">        <span class="comment">// 保证了数组的初始化的安全性</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 很有可能执行到这里的时候，table 已经不为空了，这里是双重 check</span></span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 进行初始化</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-2-新增槽点值时的线程安全"><a href="#3-2-新增槽点值时的线程安全" class="headerlink" title="3.2 新增槽点值时的线程安全"></a>3.2 新增槽点值时的线程安全</h4><p>此时为了保证线程安全，做了四处优化：</p>
<ol>
<li>通过自旋死循环保证一定可以新增成功。</li>
</ol>
<p>在新增之前，通过 <code>for (Node[] tab = table;;)</code> 这样的死循环来保证新增一定可以成功，一旦新增成功，就可以退出当前死循环，新增失败的话，会重复新增的步骤，直到新增成功为止。</p>
<ol>
<li>当前槽点为空时，通过 CAS 新增。</li>
</ol>
<p>Java 这里的写法非常严谨，没有在判断槽点为空的情况下直接赋值，因为在判断槽点为空和赋值的瞬间，很有可能槽点已经被其他线程赋值了，所以我们采用 CAS 算法，能够保证槽点为空的情况下赋值成功，如果恰好槽点已经被其他线程赋值，当前 CAS 操作失败，会再次执行 for 自旋，再走槽点有值的 put 流程，这里就是自旋 + CAS 的结合。</p>
<ol>
<li>当前槽点有值，锁住当前槽点。</li>
</ol>
<p>put 时，如果当前槽点有值，就是 key 的 hash 冲突的情况，此时槽点上可能是链表或红黑树，我们通过锁住槽点，来保证同一时刻只会有一个线程能对槽点进行修改，截图如下：</p>
<p><img src="http://img.mukewang.com/5d883acd0001833304130067.png" alt="图片描述"></p>
<ol>
<li>红黑树旋转时，锁住红黑树的根节点，保证同一时刻，当前红黑树只能被一个线程旋转，代码截图如下：<br><img src="http://img.mukewang.com/5d883adb000166bb05880443.png" alt="图片描述"></li>
</ol>
<p>通过以上 4 点，保证了在各种情况下的新增（不考虑扩容的情况下），都是线程安全的，通过自旋 + CAS + 锁三大姿势，实现的很巧妙，值得我们借鉴。</p>
<h4 id="3-3-扩容时的线程安全"><a href="#3-3-扩容时的线程安全" class="headerlink" title="3.3 扩容时的线程安全"></a>3.3 扩容时的线程安全</h4><p>ConcurrentHashMap 的扩容时机和 HashMap 相同，都是在 put 方法的最后一步检查是否需要扩容，如果需要则进行扩容，但两者扩容的过程完全不同，ConcurrentHashMap 扩容的方法叫做 transfer，从 put 方法的 addCount 方法进去，就能找到 transfer 方法，transfer 方法的主要思路是：</p>
<ol>
<li>首先需要把老数组的值全部拷贝到扩容之后的新数组上，先从数组的队尾开始拷贝；</li>
<li>拷贝数组的槽点时，先把原数组槽点锁住，保证原数组槽点不能操作，成功拷贝到新数组时，把原数组槽点赋值为转移节点；</li>
<li>这时如果有新数据正好需要 put 到此槽点时，发现槽点为转移节点，就会一直等待，所以在扩容完成之前，该槽点对应的数据是不会发生变化的；</li>
<li>从数组的尾部拷贝到头部，每拷贝成功一次，就把原数组中的节点设置成转移节点；</li>
<li>直到所有数组数据都拷贝到新数组时，直接把新数组整个赋值给数组容器，拷贝完成。</li>
</ol>
<p>关键源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 扩容主要分 2 步，第一新建新的空数组，第二移动拷贝每个元素到新数组中去</span></span><br><span class="line"><span class="comment">// tab：原数组，nextTab：新数组</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 老数组的长度</span></span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">    <span class="comment">// 如果新数组为空，初始化，大小为原数组的两倍，n &lt;&lt; 1</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新数组的长度</span></span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">    <span class="comment">// 代表转移节点，如果原数组上是转移节点，说明该节点正在被扩容</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    <span class="comment">// 无限自旋，i 的值会从原数组的最大值开始，慢慢递减到 0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="comment">// 结束循环的标志</span></span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 已经拷贝完成</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 每次减少 i 的值</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if 任意条件满足说明拷贝结束了</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="comment">// 拷贝结束，直接赋值，因为每次拷贝完一个节点，都在原数组上放转移节点，所以拷贝完成的节点的数据一定不会再发生变化。</span></span><br><span class="line">            <span class="comment">// 原数组发现是转移节点，是不会操作的，会一直等待转移节点消失之后在进行操作。</span></span><br><span class="line">            <span class="comment">// 也就是说数组节点一旦被标记为转移节点，是不会再发生任何变动的，所以不会有任何线程安全的问题</span></span><br><span class="line">            <span class="comment">// 所以此处直接赋值，没有任何问题。</span></span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">// 进行节点的拷贝</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果节点只有单个数据，直接拷贝，如果是链表，循环多次组成链表拷贝</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 在新数组位置上放置拷贝的值</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">// 在老数组位置上放上 ForwardingNode 节点</span></span><br><span class="line">                        <span class="comment">// put 时，发现是 ForwardingNode 节点，就不会再动这个节点的数据了</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 红黑树的拷贝</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        <span class="comment">// 红黑树的拷贝工作，同 HashMap 的内容，代码忽略</span></span><br><span class="line">                        …………</span><br><span class="line">                        <span class="comment">// 在老数组位置上放上 ForwardingNode 节点</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩容中的关键点，就是如何保证是线程安全的，小结有如下几点：</p>
<ol>
<li>拷贝槽点时，会把原数组的槽点锁住；</li>
<li>拷贝成功之后，会把原数组的槽点设置成转移节点，这样如果有数据需要 put 到该节点时，发现该槽点是转移节点，会一直等待，直到扩容成功之后，才能继续 put，可以参考 put 方法中的 helpTransfer 方法；</li>
<li>从尾到头进行拷贝，拷贝成功就把原数组的槽点设置成转移节点。</li>
<li>等扩容拷贝都完成之后，直接把新数组的值赋值给数组容器，之前等待 put 的数据才能继续 put。</li>
</ol>
<p>扩容方法还是很有意思的，通过在原数组上设置转移节点，put 时碰到转移节点时会等待扩容成功之后才能 put 的策略，来保证了整个扩容过程中肯定是线程安全的，因为数组的槽点一旦被设置成转移节点，在没有扩容完成之前，是无法进行操作的。</p>
<h3 id="4-get"><a href="#4-get" class="headerlink" title="4 get"></a>4 get</h3><p>ConcurrentHashMap 读的话，就比较简单，先获取数组的下标，然后通过判断数组下标的 key 是否和我们的 key 相等，相等的话直接返回，如果下标的槽点是链表或红黑树的话，分别调用相应的查找数据的方法，整体思路和 HashMap 很像，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="comment">//计算hashcode</span></span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="comment">//不是空的数组 &amp;&amp; 并且当前索引的槽点数据不是空的</span></span><br><span class="line">    <span class="comment">//否则该key对应的值不存在，返回null</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//槽点第一个值和key相等，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是红黑树或者转移节点，使用对应的find方法</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//如果是链表，遍历查找</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h3><p>本文摘取 ConcurrentHashMap 两个核心的方法讲解了一下，特别是 put 方法，采取了很多手段来保证了线程安全，是平时面试时的重中之重，大家可以尝试 debug 来调试一下源码，其他方法感兴趣的话，可以尝试去 GitHub 上去查看源码。</p>
<h2 id="17-并发-List、Map源码面试题"><a href="#17-并发-List、Map源码面试题" class="headerlink" title="17 并发 List、Map源码面试题"></a><strong>17 并发 List、Map源码面试题</strong></h2><h3 id="引导语-14"><a href="#引导语-14" class="headerlink" title="引导语"></a>引导语</h3><p>并发 List 和 Map 是技术面时常问的问题，问的问题也都比较深入，有很多问题都是面试官自创的，市面上找不到，所以说通过背题的方式，这一关大部分是过不了的，只有我们真正理解了 API 内部的实现，阅读过源码，才能自如应对各种类型的面试题，接着我们来看一下并发 List、Map 源码相关的面试题集。</p>
<h3 id="1-CopyOnWriteArrayList-相关"><a href="#1-CopyOnWriteArrayList-相关" class="headerlink" title="1 CopyOnWriteArrayList 相关"></a>1 CopyOnWriteArrayList 相关</h3><h4 id="1-1-和-ArrayList-相比有哪些相同点和不同点？"><a href="#1-1-和-ArrayList-相比有哪些相同点和不同点？" class="headerlink" title="1.1 和 ArrayList 相比有哪些相同点和不同点？"></a>1.1 和 ArrayList 相比有哪些相同点和不同点？</h4><p>答：相同点：底层的数据结构是相同的，都是数组的数据结构，提供出来的 API 都是对数组结构进行操作，让我们更好的使用。</p>
<p>不同点：后者是线程安全的，在多线程环境下使用，无需加锁，可直接使用。</p>
<h4 id="1-2-CopyOnWriteArrayList-通过哪些手段实现了线程安全？"><a href="#1-2-CopyOnWriteArrayList-通过哪些手段实现了线程安全？" class="headerlink" title="1.2 CopyOnWriteArrayList 通过哪些手段实现了线程安全？"></a>1.2 CopyOnWriteArrayList 通过哪些手段实现了线程安全？</h4><p>答：主要有：1. 数组容器被 volatile 关键字修饰，保证了数组内存地址被任意线程修改后，都会通知到其他线程；</p>
<ol>
<li>对数组的所有修改操作，都进行了加锁，保证了同一时刻，只能有一个线程对数组进行修改，比如我在 add 时，就无法 remove；</li>
<li>修改过程中对原数组进行了复制，是在新数组上进行修改的，修改过程中，不会对原数组产生任何影响。</li>
</ol>
<p>通过以上三点保证了线程安全。</p>
<h4 id="1-3-在-add-方法中，对数组进行加锁后，不是已经是线程安全了么，为什么还需要对老数组进行拷贝？"><a href="#1-3-在-add-方法中，对数组进行加锁后，不是已经是线程安全了么，为什么还需要对老数组进行拷贝？" class="headerlink" title="1.3 在 add 方法中，对数组进行加锁后，不是已经是线程安全了么，为什么还需要对老数组进行拷贝？"></a>1.3 在 add 方法中，对数组进行加锁后，不是已经是线程安全了么，为什么还需要对老数组进行拷贝？</h4><p>答：的确，对数组进行加锁后，能够保证同一时刻，只有一个线程能对数组进行 add，在同单核 CPU 下的多线程环境下肯定没有问题，但我们现在的机器都是多核 CPU，如果我们不通过复制拷贝新建数组，修改原数组容器的内存地址的话，是无法触发 volatile 可见性效果的，那么其他 CPU 下的线程就无法感知数组原来已经被修改了，就会引发多核 CPU 下的线程安全问题。</p>
<p>假设我们不复制拷贝，而是在原来数组上直接修改值，数组的内存地址就不会变，而数组被 volatile 修饰时，必须当数组的内存地址变更时，才能及时的通知到其他线程，内存地址不变，仅仅是数组元素值发生变化时，是无法把数组元素值发生变动的事实，通知到其它线程的。</p>
<h4 id="1-4-对老数组进行拷贝，会有性能损耗，我们平时使用需要注意什么么？"><a href="#1-4-对老数组进行拷贝，会有性能损耗，我们平时使用需要注意什么么？" class="headerlink" title="1.4 对老数组进行拷贝，会有性能损耗，我们平时使用需要注意什么么？"></a>1.4 对老数组进行拷贝，会有性能损耗，我们平时使用需要注意什么么？</h4><p>答：主要有：</p>
<ol>
<li>在批量操作时，尽量使用 addAll、removeAll 方法，而不要在循环里面使用 add、remove 方法，主要是因为 for 循环里面使用 add 、remove 的方式，在每次操作时，都会进行一次数组的拷贝(甚至多次)，非常耗性能，而 addAll、removeAll 方法底层做了优化，整个操作只会进行一次数组拷贝，由此可见，当批量操作的数据越多时，批量方法的高性能体现的越明显。</li>
</ol>
<h4 id="1-5-为什么-CopyOnWriteArrayList-迭代过程中，数组结构变动，不会抛出ConcurrentModificationException-了"><a href="#1-5-为什么-CopyOnWriteArrayList-迭代过程中，数组结构变动，不会抛出ConcurrentModificationException-了" class="headerlink" title="1.5 为什么 CopyOnWriteArrayList 迭代过程中，数组结构变动，不会抛出ConcurrentModificationException 了"></a>1.5 为什么 CopyOnWriteArrayList 迭代过程中，数组结构变动，不会抛出ConcurrentModificationException 了</h4><p>答：主要是因为 CopyOnWriteArrayList 每次操作时，都会产生新的数组，而迭代时，持有的仍然是老数组的引用，所以我们说的数组结构变动，是用新数组替换了老数组，老数组的结构并没有发生变化，所以不会抛出异常了。</p>
<h4 id="1-6-插入的数据正好在-List-的中间，请问两种-List-分别拷贝数组几次？为什么？"><a href="#1-6-插入的数据正好在-List-的中间，请问两种-List-分别拷贝数组几次？为什么？" class="headerlink" title="1.6 插入的数据正好在 List 的中间，请问两种 List 分别拷贝数组几次？为什么？"></a>1.6 插入的数据正好在 List 的中间，请问两种 List 分别拷贝数组几次？为什么？</h4><p>答：ArrayList 只需拷贝一次，假设插入的位置是 2，只需要把位置 2 （包含 2）后面的数据都往后移动一位即可，所以拷贝一次。</p>
<p>CopyOnWriteArrayList 拷贝两次，因为 CopyOnWriteArrayList 多了把老数组的数据拷贝到新数组上这一步，可能有的同学会想到这种方式：先把老数组拷贝到新数组，再把 2 后面的数据往后移动一位，这的确是一种拷贝的方式，但 CopyOnWriteArrayList 底层实现更加灵活，而是：把老数组 0 到 2 的数据拷贝到新数组上，预留出新数组 2 的位置，再把老数组 3～ 最后的数据拷贝到新数组上，这种拷贝方式可以减少我们拷贝的数据，虽然是两次拷贝，但拷贝的数据却仍然是老数组的大小，设计的非常巧妙。</p>
<h3 id="2-ConcurrentHashMap-相关"><a href="#2-ConcurrentHashMap-相关" class="headerlink" title="2 ConcurrentHashMap 相关"></a>2 ConcurrentHashMap 相关</h3><h4 id="2-1ConcurrentHashMap-和-HashMap-的相同点和不同点"><a href="#2-1ConcurrentHashMap-和-HashMap-的相同点和不同点" class="headerlink" title="2.1ConcurrentHashMap 和 HashMap 的相同点和不同点"></a>2.1ConcurrentHashMap 和 HashMap 的相同点和不同点</h4><p>答：相同点：1. 都是数组 + 链表 +红黑树的数据结构，所以基本操作的思想相同；</p>
<ol>
<li>都实现了 Map 接口，继承了 AbstractMap 抽象类，所以两者的方法大多都是相似的，可以互相切换。</li>
</ol>
<p>不同点：1. ConcurrentHashMap 是线程安全的，在多线程环境下，无需加锁，可直接使用；</p>
<ol>
<li>数据结构上，ConcurrentHashMap 多了转移节点，主要用于保证扩容时的线程安全。</li>
</ol>
<h4 id="2-2-ConcurrentHashMap-通过哪些手段保证了线程安全。"><a href="#2-2-ConcurrentHashMap-通过哪些手段保证了线程安全。" class="headerlink" title="2.2 ConcurrentHashMap 通过哪些手段保证了线程安全。"></a>2.2 ConcurrentHashMap 通过哪些手段保证了线程安全。</h4><p>答：主要有以下几点：</p>
<ol>
<li>储存 Map 数据的数组被 volatile 关键字修饰，一旦被修改，立马就能通知其他线程，因为是数组，所以需要改变其内存值，才能真正的发挥出 volatile 的可见特性；</li>
<li>put 时，如果计算出来的数组下标索引没有值的话，采用无限 for 循环 + CAS 算法，来保证一定可以新增成功，又不会覆盖其他线程 put 进去的值；</li>
<li>如果 put 的节点正好在扩容，会等待扩容完成之后，再进行 put ，保证了在扩容时，老数组的值不会发生变化；</li>
<li>对数组的槽点进行操作时，会先锁住槽点，保证只有当前线程才能对槽点上的链表或红黑树进行操作；</li>
<li>红黑树旋转时，会锁住根节点，保证旋转时的线程安全。</li>
</ol>
<h4 id="2-3-描述一下-CAS-算法在-ConcurrentHashMap-中的应用？"><a href="#2-3-描述一下-CAS-算法在-ConcurrentHashMap-中的应用？" class="headerlink" title="2.3 描述一下 CAS 算法在 ConcurrentHashMap 中的应用？"></a>2.3 描述一下 CAS 算法在 ConcurrentHashMap 中的应用？</h4><p>答：CAS 其实是一种乐观锁，一般有三个值，分别为：赋值对象，原值，新值，在执行的时候，会先判断内存中的值是否和原值相等，相等的话把新值赋值给对象，否则赋值失败，整个过程都是原子性操作，没有线程安全问题。</p>
<p>ConcurrentHashMap 的 put 方法中，有使用到 CAS ，是结合无限 for 循环一起使用的，步骤如下：</p>
<ol>
<li>计算出数组索引下标，拿出下标对应的原值；</li>
<li>CAS 覆盖当前下标的值，赋值时，如果发现内存值和 1 拿出来的原值相等，执行赋值，退出循环，否则不赋值，转到 3；</li>
<li>进行下一次 for 循环，重复执行 1，2，直到成功为止。</li>
</ol>
<p>可以看到这样做的好处，第一是不会盲目的覆盖原值，第二是一定可以赋值成功。</p>
<h4 id="2-4-ConcurrentHashMap-是如何发现当前槽点正在扩容的。"><a href="#2-4-ConcurrentHashMap-是如何发现当前槽点正在扩容的。" class="headerlink" title="2.4 ConcurrentHashMap 是如何发现当前槽点正在扩容的。"></a>2.4 ConcurrentHashMap 是如何发现当前槽点正在扩容的。</h4><p>答：ConcurrentHashMap 新增了一个节点类型，叫做转移节点，当我们发现当前槽点是转移节点时（转移节点的 hash 值是 -1），即表示 Map 正在进行扩容。</p>
<h4 id="2-5-发现槽点正在扩容时，put-操作会怎么办？"><a href="#2-5-发现槽点正在扩容时，put-操作会怎么办？" class="headerlink" title="2.5 发现槽点正在扩容时，put 操作会怎么办？"></a>2.5 发现槽点正在扩容时，put 操作会怎么办？</h4><p>答：无限 for 循环，或者走到扩容方法中去，帮助扩容，一直等待扩容完成之后，再执行 put 操作。</p>
<h4 id="2-6-两种-Map-扩容时，有啥区别？"><a href="#2-6-两种-Map-扩容时，有啥区别？" class="headerlink" title="2.6 两种 Map 扩容时，有啥区别？"></a>2.6 两种 Map 扩容时，有啥区别？</h4><p>答：区别很大，HashMap 是直接在老数据上面进行扩容，多线程环境下，会有线程安全的问题，而 ConcurrentHashMap 就不太一样，扩容过程是这样的：</p>
<ol>
<li>从数组的队尾开始拷贝；</li>
<li>拷贝数组的槽点时，先把原数组槽点锁住，拷贝成功到新数组时，把原数组槽点赋值为转移节点；</li>
<li>从数组的尾部拷贝到头部，每拷贝成功一次，就把原数组的槽点设置成转移节点；</li>
<li>直到所有数组数据都拷贝到新数组时，直接把新数组整个赋值给数组容器，拷贝完成。</li>
</ol>
<p>简单来说，通过扩容时给槽点加锁，和发现槽点正在扩容就等待的策略，保证了 ConcurrentHashMap 可以慢慢一个一个槽点的转移，保证了扩容时的线程安全，转移节点比较重要，平时问的人也比较多。</p>
<h4 id="2-7-ConcurrentHashMap-在-Java-7-和-8-中关于线程安全的做法有啥不同？"><a href="#2-7-ConcurrentHashMap-在-Java-7-和-8-中关于线程安全的做法有啥不同？" class="headerlink" title="2.7 ConcurrentHashMap 在 Java 7 和 8 中关于线程安全的做法有啥不同？"></a>2.7 ConcurrentHashMap 在 Java 7 和 8 中关于线程安全的做法有啥不同？</h4><p>答：非常不一样，拿 put 方法为例，Java 7 的做法是：</p>
<ol>
<li>把数组进行分段，找到当前 key 对应的是那一段；</li>
<li>将当前段锁住，然后再根据 hash 寻找对应的值，进行赋值操作。</li>
</ol>
<p>Java 7 的做法比较简单，缺点也很明显，就是当我们需要 put 数据时，我们会锁住改该数据对应的某一段，这一段数据可能会有很多，比如我只想 put 一个值，锁住的却是一段数据，导致这一段的其他数据都不能进行写入操作，大大的降低了并发性的效率。Java 8 解决了这个问题，从锁住某一段，修改成锁住某一个槽点，提高了并发效率。</p>
<p>不仅仅是 put，删除也是，仅仅是锁住当前槽点，缩小了锁的范围，增大了效率。</p>
<h3 id="3-总结-1"><a href="#3-总结-1" class="headerlink" title="3 总结"></a>3 总结</h3><p>因为目前大多数公司都已经在使用 Java 8 了，所以大部分面试内容还是以 Java 8 的 API 为主，特别是 CopyOnWriteArrayList 和 ConcurrentHashMap 两个 API，文章毕竟篇幅有限，建议大家多多阅读剩余源码。</p>
<h2 id="18-场景集合：并发-List、Map的应用场景"><a href="#18-场景集合：并发-List、Map的应用场景" class="headerlink" title="18 场景集合：并发 List、Map的应用场景"></a><strong>18 场景集合：并发 List、Map的应用场景</strong></h2><h3 id="引导语-15"><a href="#引导语-15" class="headerlink" title="引导语"></a>引导语</h3><p>并发 List、Map 使用最多的就是 CopyOnWriteArrayList 和 ConcurrentHashMap，在考虑 API 时，我们也无需迟疑，这两个并发类在安全和性能方面都很好，我们都可以直接使用。</p>
<p>并发的场景很多，但归根结底其实就是共享变量被多个线程同时访问，也就是说 CopyOnWriteArrayList 或 ConcurrentHashMap 会被作为共享变量，本节我们会以流程引擎为案例，现身说法，增加一下大家的工作经验积累。</p>
<p>流程引擎在实际工作中经常被使用，其主要功能就是对我们需要完成的事情，进行编排和组装，比如在淘宝下单流程中，我们一共会执行 20 个 Spring Bean，流程引擎就可以帮助我们调起 20 个 Spring Bean，并帮助我们去执行，本文介绍的重点在于如何使用 Map + List 来设计流程引擎的数据结构，以及其中需要注意到的线程安全的问题。</p>
<h3 id="1-嵌套-Map，简单流程引擎"><a href="#1-嵌套-Map，简单流程引擎" class="headerlink" title="1 嵌套 Map，简单流程引擎"></a>1 嵌套 Map，简单流程引擎</h3><p>市面上有很多流程引擎，比如说 Activiti、Flowable、Camunda 等等，功能非常齐全，但我们本小节只实现一种最最简单的流程引擎，只要能对我们需要完成的事情进行编排，并能依次的调用就行。</p>
<h4 id="1-1-流程引擎设计思路"><a href="#1-1-流程引擎设计思路" class="headerlink" title="1.1 流程引擎设计思路"></a>1.1 流程引擎设计思路</h4><p>我们认为每个流程都会做 4 个阶段的事情，阶段主要是指在整个流程中，大概可以分为几个大的步骤，每个阶段可以等同为大的步骤，分别如下：</p>
<ol>
<li>参数校验，主要是对流程的入参数进行校验；</li>
<li>业务校验，主要是对当前流程中的业务进行逻辑校验；</li>
<li>事务中落库，主要把数据落库，控制事务；</li>
<li>事务后事件，我们在数据落库，事务提交之后，可能会做一些其他事情，比如说发消息出来等等。</li>
</ol>
<p>以上每个大的阶段，都会做一些粒度较细的事情，比如说业务校验，我们可能会对两个业务对象进行校验，那么此时业务校验阶段就会做两件事情，每件具体的事情，我们叫做领域行为，在实际项目中，一个领域行为一般都是一个 Spring Bean。</p>
<p>综上所述，流程引擎嵌套数据结构就是：流程 -&gt; 阶段 -&gt; 领域行为，前者对应后者，都是一对一或者一对多的关系。</p>
<p>我们以在淘宝上买东西时，下单为例，下单指的是我们在淘宝选择好了商品和优惠券后，点击购买按钮时触发的动作。</p>
<p>为了方便举例，我们假设在淘宝上买电视和电影票，在后端，会分别对应着两个下单流程，我们画图示意一下：<br><img src="http://img.mukewang.com/5d88856f000149cd12740928.png" alt="图片描述"><br>上图中，左右两个黑色长方形大框代表着两个流程，流程下面有多个阶段，阶段用蓝色表示，每个阶段下面有多个领域行为，用红色表示。</p>
<p>可以看到两个流程中，都包含有四个阶段，阶段都是相同的，但每个阶段中的领域行为，有的相同，有的却是特有的。</p>
<p>三个概念，每个概念层层嵌套，整体组装起来，用来表示一个流程，那么这个数据结构，我们应该如何表示呢？</p>
<p>使用 Map + List 即可！</p>
<h4 id="1-2-数据结构的定义"><a href="#1-2-数据结构的定义" class="headerlink" title="1.2 数据结构的定义"></a>1.2 数据结构的定义</h4><p>流程的数据结构定义分成两步：</p>
<ol>
<li>定义出阶段、领域行为基础概念；</li>
<li>把阶段、领域行为、流程概念组合起来，定义出流程的数据结构。</li>
</ol>
<p>首先给阶段定义一个枚举，如下 StageEnum 代表流程中的阶段或步骤：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> StageEnum &#123;</span><br><span class="line">  PARAM_VALID(<span class="string">&quot;PARAM_VALID&quot;</span>, <span class="string">&quot;参数校验&quot;</span>),</span><br><span class="line"></span><br><span class="line">  BUSINESS_VALID(<span class="string">&quot;BUSINESS_VALID&quot;</span>, <span class="string">&quot;业务校验&quot;</span>),</span><br><span class="line"></span><br><span class="line">  IN_TRANSACTION(<span class="string">&quot;IN_TRANSACTION&quot;</span>, <span class="string">&quot;事务中落库&quot;</span>),</span><br><span class="line"></span><br><span class="line">  AFTER_TRANSACTION(<span class="string">&quot;AFTER_TRANSACTION&quot;</span>, <span class="string">&quot;事务后事件&quot;</span>),</span><br><span class="line">  ;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String code;</span><br><span class="line">  <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">  StageEnum(String code, String desc) &#123;</span><br><span class="line">    <span class="keyword">this</span>.code = code;</span><br><span class="line">    <span class="keyword">this</span>.desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>领域行为我们无需定义，目前通用的技术框架都是 Spring Boot，领域行为都是 Spring Bean，为了简单起见，我们给领域行为定义了一个接口，每个领域行为都要实现这个接口，方便我们编排，接口如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 领域行为</span></span><br><span class="line"><span class="comment"> * author  wenhe</span></span><br><span class="line"><span class="comment"> * date 2019/8/11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DomainAbilityBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 领域行为的方法入口</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">FlowContent <span class="title">invoke</span><span class="params">(FlowContent content)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们使用 Map + List 来定义流程，定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 第一个 key 是流程的名字</span></span><br><span class="line"><span class="comment"> * 第二个 map 的 key 是阶段，为 StageEnum 枚举，值为多个领域行为的集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Map&lt;String,Map&lt;StageEnum,List&lt;DomainAbilityBean&gt;&gt;&gt; flowMap</span><br></pre></td></tr></table></figure>

<p>至此，我们定义出了，简单流程引擎的数据结构，流程引擎看着很复杂，利用 Map + List 的组合，就巧妙的定义好了。</p>
<h3 id="2-容器初始化时，本地缓存使用"><a href="#2-容器初始化时，本地缓存使用" class="headerlink" title="2 容器初始化时，本地缓存使用"></a>2 容器初始化时，本地缓存使用</h3><p>我们定义好 Map 后，我们就需要去使用他，我们使用的大体步骤为：</p>
<ol>
<li>项目启动时，把所有的流程信息初始化到 flowMap(刚刚定义的流程的数据结构叫做 flowMap) 中去，可能是从数据库中加载，也可能是从 xml 文件中加载；</li>
<li>查找流程时，直接从 flowMap 中获取即可。</li>
</ol>
<h4 id="2-1-初始化-2"><a href="#2-1-初始化-2" class="headerlink" title="2.1 初始化"></a>2.1 初始化</h4><p>以上两步最为关键的点就是 flowMap 必须是可以随时访问到的，所有我们会把 flowMap 作为共享变量使用，也就是会被 static final 关键字所修饰，我们首先来 mock 一下把所有信息初始化到 flowMap 中去的代码，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowCenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * flowMap 是共享变量，方便访问，并且是 ConcurrentHashMap</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Map&lt;StageEnum, List&lt;DomainAbilityBean&gt;&gt;&gt; flowMap</span><br><span class="line">      = Maps.newConcurrentMap();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * PostConstruct 注解的意思就是</span></span><br><span class="line"><span class="comment">   * 在容器启动成功之后，执行 init 方法，初始化 flowMap</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@PostConstruct</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 初始化 flowMap，可能是从数据库，或者 xml 文件中加载 map</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码，关键地方在于三点：</p>
<ol>
<li>flowMap 被 static final 修饰，是个共享变量，方便访问；</li>
<li>flowMap 是 ConcurrentHashMap，所以我们所有的操作都无需加锁，比如我们在 init 方法中，对 flowMap 进行初始化，就无需加锁，因为 ConcurrentHashMap 本身已经保证了线程安全；</li>
<li>这里我们初始化的时机是在容器启动的时候，在实际的工作中，我们经常在容器启动的时候，把不会经常发生变动的数据，放到类似 List、Map 这样的共享变量中，这样当我们频繁要使用的时候，直接从内存中读取即可。</li>
</ol>
<h4 id="2-2-使用"><a href="#2-2-使用" class="headerlink" title="2.2 使用"></a>2.2 使用</h4><p>那我们实际使用的时候，只需要告诉 flowMap 当前是那个流程的那个阶段，就可以返回该流程该阶段下面的所有领域行为了，我们写了一个流程引擎使用的工具类入口，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 流程引擎对外的 API</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowStart</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 流程引擎开始</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> flowName 流程的名字</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(String flowName, FlowContent content)</span> </span>&#123;</span><br><span class="line">    invokeParamValid(flowName, content);</span><br><span class="line">    invokeBusinessValid(flowName, content);</span><br><span class="line">    invokeInTramsactionValid(flowName, content);</span><br><span class="line">    invokeAfterTramsactionValid(flowName, content);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 执行参数校验</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeParamValid</span><span class="params">(String flowName, FlowContent content)</span> </span>&#123;</span><br><span class="line">    stageInvoke(flowName, StageEnum.PARAM_VALID, content);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 执行业务校验</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeBusinessValid</span><span class="params">(String flowName, FlowContent content)</span> </span>&#123;</span><br><span class="line">    stageInvoke(flowName, StageEnum.BUSINESS_VALID, content);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 执行事务中</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeInTramsactionValid</span><span class="params">(String flowName, FlowContent content)</span> </span>&#123;</span><br><span class="line">    stageInvoke(flowName, StageEnum.IN_TRANSACTION, content);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 执行事务后</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAfterTramsactionValid</span><span class="params">(String flowName, FlowContent content)</span> </span>&#123;</span><br><span class="line">    stageInvoke(flowName, StageEnum.AFTER_TRANSACTION, content);</span><br><span class="line">  &#125;</span><br><span class="line">		</span><br><span class="line">  <span class="comment">// 批量执行 Spring Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stageInvoke</span><span class="params">(String flowName, StageEnum stage, FlowContent content)</span> </span>&#123;</span><br><span class="line">    List&lt;DomainAbilityBean&gt;</span><br><span class="line">        domainAbilitys =</span><br><span class="line">        FlowCenter.flowMap.getOrDefault(flowName, Maps.newHashMap()).get(stage);</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(domainAbilitys)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;找不到该流程对应的领域行为&quot;</span> + flowName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (DomainAbilityBean domainAbility : domainAbilitys) &#123;</span><br><span class="line">      domainAbility.invoke(content);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中可以看到，我们在流程引擎的入口，只要根据参数校验、业务校验、事务中、事务后四个阶段，从 flowMap 中得到领域行为的集合，然后对领域行为进行顺序执行即可。</p>
<p>我们在使用时，直接使用上述类的 start 方法即可。</p>
<p>当然以上演示的流程引擎只是一个大的框架，还有很多地方需要改进的地方，比如如何找到 flowName，如何初始化 flowMap，但这些都不是本节重点，本节主要想通过流程引擎案例来说明几点：</p>
<ol>
<li>把 List 和 Map 作为共享变量非常常见，就像咱们这种项目启动时，从数据库中把数据捞出来，然后封装成 List 或 Map 的结构，这样做的优点就是节约资源，不用每次用的时候都去查数据库，直接从内存中获取即可；</li>
<li>并发场景下，我们可以放心的使用 CopyOnWriteArrayList 和 ConcurrentHashMap 两个并发类，首先用 static final 对两者进行修饰，使其成为共享变量，接着在写入或者查询的时候，无需加锁，两个 API 内部已经实现了加锁的功能了；</li>
<li>有一点需要澄清一下，就是 CopyOnWriteArrayList 和 ConcurrentHashMap 只能作为单机的共享变量，如果是分布式系统，多台机器的情况下，这样做不行了，需要使用分布式缓存了。</li>
</ol>
<h3 id="3-总结-2"><a href="#3-总结-2" class="headerlink" title="3 总结"></a>3 总结</h3><p>本节内容，以流程引擎为例，说明了如何使用 Map + List 的嵌套结构设计流程引擎，以及在并发情况下，如何安全的使用 List 和 Map。</p>
<p>本案列是高并发项目的真实案例，感兴趣的同学可以在此流程引擎框架基础上进行细节补充，实现可运行的流程引擎。</p>
<h1 id="第4章-队列"><a href="#第4章-队列" class="headerlink" title="第4章 队列"></a><strong>第4章 队列</strong></h1><h2 id="19-LinkedBlockingQueue-源码解析"><a href="#19-LinkedBlockingQueue-源码解析" class="headerlink" title="19 LinkedBlockingQueue 源码解析"></a><strong>19 LinkedBlockingQueue 源码解析</strong></h2><h3 id="引导语-16"><a href="#引导语-16" class="headerlink" title="引导语"></a>引导语</h3><p>说到队列，大家的反应可能是我从来都没有用过，应该是不重要的 API 吧。如果这么想，那就大错特错了，我们平时使用到的线程池、读写锁、消息队列等等技术和框架，底层原理都是队列，所以我们万万不可轻视队列，队列是很多高级 API 的基础，学好队列，对自己深入 Java 学习非常重要。</p>
<p>本文主要以 LinkedBlockingQueue 队列为例，详细描述一下底层具体的实现。</p>
<h3 id="1-整体架构-4"><a href="#1-整体架构-4" class="headerlink" title="1 整体架构"></a>1 整体架构</h3><p>LinkedBlockingQueue 中文叫做链表阻塞队列，这个命名很好，从命名上就知道其底层数据结构是链表，并且队列是可阻塞的。接下来，我们就从整体结构上看看 LinkedBlockingQueue。</p>
<h4 id="1-1-类图"><a href="#1-1-类图" class="headerlink" title="1.1 类图"></a>1.1 类图</h4><p>首先我们来看下 LinkedBlockingQueue 类图，如下：<br><img src="http://img.mukewang.com/5d9db50c00011ed210740736.png" alt="图片描述">从类图中，我们大概可以看出两条路径：</p>
<ol>
<li>AbstractQueue -&gt; AbstractCollection -&gt; Collection -&gt;Iterable 这条路径依赖，主要是想复用 Collection 和 迭代器的一些操作，这些我们在说集合的时候，都知道这些类是干什么，能干什么，就不细说了；</li>
<li>BlockingQueue -&gt; Queue -&gt; Collection，BlockingQueue 和 Queue 是新出来的两个接口，我们重点说一下。</li>
</ol>
<p>Queue 是最基础的接口，几乎所有的队列实现类都会实现这个接口，该接口定义出了队列的三大类操作：</p>
<p>新增操作：</p>
<ol>
<li>add 队列满的时候抛出异常；</li>
<li>offer 队列满的时候返回 false。</li>
</ol>
<p>查看并删除操作：</p>
<ol>
<li>remove 队列空的时候抛异常；</li>
<li>poll 队列空的时候返回 null。</li>
</ol>
<p>只查看不删除操作：</p>
<ol>
<li>element 队列空的时候抛异常；</li>
<li>peek 队列空的时候返回 null。</li>
</ol>
<p>一共 6 种方法，除了以上分类方法，也可以分成两类：</p>
<ol>
<li>遇到队列满或空的时候，抛异常，如 add、remove、element；</li>
<li>遇到队列满或空的时候，返回特殊值，如 offer、poll、peek。</li>
</ol>
<p>实际上，这些都比较难记忆。每次需要使用的时候，我都会看会源码，才能想起这个方法是抛异常还是返回特殊值。</p>
<p>BlockingQueue 在 Queue 的基础上加上了阻塞的概念，比如一直阻塞，还是阻塞一段时间。为了方便记忆，我们画一个表格，如下：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">抛异常</th>
<th align="left">特殊值</th>
<th align="left">一直阻塞</th>
<th align="left">阻塞一段时间</th>
</tr>
</thead>
<tbody><tr>
<td align="left">新增操作–队列满</td>
<td align="left">add</td>
<td align="left">offer 返回 false</td>
<td align="left">put</td>
<td align="left">offer 过超时时间返回 false</td>
</tr>
<tr>
<td align="left">查看并删除操作–队列空</td>
<td align="left">remove</td>
<td align="left">poll 返回 null</td>
<td align="left">take</td>
<td align="left">poll 过超时时间返回 null</td>
</tr>
<tr>
<td align="left">只查看不删除操作–队列空</td>
<td align="left">element</td>
<td align="left">peek 返回 null</td>
<td align="left">暂无</td>
<td align="left">暂无</td>
</tr>
</tbody></table>
<p>PS: remove 方法，BlockingQueue 类注释中定义的是抛异常，但 LinkedBlockingQueue 中 remove 方法实际是返回 false。<br>从表格中可以看到，在新增和查看并删除两大类操作上，BlockingQueue 增加了阻塞的功能，而且可以选择一直阻塞，或者阻塞一段时间后，返回特殊值。</p>
<h4 id="1-2-类注释"><a href="#1-2-类注释" class="headerlink" title="1.2 类注释"></a>1.2 类注释</h4><p>我们看看从 LinkedBlockingQueue 的类注释中能得到那些信息：</p>
<ol>
<li>基于链表的阻塞队列，其底层的数据结构是链表；</li>
<li>链表维护先入先出队列，新元素被放在队尾，获取元素从队头部拿；</li>
<li>链表大小在初始化的时候可以设置，默认是 Integer 的最大值；</li>
<li>可以使用 Collection 和 Iterator 两个接口的所有操作，因为实现了两者的接口。</li>
</ol>
<h4 id="1-3-内部构成"><a href="#1-3-内部构成" class="headerlink" title="1.3 内部构成"></a>1.3 内部构成</h4><p>LinkedBlockingQueue 内部构成简单来说，分成三个部分：链表存储 + 锁 + 迭代器，我们来看下源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链表结构 begin</span></span><br><span class="line"><span class="comment">//链表的元素</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前元素的下一个，为空表示当前节点是最后一个</span></span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(E x) &#123; item = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表的容量，默认 Integer.MAX_VALUE</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表已有元素大小，使用 AtomicInteger，所以是线程安全的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表头</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表尾</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"><span class="comment">// 链表结构 end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 锁 begin</span></span><br><span class="line"><span class="comment">//take 时的锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// take 的条件队列，condition 可以简单理解为基于 ASQ 同步机制建立的条件队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">// put 时的锁，设计两把锁的目的，主要为了 take 和 put 可以同时进行</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// put 的条件队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br><span class="line"><span class="comment">// 锁 end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器 </span></span><br><span class="line"><span class="comment">// 实现了自己的迭代器</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">………………</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码上来看，结构是非常清晰的，三种结构各司其职：</p>
<ol>
<li>链表的作用是为了保存当前节点，节点中的数据可以是任意东西，是一个泛型，比如说队列被应用到线程池时，节点就是线程，比如队列被应用到消息队列中，节点就是消息，节点的含义主要看队列被使用的场景；</li>
<li>锁有 take 锁和 put 锁，是为了保证队列操作时的线程安全，设计两种锁，是为了 take 和 put 两种操作可以同时进行，互不影响。</li>
</ol>
<h4 id="1-4-初始化"><a href="#1-4-初始化" class="headerlink" title="1.4 初始化"></a>1.4 初始化</h4><p>初始化有三种方式：</p>
<ol>
<li>指定链表容量大小；</li>
<li>不指定链表容量大小，默认是 Integer 的最大值；</li>
<li>对已有集合数据进行初始化。</li>
</ol>
<p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不指定容量，默认 Integer 的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 指定链表容量大小，链表头尾相等，节点值（item）都是 null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    last = head = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 已有集合数据进行初始化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    putLock.lock(); <span class="comment">// Never contended, but necessary for visibility</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">            <span class="comment">// 集合内的元素不能为空</span></span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="comment">// capacity 代表链表的大小，在这里是 Integer 的最大值</span></span><br><span class="line">            <span class="comment">// 如果集合类的大小大于 Integer 的最大值，就会报错</span></span><br><span class="line">            <span class="comment">// 其实这个判断完全可以放在 for 循环外面，这样可以减少 Integer 的最大值次循环(最坏情况)</span></span><br><span class="line">            <span class="keyword">if</span> (n == capacity)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Queue full&quot;</span>);</span><br><span class="line">            enqueue(<span class="keyword">new</span> Node&lt;E&gt;(e));</span><br><span class="line">            ++n;</span><br><span class="line">        &#125;</span><br><span class="line">        count.set(n);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于初始化源码，我们说明两点：</p>
<ol>
<li>初始化时，容量大小是不会影响性能的，只影响在后面的使用，因为初始化队列太小，容易导致没有放多少就会报队列已满的错误；</li>
<li>在对给定集合数据进行初始化时，源码给了一个不优雅的示范，我们不反对在每次 for 循环的时候，都去检查当前链表的大小是否超过容量，但我们希望在 for 循环开始之前就做一步这样的工作。举个列子，给定集合大小是 1 w，链表大小是 9k，按照现在代码实现，只能在 for 循环 9k 次时才能发现，原来给定集合的大小已经大于链表大小了，导致 9k 次循环都是在浪费资源，还不如在 for 循环之前就 check 一次，如果 1w &gt; 9k，直接报错即可。</li>
</ol>
<h3 id="2-阻塞新增"><a href="#2-阻塞新增" class="headerlink" title="2 阻塞新增"></a>2 阻塞新增</h3><p>新增有多种方法，如：add、put、offer，三者的区别上文有说。我们拿 put 方法为例，put 方法在碰到队列满的时候，会一直阻塞下去，直到队列不满时，并且自己被唤醒时，才会继续去执行，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把e新增到队列的尾部。</span></span><br><span class="line"><span class="comment">// 如果有可以新增的空间的话，直接新增成功，否则当前线程陷入等待</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// e 为空，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 预先设置 c 为 -1，约定负数为新增失败</span></span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="comment">// 设置可中断锁</span></span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 队列满了</span></span><br><span class="line">        <span class="comment">// 当前线程阻塞，等待其他线程的唤醒(其他线程 take 成功后就会唤醒此处被阻塞的线程)</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            <span class="comment">// await 无限等待</span></span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列没有满，直接新增到队列的尾部</span></span><br><span class="line">        enqueue(node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新增计数赋值,注意这里 getAndIncrement 返回的是旧值</span></span><br><span class="line">        <span class="comment">// 这里的 c 是比真实的 count 小 1 的</span></span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果链表现在的大小 小于链表的容量，说明队列未满</span></span><br><span class="line">        <span class="comment">// 可以尝试唤醒一个 put 的等待线程</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// c==0，代表队列里面有一个元素</span></span><br><span class="line">    <span class="comment">// 会尝试唤醒一个take的等待线程</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 入队，把新元素放到队尾</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    last = last.next = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中我们可以总结以下几点：</p>
<ol>
<li>往队列新增数据，第一步是上锁，所以新增数据是线程安全的；</li>
<li>队列新增数据，简单的追加到链表的尾部即可；</li>
<li>新增时，如果队列满了，当前线程是会被阻塞的，阻塞的底层使用是锁的能力，底层实现其它也和队列相关，原理我们在锁章节会说到；</li>
<li>新增数据成功后，在适当时机，会唤起 put 的等待线程（队列不满时），或者 take 的等待线程（队列不为空时），这样保证队列一旦满足 put 或者 take 条件时，立马就能唤起阻塞线程，继续运行，保证了唤起的时机不被浪费。</li>
</ol>
<p>以上就是 put 方法的原理，至于 offer 方法阻塞超过一端时间后，仍未成功，就会直接返回默认值的实现，和 put 方法相比只修改了几行代码，如下截图：</p>
<p><img src="http://img.mukewang.com/5d9db53e000110c724481374.png" alt="图片描述"></p>
<h3 id="3-阻塞删除"><a href="#3-阻塞删除" class="headerlink" title="3 阻塞删除"></a>3 阻塞删除</h3><p>删除的方法也很多，我们主要看两个关键问题：</p>
<ol>
<li>删除的原理是怎样的；</li>
<li>查看并删除和只查看不删除两种的区别是如何实现的。</li>
</ol>
<p>首先我们来看第一个问题，我们以 take 方法为例，说明一下查看并删除的底层源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 阻塞拿数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E x;</span><br><span class="line">    <span class="comment">// 默认负数，代表失败</span></span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// count 代表当前链表数据的真实大小</span></span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 空队列时，阻塞，等待其他线程唤醒</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 非空队列，从队列的头部拿一个出来</span></span><br><span class="line">        x = dequeue();</span><br><span class="line">        <span class="comment">// 减一计算，注意 getAndDecrement 返回的值是旧值</span></span><br><span class="line">        <span class="comment">// c 比真实的 count 大1</span></span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果队列里面有值，从 take 的等待线程里面唤醒一个。</span></span><br><span class="line">        <span class="comment">// 意思是队列里面有值啦,唤醒之前被阻塞的线程</span></span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果队列空闲还剩下一个，尝试从 put 的等待线程中唤醒一个</span></span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 队头中取数据</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; h = head;</span><br><span class="line">    Node&lt;E&gt; first = h.next;</span><br><span class="line">    h.next = h; <span class="comment">// help GC</span></span><br><span class="line">    head = first;</span><br><span class="line">    E x = first.item;</span><br><span class="line">    first.item = <span class="keyword">null</span>;<span class="comment">// 头节点指向 null，删除</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整体流程和 put 很相似，都是先上锁，然后从队列的头部拿出数据，如果队列为空，会一直阻塞到队列有值为止。</p>
<p>而查看不删除元素更加简单，直接把队列头的数据拿出来即可，我们以 peek 为例，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查看并不删除元素，如果队列为空，返回 null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// count 代表队列实际大小，队列为空，直接返回 null</span></span><br><span class="line">    <span class="keyword">if</span> (count.get() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 拿到队列头</span></span><br><span class="line">        Node&lt;E&gt; first = head.next;</span><br><span class="line">        <span class="comment">// 判断队列头是否为空，并返回</span></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> first.item;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，查看并删除，和查看不删除两者从队头拿数据的逻辑不太一致，从而导致一个会删除，一个不会删除队头数据。</p>
<h3 id="4-总结-1"><a href="#4-总结-1" class="headerlink" title="4 总结"></a>4 总结</h3><p>本文通过 LinkedBlockingQueue 的源码，来介绍了下链表队列，当队列满和空的场景下，新增和删除数据时，队列有啥变化。</p>
<p>队列本身就是一个阻塞工具，我们可以把这个工具应用到各种阻塞场景中，比如说队列应用到线程池，当线程池跑满时，我们把新的请求都放到阻塞队列中等待；队列应用到消息队列，当消费者处理能力有限时，我们可以把消息放到队列中等待，让消费者慢慢消费；每应用到一个新的场景中，都是一个新的技术工具，所以学好队列，用处很大。</p>
<h2 id="20-SynchronousQueue-源码解析"><a href="#20-SynchronousQueue-源码解析" class="headerlink" title="20 SynchronousQueue 源码解析"></a><strong>20 SynchronousQueue 源码解析</strong></h2><h3 id="引导语-17"><a href="#引导语-17" class="headerlink" title="引导语"></a>引导语</h3><p>SynchronousQueue 是比较独特的队列，其本身是没有容量大小，比如我放一个数据到队列中，我是不能够立马返回的，我必须等待别人把我放进去的数据消费掉了，才能够返回。SynchronousQueue 在消息队列技术中间件中被大量使用，本文就来从底层实现来看下 SynchronousQueue 到底是如何做到的。</p>
<h3 id="1-整体架构-5"><a href="#1-整体架构-5" class="headerlink" title="1 整体架构"></a>1 整体架构</h3><p>SynchronousQueue 的整体设计比较抽象，在内部抽象出了两种算法实现，一种是先入先出的队列，一种是后入先出的堆栈，两种算法被两个内部类实现，而直接对外的 put，take 方法的实现就非常简单，都是直接调用两个内部类的 transfer 方法进行实现，整体的调用关系如下图所示：</p>
<p><img src="http://img.mukewang.com/5da53a4a0001ce6924601406.png" alt="图片描述"></p>
<h4 id="1-1-类注释-3"><a href="#1-1-类注释-3" class="headerlink" title="1.1 类注释"></a>1.1 类注释</h4><p>源码的类注释往往能给我带来很多疑问和有用的信息，我们来看下类注释都说了什么：</p>
<ol>
<li>队列不存储数据，所以没有大小，也无法迭代；</li>
<li>插入操作的返回必须等待另一个线程完成对应数据的删除操作，反之亦然；</li>
<li>队列由两种数据结构组成，分别是后入先出的堆栈和先入先出的队列，堆栈是非公平的，队列是公平的。</li>
</ol>
<p>看到类注释，大家是不是有一些疑问，比如第二点是如何做到的？堆栈又是如何实现的呢？接下来我们一点一点揭晓。</p>
<h4 id="1-2-类图"><a href="#1-2-类图" class="headerlink" title="1.2 类图"></a>1.2 类图</h4><p>SynchronousQueue 整体类图和 LinkedBlockingQueue 相似，都是实现了 BlockingQueue 接口，但因为其不储存数据结构，有一些方法是没有实现的，比如说 isEmpty、size、contains、remove 和迭代等方法，这些方法都是默认实现，如下截图：</p>
<p><img src="http://img.mukewang.com/5da53a3e0001e3c213841432.png" alt="图片描述"></p>
<h4 id="1-3-结构细节"><a href="#1-3-结构细节" class="headerlink" title="1.3 结构细节"></a>1.3 结构细节</h4><p>SynchronousQueue 底层结构和其它队列完全不同，有着独特的两种数据结构：队列和堆栈，我们一起来看下数据结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 堆栈和队列共同的接口</span></span><br><span class="line"><span class="comment">// 负责执行 put or take</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Transferer</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// e 为空的，会直接返回特殊值，不为空会传递给消费者</span></span><br><span class="line">    <span class="comment">// timed 为 true，说明会有超时时间</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆栈 后入先出 非公平</span></span><br><span class="line"><span class="comment">// Scherer-Scott 算法</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferStack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Transferer</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列 先入先出 公平</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Transferer</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Transferer&lt;E&gt; transferer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参构造器默认为非公平的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    transferer = fair ? <span class="keyword">new</span> TransferQueue&lt;E&gt;() : <span class="keyword">new</span> TransferStack&lt;E&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中我们可以得到几点：</p>
<ol>
<li>堆栈和队列都有一个共同的接口，叫做 Transferer，该接口有个方法：transfer，该方法很神奇，会承担 take 和 put 的双重功能；</li>
<li>在我们初始化的时候，是可以选择是使用堆栈还是队列的，如果你不选择，默认的就是堆栈，类注释中也说明了这一点，堆栈的效率比队列更高。</li>
</ol>
<p>接下来我们来看下堆栈和队列的具体实现。</p>
<h3 id="2-非公平的堆栈"><a href="#2-非公平的堆栈" class="headerlink" title="2 非公平的堆栈"></a>2 非公平的堆栈</h3><h4 id="2-1-堆栈的结构"><a href="#2-1-堆栈的结构" class="headerlink" title="2.1 堆栈的结构"></a>2.1 堆栈的结构</h4><p>首先我们来介绍下堆栈的整体结构，如下：</p>
<p><img src="http://img.mukewang.com/5da53a31000147a007280674.png" alt="图片描述"></p>
<p>从上图中我们可以看到，我们有一个大的堆栈池，池的开口叫做堆栈头，put 的时候，就往堆栈池中放数据。take 的时候，就从堆栈池中拿数据，两者操作都是在堆栈头上操作数据，从图中可以看到，越靠近堆栈头，数据越新，所以每次 take 的时候，都会拿到堆栈头的最新数据，这就是我们说的后入先出，也就是非公平的。</p>
<p>图中 SNode 就是源码中栈元素的表示，我们看下源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SNode</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 栈的下一个，就是被当前栈压在下面的栈元素</span></span><br><span class="line">    <span class="keyword">volatile</span> SNode next;</span><br><span class="line">    <span class="comment">// 节点匹配，用来判断阻塞栈元素能被唤醒的时机</span></span><br><span class="line">    <span class="comment">// 比如我们先执行 take，此时队列中没有数据，take 被阻塞了，栈元素为 SNode1</span></span><br><span class="line">    <span class="comment">// 当有 put 操作时，会把当前 put 的栈元素赋值给 SNode1 的 match 属性，并唤醒 take 操作</span></span><br><span class="line">    <span class="comment">// 当 take 被唤醒，发现 SNode1 的 match 属性有值时，就能拿到 put 进来的数据，从而返回</span></span><br><span class="line">    <span class="keyword">volatile</span> SNode match;</span><br><span class="line">    <span class="comment">// 栈元素的阻塞是通过线程阻塞来实现的，waiter 为阻塞的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread waiter;</span><br><span class="line">    <span class="comment">// 未投递的消息，或者未消费的消息</span></span><br><span class="line">    Object item;             </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h4 id="2-2-入栈和出栈"><a href="#2-2-入栈和出栈" class="headerlink" title="2.2 入栈和出栈"></a>2.2 入栈和出栈</h4><p>入栈指的是使用 put 等方法，把数据放到堆栈池中，出栈指的使用 take 等方法，把数据从堆栈池中拿出来，操作的对象都是堆栈头，虽然两者的一个是从堆栈头拿数据，一个是放数据，但底层实现的方法却是同一个，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// transfer 方法思路比较复杂，因为 take 和 put 两个方法都揉在了一起</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function">E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">    SNode s = <span class="keyword">null</span>; <span class="comment">// constructed/reused as needed</span></span><br><span class="line">    <span class="comment">// e 为空，说明是 take 方法，不为空是 put 方法</span></span><br><span class="line">    <span class="keyword">int</span> mode = (e == <span class="keyword">null</span>) ? REQUEST : DATA;</span><br><span class="line">    <span class="comment">// 自旋</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 拿出头节点，有几种情况</span></span><br><span class="line">        <span class="comment">// 1：头节点为空，说明队列中还没有数据</span></span><br><span class="line">        <span class="comment">// 2：头节点不为空，并且是 take 类型的，说明头节点线程正等着拿数据。</span></span><br><span class="line">        <span class="comment">// 3：头节点不为空，并且是 put 类型的，说明头节点线程正等着放数据。</span></span><br><span class="line">        SNode h = head;</span><br><span class="line">        <span class="comment">// 栈头为空，说明队列中还没有数据。</span></span><br><span class="line">        <span class="comment">// 栈头不为空，并且栈头的类型和本次操作一致，比如都是 put，那么就把</span></span><br><span class="line">        <span class="comment">// 本次 put 操作放到该栈头的前面即可，让本次 put 能够先执行</span></span><br><span class="line">        <span class="keyword">if</span> (h == <span class="keyword">null</span> || h.mode == mode) &#123;  <span class="comment">// empty or same-mode</span></span><br><span class="line">            <span class="comment">// 设置了超时时间，并且 e 进栈或者出栈要超时了，</span></span><br><span class="line">            <span class="comment">// 就会丢弃本次操作，返回 null 值。</span></span><br><span class="line">            <span class="comment">// 如果栈头此时被取消了，丢弃栈头，取下一个节点继续消费</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>) &#123;      <span class="comment">// can&#x27;t wait</span></span><br><span class="line">                <span class="comment">// 栈头操作被取消</span></span><br><span class="line">                <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.isCancelled())</span><br><span class="line">                    <span class="comment">// 丢弃栈头，把栈头后一个元素作为栈头</span></span><br><span class="line">                    casHead(h, h.next);     <span class="comment">// pop cancelled node</span></span><br><span class="line">                <span class="comment">//栈头是空的，直接返回 null</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 没有超时，直接把 e 作为新的栈头</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (casHead(h, s = snode(s, e, h, mode))) &#123;</span><br><span class="line">                <span class="comment">// e 等待出栈，一种是空队列 take，一种是 put</span></span><br><span class="line">                SNode m = awaitFulfill(s, timed, nanos);</span><br><span class="line">                <span class="keyword">if</span> (m == s) &#123;               <span class="comment">// wait was cancelled</span></span><br><span class="line">                    clean(s);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 本来 s 是栈头的，现在 s 不是栈头了，s 后面又来了一个数，把新的数据作为栈头</span></span><br><span class="line">                <span class="keyword">if</span> ((h = head) != <span class="keyword">null</span> &amp;&amp; h.next == s)</span><br><span class="line">                    casHead(h, s.next);     <span class="comment">// help s&#x27;s fulfiller</span></span><br><span class="line">                <span class="keyword">return</span> (E) ((mode == REQUEST) ? m.item : s.item);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 栈头正在等待其他线程 put 或 take</span></span><br><span class="line">        <span class="comment">// 比如栈头正在阻塞，并且是 put 类型，而此次操作正好是 take 类型，走此处</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isFulfilling(h.mode)) &#123; <span class="comment">// try to fulfill</span></span><br><span class="line">            <span class="comment">// 栈头已经被取消，把下一个元素作为栈头</span></span><br><span class="line">            <span class="keyword">if</span> (h.isCancelled())            <span class="comment">// already cancelled</span></span><br><span class="line">                casHead(h, h.next);         <span class="comment">// pop and retry</span></span><br><span class="line">            <span class="comment">// snode 方法第三个参数 h 代表栈头，赋值给 s 的 next 属性</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (casHead(h, s=snode(s, e, h, FULFILLING|mode))) &#123;</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123; <span class="comment">// loop until matched or waiters disappear</span></span><br><span class="line">                    <span class="comment">// m 就是栈头，通过上面 snode 方法刚刚赋值</span></span><br><span class="line">                    SNode m = s.next;       <span class="comment">// m is s&#x27;s match</span></span><br><span class="line">                    <span class="keyword">if</span> (m == <span class="keyword">null</span>) &#123;        <span class="comment">// all waiters are gone</span></span><br><span class="line">                        casHead(s, <span class="keyword">null</span>);   <span class="comment">// pop fulfill node</span></span><br><span class="line">                        s = <span class="keyword">null</span>;           <span class="comment">// use new node next time</span></span><br><span class="line">                        <span class="keyword">break</span>;              <span class="comment">// restart main loop</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    SNode mn = m.next;</span><br><span class="line">                     <span class="comment">// tryMatch 非常重要的方法，两个作用：</span></span><br><span class="line">                     <span class="comment">// 1 唤醒被阻塞的栈头 m，2 把当前节点 s 赋值给 m 的 match 属性</span></span><br><span class="line">                     <span class="comment">// 这样栈头 m 被唤醒时，就能从 m.match 中得到本次操作 s</span></span><br><span class="line">                     <span class="comment">// 其中 s.item 记录着本次的操作节点，也就是记录本次操作的数据</span></span><br><span class="line">                    <span class="keyword">if</span> (m.tryMatch(s)) &#123;</span><br><span class="line">                        casHead(s, mn);     <span class="comment">// pop both s and m</span></span><br><span class="line">                        <span class="keyword">return</span> (E) ((mode == REQUEST) ? m.item : s.item);</span><br><span class="line">                    &#125; <span class="keyword">else</span>                  <span class="comment">// lost match</span></span><br><span class="line">                        s.casNext(m, mn);   <span class="comment">// help unlink</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                            <span class="comment">// help a fulfiller</span></span><br><span class="line">            SNode m = h.next;               <span class="comment">// m is h&#x27;s match</span></span><br><span class="line">            <span class="keyword">if</span> (m == <span class="keyword">null</span>)                  <span class="comment">// waiter is gone</span></span><br><span class="line">                casHead(h, <span class="keyword">null</span>);           <span class="comment">// pop fulfilling node</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                SNode mn = m.next;</span><br><span class="line">                <span class="keyword">if</span> (m.tryMatch(h))          <span class="comment">// help match</span></span><br><span class="line">                    casHead(h, mn);         <span class="comment">// pop both h and m</span></span><br><span class="line">                <span class="keyword">else</span>                        <span class="comment">// lost match</span></span><br><span class="line">                    h.casNext(m, mn);       <span class="comment">// help unlink</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中密密麻麻的注释，我们就可以看出来此方法比较复杂，我们总结一下大概的操作思路：</p>
<ol>
<li>判断是 put 方法还是 take 方法；</li>
<li>判断栈头数据是否为空，如果为空或者栈头的操作和本次操作一致，是的话走 3，否则走 5；</li>
<li>判断操作有无设置超时时间，如果设置了超时时间并且已经超时，返回 null，否则走 4；</li>
<li>如果栈头为空，把当前操作设置成栈头，或者栈头不为空，但栈头的操作和本次操作相同，也把当前操作设置成栈头，并看看其它线程能否满足自己，不能满足则阻塞自己。比如当前操作是 take，但队列中没有数据，则阻塞自己；</li>
<li>如果栈头已经是阻塞住的，需要别人唤醒的，判断当前操作能否唤醒栈头，可以唤醒走 6，否则走 4；</li>
<li>把自己当作一个节点，赋值到栈头的 match 属性上，并唤醒栈头节点；</li>
<li>栈头被唤醒后，拿到 match 属性，就是把自己唤醒的节点的信息，返回。</li>
</ol>
<p>在整个过程中，有一个节点阻塞的方法，实现原理如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">SNode <span class="title">awaitFulfill</span><span class="params">(SNode s, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// deadline 死亡时间，如果设置了超时时间的话，死亡时间等于当前时间 + 超时时间，否则就是 0</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">    Thread w = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 自旋的次数，如果设置了超时时间，会自旋 32 次，否则自旋 512 次。</span></span><br><span class="line">    <span class="comment">// 比如本次操作是 take 操作，自选次数后，仍没有其他线程 put 数据进来</span></span><br><span class="line">    <span class="comment">// 就会阻塞，有超时时间的，会阻塞固定的时间，否则一致阻塞下去</span></span><br><span class="line">    <span class="keyword">int</span> spins = (shouldSpin(s) ?</span><br><span class="line">                 (timed ? maxTimedSpins : maxUntimedSpins) : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 当前线程有无被打断，如果过了超时时间，当前线程就会被打断</span></span><br><span class="line">        <span class="keyword">if</span> (w.isInterrupted())</span><br><span class="line">            s.tryCancel();</span><br><span class="line"></span><br><span class="line">        SNode m = s.match;</span><br><span class="line">        <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="comment">// 超时了，取消当前线程的等待操作</span></span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                s.tryCancel();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 自选次数减少 1</span></span><br><span class="line">        <span class="keyword">if</span> (spins &gt; <span class="number">0</span>)</span><br><span class="line">            spins = shouldSpin(s) ? (spins-<span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 把当前线程设置成 waiter，主要是通过线程来完成阻塞和唤醒</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s.waiter == <span class="keyword">null</span>)</span><br><span class="line">            s.waiter = w; <span class="comment">// establish waiter so can park next iter</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!timed)</span><br><span class="line">            <span class="comment">// 通过 park 进行阻塞，这个我们在锁章节中会说明</span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; spinForTimeoutThreshold)</span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从节点阻塞代码中，我们可以发现，其阻塞的策略，并不是一上来就阻塞住，而是在自旋一定次数后，仍然没有其它线程来满足自己的要求时，才会真正的阻塞住。</p>
<h3 id="3-公平的队列"><a href="#3-公平的队列" class="headerlink" title="3 公平的队列"></a>3 公平的队列</h3><p>首先我们来看一下队列中的每个元素的组成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 队列头 */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> QNode head;</span><br><span class="line"><span class="comment">/** 队列尾 */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> QNode tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列的元素</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">QNode</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前元素的下一个元素</span></span><br><span class="line">    <span class="keyword">volatile</span> QNode next;         </span><br><span class="line">    <span class="comment">// 当前元素的值，如果当前元素被阻塞住了，等其他线程来唤醒自己时，其他线程</span></span><br><span class="line">    <span class="comment">// 会把自己 set 到 item 里面</span></span><br><span class="line">    <span class="keyword">volatile</span> Object item;         <span class="comment">// CAS&#x27;ed to or from null</span></span><br><span class="line">    <span class="comment">// 可以阻塞住的当前线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread waiter;       <span class="comment">// to control park/unpark</span></span><br><span class="line">    <span class="comment">// true 是 put，false 是 take</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isData;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>公平的队列主要使用的是 TransferQueue 内部类的 transfer 方法，我们一起来看下源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    QNode s = <span class="keyword">null</span>; <span class="comment">// constructed/reused as needed</span></span><br><span class="line">    <span class="comment">// true 是 put，false 是 get</span></span><br><span class="line">    <span class="keyword">boolean</span> isData = (e != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 队列头和尾的临时变量,队列是空的时候，t=h</span></span><br><span class="line">        QNode t = tail;</span><br><span class="line">        QNode h = head;</span><br><span class="line">        <span class="comment">// tail 和 head 没有初始化时，无限循环</span></span><br><span class="line">        <span class="comment">// 虽然这种 continue 非常耗cpu，但感觉不会碰到这种情况</span></span><br><span class="line">        <span class="comment">// 因为 tail 和 head 在 TransferQueue 初始化的时候，就已经被赋值空节点了</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span> || h == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 首尾节点相同，说明是空队列</span></span><br><span class="line">        <span class="comment">// 或者尾节点的操作和当前节点操作一致</span></span><br><span class="line">        <span class="keyword">if</span> (h == t || t.isData == isData) &#123;</span><br><span class="line">            QNode tn = t.next;</span><br><span class="line">            <span class="comment">// 当 t 不是 tail 时，说明 tail 已经被修改过了</span></span><br><span class="line">            <span class="comment">// 因为 tail 没有被修改的情况下，t 和 tail 必然相等</span></span><br><span class="line">            <span class="comment">// 因为前面刚刚执行赋值操作： t = tail</span></span><br><span class="line">            <span class="keyword">if</span> (t != tail)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 队尾后面的值还不为空，t 还不是队尾，直接把 tn 赋值给 t，这是一步加强校验。</span></span><br><span class="line">            <span class="keyword">if</span> (tn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                advanceTail(t, tn);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//超时直接返回 null</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>)        <span class="comment">// can&#x27;t wait</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//构造node节点</span></span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line">                s = <span class="keyword">new</span> QNode(e, isData);</span><br><span class="line">            <span class="comment">//如果把 e 放到队尾失败，继续递归放进去</span></span><br><span class="line">            <span class="keyword">if</span> (!t.casNext(<span class="keyword">null</span>, s))        <span class="comment">// failed to link in</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            advanceTail(t, s);              <span class="comment">// swing tail and wait</span></span><br><span class="line">            <span class="comment">// 阻塞住自己</span></span><br><span class="line">            Object x = awaitFulfill(s, e, timed, nanos);</span><br><span class="line">            <span class="keyword">if</span> (x == s) &#123;                   <span class="comment">// wait was cancelled</span></span><br><span class="line">                clean(t, s);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!s.isOffList()) &#123;           <span class="comment">// not already unlinked</span></span><br><span class="line">                advanceHead(t, s);          <span class="comment">// unlink if head</span></span><br><span class="line">                <span class="keyword">if</span> (x != <span class="keyword">null</span>)              <span class="comment">// and forget fields</span></span><br><span class="line">                    s.item = s;</span><br><span class="line">                s.waiter = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (x != <span class="keyword">null</span>) ? (E)x : e;</span><br><span class="line">        <span class="comment">// 队列不为空，并且当前操作和队尾不一致</span></span><br><span class="line">        <span class="comment">// 也就是说当前操作是队尾是对应的操作</span></span><br><span class="line">        <span class="comment">// 比如说队尾是因为 take 被阻塞的，那么当前操作必然是 put</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                            <span class="comment">// complementary-mode</span></span><br><span class="line">            <span class="comment">// 如果是第一次执行，此处的 m 代表就是 tail</span></span><br><span class="line">            <span class="comment">// 也就是这行代码体现出队列的公平，每次操作时，从头开始按照顺序进行操作</span></span><br><span class="line">            QNode m = h.next;               <span class="comment">// node to fulfill</span></span><br><span class="line">            <span class="keyword">if</span> (t != tail || m == <span class="keyword">null</span> || h != head)</span><br><span class="line">                <span class="keyword">continue</span>;                   <span class="comment">// inconsistent read</span></span><br><span class="line"></span><br><span class="line">            Object x = m.item;</span><br><span class="line">            <span class="keyword">if</span> (isData == (x != <span class="keyword">null</span>) ||    <span class="comment">// m already fulfilled</span></span><br><span class="line">                x == m ||                   <span class="comment">// m cancelled</span></span><br><span class="line">                <span class="comment">// m 代表栈头</span></span><br><span class="line">                <span class="comment">// 这里把当前的操作值赋值给阻塞住的 m 的 item 属性</span></span><br><span class="line">                <span class="comment">// 这样 m 被释放时，就可得到此次操作的值</span></span><br><span class="line">                !m.casItem(x, e)) &#123;         <span class="comment">// lost CAS</span></span><br><span class="line">                advanceHead(h, m);          <span class="comment">// dequeue and retry</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前操作放到队头</span></span><br><span class="line">            advanceHead(h, m);              <span class="comment">// successfully fulfilled</span></span><br><span class="line">            <span class="comment">// 释放队头阻塞节点</span></span><br><span class="line">            LockSupport.unpark(m.waiter);</span><br><span class="line">            <span class="keyword">return</span> (x != <span class="keyword">null</span>) ? (E)x : e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码比较复杂，我们需要搞清楚的是，线程被阻塞住后，当前线程是如何把自己的数据传给阻塞线程的。为了方便说明，我们假设线程 1 往队列中 take 数据 ，被阻塞住了，变成阻塞线程 A ，然后线程 2 开始往队列中 put 数据 B，大致的流程是这样的：</p>
<ol>
<li>线程 1 从队列中拿数据，发现队列中没有数据，于是被阻塞，成为 A ；</li>
<li>线程 2 往队尾 put 数据，会从队尾往前找到第一个被阻塞的节点，假设此时能找到的就是节点 A，然后线程 B 把将 put 的数据放到节点 A 的 item 属性里面，并唤醒线程 1；</li>
<li>线程 1 被唤醒后，就能从 A.item 里面拿到线程 2 put 的数据了，线程 1 成功返回。</li>
</ol>
<p>从这个过程中，我们能看出公平主要体现在，每次 put 数据的时候，都 put 到队尾上，而每次拿数据时，并不是直接从堆头拿数据，而是从队尾往前寻找第一个被阻塞的线程，这样就会按照顺序释放被阻塞的线程。</p>
<h3 id="4-总结-2"><a href="#4-总结-2" class="headerlink" title="4 总结"></a>4 总结</h3><p>SynchronousQueue 源码比较复杂，建议大家进行源码的 debug 来学习源码，为大家准备了调试类：SynchronousQueueDemo，大家可以下载源码自己调试一下，这样学起来应该会更加轻松一点。</p>
<h2 id="21-DelayQueue-源码解析"><a href="#21-DelayQueue-源码解析" class="headerlink" title="21 DelayQueue 源码解析"></a><strong>21 DelayQueue 源码解析</strong></h2><h3 id="引导语-18"><a href="#引导语-18" class="headerlink" title="引导语"></a>引导语</h3><p>之前我们说的阻塞队列，都是资源足够时立马执行。本章我们说的队列比较特殊，是一种延迟队列，意思是延迟执行，并且可以设置延迟多久之后执行，比如设置过 5 秒钟之后再执行，在一些延迟执行的场景被大量使用，比如说延迟对账等等。</p>
<h3 id="1-整体设计"><a href="#1-整体设计" class="headerlink" title="1 整体设计"></a>1 整体设计</h3><p>DelayQueue 延迟队列底层使用的是锁的能力，比如说要在当前时间往后延迟 5 秒执行，那么当前线程就会沉睡 5 秒，等 5 秒后线程被唤醒时，如果能获取到资源的话，线程即可立马执行。原理上似乎很简单，但内部实现却很复杂，有很多难点，比如当运行资源不够，多个线程同时被唤醒时，如何排队等待？比如说在何时阻塞？何时开始执行等等？接下来我们从源码角度来看下是如何实现的。</p>
<h4 id="1-1-类注释-4"><a href="#1-1-类注释-4" class="headerlink" title="1.1 类注释"></a>1.1 类注释</h4><p>类注释上比较简单，只说了三个概念：</p>
<ol>
<li>队列中元素将在过期时被执行，越靠近队头，越早过期；</li>
<li>未过期的元素不能够被 take；</li>
<li>不允许空元素。</li>
</ol>
<p>这三个概念，其实就是三个问题，下文我们会一一看下这三点是如何实现的。</p>
<h4 id="1-2-类图-1"><a href="#1-2-类图-1" class="headerlink" title="1.2 类图"></a>1.2 类图</h4><p>DelayQueue 的类图和之前的队列一样，不多说，关键是 DelayQueue 类上是有泛型的，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueue</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Delayed</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br></pre></td></tr></table></figure>

<p>从泛型中可以看出，DelayQueue 中的元素必须是 Delayed 的子类，Delayed 是表达延迟能力的关键接口，其继承了 Comparable 接口，并定义了还剩多久过期的方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Delayed</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Delayed</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说 DelayQueue 队列中的元素必须是实现 Delayed 接口和 Comparable 接口的，并覆写了 getDelay 方法和 compareTo 的方法才行，不然在编译时，编译器就会提醒我们元素必须强制实现 Delayed 接口。</p>
<p>除此之外 DelayQueue 还大量使用了 PriorityQueue 队列的大量功能，这个和 SynchronousQueue 队列很像，大量复用了其它基础类的逻辑，代码示例如下：</p>
<p><img src="http://img.mukewang.com/5da56dcc0001306c13701376.png" alt="图片描述">PriorityQueue 中文叫做优先级队列，在此处的作用就是可以根据过期时间做优先级排序，让先过期的可以先执行，用来实现类注释中的第一点。</p>
<p>这里的复用的思想还是蛮重要的，我们在源码中经常会遇到这种思想，比如说 LinkedHashMap 复用 HashMap 的能力，Set 复用 Map 的能力，还有此处的 DelayQueue 复用 PriorityQueue 的能力。小结一下，如果想要复用需要做到哪些：</p>
<ol>
<li>需要把能遇见可复用的功能尽量抽象，并开放出可扩展的地方，比如说 HashMap 在操作数组的方法中，都给 LinkedHashMap 开放出很多 after 开头的方法，便于 LinkedHashMap 进行排序、删除等等；</li>
<li>采用组合或继承两种手段进行复用，比如 LinkedHashMap 采用的继承、 Set 和 DelayQueue 采用的组合，组合的意思就是把可复用的类给依赖进来。</li>
</ol>
<h3 id="2-演示"><a href="#2-演示" class="headerlink" title="2 演示"></a>2 演示</h3><p>为了方便大家理解，写了一个演示的 demo，演示了一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueueDemo</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 队列消息的生产者</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue queue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Product</span><span class="params">(BlockingQueue queue)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;begin put&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> beginTime = System.currentTimeMillis();</span><br><span class="line">        queue.put(<span class="keyword">new</span> DelayedDTO(System.currentTimeMillis() + <span class="number">2000L</span>,beginTime));<span class="comment">//延迟 2 秒执行</span></span><br><span class="line">        queue.put(<span class="keyword">new</span> DelayedDTO(System.currentTimeMillis() + <span class="number">5000L</span>,beginTime));<span class="comment">//延迟 5 秒执行</span></span><br><span class="line">        queue.put(<span class="keyword">new</span> DelayedDTO(System.currentTimeMillis() + <span class="number">1000L</span> * <span class="number">10</span>,beginTime));<span class="comment">//延迟 10 秒执行</span></span><br><span class="line">        log.info(<span class="string">&quot;end put&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;&quot;</span> + e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// 队列的消费者</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue queue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue queue)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;Consumer begin&quot;</span>);</span><br><span class="line">        ((DelayedDTO) queue.take()).run();</span><br><span class="line">        ((DelayedDTO) queue.take()).run();</span><br><span class="line">        ((DelayedDTO) queue.take()).run();</span><br><span class="line">        log.info(<span class="string">&quot;Consumer end&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;&quot;</span> + e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Data</span></span><br><span class="line">  <span class="comment">// 队列元素，实现了 Delayed 接口</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedDTO</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</span><br><span class="line">    Long s;</span><br><span class="line">    Long beginTime;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelayedDTO</span><span class="params">(Long s,Long beginTime)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.s = s;</span><br><span class="line">      <span class="keyword">this</span>.beginTime =beginTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> unit.convert(s - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="keyword">int</span>) (<span class="keyword">this</span>.getDelay(TimeUnit.MILLISECONDS) - o.getDelay(TimeUnit.MILLISECONDS));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">      log.info(<span class="string">&quot;现在已经过了&#123;&#125;秒钟&quot;</span>,(System.currentTimeMillis() - beginTime)/<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// demo 运行入口</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    BlockingQueue q = <span class="keyword">new</span> DelayQueue();</span><br><span class="line">    DelayQueueDemo.Product p = <span class="keyword">new</span> DelayQueueDemo.Product(q);</span><br><span class="line">    DelayQueueDemo.Consumer c = <span class="keyword">new</span> DelayQueueDemo.Consumer(q);</span><br><span class="line">    <span class="keyword">new</span> Thread(c).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(p).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">打印出来的结果如下：</span><br><span class="line"><span class="number">06</span>:<span class="number">57</span>:<span class="number">50.544</span> [Thread-<span class="number">0</span>] Consumer begin</span><br><span class="line"><span class="number">06</span>:<span class="number">57</span>:<span class="number">50.544</span> [Thread-<span class="number">1</span>] begin put</span><br><span class="line"><span class="number">06</span>:<span class="number">57</span>:<span class="number">50.551</span> [Thread-<span class="number">1</span>] end put</span><br><span class="line"><span class="number">06</span>:<span class="number">57</span>:<span class="number">52.554</span> [Thread-<span class="number">0</span>] 延迟了<span class="number">2</span>秒钟才执行</span><br><span class="line"><span class="number">06</span>:<span class="number">57</span>:<span class="number">55.555</span> [Thread-<span class="number">0</span>] 延迟了<span class="number">5</span>秒钟才执行</span><br><span class="line"><span class="number">06</span>:<span class="number">58</span>:<span class="number">00</span>.<span class="number">555</span> [Thread-<span class="number">0</span>] 延迟了<span class="number">10</span>秒钟才执行</span><br><span class="line"><span class="number">06</span>:<span class="number">58</span>:<span class="number">00</span>.<span class="number">556</span> [Thread-<span class="number">0</span>] Consumer end</span><br></pre></td></tr></table></figure>

<p>写这个代码的目的主要想演示一下延迟执行的例子，我们大概的思路是：</p>
<ol>
<li>新建队列的元素，如 DelayedDTO，必须实现 Delayed 接口，我们在 getDelay 方法中实现了现在离过期时间还剩多久的方法。</li>
<li>定义队列元素的生产者，和消费者，对应着代码中的 Product 和 Consumer。</li>
<li>对生产者和消费者就行初始化和管理，对应着我们的 main 方法。</li>
</ol>
<p>虽然这只是一个简单的 demo，但实际工作中，我们使用 DelayQueue 基本上就是这种思想，只不过写代码的时候会更加通用和周全，接下来我们来看下 DelayQueue 是如何实现 put 和 take 的。</p>
<h3 id="3-放数据"><a href="#3-放数据" class="headerlink" title="3 放数据"></a>3 放数据</h3><p>我们以 put 为例，put 调用的是 offer 的方法，offer 的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 上锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 PriorityQueue 的扩容，排序等能力</span></span><br><span class="line">        q.offer(e);</span><br><span class="line">        <span class="comment">// 如果恰好刚放进去的元素正好在队列头</span></span><br><span class="line">        <span class="comment">// 立马唤醒 take 的阻塞线程，执行 take 操作</span></span><br><span class="line">        <span class="comment">// 如果元素需要延迟执行的话，可以使其更快的沉睡计时</span></span><br><span class="line">        <span class="keyword">if</span> (q.peek() == e) &#123;</span><br><span class="line">            leader = <span class="keyword">null</span>;</span><br><span class="line">            available.signal();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到其实底层使用到的是 PriorityQueue 的 offer 方法，我们来看下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新增元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果是空元素的话，抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> i = size;</span><br><span class="line">    <span class="comment">// 队列实际大小大于容量时，进行扩容</span></span><br><span class="line">    <span class="comment">// 扩容策略是：如果老容量小于 64，2 倍扩容，如果大于 64，50 % 扩容</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">        grow(i + <span class="number">1</span>);</span><br><span class="line">    size = i + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 如果队列为空，当前元素正好处于队头</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">        queue[<span class="number">0</span>] = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="comment">// 如果队列不为空，需要根据优先级进行排序</span></span><br><span class="line">        siftUp(i, e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按照从小到大的顺序排列</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;) x;</span><br><span class="line">        <span class="comment">// k 是当前队列实际大小的位置</span></span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 对 k 进行减倍</span></span><br><span class="line">            <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            Object e = queue[parent];</span><br><span class="line">            <span class="comment">// 如果 x 比 e 大，退出，把 x 放在 k 位置上</span></span><br><span class="line">            <span class="keyword">if</span> (key.compareTo((E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// x 比 e 小，继续循环，直到找到 x 比队列中元素大的位置</span></span><br><span class="line">            queue[k] = e;</span><br><span class="line">            k = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[k] = key;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，PriorityQueue 的 offer 方法主要做了三件事情：</p>
<ol>
<li>对新增元素进行判空；</li>
<li>对队列进行扩容，扩容策略和集合的扩容策略很相近；</li>
<li>根据元素的 compareTo 方法进行排序，我们希望最终排序的结果是从小到大的，因为我们想让队头的都是过期的数据，我们需要在 compareTo 方法里面实现：通过每个元素的过期时间进行排序，如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">int</span>) (<span class="keyword">this</span>.getDelay(TimeUnit.MILLISECONDS) - o.getDelay(TimeUnit.MILLISECONDS));</span><br></pre></td></tr></table></figure>

<p>这样便可实现越快过期的元素越能排到队头。</p>
<p>可以看到，新增数据时，只是使用到了 compareTo 方法，来对队列中的元素进行排序，接下来我们看下，取数据时，是如何操作的。</p>
<h3 id="4-拿数据"><a href="#4-拿数据" class="headerlink" title="4 拿数据"></a>4 拿数据</h3><p>取数据时，如果发现有元素的过期时间到了，就能拿出数据来，如果没有过期元素，那么线程就会一直阻塞，我们以 take 为例子，来看一下核心源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// 从队头中拿数据出来</span></span><br><span class="line">    E first = q.peek();</span><br><span class="line">    <span class="comment">// 如果为空，说明队列中，没有数据，阻塞住</span></span><br><span class="line">    <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">        available.await();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取队头数据的过期时间</span></span><br><span class="line">        <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">        <span class="comment">// 如果过期了，直接返回队头数据</span></span><br><span class="line">        <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> q.poll();</span><br><span class="line">        <span class="comment">// 引用置为 null ，便于 gc，这样可以让线程等待时，回收 first 变量</span></span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// leader 不为空的话，表示当前队列元素之前已经被设置过阻塞时间了</span></span><br><span class="line">        <span class="comment">// 直接阻塞当前线程等待。</span></span><br><span class="line">        <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">            available.await();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 之前没有设置过阻塞时间，按照一定的时间进行阻塞</span></span><br><span class="line">            Thread thisThread = Thread.currentThread();</span><br><span class="line">            leader = thisThread;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 进行阻塞</span></span><br><span class="line">                available.awaitNanos(delay);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                    leader = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到阻塞等待的功能底层使用的是锁的能力，这个我们在后面章节中会说到。</p>
<p>以上演示的 take 方法是会无限阻塞，直到队头的过期时间到了才会返回，如果不想无限阻塞，可以尝试 poll 方法，设置超时时间，在超时时间内，队头元素还没有过期的话，就会返回 null。</p>
<h3 id="5-总结-1"><a href="#5-总结-1" class="headerlink" title="5 总结"></a>5 总结</h3><p>DelayQueue 是非常有意思的队列，底层使用了排序和超时阻塞实现了延迟队列，排序使用的是 PriorityQueue 排序能力，超时阻塞使用得是锁的等待能力，可以看出 DelayQueue 其实就是为了满足延迟执行的场景，在已有 API 的基础上进行了封装，我们在工作中，可以学习这种思想，对已有的功能能复用的尽量复用，减少开发的工作量。</p>
<h2 id="22-ArrayBlockingQueue-源码解析"><a href="#22-ArrayBlockingQueue-源码解析" class="headerlink" title="22 ArrayBlockingQueue 源码解析"></a><strong>22 ArrayBlockingQueue 源码解析</strong></h2><h3 id="引导语-19"><a href="#引导语-19" class="headerlink" title="引导语"></a>引导语</h3><p>本小节我们来介绍本章最后一个队列：ArrayBlockingQueue。按照字面翻译，中文叫做数组阻塞队列，从名称上看，我们就比较清楚此阻塞队列底层使用的是数组。一说到数组，大家可能会想到 ArrayList 和 HashMap，举新增场景来说 ArrayList 通过 size ++ 找到新增的数组下标位置，HashMap 通过 hash 算法计算出下标位置，那么 ArrayBlockingQueue 是不是也是这两种方法呢？都不是，ArrayBlockingQueue 使用的是一种非常奇妙的方式，我们一起拭目以待。</p>
<p>全文为了方便说明，队头的说法就是数组头，队尾的说法就是数组尾。</p>
<h3 id="1-整体架构-6"><a href="#1-整体架构-6" class="headerlink" title="1 整体架构"></a>1 整体架构</h3><p>我们从类注释上可以得到一些有用的信息：</p>
<h4 id="1-1-类注释-5"><a href="#1-1-类注释-5" class="headerlink" title="1.1 类注释"></a>1.1 类注释</h4><ol>
<li>有界的阻塞数组，容量一旦创建，后续大小无法修改；</li>
<li>元素是有顺序的，按照先入先出进行排序，从队尾插入数据数据，从队头拿数据；</li>
<li>队列满时，往队列中 put 数据会被阻塞，队列空时，往队列中拿数据也会被阻塞。</li>
</ol>
<p>从类注释上可以看出 ArrayBlockingQueue 和一般的数组结构的类不太一样，是不能够动态扩容的，如果队列满了或者空时，take 和 put 都会被阻塞。</p>
<h4 id="1-2-数据结构"><a href="#1-2-数据结构" class="headerlink" title="1.2 数据结构"></a>1.2 数据结构</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 队列存放在 object 的数组里面</span></span><br><span class="line"><span class="comment">// 数组大小必须在初始化的时候手动设置，没有默认大小</span></span><br><span class="line"><span class="keyword">final</span> Object[] items;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下次拿数据的时候的索引位置</span></span><br><span class="line"><span class="keyword">int</span> takeIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下次放数据的索引位置</span></span><br><span class="line"><span class="keyword">int</span> putIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前已有元素的大小</span></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可重入的锁</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">// take的队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line"><span class="comment">// put的队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br></pre></td></tr></table></figure>

<p>以上代码有两个关键的字段，takeIndex 和 putIndex，分别表示下次拿数据和放数据的索引位置。所以说在新增数据和拿数据时，都无需计算，就能知道应该新增到什么位置，应该从什么位置拿数据。</p>
<h3 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2 初始化"></a>2 初始化</h3><p>初始化时，有两个重要的参数：数组的大小、是否是公平，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">    <span class="comment">// 队列不为空 Condition，在 put 成功时使用</span></span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    <span class="comment">// 队列不满 Condition，在 take 成功时使用</span></span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中我们可以看出，第二个参数是否公平，主要用于读写锁是否公平，如果是公平锁，那么在锁竞争时，就会按照先来先到的顺序，如果是非公平锁，锁竞争时随机的。</p>
<p>对于锁公平和非公平，我们举个例子：比如说现在队列是满的，还有很多线程执行 put 操作，必然会有很多线程阻塞等待，当有其它线程执行 take 时，会唤醒等待的线程，如果是公平锁，会按照阻塞等待的先后顺序，依次唤醒阻塞的线程，如果是非公平锁，会随机唤醒沉睡的线程。</p>
<p>所以说队列满很多线程执行 put 操作时，如果是公平锁，数组元素新增的顺序就是阻塞线程被释放的先后顺序，是有顺序的，而非公平锁，由于阻塞线程被释放的顺序是随机的，所以元素插入到数组的顺序也就不会按照插入的顺序了。</p>
<p>队列空时，也是一样的道理。</p>
<p>ArrayBlockingQueue 通过锁的公平和非公平，轻松实现了数组元素的插入顺序的问题。如果要实现这个功能，你会怎么做呢？会想到利用锁的功能么？其实这种思想我们在文中多次提到，当我们需要完成一件事情时，首先看看已有的 API 能不能满足，如果可以的话，通过继承和组合的方式来实现，ArrayBlockingQueue 就是组合了锁的功能。</p>
<p>初始化时，如果给定了原始数据的话，一定要注意原始数据的大小一定要小于队列的容量，否则会抛异常，如下图所示：</p>
<p><img src="http://img.mukewang.com/5da9962c0001338b13541200.png" alt="图片描述"><br>我们写了一个 demo，报错如下：</p>
<p><img src="http://img.mukewang.com/5da9963b00018d9022401200.png" alt="图片描述"></p>
<h3 id="3-新增数据"><a href="#3-新增数据" class="headerlink" title="3 新增数据"></a>3 新增数据</h3><p>数据新增都会按照 putIndex 的位置进行新增，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新增，如果队列满，无限阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 元素不能为空</span></span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 队列如果是满的，就无限等待</span></span><br><span class="line">        <span class="comment">// 一直等待队列中有数据被拿走时，自己被唤醒</span></span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1; 同一时刻只能一个线程进行操作此方法</span></span><br><span class="line">    <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="comment">// putIndex 为本次插入的位置</span></span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    <span class="comment">// ++ putIndex 计算下次插入的位置</span></span><br><span class="line">    <span class="comment">// 如果下次插入的位置，正好等于队尾，下次插入就从 0 开始</span></span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="comment">// 唤醒因为队列空导致的等待线程</span></span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中，我们可以看出，其实新增就两种情况：</p>
<ol>
<li>本次新增的位置居中，直接新增，下图演示的是 putIndex 在数组下标为 5 的位置，还不到队尾，那么可以直接新增，计算下次新增的位置应该是 6；<br><img src="http://img.mukewang.com/5da996520001b78412100296.png" alt="图片描述"></li>
<li>新增的位置到队尾了，那么下次新增时就要从头开始了，示意图如下：<br><img src="http://img.mukewang.com/5dc385f60001236510260354.png" alt="图片描述"></li>
</ol>
<p>上面这张图演示的就是这行代码：<code>if (++putIndex == items.length) putIndex = 0;</code></p>
<p>可以看到当新增到队尾时，下次新增会重新从队头重新开始。</p>
<h3 id="4-拿数据-1"><a href="#4-拿数据-1" class="headerlink" title="4 拿数据"></a>4 拿数据</h3><p>拿数据都是从队头开始拿数据，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果队列为空，无限等待</span></span><br><span class="line">        <span class="comment">// 直到队列中有数据被 put 后，自己被唤醒</span></span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="comment">// 从队列中拿数据</span></span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="comment">// takeIndex 代表本次拿数据的位置，是上一次拿数据时计算好的</span></span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line">    <span class="comment">// 帮助 gc</span></span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// ++ takeIndex 计算下次拿数据的位置</span></span><br><span class="line">    <span class="comment">// 如果正好等于队尾的话，下次就从 0 开始拿数据</span></span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 队列实际大小减 1</span></span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    <span class="comment">// 唤醒被队列满所阻塞的线程</span></span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中可以看出，每次拿数据的位置就是 takeIndex 的位置，在找到本次该拿的数据之后，会把 takeIndex 加 1，计算下次拿数据时的索引位置，有个特殊情况是，如果本次拿数据的位置已经是队尾了，那么下次拿数据的位置就要从头开始，就是从 0 开始了。</p>
<h3 id="5-删除数据"><a href="#5-删除数据" class="headerlink" title="5 删除数据"></a>5 删除数据</h3><p>删除数据很有意思，我们一起来看下核心源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一共有两种情况：</span></span><br><span class="line"><span class="comment">// 1：删除位置和 takeIndex 的关系：删除位置和 takeIndex 一样，比如 takeIndex 是 2， 而要删除的位置正好也是 2，那么就把位置 2 的数据置为 null ,并重新计算 takeIndex 为 3。</span></span><br><span class="line"><span class="comment">// 2：找到要删除元素的下一个，计算删除元素和 putIndex 的关系</span></span><br><span class="line"><span class="comment">// 如果下一个元素不是 putIndex，就把下一个元素往前移动一位</span></span><br><span class="line"><span class="comment">// 如果下一个元素是 putIndex，把 putIndex 的值修改成删除的位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeAt</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> removeIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="comment">// 情况1 如果删除位置正好等于下次要拿数据的位置</span></span><br><span class="line">    <span class="keyword">if</span> (removeIndex == takeIndex) &#123;</span><br><span class="line">        <span class="comment">// 下次要拿数据的位置直接置空</span></span><br><span class="line">        items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 要拿数据的位置往后移动一位</span></span><br><span class="line">        <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">            takeIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 当前数组的大小减一</span></span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">            itrs.elementDequeued();</span><br><span class="line">    <span class="comment">// 情况 2</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> putIndex = <span class="keyword">this</span>.putIndex;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = removeIndex;;) &#123;</span><br><span class="line">            <span class="comment">// 找到要删除元素的下一个</span></span><br><span class="line">            <span class="keyword">int</span> next = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (next == items.length)</span><br><span class="line">                next = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 下一个元素不是 putIndex</span></span><br><span class="line">            <span class="keyword">if</span> (next != putIndex) &#123;</span><br><span class="line">                <span class="comment">// 下一个元素往前移动一位</span></span><br><span class="line">                items[i] = items[next];</span><br><span class="line">                i = next;</span><br><span class="line">            <span class="comment">// 下一个元素是 putIndex</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 删除元素</span></span><br><span class="line">                items[i] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 下次放元素时，应该从本次删除的元素放</span></span><br><span class="line">                <span class="keyword">this</span>.putIndex = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">            itrs.removedAt(removeIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    notFull.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除数据的情况比较复杂，一共有两种情况，第一种情况是 takeIndex == removeIndex，我们画个示意图来看下处理方式：</p>
<p><img src="http://img.mukewang.com/5da9967c0001f1a112600970.png" alt="图片描述"><br>第二种情况又分两种：</p>
<ol>
<li>如果 removeIndex + 1 != putIndex 的话，就把下一个元素往前移动一位，示意图如下：<br><img src="http://img.mukewang.com/5da996880001782712280958.png" alt="图片描述"></li>
<li>如果 removeIndex + 1 == putIndex 的话，就把 putIndex 的值修改成删除的位置，示意图如下：</li>
</ol>
<p><img src="http://img.mukewang.com/5da9969c0001254d12300940.png" alt="图片描述"></p>
<p>ArrayBlockingQueue 的删除方法其实还蛮复杂的，需要考虑到很多特殊的场景。</p>
<h3 id="6-总结-1"><a href="#6-总结-1" class="headerlink" title="6 总结"></a>6 总结</h3><p>ArrayBlockingQueue 底层是有界的数组，整体来说，和其它队列差别不多，需要注意的是，当 takeIndex、putIndex 到队尾的时候，都会重新从 0 开始循环，这点是比较特殊的，在我们学习源码时，需要特别注意。</p>
<h2 id="23-队列在源码方面的面试题"><a href="#23-队列在源码方面的面试题" class="headerlink" title="23 队列在源码方面的面试题"></a><strong>23 队列在源码方面的面试题</strong></h2><h3 id="引导语-20"><a href="#引导语-20" class="headerlink" title="引导语"></a>引导语</h3><p>队列在源码方面的面试题，一般面试官会从锁，线程池等知识点作为问题入口，慢慢的问到队列，由于锁、线程池咱们还没有学习到，所以本章就直奔主题，从队列入手，看看队列都有哪些面试题（队列种类很多，本文在说队列的通用特征时，都是在说其大部分队列的通用特征，如有某种队列特征不符，不在一一说明）。</p>
<h3 id="1-面试题-1"><a href="#1-面试题-1" class="headerlink" title="1 面试题"></a>1 面试题</h3><h4 id="1-1-说说你对队列的理解，队列和集合的区别。"><a href="#1-1-说说你对队列的理解，队列和集合的区别。" class="headerlink" title="1.1 说说你对队列的理解，队列和集合的区别。"></a>1.1 说说你对队列的理解，队列和集合的区别。</h4><p>答：对队列的理解：</p>
<ol>
<li>首先队列本身也是个容器，底层也会有不同的数据结构，比如 LinkedBlockingQueue 是底层是链表结构，所以可以维持先入先出的顺序，比如 DelayQueue 底层可以是队列或堆栈，所以可以保证先入先出，或者先入后出的顺序等等，底层的数据结构不同，也造成了操作实现不同；</li>
<li>部分队列（比如 LinkedBlockingQueue ）提供了暂时存储的功能，我们可以往队列里面放数据，同时也可以从队列里面拿数据，两者可以同时进行；</li>
<li>队列把生产数据的一方和消费数据的一方进行解耦，生产者只管生产，消费者只管消费，两者之间没有必然联系，队列就像生产者和消费者之间的数据通道一样，如 LinkedBlockingQueue；</li>
<li>队列还可以对消费者和生产者进行管理，比如队列满了，有生产者还在不停投递数据时，队列可以使生产者阻塞住，让其不再能投递，比如队列空时，有消费者过来拿数据时，队列可以让消费者 hodler 住，等有数据时，唤醒消费者，让消费者拿数据返回，如 ArrayBlockingQueue；</li>
<li>队列还提供阻塞的功能，比如我们从队列拿数据，但队列中没有数据时，线程会一直阻塞到队列有数据可拿时才返回。</li>
</ol>
<p>队列和集合的区别：</p>
<ol>
<li><p>和集合的相同点，队列（部分例外）和集合都提供了数据存储的功能，底层的储存数据结构是有些相似的，比如说 LinkedBlockingQueue 和 LinkedHashMap 底层都使用的是链表，ArrayBlockingQueue 和 ArrayList 底层使用的都是数组。</p>
</li>
<li><p>和集合的区别：</p>
<p>2.1 部分队列和部分集合底层的存储结构很相似的，但两者为了完成不同的事情，提供的 API 和其底层的操作实现是不同的。</p>
<p>2.2 队列提供了阻塞的功能，能对消费者和生产者进行简单的管理，队列空时，会阻塞消费者，有其他线程进行 put 操作后，会唤醒阻塞的消费者，让消费者拿数据进行消费，队列满时亦然。</p>
<p>2.3 解耦了生产者和消费者，队列就像是生产者和消费者之间的管道一样，生产者只管往里面丢，消费者只管不断消费，两者之间互不关心。</p>
</li>
</ol>
<h4 id="1-2-哪些队列具有阻塞的功能，大概是如何阻塞的？"><a href="#1-2-哪些队列具有阻塞的功能，大概是如何阻塞的？" class="headerlink" title="1.2 哪些队列具有阻塞的功能，大概是如何阻塞的？"></a>1.2 哪些队列具有阻塞的功能，大概是如何阻塞的？</h4><p>答：队列主要提供了两种阻塞功能，如下：</p>
<ol>
<li>LinkedBlockingQueue 链表阻塞队列和 ArrayBlockingQueue 数组阻塞队列是一类，前者容量是 Integer 的最大值，后者数组大小固定，两个阻塞队列都可以指定容量大小，当队列满时，如果有线程 put 数据，线程会阻塞住，直到有其他线程进行消费数据后，才会唤醒阻塞线程继续 put，当队列空时，如果有线程 take 数据，线程会阻塞到队列不空时，继续 take。</li>
<li>SynchronousQueue 同步队列，当线程 put 时，必须有对应线程把数据消费掉，put 线程才能返回，当线程 take 时，需要有对应线程进行 put 数据时，take 才能返回，反之则阻塞，举个例子，线程 A put 数据 A1 到队列中了，此时并没有任何的消费者，线程 A 就无法返回，会阻塞住，直到有线程消费掉数据 A1 时，线程 A 才能返回。</li>
</ol>
<h4 id="1-3-底层是如何实现阻塞的？"><a href="#1-3-底层是如何实现阻塞的？" class="headerlink" title="1.3 底层是如何实现阻塞的？"></a>1.3 底层是如何实现阻塞的？</h4><p>答：队列本身并没有实现阻塞的功能，而是利用 Condition 的等待唤醒机制，阻塞底层实现就是更改线程的状态为沉睡，细节我们在锁小节会说到。</p>
<h4 id="1-4-LinkedBlockingQueue-和-ArrayBlockingQueue-有啥区别。"><a href="#1-4-LinkedBlockingQueue-和-ArrayBlockingQueue-有啥区别。" class="headerlink" title="1.4 LinkedBlockingQueue 和 ArrayBlockingQueue 有啥区别。"></a>1.4 LinkedBlockingQueue 和 ArrayBlockingQueue 有啥区别。</h4><p>答：相同点：</p>
<ol>
<li>两者的阻塞机制大体相同，比如在队列满、空时，线程都会阻塞住。</li>
</ol>
<p>不同点：</p>
<ol>
<li>LinkedBlockingQueue 底层是链表结构，容量默认是 Interge 的最大值，ArrayBlockingQueue 底层是数组，容量必须在初始化时指定。</li>
<li>两者的底层结构不同，所以 take、put、remove 的底层实现也就不同。</li>
</ol>
<h4 id="1-5-往队列里面-put-数据是线程安全的么？为什么？"><a href="#1-5-往队列里面-put-数据是线程安全的么？为什么？" class="headerlink" title="1.5 往队列里面 put 数据是线程安全的么？为什么？"></a>1.5 往队列里面 put 数据是线程安全的么？为什么？</h4><p>答：是线程安全的，在 put 之前，队列会自动加锁，put 完成之后，锁会自动释放，保证了同一时刻只会有一个线程能操作队列的数据，以 LinkedBlockingQueue 为例子，put 时，会加 put 锁，并只对队尾 tail 进行操作，take 时，会加 take 锁，并只对队头 head 进行操作，remove 时，会同时加 put 和 take 锁，所以各种操作都是线程安全的，我们工作中可以放心使用。</p>
<h4 id="1-6-take-的时候也会加锁么？既然-put-和-take-都会加锁，是不是同一时间只能运行其中一个方法。"><a href="#1-6-take-的时候也会加锁么？既然-put-和-take-都会加锁，是不是同一时间只能运行其中一个方法。" class="headerlink" title="1.6 take 的时候也会加锁么？既然 put 和 take 都会加锁，是不是同一时间只能运行其中一个方法。"></a>1.6 take 的时候也会加锁么？既然 put 和 take 都会加锁，是不是同一时间只能运行其中一个方法。</h4><p>答：1：是的，take 时也会加锁的，像 LinkedBlockingQueue 在执行 take 方法时，在拿数据的同时，会把当前数据删除掉，就改变了链表的数据结构，所以需要加锁来保证线程安全。</p>
<p>2：这个需要看情况而言，对于 LinkedBlockingQueue 来说，队列的 put 和 take 都会加锁，但两者的锁是不一样的，所以两者互不影响，可以同时进行的，对于 ArrayBlockingQueue 而言，put 和 take 是同一个锁，所以同一时刻只能运行一个方法。</p>
<h4 id="1-7-工作中经常使用队列的-put、take-方法有什么危害，如何避免。"><a href="#1-7-工作中经常使用队列的-put、take-方法有什么危害，如何避免。" class="headerlink" title="1.7 工作中经常使用队列的 put、take 方法有什么危害，如何避免。"></a>1.7 工作中经常使用队列的 put、take 方法有什么危害，如何避免。</h4><p>答：当队列满时，使用 put 方法，会一直阻塞到队列不满为止。</p>
<p>当队列空时，使用 take 方法，会一直阻塞到队列有数据为止。</p>
<p>两个方法都是无限（永远、没有超时时间的意思）阻塞的方法，容易使得线程全部都阻塞住，大流量时，导致机器无线程可用，所以建议在流量大时，使用 offer 和 poll 方法来代替两者，我们只需要设置好超时阻塞时间，这两个方法如果在超时时间外，还没有得到数据的话，就会返回默认值（LinkedBlockingQueue 为例），这样就不会导致流量大时，所有的线程都阻塞住了。</p>
<p>这个也是生产事故常常发生的原因之一，尝试用 put 和 take 方法，在平时自测中根本无法发现，对源码不熟悉的同学也不会意识到会有问题，当线上大流量打进来时，很有可能会发生故障，所以我们平时工作中使用队列时，需要谨慎再谨慎。</p>
<h4 id="1-8-把数据放入队列中后，有木有办法让队列过一会儿再执行？"><a href="#1-8-把数据放入队列中后，有木有办法让队列过一会儿再执行？" class="headerlink" title="1.8 把数据放入队列中后，有木有办法让队列过一会儿再执行？"></a>1.8 把数据放入队列中后，有木有办法让队列过一会儿再执行？</h4><p>答：可以的，DelayQueue 提供了这种机制，可以设置一段时间之后再执行，该队列有个唯一的缺点，就是数据保存在内存中，在重启和断电的时候，数据容易丢失，所以定时的时间我们都不会设置很久，一般都是几秒内，如果定时的时间需要设置很久的话，可以考虑采取延迟队列中间件（这种中间件对数据会进行持久化，不怕断电的发生）进行实现。</p>
<h4 id="1-9-DelayQueue-对元素有什么要求么，我把-String-放到队列中去可以么？"><a href="#1-9-DelayQueue-对元素有什么要求么，我把-String-放到队列中去可以么？" class="headerlink" title="1.9 DelayQueue 对元素有什么要求么，我把 String 放到队列中去可以么？"></a>1.9 DelayQueue 对元素有什么要求么，我把 String 放到队列中去可以么？</h4><p>答：DelayQueue 要求元素必须实现 Delayed 接口，Delayed 本身又实现了 Comparable 接口，Delayed 接口的作用是定义还剩下多久就会超时，给使用者定制超时时间的，Comparable 接口主要用于对元素之间的超时时间进行排序的，两者结合，就可以让越快过期的元素能够排在前面。</p>
<p>所以把 String 放到 DelayQueue 中是不行的，编译都无法通过，DelayQueue 类在定义的时候，是有泛型定义的，泛型类型必须是 Delayed 接口的子类才行。</p>
<h4 id="1-10-DelayQueue-如何让快过期的元素先执行的？"><a href="#1-10-DelayQueue-如何让快过期的元素先执行的？" class="headerlink" title="1.10 DelayQueue 如何让快过期的元素先执行的？"></a>1.10 DelayQueue 如何让快过期的元素先执行的？</h4><p>答：DelayQueue 中的元素都实现 Delayed 和 Comparable 接口的，其内部会使用 Comparable 的 compareTo 方法进行排序，我们可以利用这个功能，在 compareTo 方法中实现过期时间和当前时间的差，这样越快过期的元素，计算出来的差值就会越小，就会越先被执行。</p>
<h4 id="1-11-如何查看-SynchronousQueue-队列的大小？"><a href="#1-11-如何查看-SynchronousQueue-队列的大小？" class="headerlink" title="1.11 如何查看 SynchronousQueue 队列的大小？"></a>1.11 如何查看 SynchronousQueue 队列的大小？</h4><p>答：此题是个陷进题，题目首先设定了 SynchronousQueue 是可以查看大小的，实际上 SynchronousQueue 本身是没有容量的，所以也无法查看其容量的大小，其内部的 size 方法都是写死的返回 0。</p>
<h4 id="1-12-SynchronousQueue-底层有几种数据结构，两者有何不同？"><a href="#1-12-SynchronousQueue-底层有几种数据结构，两者有何不同？" class="headerlink" title="1.12 SynchronousQueue 底层有几种数据结构，两者有何不同？"></a>1.12 SynchronousQueue 底层有几种数据结构，两者有何不同？</h4><p>答：底层有两种数据结构，分别是队列和堆栈。</p>
<p>两者不同点：</p>
<ol>
<li>队列维护了先入先出的顺序，所以最先进去队列的元素会最先被消费，我们称为公平的，而堆栈则是先入后出的顺序，最先进入堆栈中的数据可能会最后才会被消费，我们称为不公平的。</li>
<li>两者的数据结构不同，导致其 take 和 put 方法有所差别，具体的可以看 《 SynchronousQueue 源码解析 》章节。</li>
</ol>
<h4 id="1-13-假设-SynchronousQueue-底层使用的是堆栈，线程-1-执行-take-操作阻塞住了，然后有线程-2-执行-put-操作，问此时线程-2-是如何把-put-的数据传递给-take-的？"><a href="#1-13-假设-SynchronousQueue-底层使用的是堆栈，线程-1-执行-take-操作阻塞住了，然后有线程-2-执行-put-操作，问此时线程-2-是如何把-put-的数据传递给-take-的？" class="headerlink" title="1.13 假设 SynchronousQueue 底层使用的是堆栈，线程 1 执行 take 操作阻塞住了，然后有线程 2 执行 put 操作，问此时线程 2 是如何把 put 的数据传递给 take 的？"></a>1.13 假设 SynchronousQueue 底层使用的是堆栈，线程 1 执行 take 操作阻塞住了，然后有线程 2 执行 put 操作，问此时线程 2 是如何把 put 的数据传递给 take 的？</h4><p>答：这是一个好问题，也是理解 SynchronousQueue 的核心问题。</p>
<p>首先线程 1 被阻塞住，此时堆栈头就是线程 1 了，此时线程 2 执行 put 操作，会把 put 的数据赋值给堆栈头的 match 属性，并唤醒线程 1，线程 1 被唤醒后，拿到堆栈头中的 match 属性，就能够拿到 put 的数据了。</p>
<p>严格上说并不是 put 操作直接把数据传递给了 take，而是 put 操作改变了堆栈头的数据，从而 take 可以从堆栈头上直接拿到数据，堆栈头是 take 和 put 操作之间的沟通媒介。</p>
<h4 id="1-14-如果想使用固定大小的队列，有几种队列可以选择，有何不同？"><a href="#1-14-如果想使用固定大小的队列，有几种队列可以选择，有何不同？" class="headerlink" title="1.14 如果想使用固定大小的队列，有几种队列可以选择，有何不同？"></a>1.14 如果想使用固定大小的队列，有几种队列可以选择，有何不同？</h4><p>答：可以使用 LinkedBlockingQueue 和 ArrayBlockingQueue 两种队列。</p>
<p>前者是链表，后者是数组，链表新增时，只要建立起新增数据和链尾数据之间的关联即可，数组新增时，需要考虑到索引的位置（takeIndex 和 putIndex 分别记录着下次拿数据、放数据的索引位置），如果增加到了数组最后一个位置，下次就要重头开始新增。</p>
<h4 id="1-15-ArrayBlockingQueue-可以动态扩容么？用到数组最后一个位置时怎么办？"><a href="#1-15-ArrayBlockingQueue-可以动态扩容么？用到数组最后一个位置时怎么办？" class="headerlink" title="1.15 ArrayBlockingQueue 可以动态扩容么？用到数组最后一个位置时怎么办？"></a>1.15 ArrayBlockingQueue 可以动态扩容么？用到数组最后一个位置时怎么办？</h4><p>答：不可以的，虽然 ArrayBlockingQueue 底层是数组，但不能够动态扩容的。</p>
<p>假设 put 操作用到了数组的最后一个位置，那么下次 put 就需要从数组 0 的位置重新开始了。</p>
<p>假设 take 操作用到数组的最后一个位置，那么下次 take 的时候也会从数组 0 的位置重新开始。</p>
<h4 id="1-16-ArrayBlockingQueue-take-和-put-都是怎么找到索引位置的？是利用-hash-算法计算得到的么？"><a href="#1-16-ArrayBlockingQueue-take-和-put-都是怎么找到索引位置的？是利用-hash-算法计算得到的么？" class="headerlink" title="1.16 ArrayBlockingQueue take 和 put 都是怎么找到索引位置的？是利用 hash 算法计算得到的么？"></a>1.16 ArrayBlockingQueue take 和 put 都是怎么找到索引位置的？是利用 hash 算法计算得到的么？</h4><p>答：ArrayBlockingQueue 有两个属性，为 takeIndex 和 putIndex，分别标识下次 take 和 put 的位置，每次 take 和 put 完成之后，都会往后加一，虽然底层是数组，但和 HashMap 不同，并不是通过 hash 算法计算得到的。</p>
<h3 id="2-总结"><a href="#2-总结" class="headerlink" title="2 总结"></a>2 总结</h3><p>队列是锁、线程池等复杂 API 的基础，很多面试官都会在问这些 API 时冷不防的问你队列的知识，如果你回答不好，面试官可能会认为你仅仅是用过锁和线程池，但却对其底层的原理和实现了解的不够全面，所以说队列还是蛮重要的，但队列的源码比较复杂，建议大家可以尝试 debug 的方式来理解源码。</p>
<h2 id="24-举一反三：队列在-Java-其它源码中的应用"><a href="#24-举一反三：队列在-Java-其它源码中的应用" class="headerlink" title="24 举一反三：队列在 Java 其它源码中的应用"></a><strong>24 举一反三：队列在 Java 其它源码中的应用</strong></h2><h3 id="引导语-21"><a href="#引导语-21" class="headerlink" title="引导语"></a>引导语</h3><p>队列除了提供 API 供开发者使用外，自身也和 Java 中其他 API 紧密结合，比如线程池和锁，线程池直接使用了队列的 API，锁借鉴了队列的思想，重新实现了队列，线程池和锁都是我们工作中经常使用的 API，也是面试官常问的 API，队列在两者的实现上发挥着至关重要的作用，接下来我们一起来看下。</p>
<h3 id="1-队列和线程池的结合"><a href="#1-队列和线程池的结合" class="headerlink" title="1 队列和线程池的结合"></a>1 队列和线程池的结合</h3><h4 id="1-1-队列在线程池中的作用"><a href="#1-1-队列在线程池中的作用" class="headerlink" title="1.1 队列在线程池中的作用"></a>1.1 队列在线程池中的作用</h4><p>线程池大家应该都使用过，比如我们想新建一个固定大小的线程池，并让运行的线程打印一句话出来，我们会这么写代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// submit 是提交任务的意思</span></span><br><span class="line"><span class="comment">// Thread.currentThread() 得到当前线程</span></span><br><span class="line">executorService.submit(() -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is run&quot;</span>));</span><br><span class="line"><span class="comment">// 打印结果(我们打印出了当前线程的名字)：</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> is run</span><br></pre></td></tr></table></figure>

<p>代码中的 Executors 是并发的工具类，主要是为了帮助我们更方便的构造线程池的，其中 newFixedThreadPool 方法表示会构造出固定大小的线程池，我们给的入参是 10，代表线程池最大可以构造 10 个线程出来。</p>
<p>在实际的工作中，我们对流量的大小是无法控制的，这里我们设定的最大是 10 个线程，但如果一下子来了 100 个请求，这时候 10 个线程肯定是忙不过来了，那么剩余的 90 个请求怎么办呢？</p>
<p>这时候就需要队列出马了，我们会把线程无法消化的数据放到队列中去，让数据在队列中排队，等线程有能力消费了，再从队列中拿出来慢慢去消费。</p>
<p>我们画一个图释义一下：</p>
<p><img src="https://raw.githubusercontent.com/woshiamiaojiang/image-hosting/master/5db11ff30001cf3511460486.png" alt="图片描述"></p>
<p>上图右边表示 10 个线程正在全力消费请求，左边表示剩余请求正在队列中排队，等待消费。</p>
<p>由此可见，队列在线程池中占有很重要的地位，当线程池中的线程忙不过来的时候，请求都可以在队列中等待，从而慢慢地消费。</p>
<p>接下来我们来看下，线程池到底用到了那几种队列类型，分别起的什么作用。</p>
<h4 id="1-2-线程池中使用到的队列的类型"><a href="#1-2-线程池中使用到的队列的类型" class="headerlink" title="1.2 线程池中使用到的队列的类型"></a>1.2 线程池中使用到的队列的类型</h4><h5 id="1-2-1-LinkedBlockingQueue-队列的使用"><a href="#1-2-1-LinkedBlockingQueue-队列的使用" class="headerlink" title="1.2.1 LinkedBlockingQueue 队列的使用"></a>1.2.1 LinkedBlockingQueue 队列的使用</h5><p>刚刚我们说的 newFixedThreadPool 是一种固定大小的线程池，意思是当线程池初始化好后，线程池里面的线程大小是不会变的了（线程池默认设置是不会回收核心线程数的），我们来看下 newFixedThreadPool 的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ThreadPoolExecutor 初始化时，第一个参数表示 coreSize，第二个参数是 maxSize，coreSize == maxSize,</span></span><br><span class="line"><span class="comment">// 表示线程池初始化时，线程大小已固定，所以叫做固定(Fixed)线程池。 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码中可以看到初始化了 ThreadPoolExecutor，ThreadPoolExecutor 是线程池的 API，我们在线程池章节会细说，它的第五个构造参数就是队列，线程池根据场景会选择不同的队列，此处使用的是 LinkedBlockingQueue，并且是默认参数的 Queue，这说明此阻塞队列的最大容量是 Integer 的最大值，也就是说当线程池的处理能力有限时，阻塞队列中最大可以存放 Integer 最大值个任务。</p>
<p>但我们在实际工作中，常常不建议直接使用 newFixedThreadPool，主要是因为其使用的是 LinkedBlockingQueue 的默认构造器，队列容量太大了，在要求实时响应的请求中，队列容量太大往往危害也很大。</p>
<p>比如说我们用上述的线程池，线程 10 个，队列是 Integer 的最大值，当并发流量很大时，比如来了 1w/qps 请求，这时候 10 个线程根本消费不完，就会有很多请求被阻塞在队列中，虽然 10 个线程仍然在不断地消费，但需要消费完队列中的所有数据是需要时间的，假设需要 3 秒才能全部消费完，而这些实时请求都是有超时时间的，默认超时时间是 2 秒，当时间到达 2 秒时，请求已经超时了，返回报错，可这时候队列中的任务还有很多都在等待消费呢，即使后来消费完成，也无法返回给调用方了。</p>
<p>以上情况就会造成，调用方看到接口是超时报错返回的，但服务端的任务其实还在排队执行，过了 3 秒后，服务端的任务可能都会执行成功，但调用方已经无法感知了，调用方再次调用时，就会发现其实这笔请求已经成功了。</p>
<p>如果调用方是从页面发起的，那么体验就会更差，页面上第一次调用页面报错，用户重新刷新页面时，页面显示上次的请求已经成功了，这个就是很不好的体验了。</p>
<p>所以我们希望队列的大小不要设置成那么大，可以根据实际的消费情况来设置队列的大小，这样就可以保证在接口超时前，队列中排队的请求可以执行完。</p>
<p>场景比较复杂，为了方便理解，我们画了一个图，把整个流程释义一下：<br><img src="http://img.mukewang.com/5db120020001e74f15260518.png" alt="图片描述"></p>
<p>这种问题，在实际工作中已经属于非常严重的生产事故了，我们使用时一定要小心。</p>
<p>和 newFixedThreadPool 相同的是，newSingleThreadExecutor 方法底层使用的也是 LinkedBlockingQueue，newSingleThreadExecutor 线程池底层线程只会有一个，这代表着这个线程池一次只能处理一个请求，其余的请求都会在队列中排队等待执行，我们看下 newSingleThreadExecutor 的源码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        <span class="comment">// 前两个参数规定了这个线程池一次只能消费一个线程</span></span><br><span class="line">        <span class="comment">// 第五个参数使用的是 LinkedBlockingQueue,说明当请求超过单线程消费能力时，就会排队</span></span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，底层使用的也是 LinkedBlockingQueue 的默认参数，也就是说排队的最大值是 Integer 的最大值。</p>
<h5 id="1-2-2-SynchronousQueue-队列"><a href="#1-2-2-SynchronousQueue-队列" class="headerlink" title="1.2.2 SynchronousQueue 队列"></a>1.2.2 SynchronousQueue 队列</h5><p>除了 newFixedThreadPool 方法，在线程池新建时，还有其他的几个方法也对应着不同的队列，我们一起来看下 newCachedThreadPool，newCachedThreadPool 底层对应的是 SynchronousQueue 队列，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第五个参数是 SynchronousQueue</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SynchronousQueue 队列是没有大小限制的，请求多少队列都能承受的住，可以说这是他的优点，缺点就是每次往队列里面 put 数据时，并不能立马返回，而是需要等待有线程 take 数据之后，才能正常返回，如果请求量大，而消费能力较差时，就会导致大量请求被 hodler 住，必须等到慢慢消费完成之后才能被释放，所以在平时工作使用中也需要慎重。</p>
<h5 id="1-2-3-DelayedWorkQueue"><a href="#1-2-3-DelayedWorkQueue" class="headerlink" title="1.2.3 DelayedWorkQueue"></a>1.2.3 DelayedWorkQueue</h5><p>newScheduledThreadPool 代表定时任务线程池，底层源码如下：<br><img src="http://img.mukewang.com/5db12015000125e222240760.png" alt="图片描述"></p>
<p>截图从左往右我们可以看到，底层队列使用的是 DelayedWorkQueue 延迟队列，说明线程池底层延时的功能就是 DelayedWorkQueue 队列提供的，新的延迟请求都先到队列中去，延迟时间到了，线程池自然就能从队列中拿出线程进行执行了。</p>
<p>newSingleThreadScheduledExecutor 方法也是和 newScheduledThreadPool 一样的，使用 DelayedWorkQueue 的延迟功能，只不过前者是单个线程执行。</p>
<h4 id="1-3-小结"><a href="#1-3-小结" class="headerlink" title="1.3 小结"></a>1.3 小结</h4><p>从线程池的源码中，我们可以看到：</p>
<ol>
<li>队列在线程池的设计中，起着缓冲数据，延迟执行数据的作用，当线程池消费能力有限时，可以让请求进行排队，让线程池可以慢慢消费。</li>
<li>线程池根据不同的场景，选择使用了 DelayedWorkQueue、SynchronousQueue、LinkedBlockingQueue 多种队列，从而实现自己不同的功能，比如使用 DelayedWorkQueue 的延迟功能来实现定时执行线程池。</li>
</ol>
<h3 id="2-队列和锁的结合"><a href="#2-队列和锁的结合" class="headerlink" title="2 队列和锁的结合"></a>2 队列和锁的结合</h3><p>我们平时写锁代码的时候都这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">  <span class="comment">//throw Exception;</span></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化锁 -&gt; 加锁 -&gt; 执行业务逻辑 -&gt; 释放锁，这是正常的流程，但我们知道同一时刻只能有一个线程才能获得锁的，那么此时其他获取不到锁的线程该怎么办呢？</p>
<p>等待，其他获取不到锁的线程，都会到一个等待队列中去等待，等待锁被释放掉时，再去竞争锁，我们画一个示意图。</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" alt="图片描述"></p>
<p>图中红色标识的就是同步队列，获取不到锁的线程都会到同步队列中去排队，当锁被释放后，同步队列中的线程就又开始去竞争锁。</p>
<p>可以看出队列在锁中起的作用之一，就是帮助管理获取不到锁的线程，让这些线程可以耐心的等待。</p>
<p>同步队列并没有使用现有的队列的 API 去实现，但底层的结构，思想和目前队列是一致的，所以我们学好队列章节，对理解锁的同步队列，用处非常大。</p>
<h3 id="3-总结-3"><a href="#3-总结-3" class="headerlink" title="3 总结"></a>3 总结</h3><p>队列的数据结构真的很重要，在线程池和锁两个重量级 API 中起着非常重要的作用，我们要非常清楚队列底层的大体的数据结构，了解数据是如何入队的，如何出队的，队列这章也是比较复杂的，建议大家多多 debug，我们 github 上也提供了一些 debug 的 demo，大家可以尝试调试起来。</p>
<h2 id="25-整体设计：队列设计思想、工作中使用场景"><a href="#25-整体设计：队列设计思想、工作中使用场景" class="headerlink" title="25 整体设计：队列设计思想、工作中使用场景"></a><strong>25 整体设计：队列设计思想、工作中使用场景</strong></h2><h4 id="引导语-22"><a href="#引导语-22" class="headerlink" title="引导语"></a>引导语</h4><p>本章我们学习了 LinkedBlockingQueue、ArrayBlockingQueue、SynchronousQueue、DelayQueue 四种队列，四种队列底层数据结构各不相同，使用场景也不相同，本章我们从设计思想和使用场景两个大的方向做一些对比和总结。</p>
<h3 id="1-设计思想"><a href="#1-设计思想" class="headerlink" title="1 设计思想"></a>1 设计思想</h3><p>首先我们画出队列的总体设计图：<br><img src="http://img.mukewang.com/5db148170001daa312560972.png" alt="图片描述"></p>
<p>从图中我们可以看出几点：</p>
<ol>
<li>队列解耦了生产者和消费者，提供了生产者和消费者间关系的多种形式，比如 LinkedBlockingQueue、ArrayBlockingQueue 两种队列就把解耦了生产者和消费者，比如 SynchronousQueue 这种就把生产者和消费者相互对应（生产者的消息被消费者开始消费之后，生产者才能返回，为了方便理解，使用相互对应这个词）；</li>
<li>不同的队列有着不同的数据结构，有链表（LinkedBlockingQueue）、数组（ArrayBlockingQueue）、堆栈（SynchronousQueue）等；</li>
<li>不同的数据结构，决定了入队和出队的姿势是不同的。</li>
</ol>
<p>接下来我们分别按照这几个方面来总结分析一下。</p>
<h4 id="1-1-队列的数据结构"><a href="#1-1-队列的数据结构" class="headerlink" title="1.1 队列的数据结构"></a>1.1 队列的数据结构</h4><p>链表结构的队列就是 LinkedBlockingQueue，其特征如下：</p>
<ol>
<li>初始大小默认是 Integer 的最大值，也可以设置初始大小；</li>
<li>链表元素通过 next 属性关联下一个元素；</li>
<li>新增是从链表的尾部新增，拿是从链表头开始拿。</li>
</ol>
<p>数组结构的队列是 ArrayBlockingQueue，特征如下：</p>
<ol>
<li>容量大小是固定的，不能动态扩容；</li>
<li>有 takeIndex 和 putIndex 两个索引记录下次拿和新增的位置；</li>
<li>当 takeIndex 和 putIndex 到达数组的最后一个位置时，下次都是从 0 开始循环。</li>
</ol>
<p>SynchronousQueue 有着两种数据结构，分别是队列和堆栈，特征如下：</p>
<ol>
<li>队列保证了先入先出的数据结构，体现了公平性；</li>
<li>堆栈是先入后出的数据结构，是不公平的，但性能高于先入先出。</li>
</ol>
<h4 id="1-2-入队和出队的方式"><a href="#1-2-入队和出队的方式" class="headerlink" title="1.2 入队和出队的方式"></a>1.2 入队和出队的方式</h4><p>不同的队列有着不同的数据结构，导致其入队和出队的方式也不同：</p>
<ol>
<li>链表是入队是直接追加到队尾，出队是从链表头拿数据；</li>
<li>数组是有 takeIndex 和 putIndex 两个索引位置记录下次拿和取的位置，如总体设计图，入队直接指向了 putIndex，出队指向了 takeIndex；</li>
<li>堆栈主要都是围绕栈头进行入栈和出栈的。</li>
</ol>
<h4 id="1-3-生产者和消费者之间的通信机制"><a href="#1-3-生产者和消费者之间的通信机制" class="headerlink" title="1.3 生产者和消费者之间的通信机制"></a>1.3 生产者和消费者之间的通信机制</h4><p>从四种队列我们可以看出来生产者和消费者之间有两种通信机制，一种是强关联，一种是无关联。</p>
<p>强关联主要是指 SynchronousQueue 队列，生产者往队列中 put 数据，如果这时候没有消费者消费的话，生产者就会一直阻塞住，是无法返回的；消费者来队列里取数据，如果这时候队列中没有数据，消费者也会一直阻塞住，所以 SynchronousQueue 队列模型中，生产者和消费者是强关联的，如果只有其中一方存在，只会阻塞，是无法传递数据的。</p>
<p>无关联主要是说有数据存储功能的队列，比如说 LinkedBlockingQueue 和 ArrayBlockingQueue，只要队列容器不满，生产者就能放成功，生产者就可以直接返回，和有无消费者一点关系都没有，生产者和消费者完全解耦，通过队列容器的储存功能进行解耦。</p>
<h3 id="2-工作中的使用场景"><a href="#2-工作中的使用场景" class="headerlink" title="2 工作中的使用场景"></a>2 工作中的使用场景</h3><p>在日常工作中，我们需要根据队列的特征来匹配业务场景，从而决定使用哪种队列，我们总结下各个队列适合使用的场景：</p>
<h4 id="2-1-LinkedBlockingQueue"><a href="#2-1-LinkedBlockingQueue" class="headerlink" title="2.1 LinkedBlockingQueue"></a>2.1 LinkedBlockingQueue</h4><p>适合对生产的数据大小不定（时高时低），数据量较大的场景，比如说我们在淘宝上买东西，点击下单按钮时，对应着后台的系统叫做下单系统，下单系统会把下单请求都放到一个线程池里面，这时候我们初始化线程池时，一般会选择 LinkedBlockingQueue，并且设置一个合适的大小，此时选择 LinkedBlockingQueue 主要原因在于：在不高于我们设定的阈值内，队列里面的大小可大可小，不会有任何性能损耗，正好符合下单流量的特点，时大时小。</p>
<p>一般工作中，我们大多数都会选择 LinkedBlockingQueue 队列，但会设置 LinkedBlockingQueue 的最大容量，如果初始化时直接使用默认的 Integer 的最大值，当流量很大，而消费者处理能力很差时，大量请求都会在队列中堆积，会大量消耗机器的内存，就会降低机器整体性能甚至引起宕机，一旦宕机，在队列中的数据都会消失，因为队列的数据是保存在内存中的，一旦机器宕机，内存中的数据都会消失的，所以使用 LinkedBlockingQueue 队列时，建议还是要根据日常的流量设置合适的队列的大小。</p>
<h4 id="2-2-ArrayBlockingQueue"><a href="#2-2-ArrayBlockingQueue" class="headerlink" title="2.2 ArrayBlockingQueue"></a>2.2 ArrayBlockingQueue</h4><p>一般用于生产数据固定的场景，比如说系统每天会进行对账，对账完成之后，会固定的产生 100 条对账结果，因为对账结果固定，我们就可以使用 ArrayBlockingQueue 队列，大小可以设置成 100。</p>
<h4 id="2-3-DelayQueue"><a href="#2-3-DelayQueue" class="headerlink" title="2.3 DelayQueue"></a>2.3 DelayQueue</h4><p>延迟队列，在工作中经常遇到，主要用于任务不想立马执行，想等待一段时间才执行的场景。</p>
<p>比如说延迟对账，我们在工作中曾经遇到过这样的场景：我们在淘宝上买东西，弹出支付宝付款页面，在我们输入指纹的瞬间，流程主要是前端 -》交易后端 -》支付后端，交易后端调用支付后端主要是为了把我们支付宝的钱划给商家，而交易调用支付的过程中，有小概率的情况，因为网络抖动会发生超时的情况，这时候就需要通过及时的对账来解决这个事情（对账只是解决这个问题的手段之一），我们简单画一个流程图：<br><img src="http://img.mukewang.com/5db1482c0001d1fd11880618.png" alt="图片描述"></p>
<p>这是一个真实场景，为了方便描述，已经大大简化了，再说明几点：</p>
<ol>
<li>交易调用支付的接口，这个接口的作用就是为了把小美的 800 元转给商家小明；</li>
<li>接口调用超时，此时交易系统并不知道 800 有没有成功转给小明，当然想知道的方式有很多，我们选择了对账的方式，对账的目的就是为了知道当前 800 元有没有成功转给小明；</li>
<li>延迟对账的目的，因为支付系统把 800 元转给商家小明也是需要时间的，如果超时之后立马对账，可能转账的动作还在进行中，导致对账的结果不准确，所以需要延迟几秒后再去对账；</li>
<li>对账之后的结果有几种，比如已经成功的把 800 元转给小明了，这时候需要把对账结果告诉交易系统，交易系统更新数据，前端就能够显示转账成功了。</li>
</ol>
<p>在这个案列中，延迟对账的核心技术就是 DelayQueue，我们大概这么做的：新建对账任务，设置 3 秒之后执行，把任务放到 DelayQueue 中，过了 3 秒之后，就会自动执行对账任务了。</p>
<p>DelayQueue 延迟执行的功能就在这个场景中得到应用。</p>
<h3 id="3-总结-4"><a href="#3-总结-4" class="headerlink" title="3 总结"></a>3 总结</h3><p>我们不会为了阅读源码而读源码，我们读源码的最初目的，是为了提高我们的技术深度，最终目的是为了在不同的场景中，能够选择合适的技术进行落地，本章中解释的一些队列的场景，我们在工作中其实都会遇到，特别是在使用线程池时，使用哪种队列是我们必须思考的一个问题，所以本章先比较了各个队列的适合使用场景，然后举了几个案列进行具体分析，希望大家也能把技术具体落地到实际工作中，使技术推动、辅助业务。</p>
<h2 id="26-惊叹面试官：由浅入深手写队列"><a href="#26-惊叹面试官：由浅入深手写队列" class="headerlink" title="26 惊叹面试官：由浅入深手写队列"></a><strong>26 惊叹面试官：由浅入深手写队列</strong></h2><h3 id="引导语-23"><a href="#引导语-23" class="headerlink" title="引导语"></a>引导语</h3><p>现在不少大厂面试的时候会要求手写代码，我曾经看过一个大厂面试时，要求在线写代码，题目就是：在不使用 Java 现有队列 API 的情况下，手写出一个队列的实现出来，队列的数据结构，入队和出队方式都自己定义。</p>
<p>这题其实考察的有几个点：</p>
<ol>
<li>考察你对队列的内部结构熟不熟悉；</li>
<li>考察你定义 API 的功底；</li>
<li>考察写代码的基本功，代码风格。</li>
</ol>
<p>本章就和大家一起，结合以上几点，手写一个队列出来，一起来熟悉一下思路和过程，完整队列代码见：demo.four.DIYQueue 和 demo.four.DIYQueueDemo</p>
<h3 id="1-接口定义"><a href="#1-接口定义" class="headerlink" title="1 接口定义"></a>1 接口定义</h3><p>在实现队列之前，我们首先需要定义出队列的接口，就是我们常说的 API，API 是我们队列的门面，定义时主要原则就是简单和好用。</p>
<p>我们这次实现的队列只定义放数据和拿数据两个功能，接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 定义队列的接口，定义泛型，可以让使用者放任意类型到队列中去</span></span><br><span class="line"><span class="comment">* author  wenhe</span></span><br><span class="line"><span class="comment">* date 2019/9/1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 放数据</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> item 入参</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> true 成功、false 失败</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">put</span><span class="params">(T item)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 拿数据，返回一个泛型值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">T <span class="title">take</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 队列中元素的基本结构</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 数据本身</span></span><br><span class="line">    T item;</span><br><span class="line">    <span class="comment">// 下一个元素</span></span><br><span class="line">    Node&lt;T&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.item = item;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有几点我们说明下：</p>
<ol>
<li>定义接口时，一定要写注释，接口的注释，方法的注释等等，这样别人看我们的接口时，会轻松很多‘；</li>
<li>定义接口时，要求命名简洁明了，最好让别人一看见命名就知道这个接口是干啥的，比如我们命名为 Queue，别人一看就清楚这个接口是和队列相关的；</li>
<li>用好泛型，因为我们不清楚放进队列中的到底都是那些值，所以我们使用了泛型 T，表示可以在队列中放任何值；</li>
<li>接口里面无需给方法写上 public 方法，因为接口中的方法默认都是 public 的，你写上编译器也会置灰，如下图：<br><img src="http://img.mukewang.com/5db14faa0001928904140484.png" alt="图片描述"></li>
<li>我们在接口中定义了基础的元素 Node，这样队列子类如果想用的话，可以直接使用，增加了复用的可能性。</li>
</ol>
<h3 id="2-队列子类实现"><a href="#2-队列子类实现" class="headerlink" title="2 队列子类实现"></a>2 队列子类实现</h3><p>接着我们就要开始写子类实现了，我们准备写个最常用的链表数据结构的队列。</p>
<h4 id="2-1-数据结构"><a href="#2-1-数据结构" class="headerlink" title="2.1 数据结构"></a>2.1 数据结构</h4><p>底层数据结构我们采用链表，一说到链表，大家应该马上就会想到三个关键要素：链表头、链表尾和链表元素，我们也实现了，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 队列头</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Node&lt;T&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 队列尾</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Node&lt;T&gt; tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义队列元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DIYNode</span> <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DIYNode</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(item);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了这些元素之外，我们还有队列容器的容量大小、队列目前的使用大小、放数据锁、拿数据锁等等，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 队列的大小，使用 AtomicInteger 来保证其线程安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> AtomicInteger size = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Integer capacity;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 放数据锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拿数据锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br></pre></td></tr></table></figure>



<h4 id="2-2-初始化"><a href="#2-2-初始化" class="headerlink" title="2.2 初始化"></a>2.2 初始化</h4><p>我们提供了使用默认容量（Integer 的最大值）和指定容量两种方式，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参数构造器，默认最大容量是 Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DIYQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  capacity = Integer.MAX_VALUE;</span><br><span class="line">  head = tail = <span class="keyword">new</span> DIYNode(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有参数构造器，可以设定容量的大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacity</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DIYQueue</span><span class="params">(Integer capacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 进行边界的校验</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">null</span> == capacity || capacity &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">  head = tail = <span class="keyword">new</span> DIYNode(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-3-put-方法的实现"><a href="#2-3-put-方法的实现" class="headerlink" title="2.3 put 方法的实现"></a>2.3 put 方法的实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 禁止空数据</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">null</span> == item)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 尝试加锁，500 毫秒未获得锁直接被打断</span></span><br><span class="line">    <span class="keyword">boolean</span> lockSuccess = putLock.tryLock(<span class="number">300</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">	<span class="keyword">if</span>(!lockSuccess)&#123;</span><br><span class="line">	  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 校验队列大小</span></span><br><span class="line">    <span class="keyword">if</span>(size.get() &gt;= capacity)&#123;</span><br><span class="line">      log.info(<span class="string">&quot;queue is full&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 追加到队尾</span></span><br><span class="line">    tail = tail.next = <span class="keyword">new</span> DIYNode(item);</span><br><span class="line">    <span class="comment">// 计数</span></span><br><span class="line">    size.incrementAndGet();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">    log.info(<span class="string">&quot;tryLock 500 timeOut&quot;</span>, e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    log.error(<span class="string">&quot;put error&quot;</span>, e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    putLock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>put 方法的实现有几点我们需要注意的是：</p>
<ol>
<li>注意 try catch finally 的节奏，catch 可以捕捉多种类型的异常，我们这里就捕捉了超时异常和未知异常，在 finally 里面一定记得要释放锁，不然锁不会自动释放的，这个一定不能用错，体现了我们代码的准确性；</li>
<li>必要的逻辑检查还是需要的，比如入参是否为空的空指针检查，队列是否满的临界检查，这些检查代码可以体现出我们逻辑的严密性；</li>
<li>在代码的关键地方加上日志和注释，这点也是非常重要的，我们不希望关键逻辑代码注释和日志都没有，不利于阅读代码和排查问题；</li>
<li>注意线程安全，此处实现我们除了加锁之外，对于容量的大小（size）我们选择线程安全的计数类：AtomicInteger，来保证了线程安全；</li>
<li>加锁的时候，我们最好不要使用永远阻塞的方法，我们一定要用带有超时时间的阻塞方法，此处我们设置的超时时间是 300 毫秒，也就是说如果 300 毫秒内还没有获得锁，put 方法直接返回 false，当然时间大小你可以根据情况进行设置；</li>
<li>根据不同的情况设置不同的返回值，put 方法返回的是 false，在发生异常时，我们可以选择返回 false，或者直接抛出异常；</li>
<li>put 数据时追加到队尾的，所以我们只需要把新数据转化成 DIYNode，放到队列的尾部即可。</li>
</ol>
<h4 id="2-4-take-方法的实现"><a href="#2-4-take-方法的实现" class="headerlink" title="2.4 take 方法的实现"></a>2.4 take 方法的实现</h4><p>take 方法和 put 方法的实现非常类似，只不过 take 是从头部拿取数据，代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">take</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 队列是空的，返回 null</span></span><br><span class="line">  <span class="keyword">if</span>(size.get() == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 拿数据我们设置的超时时间更短</span></span><br><span class="line">    <span class="keyword">boolean</span> lockSuccess = takeLock.tryLock(<span class="number">200</span>,TimeUnit.MILLISECONDS);</span><br><span class="line">	<span class="keyword">if</span>(!lockSuccess)&#123;</span><br><span class="line">	    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;加锁失败&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 把头结点的下一个元素拿出来</span></span><br><span class="line">    Node expectHead = head.next;</span><br><span class="line">    <span class="comment">// 把头结点的值拿出来</span></span><br><span class="line">    T result = head.item;</span><br><span class="line">    <span class="comment">// 把头结点的值置为 null，帮助 gc</span></span><br><span class="line">    head.item = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 重新设置头结点的值</span></span><br><span class="line">    head = (DIYNode) expectHead;</span><br><span class="line">    size.decrementAndGet();</span><br><span class="line">    <span class="comment">// 返回头结点的值</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    log.info(<span class="string">&quot; tryLock 200 timeOut&quot;</span>,e);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.info(<span class="string">&quot; take error &quot;</span>,e);</span><br><span class="line">  &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">      takeLock.unlock();</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上几步，我们的队列已经写完了，完整代码见：demo.four.DIYQueue。</p>
<h3 id="3-测试"><a href="#3-测试" class="headerlink" title="3 测试"></a>3 测试</h3><p>API 写好了，接下来我们要针对 API 写一些场景测试和单元测试，我们先写个场景测试，看看 API 能否跑通，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DIYQueueDemo</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 我们需要测试的队列</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Queue&lt;String&gt; queue = <span class="keyword">new</span> DIYQueue&lt;&gt;();</span><br><span class="line">	<span class="comment">// 生产者</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Product</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Product</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> success = queue.put(message);</span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">          log.info(<span class="string">&quot;put &#123;&#125; success&quot;</span>, message);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;put &#123;&#125; fail&quot;</span>, message);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;put &#123;&#125; fail&quot;</span>, message);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// 消费者</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        String message = (String) queue.take();</span><br><span class="line">        log.info(<span class="string">&quot;consumer message :&#123;&#125;&quot;</span>,message);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;consumer message fail&quot;</span>,e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// 场景测试</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDIYQueue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor executor =</span><br><span class="line">        <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>,<span class="number">10</span>,<span class="number">0</span>,TimeUnit.MILLISECONDS,</span><br><span class="line">                               <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 是偶数的话，就提交一个生产者，奇数的话提交一个消费者</span></span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">          executor.submit(<span class="keyword">new</span> Product(i+<span class="string">&quot;&quot;</span>));</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        executor.submit(<span class="keyword">new</span> Consumer());</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>代码测试的场景比较简单，从 0 开始循环到 1000，如果是偶数，就让生产者去生产数据，并放到队列中，如果是奇数，就让消费者去队列中拿数据出来进行消费，运行之后的结果如下：</p>
<p><img src="http://img.mukewang.com/5db14fc70001617f08660711.png" alt="图片描述"><br>从显示的结果来看，咱们写的 DIYQueue 没有太大的问题，当然如果想大规模的使用，还需要详细的单元测试和性能测试。</p>
<h3 id="4-总结-3"><a href="#4-总结-3" class="headerlink" title="4 总结"></a>4 总结</h3><p>通过本章的学习，不知道你有没有一种队列很简单的感觉，其实队列本身就很简单，没有想象的那么复杂。</p>
<p>只要我们懂得了队列的基本原理，清楚几种常用的数据结构，手写队列问题其实并不大，你也赶紧来试一试吧。</p>
<h1 id="第5章-线程"><a href="#第5章-线程" class="headerlink" title="第5章 线程"></a><strong>第5章 线程</strong></h1><h2 id="27-Thread-源码解析"><a href="#27-Thread-源码解析" class="headerlink" title="27 Thread 源码解析"></a><strong>27 Thread 源码解析</strong></h2><h3 id="引导语-24"><a href="#引导语-24" class="headerlink" title="引导语"></a>引导语</h3><p>从本章开始我们开始学习线程的知识，线程是非常有趣的一个章节，大多数同学对于线程 API，属于不用就忘，到用时需要百度的情况，希望通过本小节的源码阅读，能够加深对线程的印象。</p>
<p>本小节主要三章，本章主要说线程的基本概念、使用姿势、Thread 和 Runnable 的源码；Future、ExecutorService 源码解析章节主要说异步线程执行；押宝线程源码面试题章节主要说说常遇到的源码面试题。</p>
<p>由于线程的概念很多，所以本章会先介绍很多线程的基本概念，说清楚后再解析源码，不然有些同学会看不懂，大家见谅。</p>
<h3 id="1-类注释-1"><a href="#1-类注释-1" class="headerlink" title="1 类注释"></a>1 类注释</h3><h4 id="1-1-Thread"><a href="#1-1-Thread" class="headerlink" title="1.1 Thread"></a>1.1 Thread</h4><ol>
<li><p>每个线程都有优先级，高优先级的线程可能会优先执行；</p>
</li>
<li><p>父线程创建子线程后，优先级、是否是守护线程等属性父子线程是一致的；</p>
</li>
<li><p>JVM 启动时，通常都启动 MAIN 非守护线程，以下任意一个情况发生时，线程就会停止：</p>
<p>退出方法被调用，并且安全机制允许这么做（比如调用 Thread.interrupt 方法）；</p>
<p>所有非守护线程都消亡，或者从运行的方法正常返回，或者运行的方法抛出了异常；</p>
</li>
<li><p>每个线程都有名字，多个线程可能具有相同的名字，Thread 有的构造器如果没有指定名字，会自动生成一个名字。</p>
</li>
</ol>
<h3 id="2-线程的基本概念"><a href="#2-线程的基本概念" class="headerlink" title="2 线程的基本概念"></a>2 线程的基本概念</h3><p>我们接下来介绍一下线程的基本概念：</p>
<h4 id="2-1-线程的状态"><a href="#2-1-线程的状态" class="headerlink" title="2.1 线程的状态"></a>2.1 线程的状态</h4><p>网上有各种介绍线程状态的文章，我们这里说线程的状态是从源码的角度，源码中一共列举了六种状态，如下图：<br><img src="http://img.mukewang.com/5db92718000105e912540550.png" alt="图片描述"></p>
<p>我们解析一下这个图：</p>
<ol>
<li>NEW 表示线程创建成功，但没有运行，在 new Thread 之后，没有 start 之前，线程的状态都是 NEW；</li>
<li>当我们运行 strat 方法，子线程被创建成功之后，子线程的状态变成 RUNNABLE，RUNNABLE 表示线程正在运行中；</li>
<li>子线程运行完成、被打断、被中止，状态都会从 RUNNABLE 变成 TERMINATED，TERMINATED 表示线程已经运行结束了；</li>
<li>如果线程正好在等待获得 monitor lock 锁，比如在等待进入 synchronized 修饰的代码块或方法时，会从 RUNNABLE 变成 BLOCKED，BLOCKED 表示阻塞的意思；</li>
<li>WAITING 和 TIMED_WAITING 类似，都表示在遇到 Object#wait、Thread#join、LockSupport#park 这些方法时，线程就会等待另一个线程执行完特定的动作之后，才能结束等待，只不过 TIMED_WAITING 是带有等待时间的（可以看下面的 join 方法的 demo）。</li>
</ol>
<p>再次重申，这 6 种状态并不是线程所有的状态，只是在 Java 源码中列举出的 6 种状态， Java 线程的处理方法都是围绕这 6 种状态的。</p>
<h4 id="2-2-优先级"><a href="#2-2-优先级" class="headerlink" title="2.2 优先级"></a>2.2 优先级</h4><p>优先级代表线程执行的机会的大小，优先级高的可能先执行，低的可能后执行，在 Java 源码中，优先级从低到高分别是 1 到 10，线程默认 new 出来的优先级都是 5，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最低优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通优先级，也是默认的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>



<h4 id="2-3-守护线程"><a href="#2-3-守护线程" class="headerlink" title="2.3 守护线程"></a>2.3 守护线程</h4><p>我们默认创建的线程都是非守护线程。创建守护线程时，需要将 Thread 的 daemon 属性设置成 true，守护线程的优先级很低，当 JVM 退出时，是不关心有无守护线程的，即使还有很多守护线程，JVM 仍然会退出，我们在工作中，可能会写一些工具做一些监控的工作，这时我们都是用守护子线程去做，这样即使监控抛出异常，但因为是子线程，所以也不会影响到业务主线程，因为是守护线程，所以 JVM 也无需关注监控是否正在运行，该退出就退出，所以对业务不会产生任何影响。</p>
<h4 id="2-4-ClassLoader"><a href="#2-4-ClassLoader" class="headerlink" title="2.4 ClassLoader"></a>2.4 ClassLoader</h4><p>ClassLoader 我们可以简单理解成类加载器，就是把类从文件、二进制数组、URL 等位置加载成可运行 Class。</p>
<h3 id="3-线程两种初始化方式"><a href="#3-线程两种初始化方式" class="headerlink" title="3 线程两种初始化方式"></a>3 线程两种初始化方式</h3><p>无返回值的线程主要有两种初始化方式：</p>
<h4 id="3-1-继承-Thread，成为-Thread-的子类"><a href="#3-1-继承-Thread，成为-Thread-的子类" class="headerlink" title="3.1 继承 Thread，成为 Thread 的子类"></a>3.1 继承 Thread，成为 Thread 的子类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继承 Thread，实现其 run 方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(Thread.currentThread().getName());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">// 调用 start 方法即可，会自动调用到 run 方法的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extendThreadInit</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">new</span> MyThread().start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码打印出的线程名称是：Thread-0，而主线程的名字是：Thread [main,5,main]，由此可见，的确是开了一个子线程来执行打印的操作。</p>
<p>我们一起来看下 start 的底层源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该方法可以创建一个新的线程出来</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果没有初始化，抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">    group.add(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// started 是个标识符，我们在做一些事情的时候，经常这么写</span></span><br><span class="line">    <span class="comment">// 动作发生之前标识符是 false，发生完成之后变成 true</span></span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这里会创建一个新的线程，执行完成之后，新的线程已经在运行了，既 target 的内容已经在运行了</span></span><br><span class="line">        start0();</span><br><span class="line">        <span class="comment">// 这里执行的还是主线程</span></span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果失败，把线程从线程组中删除</span></span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         <span class="comment">// Throwable 可以捕捉一些 Exception 捕捉不到的异常，比如说子线程抛出的异常</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">              it will be passed up the call stack */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 开启新线程使用的是 native 方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>



<h4 id="3-2-实现-Runnable-接口，作为-Thread-的入参"><a href="#3-2-实现-Runnable-接口，作为-Thread-的入参" class="headerlink" title="3.2 实现 Runnable 接口，作为 Thread 的入参"></a>3.2 实现 Runnable 接口，作为 Thread 的入参</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125; begin run&quot;</span>,Thread.currentThread().getName());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 开一个子线程去执行</span></span><br><span class="line">thread.start();</span><br><span class="line"><span class="comment">// 不会新起线程，是在当前主线程上继续运行</span></span><br><span class="line">thread.run();</span><br></pre></td></tr></table></figure>

<p>这种就是实现 Runnable 的接口，并作为 Thread 构造器的入参，我们调用时使用了两种方式，可以根据情况选择使用 start 或 run 方法，使用 start 会开启子线程来执行 run 里面的内容，使用 run 方法执行的还是主线程。</p>
<p>我们来看下 run 方法的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单的运行，不会新起线程，target 是 Runnable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码中的 target 就是在 new Thread 时，赋值的 Runnable。</p>
<h3 id="4-线程初始化"><a href="#4-线程初始化" class="headerlink" title="4 线程初始化"></a>4 线程初始化</h3><p>线程初始化的源码有点长，我们只看比较重要的代码 (不重要的被我删掉了)，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无参构造器，线程名字自动生成</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// g 代表线程组，线程组可以对组内的线程进行批量的操作，比如批量的打断 interrupt</span></span><br><span class="line"><span class="comment">// target 是我们要运行的对象</span></span><br><span class="line"><span class="comment">// name 我们可以自己传，如果不传默认是 &quot;Thread-&quot; + nextThreadNum()，nextThreadNum 方法返回的是自增的数字</span></span><br><span class="line"><span class="comment">// stackSize 可以设置堆栈的大小</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">long</span> stackSize, AccessControlContext acc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;name cannot be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = name.toCharArray();</span><br><span class="line">    <span class="comment">// 当前线程作为父线程</span></span><br><span class="line">    Thread parent = currentThread();</span><br><span class="line">    <span class="keyword">this</span>.group = g;</span><br><span class="line">    <span class="comment">// 子线程会继承父线程的守护属性</span></span><br><span class="line">    <span class="keyword">this</span>.daemon = parent.isDaemon();</span><br><span class="line">    <span class="comment">// 子线程继承父线程的优先级属性</span></span><br><span class="line">    <span class="keyword">this</span>.priority = parent.getPriority();</span><br><span class="line">    <span class="comment">// classLoader</span></span><br><span class="line">    <span class="keyword">if</span> (security == <span class="keyword">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">    <span class="keyword">this</span>.inheritedAccessControlContext =</span><br><span class="line">            acc != <span class="keyword">null</span> ? acc : AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">    setPriority(priority);</span><br><span class="line">    <span class="comment">// 当父线程的 inheritableThreadLocals 的属性值不为空时</span></span><br><span class="line">    <span class="comment">// 会把 inheritableThreadLocals 里面的值全部传递给子线程</span></span><br><span class="line">    <span class="keyword">if</span> (parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line">    <span class="comment">/* Set thread ID */</span></span><br><span class="line">    <span class="comment">// 线程 id 自增</span></span><br><span class="line">    tid = nextThreadID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从初始化源码中可以看到，很多属性，子线程都是直接继承父线程的，包括优先性、守护线程、inheritableThreadLocals 里面的值等等。</p>
<h3 id="5-线程其他操作"><a href="#5-线程其他操作" class="headerlink" title="5 线程其他操作"></a>5 线程其他操作</h3><h4 id="5-1-join"><a href="#5-1-join" class="headerlink" title="5.1 join"></a>5.1 join</h4><p>join 的意思就是当前线程等待另一个线程执行完成之后，才能继续操作，我们写了一个 demo，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  Thread main = Thread.currentThread();</span><br><span class="line">  log.info(<span class="string">&quot;&#123;&#125; is run。&quot;</span>,main.getName());</span><br><span class="line">  Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      log.info(<span class="string">&quot;&#123;&#125; begin run&quot;</span>,Thread.currentThread().getName());</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">30000L</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      log.info(<span class="string">&quot;&#123;&#125; end run&quot;</span>,Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 开一个子线程去执行</span></span><br><span class="line">  thread.start();</span><br><span class="line">  <span class="comment">// 当前主线程等待子线程执行完成之后再执行</span></span><br><span class="line">  thread.join();</span><br><span class="line">  log.info(<span class="string">&quot;&#123;&#125; is end&quot;</span>, Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行的结果，就是主线程在执行 thread.join (); 代码后会停住，会等待子线程沉睡 30 秒后再执行，这里的 join 的作用就是让主线程等待子线程执行完成，我们画一个图示意一下：<br><img src="http://img.mukewang.com/5db927370001f7e411520448.png" alt="图片描述"></p>
<p>从图中可以看出，主线程一直等待子线程沉睡 30s 后才继续执行，在等待期间，主线程的状态也是 TIMED_WAITING。</p>
<h4 id="5-2-yield"><a href="#5-2-yield" class="headerlink" title="5.2 yield"></a>5.2 yield</h4><p>yield 是个 native 方法，底层代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>意思是当前线程做出让步，放弃当前 cpu，让 cpu 重新选择线程，避免线程过度使用 cpu，我们在写 while 死循环的时候，预计短时间内 while 死循环可以结束的话，可以在循环里面使用 yield 方法，防止 cpu 一直被 while 死循环霸占。</p>
<p>有点需要说明的是，让步不是绝不执行，重新竞争时，cpu 也有可能重新选中自己。</p>
<h4 id="5-3-sleep"><a href="#5-3-sleep" class="headerlink" title="5.3 sleep"></a>5.3 sleep</h4><p>sleep 也是 native 方法，可以接受毫秒的一个入参，也可以接受毫秒和纳秒的两个入参，意思是当前线程会沉睡多久，沉睡时不会释放锁资源，所以沉睡时，其它线程是无法得到锁的。</p>
<p>接受毫秒和纳秒两个入参时，如果给定纳秒大于等于 0.5 毫秒，算一个毫秒，否则不算。</p>
<h4 id="5-4-interrupt"><a href="#5-4-interrupt" class="headerlink" title="5.4 interrupt"></a>5.4 interrupt</h4><p>interrupt 中文是打断的意思，意思是可以打断中止正在运行的线程，比如：</p>
<ol>
<li>Object#wait ()、Thread#join ()、Thread#sleep (long) 这些方法运行后，线程的状态是 WAITING 或 TIMED_WAITING，这时候打断这些线程，就会抛出 InterruptedException 异常，使线程的状态直接到 TERMINATED；</li>
<li>如果 I/O 操作被阻塞了，我们主动打断当前线程，连接会被关闭，并抛出 ClosedByInterruptException 异常；</li>
</ol>
<p>我们举一个例子来说明如何打断 WAITING 的线程，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInterrupt</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      log.info(<span class="string">&quot;&#123;&#125; begin run&quot;</span>,Thread.currentThread().getName());</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;子线程开始沉睡 30 s&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">30000L</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;子线程被打断&quot;</span>);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      log.info(<span class="string">&quot;&#123;&#125; end run&quot;</span>,Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 开一个子线程去执行</span></span><br><span class="line">  thread.start();</span><br><span class="line">  Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">  log.info(<span class="string">&quot;主线程等待 1s 后，发现子线程还没有运行成功，打断子线程&quot;</span>);</span><br><span class="line">  thread.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子主要说的是，主线程会等待子线程执行 1s，如果 1s 内子线程还没有执行完，就会打断子线程，子线程被打断后，会抛出 InterruptedException 异常，执行结束，运行的结果如下图：</p>
<p><img src="http://img.mukewang.com/5db9274b0001eb9718840506.png" alt="图片描述"></p>
<h3 id="6-总结-2"><a href="#6-总结-2" class="headerlink" title="6 总结"></a>6 总结</h3><p>本章主要介绍了线程的基本概念、状态、无返回值线程的初始化方式和线程的常用操作，这些知识也是工作中常用的，也是大家都必须了解的，为后面的学习打下基础。</p>
<h2 id="28-Future、ExecutorService-源码解析"><a href="#28-Future、ExecutorService-源码解析" class="headerlink" title="28 Future、ExecutorService 源码解析"></a><strong>28 Future、ExecutorService 源码解析</strong></h2><h3 id="引导语-25"><a href="#引导语-25" class="headerlink" title="引导语"></a>引导语</h3><p>本章和大家一起看下有返回值的线程如何创建，两种线程 API 之间如何关联，介绍一下和线程相关的其余 API。</p>
<h3 id="1-整体架构-7"><a href="#1-整体架构-7" class="headerlink" title="1 整体架构"></a>1 整体架构</h3><p>画了一个关于线程 API 之间关系的依赖图，如下：<br><img src="http://img.mukewang.com/5db928f50001c19520623172.png" alt="图片描述"></p>
<p>在上一章节，我们说了 Thread 和 Runnable，本小节我们按照这个图把剩下的几个 API 也说完，然后把 API 之间的关系理清楚。</p>
<p>为了方便大家更好的理解，我们首先看一个 demo，这个场景说的是我们往线程池里面提交一个有返回值的线程，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先我们创建了一个线程池</span></span><br><span class="line">ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">3</span>, <span class="number">3</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                                     <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;());</span><br><span class="line"><span class="comment">// futureTask 我们叫做线程任务，构造器的入参是 Callable</span></span><br><span class="line">FutureTask futureTask = <span class="keyword">new</span> FutureTask(<span class="keyword">new</span> Callable&lt;String&gt; () &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    <span class="comment">// 返回一句话</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;我是子线程&quot;</span>+Thread.currentThread().getName();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 把任务提交到线程池中，线程池会分配线程帮我们执行任务</span></span><br><span class="line">executor.submit(futureTask);</span><br><span class="line"><span class="comment">// 得到任务执行的结果</span></span><br><span class="line">String result = (String) futureTask.get();</span><br><span class="line">log.info(<span class="string">&quot;result is &#123;&#125;&quot;</span>,result);</span><br></pre></td></tr></table></figure>

<p>从上面这个 demo 中，我们大概可以看出各个 API 的作用：</p>
<ol>
<li>Callable 定义我们需要做的事情，是可以有返回值的；</li>
<li>FutureTask 我们叫做任务，入参是 Callable，是对 Callable 的包装，方便线程池的使用；</li>
<li>最后通过 FutureTask.get() 得到子线程的计算结果。</li>
</ol>
<p>接着我们分别来看看各种 API 的底层实现。</p>
<h3 id="2-Callable"><a href="#2-Callable" class="headerlink" title="2 Callable"></a>2 Callable</h3><p>Callable 是一个接口，约定了线程要做的事情，和 Runnable 一样，不过这个线程任务是有返回值的，我们来看下接口定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回值是一个泛型，可以定义成任何类型，但我们使用的时候，都不会直接使用 Callable，而是会结合 FutureTask 一起使用。</p>
<h3 id="3-FutureTask"><a href="#3-FutureTask" class="headerlink" title="3 FutureTask"></a>3 FutureTask</h3><p>FutureTask 我们可以当做是线程运行的具体任务，从上图中，我们可以看到 FutureTask 实现了 RunnableFuture 接口，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 RunnableFuture 又实现了 Runnable, Future 两个接口，接下来我们先看 Future，再看 RunnableFuture，最后看 FutureTask。</p>
<h4 id="3-1-Future"><a href="#3-1-Future" class="headerlink" title="3.1 Future"></a>3.1 Future</h4><p>我们刚才说 Callable 是可以返回子线程执行结果的，在获取结果的时候，就需要用到 Future 接口了。</p>
<p>Future 接口注释上写了这些：</p>
<ol>
<li>定义了异步计算的接口，提供了计算是否完成的 check、等待完成和取回等多种方法；</li>
<li>如果想得到结果可以使用 get 方法，此方法(无参方法)会一直阻塞到异步任务计算完成；</li>
<li>取消可以使用 cancel 方法，但一旦任务计算完成，就无法被取消了。</li>
</ol>
<p>Future 接口定义了这些方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果任务已经成功了，或已经取消了，是无法再取消的，会直接返回取消成功(true)</span></span><br><span class="line"><span class="comment">// 如果任务还没有开始进行时，发起取消，是可以取消成功的。</span></span><br><span class="line"><span class="comment">// 如果取消时，任务已经在运行了，mayInterruptIfRunning 为 true 的话，就可以打断运行中的线程</span></span><br><span class="line"><span class="comment">// mayInterruptIfRunning 为 false，表示不能打断直接返回</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回线程是否已经被取消了，true 表示已经被取消了</span></span><br><span class="line"><span class="comment">// 如果线程已经运行结束了，isCancelled 和 isDone 返回的都是 true</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程是否已经运行结束了</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待结果返回</span></span><br><span class="line"><span class="comment">// 如果任务被取消了，抛 CancellationException 异常</span></span><br><span class="line"><span class="comment">// 如果等待过程中被打断了，抛 InterruptedException 异常</span></span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待，但是带有超时时间的，如果超时时间外仍然没有响应，抛 TimeoutException 异常</span></span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br></pre></td></tr></table></figure>

<p>从接口上可以看出，Future 定义了各种方法对任务进行了管理，比如说取消任务，得到任务的计算结果等等。</p>
<h4 id="3-2-RunnableFuture"><a href="#3-2-RunnableFuture" class="headerlink" title="3.2 RunnableFuture"></a>3.2 RunnableFuture</h4><p>RunnableFuture 也是一个接口，定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RunnableFuture 接口的最大目的，是让 Future 可以对 Runnable 进行管理，可以取消 Runnable，查看 Runnable 是否完成等等。</p>
<h4 id="3-3-统一-Callable-和-Runnable"><a href="#3-3-统一-Callable-和-Runnable" class="headerlink" title="3.3 统一 Callable 和 Runnable"></a>3.3 统一 Callable 和 Runnable</h4><p>我们现在清楚了，新建任务有两种方式，一种是无返回值的 Runnable，一种是有返回值的 Callable，但对 Java 其他 API 来说使用起来并不是很方便，没有一个统一的接口，比如说线程池在提交任务时，是不是应该针对 Runnable 和 Callable 两种情况提供不同的实现思路呢？所以 FutureTask 出现了，FutureTask 实现了 RunnableFuture 接口，又集合了 Callable（Callable 是 FutureTask 的属性），还提供了两者一系列的转化方法，这样 FutureTask 就统一了 Callable 和 Runnable，我们一起来细看下。</p>
<h5 id="3-3-1-FutureTask-的类定义"><a href="#3-3-1-FutureTask-的类定义" class="headerlink" title="3.3.1 FutureTask 的类定义"></a>3.3.1 FutureTask 的类定义</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>从类定义上可以看出来 FutureTask 实现了 RunnableFuture 接口，也就是说间接实现了 Runnnable 接口（RunnableFuture 实现了 Runnnable 接口），就是说 FutureTask 本身就是个 Runnnable，同时 FutureTask 也实现了 Future，也就是说 FutureTask 具备对任务进行管理的功能（Future 具备对任务进行管理的功能）。</p>
<h5 id="3-3-2-FutureTask-的属性"><a href="#3-3-2-FutureTask-的属性" class="headerlink" title="3.3.2 FutureTask 的属性"></a>3.3.2 FutureTask 的属性</h5><p>我们一起来看下 FutureTask 有哪些重要属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 任务状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;<span class="comment">//线程任务创建</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;<span class="comment">//任务执行中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;<span class="comment">//任务执行结束</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;<span class="comment">//任务异常</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;<span class="comment">//任务取消成功</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;<span class="comment">//任务正在被打断中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;<span class="comment">//任务被打断成功</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合了 Callable </span></span><br><span class="line"><span class="keyword">private</span> Callable&lt;V&gt; callable;</span><br><span class="line"><span class="comment">// 异步线程返回的结果</span></span><br><span class="line"><span class="keyword">private</span> Object outcome; </span><br><span class="line"><span class="comment">// 当前任务所运行的线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Thread runner;</span><br><span class="line"><span class="comment">// 记录调用 get 方法时被等待的线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br></pre></td></tr></table></figure>

<p>从属性上我们明显看到 Callable 是作为 FutureTask 的属性之一，这也就让 FutureTask 具备了转化 Callable 和 Runnable 的功能，接着我们看下 FutureTask 的构造器，看看两者是如何转化的。</p>
<h5 id="3-3-3-FutureTask-的构造器"><a href="#3-3-3-FutureTask-的构造器" class="headerlink" title="3.3.3 FutureTask 的构造器"></a>3.3.3 FutureTask 的构造器</h5><p>FutureTask 有两个构造器，分别接受 Callable 和 Runnable，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 Callable 进行初始化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.callable = callable;</span><br><span class="line">    <span class="comment">// 任务状态初始化</span></span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Runnable 初始化，并传入 result 作为返回结果。</span></span><br><span class="line"><span class="comment">// Runnable 是没有返回值的，所以 result 一般没有用，置为 null 就好了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Executors.callable 方法把 runnable 适配成 RunnableAdapter，RunnableAdapter 实现了 callable，所以也就是把 runnable 直接适配成了 callable。</span></span><br><span class="line">    <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Runnable 的两个构造器，只有一个目的，就是把入参都转化成 Callable，那么为什么不都转化成 Runnnable 呢？主要是因为 Callable 的功能比 Runnnable 丰富，Callable 有返回值，而 Runnnable 没有。</p>
<p>我们注意到入参是 Runnable 的构造器，会使用 Executors.callable 方法来把 Runnnable 转化成 Callable，Runnnable 和 Callable 两者都是接口，两者之间是无法进行转化的，所以 Java 新建了一个转化类：RunnableAdapter 来进行转化，我们来看下转化的逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转化 Runnable 成 Callable 的工具类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableAdapter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Runnable task;</span><br><span class="line">    <span class="keyword">final</span> T result;</span><br><span class="line">    RunnableAdapter(Runnable task, T result) &#123;</span><br><span class="line">        <span class="keyword">this</span>.task = task;</span><br><span class="line">        <span class="keyword">this</span>.result = result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        task.run();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到：</p>
<ol>
<li>首先 RunnableAdapter 实现了 Callable，所以 RunnableAdapter 就是 Callable；</li>
<li>其次 Runnable 是 RunnableAdapter 的一个属性，在构造 RunnableAdapter 的时候会传进来，并且在 call 方法里面调用 Runnable 的 run 方法。</li>
</ol>
<p>这是一个典型的适配模型，我们要把 Runnable 适配成 Callable，首先要实现 Callable 的接口，接着在 Callable 的 call 方法里面调用被适配对象（Runnable）的方法。</p>
<p>FutureTask 构造器设计很巧妙，将 Runnable 和 Callable 灵活的打通，向内和向外只提供功能更加丰富的 Callable 接口，值得我们学习。</p>
<h5 id="3-3-4-FutureTask-对-Future-接口方法的实现"><a href="#3-3-4-FutureTask-对-Future-接口方法的实现" class="headerlink" title="3.3.4 FutureTask 对 Future 接口方法的实现"></a>3.3.4 FutureTask 对 Future 接口方法的实现</h5><p>我们主要看几个关键的方法实现源码。</p>
<h6 id="3-3-4-1-get"><a href="#3-3-4-1-get" class="headerlink" title="3.3.4.1 get"></a>3.3.4.1 get</h6><p>get 有无限阻塞和带超时时间两种方法，我们通常建议使用带超时时间的方法，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="comment">// 如果任务已经在执行中了，并且等待一定的时间后，仍然在执行中，直接抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING &amp;&amp;</span><br><span class="line">        (s = awaitDone(<span class="keyword">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">    <span class="comment">// 任务执行成功，返回执行的结果</span></span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等待任务执行完成</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 计算等待终止时间，如果一直等待的话，终止时间为 0</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">    WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 不排队</span></span><br><span class="line">    <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 无限循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 如果线程已经被打断了，删除，抛异常</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            removeWaiter(q);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前任务状态</span></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="comment">// 当前任务已经执行完了，返回</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">            <span class="comment">// 当前任务的线程置空</span></span><br><span class="line">            <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                q.thread = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果正在执行，当前线程让出 cpu，重新竞争，防止 cpu 飙高</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">            <span class="comment">// 如果第一次运行，新建 waitNode，当前线程就是 waitNode 的属性</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</span><br><span class="line">            q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">            <span class="comment">// 默认第一次都会执行这里，执行成功之后，queued 就为 true，就不会再执行了</span></span><br><span class="line">            <span class="comment">// 把当前 waitNode 当做 waiters 链表的第一个</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">            queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,</span><br><span class="line">                                                 q.next = waiters, q);</span><br><span class="line">            <span class="comment">// 如果设置了超时时间，并过了超时时间的话，从 waiters 链表中删除当前 wait</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                <span class="keyword">return</span> state;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没有过超时时间，线程进入 TIMED_WAITING 状态</span></span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有设置超时时间，进入 WAITING 状态</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>get 方法虽然名字叫做 get，但却做了很多 wait 的事情，当发现任务还在进行中，没有完成时，就会阻塞当前进程，等待任务完成后再返回结果值。阻塞底层使用的是 LockSupport.park 方法，使当前线程进入 WAITING 或 TIMED_WAITING 状态。</p>
<h6 id="3-3-4-2-run"><a href="#3-3-4-2-run" class="headerlink" title="3.3.4.2 run"></a>3.3.4.2 run</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * run 方法可以直接被调用</span></span><br><span class="line"><span class="comment"> * 也可以开启新的线程进行调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 状态不是任务创建，或者当前任务已经有线程在执行了，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                     <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="comment">// Callable 不为空，并且已经初始化完成</span></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            <span class="keyword">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 调用执行</span></span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">                ran = <span class="keyword">false</span>;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 给 outcome 赋值</span></span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        runner = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>run 方法我们再说明几点：</p>
<ol>
<li>run 方法是没有返回值的，通过给 outcome 属性赋值（set(result)），get 时就能从 outcome 属性中拿到返回值；</li>
<li>FutureTask 两种构造器，最终都转化成了 Callable，所以在 run 方法执行的时候，只需要执行 Callable 的 call 方法即可，在执行 c.call() 代码时，如果入参是 Runnable 的话， 调用路径为 c.call() -&gt; RunnableAdapter.call() -&gt; Runnable.run()，如果入参是 Callable 的话，直接调用。</li>
</ol>
<h6 id="3-3-4-3-cancel"><a href="#3-3-4-3-cancel" class="headerlink" title="3.3.4.3 cancel"></a>3.3.4.3 cancel</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取消任务，如果正在运行，尝试去打断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(state == NEW &amp;&amp;<span class="comment">//任务状态不是创建 并且不能把 new 状态置为取消，直接返回 false</span></span><br><span class="line">          UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW,</span><br><span class="line">              mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 进行取消操作，打断可能会抛出异常，选择 try finally 的结构</span></span><br><span class="line">    <span class="keyword">try</span> &#123;    <span class="comment">// in case call to interrupt throws exception</span></span><br><span class="line">        <span class="keyword">if</span> (mayInterruptIfRunning) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread t = runner;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                    t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123; <span class="comment">// final state</span></span><br><span class="line">                <span class="comment">//状态设置成已打断</span></span><br><span class="line">                UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, INTERRUPTED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 清理线程</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-总结-4"><a href="#4-总结-4" class="headerlink" title="4 总结"></a>4 总结</h3><p>大家现在可以回头看看一开始我们贴出来的图，看看自己照着图能否想起来各个 API 的作用，比如 Callable 是干啥的，FutureTask 又有什么作用，Runnable 和 Calllable 之间又是如何关联起来，几个 API 之间的关系的确很复杂，FutureTask 是关键，通过 FutureTask 把 Runnnable、Callable、Future 都串起来了，使 FutureTask 具有三者的功能，统一了 Runnnable 和 Callable，更方便使用。</p>
<h2 id="29-押宝线程源码面试题"><a href="#29-押宝线程源码面试题" class="headerlink" title="29 押宝线程源码面试题"></a><strong>29 押宝线程源码面试题</strong></h2><h3 id="引导语-26"><a href="#引导语-26" class="headerlink" title="引导语"></a>引导语</h3><p>关于线程方面的面试题，大部分都是概念题，我们需要大概的清楚这些概念，和面试官达成共识即可，本章我们一起来看下这些面试题，对前两章的学习进行巩固。</p>
<h3 id="1-面试题-2"><a href="#1-面试题-2" class="headerlink" title="1 面试题"></a>1 面试题</h3><h4 id="1-1-创建子线程时，子线程是得不到父线程的-ThreadLocal，有什么办法可以解决这个问题？"><a href="#1-1-创建子线程时，子线程是得不到父线程的-ThreadLocal，有什么办法可以解决这个问题？" class="headerlink" title="1.1 创建子线程时，子线程是得不到父线程的 ThreadLocal，有什么办法可以解决这个问题？"></a>1.1 创建子线程时，子线程是得不到父线程的 ThreadLocal，有什么办法可以解决这个问题？</h4><p>答：这道题主要考察线程的属性和创建过程，可以这么回答。</p>
<p>可以使用 InheritableThreadLocal 来代替 ThreadLocal，ThreadLocal 和 InheritableThreadLocal 都是线程的属性，所以可以做到线程之间的数据隔离，在多线程环境下我们经常使用，但在有子线程被创建的情况下，父线程 ThreadLocal 是无法传递给子线程的，但 InheritableThreadLocal 可以，主要是因为在线程创建的过程中，会把</p>
<p>InheritableThreadLocal 里面的所有值传递给子线程，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当父线程的 inheritableThreadLocals 的值不为空时</span></span><br><span class="line"><span class="comment">// 会把 inheritableThreadLocals 里面的值全部传递给子线程</span></span><br><span class="line"><span class="keyword">if</span> (parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">        ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br></pre></td></tr></table></figure>



<h4 id="1-2-线程创建有几种实现方式？"><a href="#1-2-线程创建有几种实现方式？" class="headerlink" title="1.2 线程创建有几种实现方式？"></a>1.2 线程创建有几种实现方式？</h4><p>答：主要有三种，分成两大类，第一类是子线程没有返回值，第二类是子线程有返回值。</p>
<p>无返回值的线程有两种写法，第一种是继承 Thread，可以这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(Thread.currentThread().getName());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extendThreadInit</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">new</span> MyThread().start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种是实现 Runnable 接口，并作为 Thread 构造器的入参，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125; begin run&quot;</span>,Thread.currentThread().getName());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 开一个子线程去执行</span></span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<p>这两种都会开一个子线程去执行任务，并且是没有返回值的，如果需要子线程有返回值，需要使用 Callable 接口，但 Callable 接口是无法直接作为 Thread 构造器的入参的，必须结合 FutureTask 一起使用，可以这样写代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testThreadByCallable</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">  FutureTask futureTask = <span class="keyword">new</span> FutureTask(<span class="keyword">new</span> Callable&lt;String&gt; () &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">      String result = <span class="string">&quot;我是子线程&quot;</span>+Thread.currentThread().getName();</span><br><span class="line">      log.info(<span class="string">&quot;子线程正在运行：&#123;&#125;&quot;</span>,Thread.currentThread().getName());</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">  log.info(<span class="string">&quot;返回的结果是 &#123;&#125;&quot;</span>,futureTask.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把 FutureTask 作为 Thread 的入参就可以了，FutureTask 组合了 Callable ，使我们可以使用 Callable，并且 FutureTask 实现了 Runnable 接口，使其可以作为 Thread 构造器的入参，还有 FutureTask 实现了 Future，使其对任务有一定的管理功能。</p>
<h4 id="1-3-子线程-1-去等待子线程-2-执行完成之后才能执行，如何去实现？"><a href="#1-3-子线程-1-去等待子线程-2-执行完成之后才能执行，如何去实现？" class="headerlink" title="1.3 子线程 1 去等待子线程 2 执行完成之后才能执行，如何去实现？"></a>1.3 子线程 1 去等待子线程 2 执行完成之后才能执行，如何去实现？</h4><p>答：这里考察的就是 Thread.join 方法，我们可以这么做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJoin2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      log.info(<span class="string">&quot;我是子线程 2,开始沉睡&quot;</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000L</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      log.info(<span class="string">&quot;我是子线程 2，执行完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      log.info(<span class="string">&quot;我是子线程 1，开始运行&quot;</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">      log.info(<span class="string">&quot;我是子线程 1，我在等待子线程 2&quot;</span>);</span><br><span class="line">      <span class="comment">// 这里是代码关键  </span></span><br><span class="line">      thread2.join();</span><br><span class="line">      log.info(<span class="string">&quot;我是子线程 1，子线程 2 执行完成，我继续执行&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      log.info(<span class="string">&quot;我是子线程 1，执行完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  thread1.start();</span><br><span class="line">  thread2.start();</span><br><span class="line">  Thread.sleep(<span class="number">100000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子线程 1 需要等待子线程 2，只需要子线程 1 运行的时候，调用子线程 2 的 join 方法即可，这样线程 1 执行到 join 代码时，就会等待线程 2 执行完成之后，才会继续执行。</p>
<h4 id="1-4-守护线程和非守护线程的区别？如果我想在项目启动的时候收集代码信息，请问是守护线程好，还是非守护线程好，为什么？"><a href="#1-4-守护线程和非守护线程的区别？如果我想在项目启动的时候收集代码信息，请问是守护线程好，还是非守护线程好，为什么？" class="headerlink" title="1.4 守护线程和非守护线程的区别？如果我想在项目启动的时候收集代码信息，请问是守护线程好，还是非守护线程好，为什么？"></a>1.4 守护线程和非守护线程的区别？如果我想在项目启动的时候收集代码信息，请问是守护线程好，还是非守护线程好，为什么？</h4><p>答：两者的主要区别是，在 JVM 退出时，JVM 是不会管守护线程的，只会管非守护线程，如果非守护线程还有在运行的，JVM 就不会退出，如果没有非守护线程了，但还有守护线程的，JVM 直接退出。</p>
<p>如果需要在项目启动的时候收集代码信息，就需要看收集工作是否重要了，如果不太重要，又很耗时，就应该选择守护线程，这样不会妨碍 JVM 的退出，如果收集工作非常重要的话，那么就需要非守护进程，这样即使启动时发生未知异常，JVM 也会等到代码收集信息线程结束后才会退出，不会影响收集工作。</p>
<h4 id="1-5-线程-start-和-run-之间的区别。"><a href="#1-5-线程-start-和-run-之间的区别。" class="headerlink" title="1.5 线程 start 和 run 之间的区别。"></a>1.5 线程 start 和 run 之间的区别。</h4><p>答：调用 Thread.start 方法会开一个新的线程，run 方法不会。</p>
<h4 id="1-6-Thread、Runnable、Callable-三者之间的区别。"><a href="#1-6-Thread、Runnable、Callable-三者之间的区别。" class="headerlink" title="1.6 Thread、Runnable、Callable 三者之间的区别。"></a>1.6 Thread、Runnable、Callable 三者之间的区别。</h4><p>答：Thread 实现了 Runnable，本身就是 Runnable，但同时负责线程创建、线程状态变更等操作。</p>
<p>Runnable 是无返回值任务接口，Callable 是有返回值任务接口，如果任务需要跑起来，必须需要 Thread 的支持才行，Runnable 和 Callable 只是任务的定义，具体执行还需要靠 Thread。</p>
<h4 id="1-7-线程池-submit-有两个方法，方法一可接受-Runnable，方法二可接受-Callable，但两个方法底层的逻辑却是同一套，这是如何适配的。"><a href="#1-7-线程池-submit-有两个方法，方法一可接受-Runnable，方法二可接受-Callable，但两个方法底层的逻辑却是同一套，这是如何适配的。" class="headerlink" title="1.7 线程池 submit 有两个方法，方法一可接受 Runnable，方法二可接受 Callable，但两个方法底层的逻辑却是同一套，这是如何适配的。"></a>1.7 线程池 submit 有两个方法，方法一可接受 Runnable，方法二可接受 Callable，但两个方法底层的逻辑却是同一套，这是如何适配的。</h4><p>答：问题考察点在于 Runnable 和 Callable 之间是如何转化的，可以这么回答。</p>
<p>Runnable 和 Callable 是通过 FutureTask 进行统一的，FutureTask 有个属性是 Callable，同时也实现了 Runnable 接口，两者的统一转化是在 FutureTask 的构造器里实现的，FutureTask 的最终目标是把 Runnable 和 Callable 都转化成 Callable，Runnable 转化成 Callable 是通过 RunnableAdapter 适配器进行实现的。</p>
<p>线程池的 submit 底层的逻辑只认 FutureTask，不认 Runnable 和 Callable 的差异，所以只要都转化成 FutureTask，底层实现都会是同一套。</p>
<p>具体 Runnable 转化成 Callable 的代码和逻辑可以参考上一章，有非常详细的描述。</p>
<h4 id="1-8-Callable-能否丢给-Thread-去执行？"><a href="#1-8-Callable-能否丢给-Thread-去执行？" class="headerlink" title="1.8 Callable 能否丢给 Thread 去执行？"></a>1.8 Callable 能否丢给 Thread 去执行？</h4><p>答：可以的，可以新建 Callable，并作为 FutureTask 的构造器入参，然后把 FutureTask 丢给 Thread 去执行即可。</p>
<h4 id="1-9-FutureTask-有什么作用-谈谈对-FutureTask-的理解-。"><a href="#1-9-FutureTask-有什么作用-谈谈对-FutureTask-的理解-。" class="headerlink" title="1.9 FutureTask 有什么作用(谈谈对 FutureTask 的理解)。"></a>1.9 FutureTask 有什么作用(谈谈对 FutureTask 的理解)。</h4><p>答：作用如下：</p>
<ol>
<li>组合了 Callable，实现了 Runnable，把 Callable 和 Runnnable 串联了起来。</li>
<li>统一了有参任务和无参任务两种定义方式，方便了使用。</li>
<li>实现了 Future 的所有方法，对任务有一定的管理功能，比如说拿到任务执行结果，取消任务，打断任务等等。</li>
</ol>
<h4 id="1-10-聊聊对-FutureTask-的-get、cancel-方法的理解"><a href="#1-10-聊聊对-FutureTask-的-get、cancel-方法的理解" class="headerlink" title="1.10 聊聊对 FutureTask 的 get、cancel 方法的理解"></a>1.10 聊聊对 FutureTask 的 get、cancel 方法的理解</h4><p>答：get 方法主要作用是得到 Callable 异步任务执行的结果，无参 get 会一直等待任务执行完成之后才返回，有参 get 方法可以设定固定的时间，在设定的时间内，如果任务还没有执行成功，直接返回异常，在实际工作中，建议多多使用 get 有参方法，少用 get 无参方法，防止任务执行过慢时，多数线程都在等待，造成线程耗尽的问题。</p>
<p>cancel 方法主要用来取消任务，如果任务还没有执行，是可以取消的，如果任务已经在执行过程中了，你可以选择不取消，或者直接打断执行中的任务。</p>
<p>两个方法具体的执行步骤和原理见上一章节源码解析。</p>
<h4 id="1-11-Thread-yield-方法在工作中有什么用？"><a href="#1-11-Thread-yield-方法在工作中有什么用？" class="headerlink" title="1.11 Thread.yield 方法在工作中有什么用？"></a>1.11 Thread.yield 方法在工作中有什么用？</h4><p>答：yield 方法表示当前线程放弃 cpu，重新参与到 cpu 的竞争中去，再次竞争时，自己有可能得到 cpu 资源，也有可能得不到，这样做的好处是防止当前线程一直霸占 cpu。</p>
<p>我们在工作中可能会写一些 while 自旋的代码，如果我们一直 while 自旋，不采取任何手段，我们会发现 cpu 一直被当前 while 循环占用，如果能预见 while 自旋时间很长，我们会设置一定的判断条件，让当前线程陷入阻塞，如果能预见 while 自旋时间很短，我们通常会使用 Thread.yield 方法，使当前自旋线程让步，不一直霸占 cpu，比如这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span> (!stop)&#123;</span><br><span class="line">  <span class="comment">// dosomething</span></span><br><span class="line">  Thread.yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1-12-wait-和sleep-的相同点和区别"><a href="#1-12-wait-和sleep-的相同点和区别" class="headerlink" title="1.12 wait()和sleep()的相同点和区别?"></a>1.12 wait()和sleep()的相同点和区别?</h4><p>答：相同点：</p>
<ol>
<li>两者都让线程进入到 TIMED_WAITING 状态，并且可以设置等待的时间。</li>
</ol>
<p>不同点：</p>
<ol>
<li>wait 是 Object 类的方法，sleep 是 Thread 类的方法。</li>
<li>sleep 不会释放锁，沉睡的时候，其它线程是无法获得锁的，但 wait 会释放锁。</li>
</ol>
<h4 id="1-13-写一个简单的死锁-demo"><a href="#1-13-写一个简单的死锁-demo" class="headerlink" title="1.13 写一个简单的死锁 demo"></a>1.13 写一个简单的死锁 demo</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 共享变量 1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object share1 = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">// 共享变量 2</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object share2 = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDeadLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化线程 1，线程 1 需要在锁定 share1 共享资源的情况下再锁定 share2</span></span><br><span class="line">  Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (share1)&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">synchronized</span> (share2)&#123;</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125; is run&quot;</span>,Thread.currentThread().getName());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化线程 2，线程 2 需要在锁定 share2 共享资源的情况下再锁定 share1</span></span><br><span class="line">  Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (share2)&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">synchronized</span> (share1)&#123;</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125; is run&quot;</span>,Thread.currentThread().getName());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 当线程 1、2 启动后，都在等待对方锁定的资源，但都得不到，造成死锁</span></span><br><span class="line">  thread1.start();</span><br><span class="line">  thread2.start();</span><br><span class="line">  Thread.sleep(<span class="number">1000000000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-总结-1"><a href="#2-总结-1" class="headerlink" title="2 总结"></a>2 总结</h3><p>线程章节算是中等难度，我们需要清楚线程的概念，线程如何初始化，线程的状态变更等等问题，这些知识点都是线程池、锁的基础，学好线程后，再学习线程池和锁就会轻松很多。</p>
<h1 id="第6章-锁"><a href="#第6章-锁" class="headerlink" title="第6章 锁"></a><strong>第6章 锁</strong></h1><h2 id="30-AbstractQueuedSynchronizer-源码解析（上）"><a href="#30-AbstractQueuedSynchronizer-源码解析（上）" class="headerlink" title="30 AbstractQueuedSynchronizer 源码解析（上）"></a><strong>30 AbstractQueuedSynchronizer 源码解析（上）</strong></h2><h3 id="引导语-27"><a href="#引导语-27" class="headerlink" title="引导语"></a>引导语</h3><p>AbstractQueuedSynchronizer 中文翻译叫做同步器，简称 AQS，是各种各样锁的基础，比如说 ReentrantLock、CountDownLatch 等等，这些我们经常用的锁底层实现都是 AQS，所以学好 AQS 对于后面理解锁的实现是非常重要的。</p>
<p>锁章节的内容是这么安排的：</p>
<p>1：AQS 源码非常多，我们会分成两个小节来说，先把底层原理弄清楚；</p>
<p>2：我们平时用不到 AQS，只会接触到 ReentrantLock、CountDownLatch 这些锁，我们以两个锁为例子，讲解下源码，因为 AQS 只要弄懂了，所有的锁你只要清楚锁的目的，就能够利用 AQS 去实现它；</p>
<p>3：总结一下锁的面试题；</p>
<p>4：总结一下锁在工作中有哪些使用场景，举几个实际的例子，看看锁使用时，有哪些注意事项；</p>
<p>5：最后我们自己来实现一个锁，看看如果我们自己来实现锁，有哪些步骤，需要注意哪些事项。</p>
<p>ps：本章内容需要大量队列基础知识，没有看过第四章节队列的同学，建议先阅读下队列章节。</p>
<h3 id="1-整体架构-8"><a href="#1-整体架构-8" class="headerlink" title="1 整体架构"></a>1 整体架构</h3><p>首先我们来看一下 AQS 的整体架构图，如下：<br><img src="http://img.mukewang.com/5dc37d400001cb6f21120846.png" alt="图片描述"></p>
<p>这个图总结了 AQS 整体架构的组成，和部分场景的动态流向，图中两个点说明一下，方便大家观看。</p>
<ol>
<li>AQS 中队列只有两个：同步队列 + 条件队列，底层数据结构两者都是链表；</li>
<li>图中有四种颜色的线代表四种不同的场景，1、2、3 序号代表看的顺序。</li>
</ol>
<p>AQS 本身就是一套锁的框架，它定义了获得锁和释放锁的代码结构，所以如果要新建锁，只要继承 AQS，并实现相应方法即可。</p>
<p>接下来我们一起来看下这个图中各个细节点。</p>
<h4 id="1-1-类注释-6"><a href="#1-1-类注释-6" class="headerlink" title="1.1 类注释"></a>1.1 类注释</h4><p>首先我们来看一下，从 AQS 类注释上，我们可以得到哪些信息：</p>
<ol>
<li>提供了一种框架，自定义了先进先出的同步队列，让获取不到锁的线程能进入同步队列中排队；</li>
<li>同步器有个状态字段，我们可以通过状态字段来判断能否得到锁，此时设计的关键在于依赖安全的 atomic value 来表示状态（虽然注释是这个意思，但实际上是通过把状态声明为 volatile，在锁里面修改状态值来保证线程安全的）；</li>
<li>子类可以通过给状态 CAS 赋值来决定能否拿到锁，可以定义那些状态可以获得锁，哪些状态表示获取不到锁（比如定义状态值是 0 可以获得锁，状态值是 1 就获取不到锁）；</li>
<li>子类可以新建非 public 的内部类，用内部类来继承 AQS，从而实现锁的功能；</li>
<li>AQS 提供了排它模式和共享模式两种锁模式。排它模式下：只有一个线程可以获得锁，共享模式可以让多个线程获得锁，子类 ReadWriteLock 实现了两种模式；</li>
<li>内部类 ConditionObject 可以被用作 Condition，我们通过 new ConditionObject () 即可得到条件队列；</li>
<li>AQS 实现了锁、排队、锁队列等框架，至于如何获得锁、释放锁的代码并没有实现，比如 tryAcquire、tryRelease、tryAcquireShared、tryReleaseShared、isHeldExclusively 这些方法，AQS 中默认抛 UnsupportedOperationException 异常，都是需要子类去实现的；</li>
<li>AQS 继承 AbstractOwnableSynchronizer 是为了方便跟踪获得锁的线程，可以帮助监控和诊断工具识别是哪些线程持有了锁；</li>
<li>AQS 同步队列和条件队列，获取不到锁的节点在入队时是先进先出，但被唤醒时，可能并不会按照先进先出的顺序执行。</li>
</ol>
<p>AQS 的注释还有很多很多，以上 9 点是挑选出来稍微比较重要的注释总结。</p>
<h4 id="1-2-类定义"><a href="#1-2-类定义" class="headerlink" title="1.2 类定义"></a>1.2 类定义</h4><p>AQS 类定义代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<p>可以看出两点：</p>
<ol>
<li>AQS 是个抽象类，就是给各种锁子类继承用的，AQS 定义了很多如何获得锁，如何释放锁的抽象方法，目的就是为了让子类去实现；</li>
<li>继承了 AbstractOwnableSynchronizer，AbstractOwnableSynchronizer 的作用就是为了知道当前是那个线程获得了锁，方便监控用的，代码如下：<br><img src="http://img.mukewang.com/5dc37d20000197d121001410.png" alt="图片描述"></li>
</ol>
<h4 id="1-3-基本属性"><a href="#1-3-基本属性" class="headerlink" title="1.3 基本属性"></a>1.3 基本属性</h4><p>AQS 的属性可简单分为四类：同步器简单属性、同步队列属性、条件队列属性、公用 Node。</p>
<h5 id="1-3-1-简单属性"><a href="#1-3-1-简单属性" class="headerlink" title="1.3.1 简单属性"></a>1.3.1 简单属性</h5><p>首先我们来看一下简单属性有哪些：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步器的状态，子类会根据状态字段进行判断是否可以获得锁</span></span><br><span class="line"><span class="comment">// 比如 CAS 成功给 state 赋值 1 算得到锁，赋值失败为得不到锁， CAS 成功给 state 赋值 0 算释放锁，赋值失败为释放失败</span></span><br><span class="line"><span class="comment">// 可重入锁，每次获得锁 +1，每次释放锁 -1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自旋超时阀值，单位纳秒</span></span><br><span class="line"><span class="comment">// 当设置等待时间时才会用到这个属性</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> spinForTimeoutThreshold = <span class="number">1000L</span>;</span><br></pre></td></tr></table></figure>

<p>最重要的就是 state 属性，是 int 属性的，所有继承 AQS 的锁都是通过这个字段来判断能不能获得锁，能不能释放锁。</p>
<h5 id="1-3-2-同步队列属性"><a href="#1-3-2-同步队列属性" class="headerlink" title="1.3.2 同步队列属性"></a>1.3.2 同步队列属性</h5><p>首先我们介绍以下同步队列：当多个线程都来请求锁时，某一时刻有且只有一个线程能够获得锁（排它锁），那么剩余获取不到锁的线程，都会到同步队列中去排队并阻塞自己，当有线程主动释放锁时，就会从同步队列头开始释放一个排队的线程，让线程重新去竞争锁。</p>
<p>所以同步队列的主要作用阻塞获取不到锁的线程，并在适当时机释放这些线程。</p>
<p>同步队列底层数据结构是个双向链表，我们从源码中可以看到链表的头尾，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步队列的头。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步队列的尾</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br></pre></td></tr></table></figure>

<p>源码中的 Node 是同步队列中的元素，但 Node 被同步队列和条件队列公用，所以我们在说完条件队列之后再说 Node。</p>
<h5 id="1-3-3-条件队列的属性"><a href="#1-3-3-条件队列的属性" class="headerlink" title="1.3.3 条件队列的属性"></a>1.3.3 条件队列的属性</h5><p>首先我们介绍下条件队列：条件队列和同步队列的功能一样，管理获取不到锁的线程，底层数据结构也是链表队列，但条件队列不直接和锁打交道，但常常和锁配合使用，是一定的场景下，对锁功能的一种补充。</p>
<p>条件队列的属性如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 条件队列，从属性上可以看出是链表结构</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1173984872572414699L</span>;</span><br><span class="line">    <span class="comment">// 条件队列中第一个 node</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">    <span class="comment">// 条件队列中最后一个 node</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>ConditionObject 我们就称为条件队列，我们需要使用时，直接 new ConditionObject () 即可。</p>
<p>ConditionObject 是实现 Condition 接口的，Condition 接口相当于 Object 的各种监控方法，比如 Object#wait ()、Object#notify、Object#notifyAll 这些方法，我们可以先这么理解，后面会细说。</p>
<h5 id="1-3-4-Node"><a href="#1-3-4-Node" class="headerlink" title="1.3.4 Node"></a>1.3.4 Node</h5><p>Node 非常重要，即是同步队列的节点，又是条件队列的节点，在入队的时候，我们用 Node 把线程包装一下，然后把 Node 放入两个队列中，我们看下 Node 的数据结构，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步队列单独的属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//node 是共享模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//node 是排它模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前节点的前节点</span></span><br><span class="line">    <span class="comment">// 节点 acquire 成功后就会变成head</span></span><br><span class="line">    <span class="comment">// head 节点不能被 cancelled</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前节点的下一个节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 两个队列共享的属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 表示当前节点的状态，通过节点的状态来控制节点的行为</span></span><br><span class="line">    <span class="comment">// 普通同步节点，就是 0 ，条件节点是 CONDITION -2</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// waitStatus 的状态有以下几种</span></span><br><span class="line">    <span class="comment">// 被取消</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SIGNAL 状态的意义：同步队列中的节点在自旋获取锁的时候，如果前一个节点的状态是 SIGNAL，那么自己就可以阻塞休息了，否则自己一直自旋尝试获得锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示当前 node 正在条件队列中，当有节点从同步队列转移到条件队列时，状态就会被更改成 CONDITION</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无条件传播,共享模式下，该状态的进程处于可运行状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前节点的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在同步队列中，nextWaiter 并不真的是指向其下一个节点，我们用 next 表示同步队列的下一个节点，nextWaiter 只是表示当前 Node 是排它模式还是共享模式</span></span><br><span class="line">    <span class="comment">// 但在条件队列中，nextWaiter 就是表示下一个节点元素</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 Node 的结构中，我们需要重点关注 waitStatus 字段，Node 的很多操作都是围绕着 waitStatus 字段进行的。</p>
<p>Node 的 pre、next 属性是同步队列中的链表前后指向字段，nextWaiter 是条件队列中下一个节点的指向字段，但在同步队列中，nextWaiter 只是一个标识符，表示当前节点是共享还是排它模式。</p>
<h5 id="1-3-5-共享锁和排它锁的区别"><a href="#1-3-5-共享锁和排它锁的区别" class="headerlink" title="1.3.5 共享锁和排它锁的区别"></a>1.3.5 共享锁和排它锁的区别</h5><p>排它锁的意思是同一时刻，只能有一个线程可以获得锁，也只能有一个线程可以释放锁。</p>
<p>共享锁可以允许多个线程获得同一个锁，并且可以设置获取锁的线程数量。</p>
<h4 id="1-4-Condition"><a href="#1-4-Condition" class="headerlink" title="1.4 Condition"></a>1.4 Condition</h4><p>刚才我们看条件队列 ConditionObject 时，发现其是实现 Condition 接口的，现在我们一起来看下 Condition 接口，其类注释上是这么写的：</p>
<ol>
<li>当 lock 代替 synchronized 来加锁时，Condition 就可以用来代替 Object 中相应的监控方法了，比如 Object#wait ()、Object#notify、Object#notifyAll 这些方法；</li>
<li>提供了一种线程协作方式：一个线程被暂停执行，直到被其它线程唤醒；</li>
<li>Condition 实例是绑定在锁上的，通过 Lock#newCondition 方法可以产生该实例；</li>
<li>除了特殊说明外，任意空值作为方法的入参，都会抛出空指针；</li>
<li>Condition 提供了明确的语义和行为，这点和 Object 监控方法不同。</li>
</ol>
<p>类注释上甚至还给我们举了一个例子：</p>
<p>假设我们有一个有界边界的队列，支持 put 和 take 方法，需要满足：<br>1：如果试图往空队列上执行 take，线程将会阻塞，直到队列中有可用的元素为止；<br>2：如果试图往满的队列上执行 put，线程将会阻塞，直到队列中有空闲的位置为止。</p>
<p>1、2 中线程阻塞都会到条件队列中去阻塞。</p>
<p>take 和 put 两种操作如果依靠一个条件队列，那么每次只能执行一种操作，所以我们可以新建两个条件队列，这样就可以分别执行操作了，看了这个需求，是不是觉得很像我们第三章学习的队列？实际上注释上给的 demo 就是我们学习过的队列，篇幅有限，感兴趣的可以看看 ConditionDemo 这个测试类。</p>
<p>除了类注释，Condition 还定义出一些方法，这些方法奠定了条件队列的基础，方法主要有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>

<p>这个方法的主要作用是：使当前线程一直等待，直到被 signalled 或被打断。</p>
<p>当以下四种情况发生时，条件队列中的线程将被唤醒</p>
<ol>
<li>有线程使用了 signal 方法，正好唤醒了条件队列中的当前线程；</li>
<li>有线程使用了 signalAll 方法；</li>
<li>其它线程打断了当前线程，并且当前线程支持被打断；</li>
<li>被虚假唤醒 (即使没有满足以上 3 个条件，wait 也是可能被偶尔唤醒，虚假唤醒定义可以参考： <a href="https://en.wikipedia.org/wiki/Spurious_wakeup)%E3%80%82">https://en.wikipedia.org/wiki/Spurious_wakeup)。</a></li>
</ol>
<p>被唤醒时，有一点需要注意的是：线程从条件队列中苏醒时，必须重新获得锁，才能真正被唤醒，这个我们在说源码的时候，也会强调这个。</p>
<p>await 方法还有带等待超时时间的，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回的 long 值表示剩余的给定等待时间，如果返回的时间小于等于 0 ，说明等待时间过了</span></span><br><span class="line"><span class="comment">// 选择纳秒是为了避免计算剩余等待时间时的截断误差</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虽然入参可以是任意单位的时间，但底层仍然转化成纳秒</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>

<p>除了等待方法，还是唤醒线程的两个方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 唤醒条件队列中的一个线程，在被唤醒前必须先获得锁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒条件队列中的所有线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>至此，AQS 基本的属性就已经介绍完了，接着让我们来看一看 AQS 的重要方法。</p>
<h3 id="2-同步器的状态"><a href="#2-同步器的状态" class="headerlink" title="2 同步器的状态"></a>2 同步器的状态</h3><p>在同步器中，我们有两个状态，一个叫做 state，一个叫做 waitStatus，两者是完全不同的概念：</p>
<ol>
<li>state 是锁的状态，是 int 类型，子类继承 AQS 时，都是要根据 state 字段来判断有无得到锁，比如当前同步器状态是 0，表示可以获得锁，当前同步器状态是 1，表示锁已经被其他线程持有，当前线程无法获得锁；</li>
<li>waitStatus 是节点（Node）的状态，种类很多，一共有初始化 (0)、CANCELLED (1)、SIGNAL (-1)、CONDITION (-2)、PROPAGATE (-3)，各个状态的含义可以见上文。</li>
</ol>
<p>这两个状态我们需要牢记，不要混淆了。</p>
<h3 id="3-获取锁"><a href="#3-获取锁" class="headerlink" title="3 获取锁"></a>3 获取锁</h3><p>获取锁最直观的感受就是使用 Lock.lock () 方法来获得锁，最终目的是想让线程获得对资源的访问权。</p>
<p>Lock 一般是 AQS 的子类，lock 方法根据情况一般会选择调用 AQS 的 acquire 或 tryAcquire 方法。</p>
<p>acquire 方法 AQS 已经实现了，tryAcquire 方法是等待子类去实现，acquire 方法制定了获取锁的框架，先尝试使用 tryAcquire 方法获取锁，获取不到时，再入同步队列中等待锁。tryAcquire 方法 AQS 中直接抛出一个异常，表明需要子类去实现，子类可以根据同步器的 state 状态来决定是否能够获得锁，接下来我们详细看下 acquire 的源码解析。</p>
<p>acquire 也分两种，一种是排它锁，一种是共享锁，我们一一来看下：</p>
<h4 id="3-1-acquire-排它锁"><a href="#3-1-acquire-排它锁" class="headerlink" title="3.1 acquire 排它锁"></a>3.1 acquire 排它锁</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 排它模式下，尝试获得锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tryAcquire 方法是需要实现类去实现的，实现思路一般都是 cas 给 state 赋值来决定是否能获得锁</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        <span class="comment">// addWaiter 入参代表是排他模式</span></span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码的主要步骤是（流程见整体架构图中红色场景）：</p>
<ol>
<li>尝试执行一次 tryAcquire，如果成功直接返回，失败走 2；</li>
<li>线程尝试进入同步队列，首先调用 addWaiter 方法，把当前线程放到同步队列的队尾；</li>
<li>接着调用 acquireQueued 方法，两个作用，1：阻塞当前节点，2：节点被唤醒时，使其能够获得锁；</li>
<li>如果 2、3 失败了，打断线程。</li>
</ol>
<h5 id="3-1-1-addWaiter"><a href="#3-1-1-addWaiter" class="headerlink" title="3.1.1 addWaiter"></a>3.1.1 addWaiter</h5><p>代码很少，每个方法都是关键，接下来我们先来看下 addWaiter 的源码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法主要目的：node 追加到同步队列的队尾</span></span><br><span class="line"><span class="comment">// 入参 mode 表示 Node 的模式（排它模式还是共享模式）</span></span><br><span class="line"><span class="comment">// 出参是新增的 node</span></span><br><span class="line"><span class="comment">// 主要思路：</span></span><br><span class="line"><span class="comment">// 新 node.pre = 队尾</span></span><br><span class="line"><span class="comment">// 队尾.next = 新 node</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 Node</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 这里的逻辑和 enq 一致，enq 的逻辑仅仅多了队尾是空，初始化的逻辑</span></span><br><span class="line">    <span class="comment">// 这个思路在 java 源码中很常见，先简单的尝试放一下，成功立马返回，如果不行，再 while 循环</span></span><br><span class="line">    <span class="comment">// 很多时候，这种算法可以帮忙解决大部分的问题，大部分的入队可能一次都能成功，无需自旋</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//自旋保证node加入到队尾</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程加入同步队列中方法，追加到队尾</span></span><br><span class="line"><span class="comment">// 这里需要重点注意的是，返回值是添加 node 的前一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 得到队尾节点</span></span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="comment">// 如果队尾为空，说明当前同步队列都没有初始化，进行初始化</span></span><br><span class="line">        <span class="comment">// tail = head = new Node();</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        <span class="comment">// 队尾不为空，将当前节点追加到队尾</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="comment">// node 追加到队尾</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果之前学习过队列的同学，对这个方法应该感觉毫不吃力，就是把新的节点追加到同步队列的队尾。</p>
<p>其中有一点值得我们学习的地方，是在 addWaiter 方法中，并没有进入方法后立马就自旋，而是先尝试一次追加到队尾，如果失败才自旋，因为大部分操作可能一次就会成功，这种思路在我们写自旋的时候可以借鉴。</p>
<h5 id="3-1-2-acquireQueued"><a href="#3-1-2-acquireQueued" class="headerlink" title="3.1.2 acquireQueued"></a>3.1.2 acquireQueued</h5><p>下一步就是要阻塞当前线程了，是 acquireQueued 方法来实现的，我们来看下源码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主要做两件事情：</span></span><br><span class="line"><span class="comment">// 1：通过不断的自旋尝试使自己前一个节点的状态变成 signal，然后阻塞自己。</span></span><br><span class="line"><span class="comment">// 2：获得锁的线程执行完成之后，释放锁时，会把阻塞的 node 唤醒,node 唤醒之后再次自旋，尝试获得锁</span></span><br><span class="line"><span class="comment">// 返回 false 表示获得锁成功，返回 true 表示失败</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 选上一个节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 有两种情况会走到 p == head：</span></span><br><span class="line">            <span class="comment">// 1:node 之前没有获得锁，进入 acquireQueued 方法时，才发现他的前置节点就是头节点，于是尝试获得一次锁；</span></span><br><span class="line">            <span class="comment">// 2:node 之前一直在阻塞沉睡，然后被唤醒，此时唤醒 node 的节点正是其前一个节点，也能走到 if</span></span><br><span class="line">            <span class="comment">// 如果自己 tryAcquire 成功，就立马把自己设置成 head，把上一个节点移除</span></span><br><span class="line">            <span class="comment">// 如果 tryAcquire 失败，尝试进入同步队列</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 获得锁，设置成 head 节点</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                <span class="comment">//p被回收</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// shouldParkAfterFailedAcquire 把 node 的前一个节点状态置为 SIGNAL</span></span><br><span class="line">            <span class="comment">// 只要前一个节点状态是 SIGNAL了，那么自己就可以阻塞(park)了</span></span><br><span class="line">            <span class="comment">// parkAndCheckInterrupt 阻塞当前线程</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                <span class="comment">// 线程是在这个方法里面阻塞的，醒来的时候仍然在无限 for 循环里面，就能再次自旋尝试获得锁</span></span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果获得node的锁失败，将 node 从队列中移除</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法的注释还是很清楚的，我们接着看下此方法的核心：shouldParkAfterFailedAcquire，这个方法的主要目的就是把前一个节点的状态置为 SIGNAL，只要前一个节点的状态是 SIGNAL，当前节点就可以阻塞了（parkAndCheckInterrupt 就是使节点阻塞的方法），源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前线程可以安心阻塞的标准，就是前一个节点线程状态是 SIGNAL 了。</span></span><br><span class="line"><span class="comment">// 入参 pred 是前一个节点，node 是当前节点。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键操作：</span></span><br><span class="line"><span class="comment">// 1：确认前一个节点是否有效，无效的话，一直往前找到状态不是取消的节点。</span></span><br><span class="line"><span class="comment">// 2: 把前一个节点状态置为 SIGNAL。</span></span><br><span class="line"><span class="comment">// 1、2 两步操作，有可能一次就成功，有可能需要外部循环多次才能成功（外面是个无限的 for 循环），但最后一定是可以成功的</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">// 如果前一个节点 waitStatus 状态已经是 SIGNAL 了，直接返回，不需要在自旋了</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">         * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 如果当前节点状态已经被取消了。</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">         * indicate retry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 找到前一个状态不是取消的节点，因为把当前 node 挂在有效节点身上</span></span><br><span class="line">        <span class="comment">// 因为节点状态是取消的话，是无效的，是不能作为 node 的前置节点的，所以必须找到 node 的有效节点才行</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    <span class="comment">// 否则直接把节点状态置 为SIGNAL</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">         * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>acquire 整个过程非常长，代码也非常多，但注释很清楚，可以一行一行仔细看看代码。</p>
<p>总结一下，acquire 方法大致分为三步：</p>
<ol>
<li>使用 tryAcquire 方法尝试获得锁，获得锁直接返回，获取不到锁的走 2；</li>
<li>把当前线程组装成节点（Node），追加到同步队列的尾部（addWaiter）；</li>
<li>自旋，使同步队列中当前节点的前置节点状态为 signal 后，然后阻塞自己。</li>
</ol>
<p>整体的代码结构比较清晰，一些需要注意的点，都用注释表明了，强烈建议阅读下源码。</p>
<h4 id="3-2-acquireShared-获取共享锁"><a href="#3-2-acquireShared-获取共享锁" class="headerlink" title="3.2 acquireShared 获取共享锁"></a>3.2 acquireShared 获取共享锁</h4><p>acquireShared 整体流程和 acquire 相同，代码也很相似，重复的源码就不贴了，我们就贴出来不一样的代码来，也方便大家进行比较：</p>
<ol>
<li>第一步尝试获得锁的地方，有所不同，排它锁使用的是 tryAcquire 方法，共享锁使用的是 tryAcquireShared 方法，如下图：<br><img src="http://img.mukewang.com/5dc37cd30001522218420446.png" alt="图片描述"></li>
<li>第二步不同，在于节点获得排它锁时，仅仅把自己设置为同步队列的头节点即可（setHead 方法），但如果是共享锁的话，还会去唤醒自己的后续节点，一起来获得该锁（setHeadAndPropagate 方法），不同之处如下（左边排它锁，右边共享锁）：<br><img src="http://img.mukewang.com/5dc37cc40001100018630914.png" alt="图片描述"></li>
</ol>
<p>接下来我们一起来看下 setHeadAndPropagate 方法的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主要做两件事情</span></span><br><span class="line"><span class="comment">// 1:把当前节点设置成头节点</span></span><br><span class="line"><span class="comment">// 2:看看后续节点有无正在等待，并且也是共享模式的，有的话唤醒这些节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    <span class="comment">// 当前节点设置成头节点</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Try to signal next queued node if:</span></span><br><span class="line"><span class="comment">     *   Propagation was indicated(表示指示) by caller,</span></span><br><span class="line"><span class="comment">     *     or was recorded (as h.waitStatus either before</span></span><br><span class="line"><span class="comment">     *     or after setHead) by a previous operation</span></span><br><span class="line"><span class="comment">     *     (note: this uses sign-check of waitStatus because</span></span><br><span class="line"><span class="comment">     *      PROPAGATE status may transition to SIGNAL.)</span></span><br><span class="line"><span class="comment">     * and</span></span><br><span class="line"><span class="comment">     *   The next node is waiting in shared mode,</span></span><br><span class="line"><span class="comment">     *     or we don&#x27;t know, because it appears null</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The conservatism(保守) in both of these checks may cause</span></span><br><span class="line"><span class="comment">     * unnecessary wake-ups, but only when there are multiple</span></span><br><span class="line"><span class="comment">     * racing acquires/releases, so most need signals now or soon</span></span><br><span class="line"><span class="comment">     * anyway.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// propagate &gt; 0 表示已经有节点获得共享锁了</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="comment">//共享模式，还唤醒头节点的后置节点</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放后置共享节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">     * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">     * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">     * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">     * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">     * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">     * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">     * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">     * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">// 还没有到队尾，此时队列中至少有两个节点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="comment">// 如果队列状态是 SIGNAL ，说明后续节点都需要唤醒</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">// CAS 保证只有一个节点可以运行唤醒的操作</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">// 进行唤醒操作</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一种情况，头节点没有发生移动，结束。</span></span><br><span class="line">        <span class="comment">// 第二种情况，因为此方法可以被两处调用，一次是获得锁的地方，一处是释放锁的地方，</span></span><br><span class="line">        <span class="comment">// 加上共享锁的特性就是可以多个线程获得锁，也可以释放锁，这就导致头节点可能会发生变化，</span></span><br><span class="line">        <span class="comment">// 如果头节点发生了变化，就继续循环，一直循环到头节点不变化时，结束循环。</span></span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个就是共享锁独特的地方，当一个线程获得锁后，它就会去唤醒排在它后面的其它节点，让其它节点也能够获得锁。</p>
<h3 id="4-总结-5"><a href="#4-总结-5" class="headerlink" title="4 总结"></a>4 总结</h3><p>AQS 的内容实在太多了，这只是 AQS 的上篇，但内容长度已经超过了我们平时章节的三倍了，所以不得不分节，下一章仍然是 AQS，主要讲解锁的释放和条件队列两大部分。</p>
<h2 id="31-AbstractQueuedSynchronizer-源码解析（下）"><a href="#31-AbstractQueuedSynchronizer-源码解析（下）" class="headerlink" title="31 AbstractQueuedSynchronizer 源码解析（下）"></a><strong>31 AbstractQueuedSynchronizer 源码解析（下）</strong></h2><h3 id="引导语-28"><a href="#引导语-28" class="headerlink" title="引导语"></a>引导语</h3><p>AQS 的内容太多，所以我们分成了两个章节，没有看过 AQS 上半章节的同学可以回首看一下哈，上半章节里面说了很多锁的基本概念，基本属性，如何获得锁等等，本章我们主要聊下如何释放锁和同步队列两大部分。</p>
<h3 id="1-释放锁"><a href="#1-释放锁" class="headerlink" title="1 释放锁"></a>1 释放锁</h3><p>释放锁的触发时机就是我们常用的 Lock.unLock () 方法，目的就是让线程释放对资源的访问权（流程见整体架构图紫色路线）。</p>
<p>释放锁也是分为两类，一类是排它锁的释放，一类是共享锁的释放，我们分别来看下。</p>
<h4 id="1-1-释放排它锁-release"><a href="#1-1-释放排它锁-release" class="headerlink" title="1.1 释放排它锁 release"></a>1.1 释放排它锁 release</h4><p>排它锁的释放就比较简单了，从队头开始，找它的下一个节点，如果下一个节点是空的，就会从尾开始，一直找到状态不是取消的节点，然后释放该节点，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// unlock 的基础方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tryRelease 交给实现类去实现，一般就是用当前同步器状态减去 arg，如果返回 true 说明成功释放锁。</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">// 头节点不为空，并且非初始化状态</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 从头开始唤醒等待锁的节点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 很有意思的方法，当线程释放锁成功后，从 node 开始唤醒同步队列中的节点</span></span><br><span class="line"><span class="comment">// 通过唤醒机制,保证线程不会一直在同步队列中阻塞等待</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// node 节点是当前释放锁的节点，也是同步队列的头节点</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="comment">// 如果节点已经被取消了，把节点的状态置为初始化</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿出 node 节点的后面一个节点</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">// s 为空，表示 node 的后一个节点为空</span></span><br><span class="line">    <span class="comment">// s.waitStatus 大于0，代表 s 节点已经被取消了</span></span><br><span class="line">    <span class="comment">// 遇到以上这两种情况，就从队尾开始，向前遍历，找到第一个 waitStatus 字段不是被取消的</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 这里从尾迭代，而不是从头开始迭代是有原因的。</span></span><br><span class="line">        <span class="comment">// 主要是因为节点被阻塞的时候，是在 acquireQueued 方法里面被阻塞的，唤醒时也一定会在 acquireQueued 方法里面被唤醒，唤醒之后的条件是，判断当前节点的前置节点是否是头节点，这里是判断当前节点的前置节点，所以这里必须使用从尾到头的迭代顺序才行，目的就是为了过滤掉无效的前置节点，不然节点被唤醒时，发现其前置节点还是无效节点，就又会陷入阻塞。</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="comment">// t.waitStatus &lt;= 0 说明 t 没有被取消，肯定还在等待被唤醒</span></span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒以上代码找到的线程</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1-2-释放共享锁-releaseShared"><a href="#1-2-释放共享锁-releaseShared" class="headerlink" title="1.2 释放共享锁 releaseShared"></a>1.2 释放共享锁 releaseShared</h4><p>释放共享锁的方法是 releaseShared，主要分成两步：</p>
<ol>
<li>tryReleaseShared 尝试释放当前共享锁，失败返回 false，成功走 2；</li>
<li>唤醒当前节点的后续阻塞节点，这个方法我们之前看过了，线程在获得共享锁的时候，就会去唤醒其后面的节点，方法名称为：doReleaseShared。</li>
</ol>
<p>我们一起来看下 releaseShared 的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 共享模式下，释放当前线程的共享锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">// 这个方法就是线程在获得锁时，唤醒后续节点时调用的方法</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-条件队列的重要方法"><a href="#2-条件队列的重要方法" class="headerlink" title="2 条件队列的重要方法"></a>2 条件队列的重要方法</h3><p>在看条件队列的方法之前，我们先得弄明白为什么有了同步队列，还需要条件队列？</p>
<p>主要是因为并不是所有场景一个同步队列就可以搞定的，在遇到锁 + 队列结合的场景时，就需要 Lock + Condition 配合才行，先使用 Lock 来决定哪些线程可以获得锁，哪些线程需要到同步队列里面排队阻塞；获得锁的多个线程在碰到队列满或者空的时候，可以使用 Condition 来管理这些线程，让这些线程阻塞等待，然后在合适的时机后，被正常唤醒。</p>
<p>同步队列 + 条件队列联手使用的场景，最多被使用到锁 + 队列的场景中。</p>
<p>所以说条件队列也是不可或缺的一环。</p>
<p>接下来我们来看一下条件队列一些比较重要的方法，以下方法都在 ConditionObject 内部类中。</p>
<h4 id="2-1-入队列等待-await"><a href="#2-1-入队列等待-await" class="headerlink" title="2.1 入队列等待 await"></a>2.1 入队列等待 await</h4><p>获得锁的线程，如果在碰到队列满或空的时候，就会阻塞住，这个阻塞就是用条件队列实现的，这个动作我们叫做入条件队列，方法名称为 await，流程见整体架构图中深绿色箭头流向，我们一起来看下 await 的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线程入条件队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// 加入到条件队列的队尾</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">// 标记位置 A</span></span><br><span class="line">    <span class="comment">// 加入条件队列后，会释放 lock 时申请的资源，唤醒同步队列队列头的节点</span></span><br><span class="line">    <span class="comment">// 自己马上就要阻塞了，必须马上释放之前 lock 的资源，不然自己不被唤醒的话，别的线程永远得不到该共享资源了</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 确认node不在同步队列上，再阻塞，如果 node 在同步队列上，是不能够上锁的</span></span><br><span class="line">    <span class="comment">// 目前想到的只有两种可能：</span></span><br><span class="line">    <span class="comment">// 1:node 刚被加入到条件队列中，立马就被其他线程 signal 转移到同步队列中去了</span></span><br><span class="line">    <span class="comment">// 2:线程之前在条件队列中沉睡，被唤醒后加入到同步队列中去</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">// this = AbstractQueuedSynchronizer$ConditionObject</span></span><br><span class="line">        <span class="comment">// 阻塞在条件队列上</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 标记位置 B</span></span><br><span class="line">    <span class="comment">// 其他线程通过 signal 已经把 node 从条件队列中转移到同步队列中的数据结构中去了</span></span><br><span class="line">    <span class="comment">// 所以这里节点苏醒了，直接尝试 acquireQueued</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        <span class="comment">// 如果状态不是CONDITION，就会自动删除</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>await 方法有几点需要特别注意：</p>
<ol>
<li>上述代码标记位置 A 处，节点在准备进入条件队列之前，一定会先释放当前持有的锁，不然自己进去条件队列了，其余的线程都无法获得锁了；</li>
<li>上述代码标记位置 B 处，此时节点是被 Condition.signal 或者 signalAll 方法唤醒的，此时节点已经成功的被转移到同步队列中去了（整体架构图中蓝色流程），所以可以直接执行 acquireQueued 方法；</li>
<li>Node 在条件队列中的命名，源码喜欢用 Waiter 来命名，所以我们在条件队列中看到 Waiter，其实就是 Node。</li>
</ol>
<p>await 方法中有两个重要方法：addConditionWaiter 和 unlinkCancelledWaiters，我们一一看下。</p>
<h5 id="2-1-1-addConditionWaiter"><a href="#2-1-1-addConditionWaiter" class="headerlink" title="2.1.1 addConditionWaiter"></a>2.1.1 addConditionWaiter</h5><p>addConditionWaiter 方法主要是把节点放到条件队列中，方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 增加新的 waiter 到队列中，返回新添加的 waiter</span></span><br><span class="line"><span class="comment">// 如果尾节点状态不是 CONDITION 状态，删除条件队列中所有状态不是 CONDITION 的节点</span></span><br><span class="line"><span class="comment">// 如果队列为空，新增节点作为队列头节点，否则追加到尾节点上</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    <span class="comment">// If lastWaiter is cancelled, clean out.</span></span><br><span class="line">    <span class="comment">// 如果尾部的 waiter 不是 CONDITION 状态了，删除</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新建条件队列 node</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    <span class="comment">// 队列是空的，直接放到队列头</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="comment">// 队列不为空，直接到队列尾部</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整体过程比较简单，就是追加到队列的尾部，其中有个重要方法叫做 unlinkCancelledWaiters，这个方法会删除掉条件队列中状态不是 CONDITION 的所有节点，我们来看下 unlinkCancelledWaiters 方法的源码，如下：</p>
<h5 id="2-1-2-unlinkCancelledWaiters"><a href="#2-1-2-unlinkCancelledWaiters" class="headerlink" title="2.1.2 unlinkCancelledWaiters"></a>2.1.2 unlinkCancelledWaiters</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 会检查尾部的 waiter 是不是已经不是CONDITION状态了</span></span><br><span class="line"><span class="comment">// 如果不是，删除这些 waiter</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = firstWaiter;</span><br><span class="line">    <span class="comment">// trail 表示上一个状态,这个字段作用非常大，可以把状态都是 CONDITION 的 node 串联起来，即使 node 之间有其他节点都可以</span></span><br><span class="line">    Node trail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node next = t.nextWaiter;</span><br><span class="line">        <span class="comment">// 当前node的状态不是CONDITION，删除自己</span></span><br><span class="line">        <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">            <span class="comment">//删除当前node</span></span><br><span class="line">            t.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 如果 trail 是空的，咱们循环又是从头开始的，说明从头到当前节点的状态都不是 CONDITION</span></span><br><span class="line">            <span class="comment">// 都已经被删除了，所以移动队列头节点到当前节点的下一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (trail == <span class="keyword">null</span>)</span><br><span class="line">                firstWaiter = next;</span><br><span class="line">            <span class="comment">// 如果找到上次状态是CONDITION的节点的话，先把当前节点删掉，然后把自己挂到上一个状态是 CONDITION 的节点上</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                trail.nextWaiter = next;</span><br><span class="line">            <span class="comment">// 遍历结束，最后一次找到的CONDITION节点就是尾节点</span></span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                lastWaiter = trail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 状态是 CONDITION 的 Node</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            trail = t;</span><br><span class="line">        <span class="comment">// 继续循环，循环顺序从头到尾</span></span><br><span class="line">        t = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了方便大家理解这个方法，画了一个释义图，如下：<br><img src="http://img.mukewang.com/5dba408600017eaf07211157.png" alt="图片描述"></p>
<h4 id="2-2-单个唤醒-signal"><a href="#2-2-单个唤醒-signal" class="headerlink" title="2.2 单个唤醒 signal"></a>2.2 单个唤醒 signal</h4><p>signal 方法是唤醒的意思，比如之前队列满了，有了一些线程因为 take 操作而被阻塞进条件队列中，突然队列中的元素被线程 A 消费了，线程 A 就会调用 signal 方法，唤醒之前阻塞的线程，会从条件队列的头节点开始唤醒（流程见整体架构图中蓝色部分），源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 唤醒阻塞在条件队列中的节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">// 从头节点开始唤醒</span></span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// doSignal 方法会把条件队列中的节点转移到同步队列中去</span></span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把条件队列头节点转移到同步队列去</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// nextWaiter为空，说明到队尾了</span></span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">            lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 从队列头部开始唤醒，所以直接把头节点.next 置为 null，这种操作其实就是把 node 从条件队列中移除了</span></span><br><span class="line">        <span class="comment">// 这里有个重要的点是，每次唤醒都是从队列头部开始唤醒，所以把 next 置为 null 没有关系，如果唤醒是从任意节点开始唤醒的话，就会有问题，容易造成链表的割裂</span></span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// transferForSignal 方法会把节点转移到同步队列中去</span></span><br><span class="line">        <span class="comment">// 通过 while 保证 transferForSignal 能成功</span></span><br><span class="line">        <span class="comment">// 等待队列的 node 不用管他，在 await 的时候，会自动清除状态不是 Condition 的节点(通过 unlinkCancelledWaiters 方法)</span></span><br><span class="line">        <span class="comment">// (first = firstWaiter) != null  = true 的话，表示还可以继续循环， = false 说明队列中的元素已经循环完了</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>我们来看下最关键的方法：transferForSignal。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回 true 表示转移成功， false 失败</span></span><br><span class="line"><span class="comment">// 大概思路：</span></span><br><span class="line"><span class="comment">// 1. node 追加到同步队列的队尾</span></span><br><span class="line"><span class="comment">// 2. 将 node 的前一个节点状态置为 SIGNAL，成功直接返回，失败直接唤醒</span></span><br><span class="line"><span class="comment">// 可以看出来 node 的状态此时是 0 了</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If cannot change waitStatus, the node has been cancelled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 将 node 的状态从 CONDITION 修改成初始化，失败返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前队列加入到同步队列，返回的 p 是 node 在同步队列中的前一个节点</span></span><br><span class="line">    <span class="comment">// 看命名是 p，实际是 pre 单词的缩写</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="comment">// 状态修改成 SIGNAL，如果成功直接返回</span></span><br><span class="line">    <span class="comment">// 把当前节点的前一个节点修改成 SIGNAL 的原因，是因为 SIGNAL 本身就表示当前节点后面的节点都是需要被唤醒的</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        <span class="comment">// 如果 p 节点被取消，或者状态不能修改成SIGNAL，直接唤醒</span></span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个源码下来，我们可以看到，唤醒条件队列中的节点，实际上就是把条件队列中的节点转移到同步队列中，并把其前置节点状态置为 SIGNAL。</p>
<h4 id="2-3-全部唤醒-signalAll"><a href="#2-3-全部唤醒-signalAll" class="headerlink" title="2.3 全部唤醒 signalAll"></a>2.3 全部唤醒 signalAll</h4><p>signalAll 的作用是唤醒条件队列中的全部节点，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">// 拿到头节点</span></span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 从头节点开始唤醒条件队列中所有的节点</span></span><br><span class="line">        doSignalAll(first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把条件队列所有节点依次转移到同步队列去</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignalAll</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    lastWaiter = firstWaiter = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 拿出条件队列队列头节点的下一个节点</span></span><br><span class="line">        Node next = first.nextWaiter;</span><br><span class="line">        <span class="comment">// 把头节点从条件队列中删除</span></span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 头节点转移到同步队列中去</span></span><br><span class="line">        transferForSignal(first);</span><br><span class="line">        <span class="comment">// 开始循环头节点的下一个节点</span></span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (first != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中可以看出，其本质就是 for 循环调用 transferForSignal 方法，将条件队列中的节点循环转移到同步队列中去。</p>
<h3 id="3-总结-5"><a href="#3-总结-5" class="headerlink" title="3 总结"></a>3 总结</h3><p>AQS 源码终于说完了，你都懂了么，可以在默默回忆一下 AQS 架构图，看看这张图现在能不能看懂了。<img src="http://img.mukewang.com/5dba40350001cb6f21120846.png" alt="图片描述"></p>
<h2 id="32-ReentrantLock-源码解析"><a href="#32-ReentrantLock-源码解析" class="headerlink" title="32 ReentrantLock 源码解析"></a><strong>32 ReentrantLock 源码解析</strong></h2><h3 id="引导语-29"><a href="#引导语-29" class="headerlink" title="引导语"></a>引导语</h3><p>上两小节我们学习了 AQS，本章我们就要来学习一下第一个 AQS 的实现类：ReentrantLock，看看其底层是如何组合 AQS ，实现了自己的那些功能。</p>
<p>本章的描述思路是先描述清楚 ReentrantLock 的构成组件，然后使用加锁和释放锁的方法把这些组件串起来。</p>
<h3 id="1-类注释-2"><a href="#1-类注释-2" class="headerlink" title="1 类注释"></a>1 类注释</h3><p>ReentrantLock 中文我们习惯叫做可重入互斥锁，可重入的意思是同一个线程可以对同一个共享资源重复的加锁或释放锁，互斥就是 AQS 中的排它锁的意思，只允许一个线程获得锁。</p>
<p>我们来一起来看下类注释上都有哪些重要信息：</p>
<ol>
<li>可重入互斥锁，和 synchronized 锁具有同样的功能语义，但更有扩展性；</li>
<li>构造器接受 fairness 的参数，fairness 是 ture 时，保证获得锁时的顺序，false 不保证；</li>
<li>公平锁的吞吐量较低，获得锁的公平性不能代表线程调度的公平性；</li>
<li>tryLock() 无参方法没有遵循公平性，是非公平的（lock 和 unlock 都有公平和非公平，而 tryLock 只有公平锁，所以单独拿出来说一说）。</li>
</ol>
<p>我们补充一下第二点，ReentrantLock 的公平和非公平，是针对获得锁来说的，如果是公平的，可以保证同步队列中的线程从头到尾的顺序依次获得锁，非公平的就无法保证，在释放锁的过程中，我们是没有公平和非公平的说法的。</p>
<h3 id="2-类结构"><a href="#2-类结构" class="headerlink" title="2 类结构"></a>2 类结构</h3><p>ReentrantLock 类本身是不继承 AQS 的，实现了 Lock 接口，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>Lock 接口定义了各种加锁，释放锁的方法，接口有如下几个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获得锁方法，获取不到锁的线程会到同步队列中阻塞排队</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取可中断的锁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="comment">// 尝试获得锁，如果锁空闲，立马返回 true，否则返回 false</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 带有超时等待时间的锁，如果超时时间到了，仍然没有获得锁，返回 false</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 得到新的 Condition</span></span><br><span class="line"><span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>ReentrantLock 就负责实现这些接口，我们使用时，直接面对的也是这些方法，这些方法的底层实现都是交给 Sync 内部类去实现的，Sync 类的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>Sync 继承了 AbstractQueuedSynchronizer ，所以 Sync 就具有了锁的框架，根据 AQS 的框架，Sync 只需要实现 AQS 预留的几个方法即可，但 Sync 也只是实现了部分方法，还有一些交给子类 NonfairSync 和 FairSync 去实现了，NonfairSync 是非公平锁，FairSync 是公平锁，定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步器 Sync 的两个子类锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>几个类整体的结构如下：<br><img src="http://img.mukewang.com/5dc3836d0001e9e407620694.png" alt="图片描述"></p>
<p>图中 Sync、NonfairSync、FairSync 都是静态内部类的方式实现的，这个也符合 AQS 框架定义的实现标准。</p>
<h3 id="3-构造器"><a href="#3-构造器" class="headerlink" title="3 构造器"></a>3 构造器</h3><p>ReentrantLock 构造器有两种，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无参数构造器，相当于 ReentrantLock(false)，默认是非公平的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无参构造器默认构造是非公平的锁，有参构造器可以选择。</p>
<p>从构造器中可以看出，公平锁是依靠 FairSync 实现的，非公平锁是依靠 NonfairSync 实现的。</p>
<h3 id="4-Sync-同步器"><a href="#4-Sync-同步器" class="headerlink" title="4 Sync 同步器"></a>4 Sync 同步器</h3><p>Sync 表示同步器，继承了 AQS，UML 图如下：<br><img src="http://img.mukewang.com/5dc3834e00010f2b14020610.png" alt="图片描述"></p>
<p>从 UML 图中可以看出，lock 方法是个抽象方法，留给 FairSync 和 NonfairSync 两个子类去实现，我们一起来看下剩余重要的几个方法。</p>
<h4 id="4-1-nonfairTryAcquire"><a href="#4-1-nonfairTryAcquire" class="headerlink" title="4.1 nonfairTryAcquire"></a>4.1 nonfairTryAcquire</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 尝试获得非公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 同步器的状态是 0，表示同步器的锁没有人持有</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前线程持有锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">// 标记当前持有锁的线程是谁</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前线程已经持有锁了，同一个线程可以对同一个资源重复加锁，代码实现的是可重入锁</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 当前线程持有锁的数量 + acquires</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="comment">// int 是有最大值的，&lt;0 表示持有锁的数量超过了 int 的最大值</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则线程进入同步队列</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码有三点需要注意：</p>
<ol>
<li>通过判断 AQS 的 state 的状态来决定是否可以获得锁，0 表示锁是空闲的；</li>
<li>else if 的代码体现了可重入加锁，同一个线程对共享资源重入加锁，底层实现就是把 state + 1，并且可重入的次数是有限制的，为 Integer 的最大值；</li>
<li>这个方法是非公平的，所以只有非公平锁才会用到，公平锁是另外的实现。</li>
</ol>
<p>无参的 tryLock 方法调用的就是此方法，tryLock 的方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 入参数是 1 表示尝试获得一次锁</span></span><br><span class="line">    <span class="keyword">return</span> sync.nonfairTryAcquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-1-tryRelease"><a href="#4-1-tryRelease" class="headerlink" title="4.1 tryRelease"></a>4.1 tryRelease</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 释放锁方法，非公平和公平锁都使用</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前同步器的状态减去释放的个数，releases 一般为 1</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="comment">// 当前线程根本都不持有锁，报错</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 如果 c 为 0，表示当前线程持有的锁都释放了</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 c 不为 0，那么就是可重入锁，并且锁没有释放完，用 state 减去 releases 即可，无需做其他操作</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tryRelease 方法是公平锁和非公平锁都公用的，在锁释放的时候，是没有公平和非公平的说法的。</p>
<p>从代码中可以看到，锁最终被释放的标椎是 state 的状态为 0，在重入加锁的情况下，需要重入解锁相应的次数后，才能最终把锁释放，比如线程 A 对共享资源 B 重入加锁 5 次，那么释放锁的话，也需要释放 5 次之后，才算真正的释放该共享资源了。</p>
<h3 id="5-FairSync-公平锁"><a href="#5-FairSync-公平锁" class="headerlink" title="5 FairSync 公平锁"></a>5 FairSync 公平锁</h3><p>FairSync 公平锁只实现了 lock 和 tryAcquire 两个方法，lock 方法非常简单，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// acquire 是 AQS 的方法，表示先尝试获得锁，失败之后进入同步队列阻塞等待</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tryAcquire 方法是 AQS 在 acquire 方法中留给子类实现的抽象方法，FairSync 中实现的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// hasQueuedPredecessors 是实现公平的关键</span></span><br><span class="line">        <span class="comment">// 会判断当前线程是不是属于同步队列的头节点的下一个节点(头节点是释放锁的节点)</span></span><br><span class="line">        <span class="comment">// 如果是(返回false)，符合先进先出的原则，可以获得锁</span></span><br><span class="line">        <span class="comment">// 如果不是(返回true)，则继续等待</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 可重入锁</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码和 Sync 的 nonfairTryAcquire 方法实现类似，唯一不同的是在获得锁时使用 hasQueuedPredecessors 方法体现了其公平性。</p>
<h3 id="6-NonfairSync-非公平锁"><a href="#6-NonfairSync-非公平锁" class="headerlink" title="6 NonfairSync 非公平锁"></a>6 NonfairSync 非公平锁</h3><p>NonfairSync 底层实现了 lock 和 tryAcquire 两个方法，如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加锁</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// cas 给 state 赋值</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        <span class="comment">// cas 赋值成功，代表拿到当前锁，记录拿到锁的线程</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// acquire 是抽象类AQS的方法,</span></span><br><span class="line">        <span class="comment">// 会再次尝试获得锁，失败会进入到同步队列中</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 直接使用的是 Sync.nonfairTryAcquire 方法 </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-如何串起来"><a href="#7-如何串起来" class="headerlink" title="7 如何串起来"></a>7 如何串起来</h3><p>以上内容主要说了 ReentrantLock 的基本结构，比较零散，那么这些零散的结构如何串联起来呢？我们是通过 lock、tryLock、unlock 这三个 API 将以上几个类串联起来，我们来一一看下。</p>
<h4 id="7-1-lock-加锁"><a href="#7-1-lock-加锁" class="headerlink" title="7.1 lock 加锁"></a>7.1 lock 加锁</h4><p>lock 的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其底层的调用关系(只是简单表明调用关系，并不是完整分支图)如下：<br><img src="http://img.mukewang.com/5dc38319000106d713060430.png" alt="图片描述"></p>
<h4 id="7-2-tryLock-尝试加锁"><a href="#7-2-tryLock-尝试加锁" class="headerlink" title="7.2 tryLock 尝试加锁"></a>7.2 tryLock 尝试加锁</h4><p>tryLock 有两个方法，一种是无参的，一种提供了超时时间的入参，两种内部是不同的实现机制，代码分别如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无参构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.nonfairTryAcquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// timeout 为超时的时间，在时间内，仍没有得到锁，会返回 false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们一起看下两个 tryLock 的调用关系图，下图显示的是无参 tryLock 的调用关系图，如下：<br><img src="http://img.mukewang.com/5dc382ff00012db705660184.png" alt="图片描述"></p>
<p>我们需要注意的是 tryLock 无参方法底层走的就是非公平锁实现，没有公平锁的实现。</p>
<p>下图展示的是带有超时时间的有参 tryLock 的调用实现图：<br><img src="http://img.mukewang.com/5dc3824f0001906d08120370.png" alt="图片描述"></p>
<h4 id="7-3-unlock-释放锁"><a href="#7-3-unlock-释放锁" class="headerlink" title="7.3 unlock 释放锁"></a>7.3 unlock 释放锁</h4><p>unlock 释放锁的方法，底层调用的是 Sync 同步器的 release 方法，release 是 AQS 的方法，分成两步：</p>
<ol>
<li>尝试释放锁，如果释放失败，直接返回 false；</li>
<li>释放成功，从同步队列的头节点的下一个节点开始唤醒，让其去竞争锁。</li>
</ol>
<p>第一步就是我们上文中 Sync 的 tryRelease 方法（4.1），第二步 AQS 已经实现了。</p>
<p>unLock 的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="7-4-Condition"><a href="#7-4-Condition" class="headerlink" title="7.4 Condition"></a>7.4 Condition</h4><p>ReentrantLock 对 Condition 并没有改造，直接使用 AQS 的 ConditionObject 即可。</p>
<h3 id="8-总结"><a href="#8-总结" class="headerlink" title="8 总结"></a>8 总结</h3><p>这就是我们在研究完 AQS 源码之后，碰到的第一个锁，是不是感觉很简单，AQS 搭建了整个锁架构，子类锁只需要根据场景，实现 AQS 对应的方法即可，不仅仅是 ReentrantLock 是这样，JUC 中的其它锁也都是这样，只要对 AQS 了如指掌，锁其实非常简单。</p>
<h2 id="33-CountDownLatch、Atomic-等其它源码解析"><a href="#33-CountDownLatch、Atomic-等其它源码解析" class="headerlink" title="33 CountDownLatch、Atomic 等其它源码解析"></a><strong>33 CountDownLatch、Atomic 等其它源码解析</strong></h2><h3 id="引导语-30"><a href="#引导语-30" class="headerlink" title="引导语"></a>引导语</h3><p>本小节和大家一起来看看 CountDownLatch 和 Atomic 打头的原子操作类，CountDownLatch 的源码非常少，看起来比较简单，但 CountDownLatch 的实际应用却不是很容易；Atomic 原子操作类就比较好理解和应用，接下来我们分别来看一下。</p>
<h3 id="1-CountDownLatch"><a href="#1-CountDownLatch" class="headerlink" title="1 CountDownLatch"></a>1 CountDownLatch</h3><p>CountDownLatch 中文有的叫做计数器，也有翻译为计数锁，其最大的作用不是为了加锁，而是通过计数达到等待的功能，主要有两种形式的等待：</p>
<ol>
<li>让一组线程在全部启动完成之后，再一起执行（先启动的线程需要阻塞等待后启动的线程，直到一组线程全部都启动完成后，再一起执行）；</li>
<li>主线程等待另外一组线程都执行完成之后，再继续执行。</li>
</ol>
<p>我们会举一个示例来演示这两种情况，但在这之前，我们先来看看 CountDownLatch 的底层源码实现，这样就会清晰一点，不然一开始就来看示例，估计很难理解。</p>
<p>CountDownLatch 有两个比较重要的 API，分别是 await 和 countDown，管理着线程能否获得锁和锁的释放（也可以称为对 state 的计数增加和减少）。</p>
<h4 id="1-1-await"><a href="#1-1-await" class="headerlink" title="1.1 await"></a>1.1 await</h4><p>await 我们可以叫做等待，也可以叫做加锁，有两种不同入参的方法，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 带有超时时间的，最终都会转化成毫秒</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个方法底层使用的都是 sync，sync 是一个同步器，是 CountDownLatch 的内部类实现的，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出来 Sync 继承了 AbstractQueuedSynchronizer，具备了同步器的通用功能。</p>
<p>无参 await 底层使用的是 acquireSharedInterruptibly 方法，有参的使用的是 tryAcquireSharedNanos 方法，这两个方法都是 AQS 的方法，底层实现很相似，主要分成两步：</p>
<ol>
<li>使用子类的 tryAcquireShared 方法尝试获得锁，如果获取了锁直接返回，获取不到锁走 2；</li>
<li>获取不到锁，用 Node 封装一下当前线程，追加到同步队列的尾部，等待在合适的时机去获得锁。</li>
</ol>
<p>第二步是 AQS 已经实现了，第一步 tryAcquireShared 方法是交给 Sync 实现的，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果当前同步器的状态是 0 的话，表示可获得锁</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获得锁的代码也很简单，直接根据同步器的 state 字段来进行判断，但还是有两点需要注意一下：</p>
<ol>
<li>获得锁时，state 的值不会发生变化，像 ReentrantLock 在获得锁时，会把 state + 1，但 CountDownLatch 不会；</li>
<li>CountDownLatch 的 state 并不是 AQS 的默认值 0，而是可以赋值的，是在 CountDownLatch 初始化的时候赋值的，代码如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化,count 代表 state 的初始化值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;count &lt; 0&quot;</span>);</span><br><span class="line">    <span class="comment">// new Sync 底层代码是 state = count;</span></span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的初始化的 count 和一般的锁意义不太一样，count 表示我们希望等待的线程数，在两种不同的等待场景中，count 有不同的含义：</p>
<ol>
<li>让一组线程在全部启动完成之后，再一起执行的等待场景下， count 代表一组线程的个数；</li>
<li>主线程等待另外一组线程都执行完成之后，再继续执行的等待场景下，count 代表一组线程的个数。</li>
</ol>
<p>所以我们可以把 count 看做我们希望等待的一组线程的个数，可能我们是等待一组线程全部启动完成，可能我们是等待一组线程全部执行完成。</p>
<h4 id="1-2-countDown"><a href="#1-2-countDown" class="headerlink" title="1.2 countDown"></a>1.2 countDown</h4><p>countDown 中文翻译为倒计时，每调用一次，都会使 state 减一，底层调用的方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>releaseShared 是 AQS 定义的方法，方法主要分成两步：</p>
<ol>
<li>尝试释放锁（tryReleaseShared），锁释放失败直接返回，释放成功走 2；</li>
<li>释放当前节点的后置等待节点。</li>
</ol>
<p>第二步 AQS 已经实现了，第一步是 Sync 实现的，我们一起来看下 tryReleaseShared 方法的实现源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对 state 进行递减，直到 state 变成 0；</span></span><br><span class="line"><span class="comment">// state 递减为 0 时，返回 true，其余返回 false</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自旋保证 CAS 一定可以成功</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// state 已经是 0 了，直接返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 对 state 进行递减</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中可以看到，只有到 count 递减到 0 时，countDown 才会返回 true。</p>
<h4 id="1-3-示例"><a href="#1-3-示例" class="headerlink" title="1.3 示例"></a>1.3 示例</h4><p>看完 CountDownLatch 两个重要 API 后，我们来实现文章开头说的两个功能：</p>
<ol>
<li>让一组线程在全部启动完成之后，再一起执行；</li>
<li>主线程等待另外一组线程都执行完成之后，再继续执行。</li>
</ol>
<p>代码在 CountDownLatchDemo 类中，大家可以调试看看，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 线程任务</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义计数锁用来实现功能 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch startSignal;</span><br><span class="line">    <span class="comment">// 定义计数锁用来实现功能 2</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch doneSignal;</span><br><span class="line"></span><br><span class="line">    Worker(CountDownLatch startSignal, CountDownLatch doneSignal) &#123;</span><br><span class="line">      <span class="keyword">this</span>.startSignal = startSignal;</span><br><span class="line">      <span class="keyword">this</span>.doneSignal = doneSignal;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 子线程做的事情</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; begin&quot;</span>);</span><br><span class="line">        <span class="comment">// await 时有两点需要注意：await 时 state 不会发生变化，2：startSignal 的state初始化是 1，所以所有子线程都是获取不到锁的，都需要到同步队列中去等待，达到先启动的子线程等待后面启动的子线程的结果</span></span><br><span class="line">        startSignal.await();</span><br><span class="line">        doWork();</span><br><span class="line">        <span class="comment">// countDown 每次会使 state 减一，doneSignal 初始化为 9，countDown 前 8 次执行都会返回 false (releaseShared 方法)，执行第 9 次时，state 递减为 0，会 countDown 成功，表示所有子线程都执行完了，会释放 await 在 doneSignal 上的主线程</span></span><br><span class="line">        doneSignal.countDown();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; end&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">      &#125; <span class="comment">// return;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName()+<span class="string">&quot;sleep 5s …………&quot;</span>);</span><br><span class="line">      Thread.sleep(<span class="number">5000l</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// state 初始化为 1 很关键，子线程是不断的 await，await 时 state 是不会变化的，并且发现 state 都是 1，所有线程都获取不到锁</span></span><br><span class="line">    <span class="comment">// 造成所有线程都到同步队列中去等待，当主线程执行 countDown 时，就会一起把等待的线程给释放掉</span></span><br><span class="line">    CountDownLatch startSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// state 初始化成 9，表示有 9 个子线程执行完成之后，会唤醒主线程</span></span><br><span class="line">    CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) <span class="comment">// create and start threads</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(startSignal, doneSignal)).start();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;main thread begin&quot;</span>);</span><br><span class="line">    <span class="comment">// 这行代码唤醒 9 个子线程，开始执行(因为 startSignal 锁的状态是 1，所以调用一次 countDown 方法就可以释放9个等待的子线程)</span></span><br><span class="line">    startSignal.countDown();</span><br><span class="line">    <span class="comment">// 这行代码使主线程陷入沉睡，等待 9 个子线程执行完成之后才会继续执行(就是等待子线程执行 doneSignal.countDown())</span></span><br><span class="line">    doneSignal.await();           </span><br><span class="line">    System.out.println(<span class="string">&quot;main thread end&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">执行结果：</span><br><span class="line">Thread-<span class="number">0</span> begin</span><br><span class="line">Thread-<span class="number">1</span> begin</span><br><span class="line">Thread-<span class="number">2</span> begin</span><br><span class="line">Thread-<span class="number">3</span> begin</span><br><span class="line">Thread-<span class="number">4</span> begin</span><br><span class="line">Thread-<span class="number">5</span> begin</span><br><span class="line">Thread-<span class="number">6</span> begin</span><br><span class="line">Thread-<span class="number">7</span> begin</span><br><span class="line">Thread-<span class="number">8</span> begin</span><br><span class="line">main thread begin</span><br><span class="line">Thread-<span class="number">0</span>sleep <span class="number">5</span>s …………</span><br><span class="line">Thread-<span class="number">1</span>sleep <span class="number">5</span>s …………</span><br><span class="line">Thread-<span class="number">4</span>sleep <span class="number">5</span>s …………</span><br><span class="line">Thread-<span class="number">3</span>sleep <span class="number">5</span>s …………</span><br><span class="line">Thread-<span class="number">2</span>sleep <span class="number">5</span>s …………</span><br><span class="line">Thread-<span class="number">8</span>sleep <span class="number">5</span>s …………</span><br><span class="line">Thread-<span class="number">7</span>sleep <span class="number">5</span>s …………</span><br><span class="line">Thread-<span class="number">6</span>sleep <span class="number">5</span>s …………</span><br><span class="line">Thread-<span class="number">5</span>sleep <span class="number">5</span>s …………</span><br><span class="line">Thread-<span class="number">0</span> end</span><br><span class="line">Thread-<span class="number">1</span> end</span><br><span class="line">Thread-<span class="number">4</span> end</span><br><span class="line">Thread-<span class="number">3</span> end</span><br><span class="line">Thread-<span class="number">2</span> end</span><br><span class="line">Thread-<span class="number">8</span> end</span><br><span class="line">Thread-<span class="number">7</span> end</span><br><span class="line">Thread-<span class="number">6</span> end</span><br><span class="line">Thread-<span class="number">5</span> end</span><br><span class="line">main thread end</span><br></pre></td></tr></table></figure>

<p>从执行结果中，可以看出已经实现了以上两个功能，实现比较绕，大家可以根据注释，debug 看一看。</p>
<h3 id="2-Atomic-原子操作类"><a href="#2-Atomic-原子操作类" class="headerlink" title="2 Atomic 原子操作类"></a>2 Atomic 原子操作类</h3><p>Atomic 打头的原子操作类有很多，涉及到 Java 常用的数字类型的，基本都有相应的 Atomic 原子操作类，如下图所示：<br><img src="http://img.mukewang.com/5dc384550001ccb314920926.png" alt="图片描述"></p>
<p>Atomic 打头的原子操作类，在高并发场景下，都是线程安全的，我们可以放心使用。</p>
<p>我们以 AtomicInteger 为例子，来看下主要的底层实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AtomicInteger</span><span class="params">(<span class="keyword">int</span> initialValue)</span> </span>&#123;</span><br><span class="line">    value = initialValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 得到当前值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自增 1，并返回自增之前的值    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自减 1，并返回自增之前的值    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中，我们可以看到，线程安全的操作方法，底层都是使用 unsafe 方法实现，以上几个 unsafe 方法不是使用 Java 实现的，都是线程安全的。</p>
<p>AtomicInteger 是对 int 类型的值进行自增自减，那如果 Atomic 的对象是个自定义类怎么办呢，Java 也提供了自定义对象的原子操作类，叫做 AtomicReference。AtomicReference 类可操作的对象是个泛型，所以支持自定义类，其底层是没有自增方法的，操作的方法可以作为函数入参传递，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对 x 执行 accumulatorFunction 操作</span></span><br><span class="line"><span class="comment">// accumulatorFunction 是个函数，可以自定义想做的事情</span></span><br><span class="line"><span class="comment">// 返回老值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getAndAccumulate</span><span class="params">(V x,</span></span></span><br><span class="line"><span class="function"><span class="params">                                BinaryOperator&lt;V&gt; accumulatorFunction)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// prev 是老值，next 是新值</span></span><br><span class="line">    V prev, next;</span><br><span class="line">    <span class="comment">// 自旋 + CAS 保证一定可以替换老值</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get();</span><br><span class="line">        <span class="comment">// 执行自定义操作</span></span><br><span class="line">        next = accumulatorFunction.apply(prev, x);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-总结-6"><a href="#3-总结-6" class="headerlink" title="3 总结"></a>3 总结</h3><p>CountDownLatch 的源码实现简单，但真的要用好还是不简单的，其使用场景比较复杂，建议同学们可以 debug 一下 CountDownLatchDemo，在增加实战能力基础上，增加底层的理解能力。</p>
<h2 id="34-只求问倒：连环相扣系列锁面试题"><a href="#34-只求问倒：连环相扣系列锁面试题" class="headerlink" title="34 只求问倒：连环相扣系列锁面试题"></a><strong>34 只求问倒：连环相扣系列锁面试题</strong></h2><h3 id="引导语-31"><a href="#引导语-31" class="headerlink" title="引导语"></a>引导语</h3><p>面试中，问锁主要是两方面：锁的日常使用场景 + 锁原理，锁的日常使用场景主要考察对锁 API 的使用熟练度，看看你是否真的使用过这些 API，而不是纸上谈兵，锁原理主要就是问 AQS 底层的源码原理了，如果问得更加深入的话，可能会现场让你实现一个简单的锁，简单要求的会让你直接使用 AQS API，复杂要求的可能需要重新实现 AQS。</p>
<p>接下来我们一起看一看关于锁的常见源码面试题。</p>
<h3 id="1-AQS-相关面试题"><a href="#1-AQS-相关面试题" class="headerlink" title="1 AQS 相关面试题"></a>1 AQS 相关面试题</h3><h4 id="1-1-说说自己对-AQS-的理解？"><a href="#1-1-说说自己对-AQS-的理解？" class="headerlink" title="1.1 说说自己对 AQS 的理解？"></a>1.1 说说自己对 AQS 的理解？</h4><p>答：回答这样的问题的时候，面试官主要考察的是你对 AQS 的知识有没有系统的整理，建议回答的方向是由大到小，由全到细，由使用到原理。</p>
<p>如果和面试官面对面的话，可以边说边画出我们在 AQS 源码解析上中画出的整体架构图，并且可以这么说：</p>
<ol>
<li>AQS 是一个锁框架，它定义了锁的实现机制，并开放出扩展的地方，让子类去实现，比如我们在 lock 的时候，AQS 开放出 state 字段，让子类可以根据 state 字段来决定是否能够获得锁，对于获取不到锁的线程 AQS 会自动进行管理，无需子类锁关心，这就是 lock 时锁的内部机制，封装的很好，又暴露出子类锁需要扩展的地方；</li>
<li>AQS 底层是由同步队列 + 条件队列联手组成，同步队列管理着获取不到锁的线程的排队和释放，条件队列是在一定场景下，对同步队列的补充，比如获得锁的线程从空队列中拿数据，肯定是拿不到数据的，这时候条件队列就会管理该线程，使该线程阻塞；</li>
<li>AQS 围绕两个队列，提供了四大场景，分别是：获得锁、释放锁、条件队列的阻塞，条件队列的唤醒，分别对应着 AQS 架构图中的四种颜色的线的走向。</li>
</ol>
<p>以上三点都是 AQS 全局方面的描述，接着你可以问问面试官要不要说细一点，可以的话，按照 AQS 源码解析上下两篇，把四大场景都说一下就好了。</p>
<p>这样说的好处是很多的：</p>
<ol>
<li>面试的主动权把握在自己手里，而且都是自己掌握的知识点；</li>
<li>由全到细的把 AQS 全部说完，会给面试官一种你对 AQS 了如指掌的感觉，再加上全部说完耗时会很久，面试时间又很有限，面试官就不会再问关于 AQS 一些刁钻的问题了，这样 AQS 就可以轻松过关。</li>
</ol>
<p>当然如果你对 AQS 了解的不是很深，那么就大概回答下 AQS 的大体架构就好了，就不要说的特别细，免得给自己挖坑。</p>
<h4 id="1-2-多个线程通过锁请求共享资源，获取不到锁的线程怎么办？"><a href="#1-2-多个线程通过锁请求共享资源，获取不到锁的线程怎么办？" class="headerlink" title="1.2 多个线程通过锁请求共享资源，获取不到锁的线程怎么办？"></a>1.2 多个线程通过锁请求共享资源，获取不到锁的线程怎么办？</h4><p>答：加锁(排它锁)主要分为以下四步：</p>
<ol>
<li>尝试获得锁，获得锁了直接返回，获取不到锁的走到 2；</li>
<li>用 Node 封装当前线程，追加到同步队列的队尾，追加到队尾时，又有两步，如 3 和 4；</li>
<li>自旋 + CAS 保证前一个节点的状态置为 signal；</li>
<li>阻塞自己，使当前线程进入等待状态。</li>
</ol>
<p>获取不到锁的线程会进行 2、3、4 步，最终会陷入等待状态，这个描述的是排它锁。</p>
<h4 id="1-3-问题-1-2-中，排它锁和共享锁的处理机制是一样的么？"><a href="#1-3-问题-1-2-中，排它锁和共享锁的处理机制是一样的么？" class="headerlink" title="1.3 问题 1.2 中，排它锁和共享锁的处理机制是一样的么？"></a>1.3 问题 1.2 中，排它锁和共享锁的处理机制是一样的么？</h4><p>答：排它锁和共享锁在问题 1.2 中的 2、3、4 步骤都是一样的， 不同的是在于第一步，线程获得排它锁的时候，仅仅把自己设置为同步队列的头节点即可，但如果是共享锁的话，还会去唤醒自己的后续节点，一起来获得该锁。</p>
<h4 id="1-4-共享锁和排它锁的区别？"><a href="#1-4-共享锁和排它锁的区别？" class="headerlink" title="1.4 共享锁和排它锁的区别？"></a>1.4 共享锁和排它锁的区别？</h4><p>答：排它锁的意思是同一时刻，只能有一个线程可以获得锁，也只能有一个线程可以释放锁。</p>
<p>共享锁可以允许多个线程获得同一个锁，并且可以设置获取锁的线程数量，共享锁之所以能够做到这些，是因为线程一旦获得共享锁，把自己设置成同步队列的头节点后，会自动的去释放头节点后等待获取共享锁的节点，让这些等待节点也一起来获得共享锁，而排它锁就不会这么干。</p>
<h4 id="1-5-排它锁和共享锁说的是加锁时的策略，那么锁释放时有排它锁和共享锁的策略么？"><a href="#1-5-排它锁和共享锁说的是加锁时的策略，那么锁释放时有排它锁和共享锁的策略么？" class="headerlink" title="1.5 排它锁和共享锁说的是加锁时的策略，那么锁释放时有排它锁和共享锁的策略么？"></a>1.5 排它锁和共享锁说的是加锁时的策略，那么锁释放时有排它锁和共享锁的策略么？</h4><p>答：是的，排它锁和共享锁，主要体现在加锁时，多个线程能否获得同一个锁。</p>
<p>但在锁释放时，是没有排它锁和共享锁的概念和策略的，概念仅仅针对锁获取。</p>
<h4 id="1-6-描述下同步队列？"><a href="#1-6-描述下同步队列？" class="headerlink" title="1.6 描述下同步队列？"></a>1.6 描述下同步队列？</h4><p>答：同步队列底层的数据结构就是双向的链表，节点叫做 Node，头节点叫做 head，尾节点叫做 tail，节点和节点间的前后指向分别叫做 prev、next，如果是面对面面试的话，可以画一下 AQS 整体架构图中的同步队列。</p>
<p>同步队列的作用：阻塞获取不到锁的线程，并在适当时机释放这些线程。</p>
<p>实现的大致过程：当多个线程都来请求锁时，某一时刻有且只有一个线程能够获得锁（排它锁），那么剩余获取不到锁的线程，都会到同步队列中去排队并阻塞自己，当有线程主动释放锁时，就会从同步队列中头节点开始释放一个排队的线程，让线程重新去竞争锁。</p>
<h4 id="1-7-描述下线程入、出同步队列的时机和过程？"><a href="#1-7-描述下线程入、出同步队列的时机和过程？" class="headerlink" title="1.7 描述下线程入、出同步队列的时机和过程？"></a>1.7 描述下线程入、出同步队列的时机和过程？</h4><p>答：(排它锁为例)从 AQS 整体架构图中，可以看出同步队列入队和出队都是有两个箭头指向，所以入队和出队的时机各有两个。</p>
<p>同步队列入队时机：</p>
<ol>
<li>多个线程请求锁，获取不到锁的线程需要到同步队列中排队阻塞；</li>
<li>条件队列中的节点被唤醒，会从条件队列中转移到同步队列中来。</li>
</ol>
<p>同步队列出队时机：</p>
<ol>
<li>锁释放时，头节点出队；</li>
<li>获得锁的线程，进入条件队列时，会释放锁，同步队列头节点开始竞争锁。</li>
</ol>
<p>四个时机的过程可以参考 AQS 源码解析，1 参考 acquire 方法执行过程，2 参考 signal 方法，3 参考 release 方法，4 参考 await 方法。</p>
<h4 id="1-8-为什么-AQS-有了同步队列之后，还需要条件队列？"><a href="#1-8-为什么-AQS-有了同步队列之后，还需要条件队列？" class="headerlink" title="1.8 为什么 AQS 有了同步队列之后，还需要条件队列？"></a>1.8 为什么 AQS 有了同步队列之后，还需要条件队列？</h4><p>答：的确，一般情况下，我们只需要有同步队列就好了，但在上锁后，需要操作队列的场景下，一个同步队列就搞不定了，需要条件队列进行功能补充，比如当队列满时，执行 put 操作的线程会进入条件队列等待，当队列空时，执行 take 操作的线程也会进入条件队列中等待，从一定程度上来看，条件队列是对同步队列的场景功能补充。</p>
<h4 id="1-9-描述一下条件队列中的元素入队和出队的时机和过程？"><a href="#1-9-描述一下条件队列中的元素入队和出队的时机和过程？" class="headerlink" title="1.9 描述一下条件队列中的元素入队和出队的时机和过程？"></a>1.9 描述一下条件队列中的元素入队和出队的时机和过程？</h4><p>答：入队时机：执行 await 方法时，当前线程会释放锁，并进入到条件队列。</p>
<p>出队时机：执行 signal、signalAll 方法时，节点会从条件队列中转移到同步队列中。</p>
<p>具体的执行过程，可以参考源码解析中 await 和 signal 方法。</p>
<h4 id="1-10-描述一下条件队列中的节点转移到同步队列中去的时机和过程？"><a href="#1-10-描述一下条件队列中的节点转移到同步队列中去的时机和过程？" class="headerlink" title="1.10 描述一下条件队列中的节点转移到同步队列中去的时机和过程？"></a>1.10 描述一下条件队列中的节点转移到同步队列中去的时机和过程？</h4><p>答：时机：当有线程执行 signal、signalAll 方法时，从条件队列的头节点开始，转移到同步队列中去。</p>
<p>过程主要是以下几步：</p>
<ol>
<li>找到条件队列的头节点，头节点 next 属性置为 null，从条件队列中移除了；</li>
<li>头节点追加到同步队列的队尾；</li>
<li>头节点状态（waitStatus）从 CONDITION 修改成 0（初始化状态）；</li>
<li>将节点的前一个节点状态置为 SIGNAL。</li>
</ol>
<h4 id="1-11-线程入条件队列时，为什么需要释放持有的锁？"><a href="#1-11-线程入条件队列时，为什么需要释放持有的锁？" class="headerlink" title="1.11 线程入条件队列时，为什么需要释放持有的锁？"></a>1.11 线程入条件队列时，为什么需要释放持有的锁？</h4><p>答：原因很简单，如果当前线程不释放锁，一旦跑去条件队里中阻塞了，后续所有的线程都无法获得锁，正确的场景应该是：当前线程释放锁，到条件队列中去阻塞后，其他线程仍然可以获得当前锁。</p>
<h3 id="2-AQS-子类锁面试题"><a href="#2-AQS-子类锁面试题" class="headerlink" title="2 AQS 子类锁面试题"></a>2 AQS 子类锁面试题</h3><h4 id="2-1-你在工作中如何使用锁的，写一个看一看？"><a href="#2-1-你在工作中如何使用锁的，写一个看一看？" class="headerlink" title="2.1 你在工作中如何使用锁的，写一个看一看？"></a>2.1 你在工作中如何使用锁的，写一个看一看？</h4><p>答：这个照实说就好了，具体 demo 可以参考：demo.sixth.ConditionDemo。</p>
<h4 id="2-1-如果我要自定义锁，大概的实现思路是什么样子的？"><a href="#2-1-如果我要自定义锁，大概的实现思路是什么样子的？" class="headerlink" title="2.1 如果我要自定义锁，大概的实现思路是什么样子的？"></a>2.1 如果我要自定义锁，大概的实现思路是什么样子的？</h4><p>答：现在有很多类似的问题，比如让你自定义队列，自定义锁等等，面试官其实并不是想让我们重新造一个轮子，而是想考察一下我们对于队列、锁理解的深度，我们只需要选择自己最熟悉的 API 描述一下就好了，所以这题我们可以选择 ReentrantLock 来描述一下实现思路：</p>
<ol>
<li>新建内部类继承 AQS，并实现 AQS 的 tryAcquire 和 tryRelease 两个方法，在 tryAcquire 方法里面实现控制能否获取锁，比如当同步器状态 state 是 0 时，即可获得锁，在 tryRelease 方法里面控制能否释放锁，比如将同步器状态递减到 0 时，即可释放锁；</li>
<li>对外提供 lock、release 两个方法，lock 表示获得锁的方法，底层调用 AQS 的 acquire 方法，release 表示释放锁的方法，底层调用 AQS 的 release 方法。</li>
</ol>
<h4 id="2-2-描述-ReentrantLock-两大特性：可重入性和公平性？底层分别如何实现的？"><a href="#2-2-描述-ReentrantLock-两大特性：可重入性和公平性？底层分别如何实现的？" class="headerlink" title="2.2 描述 ReentrantLock 两大特性：可重入性和公平性？底层分别如何实现的？"></a>2.2 描述 ReentrantLock 两大特性：可重入性和公平性？底层分别如何实现的？</h4><p>答：可重入性说的是线程可以对共享资源重复加锁，对应的，释放时也可以重复释放，对于 ReentrantLock 来说，在获得锁的时候，state 会加 1，重复获得锁时，不断的对 state 进行递增即可，比如目前 state 是 4，表示线程已经对共享资源加锁了 4 次，线程每次释放共享资源的锁时，state 就会递减 1，直到递减到 0 时，才算真正释放掉共享资源。</p>
<p>公平性和非公平指的是同步队列中的线程得到锁的机制，如果同步队列中的线程按照阻塞的顺序得到锁，我们称之为公平的，反之是非公平的，公平的底层实现是 ReentrantLock 的 tryAcquire 方法（调用的是 AQS 的 hasQueuedPredecessors 方法）里面实现的，要释放同步队列的节点时（或者获得锁时），判断当前线程节点是不是同步队列的头节点的后一个节点，如果是就释放，不是则不能释放，通过这种机制，保证同步队列中的线程得到锁时，是按照从头到尾的顺序的。</p>
<h4 id="2-3-如果一个线程需要等待一组线程全部执行完之后再继续执行，有什么好的办法么？是如何实现的？"><a href="#2-3-如果一个线程需要等待一组线程全部执行完之后再继续执行，有什么好的办法么？是如何实现的？" class="headerlink" title="2.3 如果一个线程需要等待一组线程全部执行完之后再继续执行，有什么好的办法么？是如何实现的？"></a>2.3 如果一个线程需要等待一组线程全部执行完之后再继续执行，有什么好的办法么？是如何实现的？</h4><p>答：CountDownLatch 就提供了这样的机制，比如一组线程有 5 个，只需要在初始化 CountDownLatch 时，给同步器的 state 赋值为 5，主线程执行 CountDownLatch.await ，子线程都执行 CountDownLatch.countDown 即可。</p>
<h4 id="2-4-Atomic-原子操作类可以保证线程安全，如果操作的对象是自定义的类的话，要如何做呢？"><a href="#2-4-Atomic-原子操作类可以保证线程安全，如果操作的对象是自定义的类的话，要如何做呢？" class="headerlink" title="2.4 Atomic 原子操作类可以保证线程安全，如果操作的对象是自定义的类的话，要如何做呢？"></a>2.4 Atomic 原子操作类可以保证线程安全，如果操作的对象是自定义的类的话，要如何做呢？</h4><p>答： Java 为这种情况提供了一个 API：AtomicReference，AtomicReference 类可操作的对象是个泛型，所以支持自定义类。</p>
<h3 id="3-总结-7"><a href="#3-总结-7" class="headerlink" title="3 总结"></a>3 总结</h3><p>关于 AQS 和锁场景的面试题，其实网上也很多，各个大厂出的题目也都不一样，但考察问题的本质都是一致的，如果把 AQS 架构图中，AQS 的组成和四种颜色箭头的发起时机，调用过程都弄清楚了，回答 AQS 的各种问题都会游刃有余。</p>
<h2 id="35-经验总结：各种锁在工作中使用场景和细节"><a href="#35-经验总结：各种锁在工作中使用场景和细节" class="headerlink" title="35 经验总结：各种锁在工作中使用场景和细节"></a><strong>35 经验总结：各种锁在工作中使用场景和细节</strong></h2><h3 id="引导语-32"><a href="#引导语-32" class="headerlink" title="引导语"></a>引导语</h3><p>本章主要说一说锁在工作中的使用场景，主要以 synchronized 和 CountDownLatch 为例，会分别描述一下这两种锁的使用场景和姿势。</p>
<h3 id="1-synchronized"><a href="#1-synchronized" class="headerlink" title="1 synchronized"></a>1 synchronized</h3><p>synchronized 是可重入的排它锁，和 ReentrantLock 锁功能相似，任何使用 synchronized 的地方，几乎都可以使用 ReentrantLock 来代替，两者最大的相似点就是：可重入 + 排它锁，两者的区别主要有这些：</p>
<ol>
<li>ReentrantLock 的功能更加丰富，比如提供了 Condition，可以打断的加锁 API、能满足锁 + 队列的复杂场景等等；</li>
<li>ReentrantLock 有公平锁和非公平锁之分，而 synchronized 都是非公平锁；</li>
<li>两者的使用姿势也不同，ReentrantLock 需要申明，有加锁和释放锁的 API，而 synchronized 会自动对代码块进行加锁释放锁的操作，synchronized 使用起来更加方便。</li>
</ol>
<p>synchronized 和 ReentrantLock 功能相近，所以我们就以 synchronized 举例。</p>
<h4 id="1-1-共享资源初始化"><a href="#1-1-共享资源初始化" class="headerlink" title="1.1 共享资源初始化"></a>1.1 共享资源初始化</h4><p>在分布式的系统中，我们喜欢把一些死的配置资源在项目启动的时候加锁到 JVM 内存里面去，这样请求在拿这些共享配置资源时，就可直接从内存里面拿，不必每次都从数据库中拿，减少了时间开销。</p>
<p>一般这样的共享资源有：死的业务流程配置 + 死的业务规则配置。</p>
<p>共享资源初始化的步骤一般为：项目启动 -&gt; 触发初始化动作 -&gt;单线程从数据库中捞取数据 -&gt; 组装成我们需要的数据结构 -&gt; 放到 JVM 内存中。</p>
<p>在项目启动时，为了防止共享资源被多次加载，我们往往会加上排它锁，让一个线程加载共享资源完成之后，另外一个线程才能继续加载，此时的排它锁我们可以选择 synchronized 或者 ReentrantLock，我们以 synchronized 为例，写了 mock 的代码，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 共享资源</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, String&gt; SHARED_MAP = Maps.newConcurrentMap();</span><br><span class="line"><span class="comment">// 有无初始化完成的标志位</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> loaded = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化共享资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(loaded)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">    <span class="comment">// 再次 check</span></span><br><span class="line">    <span class="keyword">if</span>(loaded)&#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">&quot;SynchronizedDemo init begin&quot;</span>);</span><br><span class="line">    <span class="comment">// 从数据库中捞取数据，组装成 SHARED_MAP 的数据格式</span></span><br><span class="line">    loaded = <span class="keyword">true</span>;</span><br><span class="line">    log.info(<span class="string">&quot;SynchronizedDemo init end&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不知道大家有没有从上述代码中发现 @PostConstruct 注解，@PostConstruct 注解的作用是在 Spring 容器初始化时，再执行该注解打上的方法，也就是说上图说的 init 方法触发的时机，是在 Spring 容器启动的时候。</p>
<p>大家可以下载演示代码，找到 DemoApplication 启动文件，在 DemoApplication 文件上右击 run，就可以启动整个 Spring Boot 项目，在 init 方法上打上断点就可以调试了。</p>
<p>我们在代码中使用了 synchronized 来保证同一时刻，只有一个线程可以执行初始化共享资源的操作，并且我们加了一个共享资源加载完成的标识位（loaded），来判断是否加载完成了，如果加载完成，那么其它加载线程直接返回。</p>
<p>如果把 synchronized 换成 ReentrantLock 也是一样的实现，只不过需要显示的使用 ReentrantLock 的 API 进行加锁和释放锁，使用 ReentrantLock 有一点需要注意的是，我们需要在 try 方法块中加锁，在 finally 方法块中释放锁，这样保证即使 try 中加锁后发生异常，在 finally 中也可以正确的释放锁。</p>
<p>有的同学可能会问，不是可以直接使用了 ConcurrentHashMap 么，为什么还需要加锁呢？的确 ConcurrentHashMap 是线程安全的，但它只能够保证 Map 内部数据操作时的线程安全，是无法保证多线程情况下，查询数据库并组装数据的整个动作只执行一次的，我们加 synchronized 锁住的是整个操作，保证整个操作只执行一次。</p>
<p>完整 demo 见 SynchronizedDemo。</p>
<h3 id="2-CountDownLatch"><a href="#2-CountDownLatch" class="headerlink" title="2 CountDownLatch"></a>2 CountDownLatch</h3><h4 id="2-1-场景"><a href="#2-1-场景" class="headerlink" title="2.1 场景"></a>2.1 场景</h4><p>1：小明在淘宝上买了一个商品，觉得不好，把这个商品退掉(商品还没有发货，只退钱)，我们叫做单商品退款，单商品退款在后台系统中运行时，整体耗时 30 毫秒。</p>
<p>2：双 11，小明在淘宝上买了 40 个商品，生成了同一个订单（实际可能会生成多个订单，为了方便描述，我们说成一个），第二天小明发现其中 30 个商品是自己冲动消费的，需要把 30 个商品一起退掉。</p>
<h4 id="2-2-实现"><a href="#2-2-实现" class="headerlink" title="2.2 实现"></a>2.2 实现</h4><p>此时后台只有单商品退款的功能，没有批量商品退款的功能（30 个商品一次退我们称为批量），为了快速实现这个功能，同学 A 按照这样的方案做的：for 循环调用 30 次单商品退款的接口，在 qa 环境测试的时候发现，如果要退款 30 个商品的话，需要耗时：30 * 30 = 900 毫秒，再加上其它的逻辑，退款 30 个商品差不多需要 1 秒了，这个耗时其实算很久了，当时同学 A 提出了这个问题，希望大家帮忙看看如何优化整个场景的耗时。</p>
<p>同学 B 当时就提出，你可以使用线程池进行执行呀，把任务都提交到线程池里面去，假如机器的 CPU 是 4 核的，最多同时能有 4 个单商品退款可以同时执行，同学 A 觉得很有道理，于是准备修改方案，为了便于理解，我们把两个方案都画出来，对比一下：<br><img src="http://img.mukewang.com/5dc386970001fb8b12120716.png" alt="图片描述"></p>
<p>同学 A 于是就按照演变的方案去写代码了，过了一天，抛出了一个问题：向线程池提交了 30 个任务后，主线程如何等待 30 个任务都执行完成呢？因为主线程需要收集 30 个子任务的执行情况，并汇总返回给前端。</p>
<p>大家可以先不往下看，自己先思考一下，我们前几章说的那种锁可以帮助解决这个问题？</p>
<p>CountDownLatch 可以的，CountDownLatch 具有这种功能，让主线程去等待子任务全部执行完成之后才继续执行。</p>
<p>此时还有一个关键，我们需要知道子线程执行的结果，所以我们用 Runnable 作为线程任务就不行了，因为 Runnable 是没有返回值的，我们需要选择 Callable 作为任务。</p>
<p>我们写了一个 demo，首先我们来看一下单个商品退款的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单商品退款，耗时 30 毫秒，退款成功返回 true，失败返回 false</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefundDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据商品 ID 进行退款</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> itemId</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">refundByItem</span><span class="params">(Long itemId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 线程沉睡 30 毫秒，模拟单个商品退款过程</span></span><br><span class="line">      Thread.sleep(<span class="number">30</span>);</span><br><span class="line">      log.info(<span class="string">&quot;refund success,itemId is &#123;&#125;&quot;</span>, itemId);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      log.error(<span class="string">&quot;refundByItemError,itemId is &#123;&#125;&quot;</span>, itemId);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们看下 30 个商品的批量退款，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BatchRefundDemo</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 定义线程池</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService EXECUTOR_SERVICE =</span><br><span class="line">      <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0L</span>,</span><br><span class="line">                                TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">20</span>));</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">batchRefund</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// state 初始化为 30 </span></span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">30</span>);</span><br><span class="line">    RefundDemo refundDemo = <span class="keyword">new</span> RefundDemo();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备 30 个商品</span></span><br><span class="line">    List&lt;Long&gt; items = Lists.newArrayListWithCapacity(<span class="number">30</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">      items.add(Long.valueOf(i+<span class="string">&quot;&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备开始批量退款</span></span><br><span class="line">    List&lt;Future&gt; futures = Lists.newArrayListWithCapacity(<span class="number">30</span>);</span><br><span class="line">    <span class="keyword">for</span> (Long item : items) &#123;</span><br><span class="line">      <span class="comment">// 使用 Callable，因为我们需要等到返回值</span></span><br><span class="line">      Future&lt;Boolean&gt; future = EXECUTOR_SERVICE.submit(<span class="keyword">new</span> Callable&lt;Boolean&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">          <span class="keyword">boolean</span> result = refundDemo.refundByItem(item);</span><br><span class="line">          <span class="comment">// 每个子线程都会执行 countDown，使 state -1 ，但只有最后一个才能真的唤醒主线程</span></span><br><span class="line">          countDownLatch.countDown();</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 收集批量退款的结果</span></span><br><span class="line">      futures.add(future);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;30 个商品已经在退款中&quot;</span>);</span><br><span class="line">    <span class="comment">// 使主线程阻塞，一直等待 30 个商品都退款完成，才能继续执行</span></span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    log.info(<span class="string">&quot;30 个商品已经退款完成&quot;</span>);</span><br><span class="line">    <span class="comment">// 拿到所有结果进行分析</span></span><br><span class="line">    List&lt;Boolean&gt; result = futures.stream().map(fu-&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// get 的超时时间设置的是 1 毫秒，是为了说明此时所有的子线程都已经执行完成了</span></span><br><span class="line">        <span class="keyword">return</span> (Boolean) fu.get(<span class="number">1</span>,TimeUnit.MILLISECONDS);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">// 打印结果统计</span></span><br><span class="line">    <span class="keyword">long</span> success = result.stream().filter(r-&gt;r.equals(<span class="keyword">true</span>)).count();</span><br><span class="line">    log.info(<span class="string">&quot;执行结果成功&#123;&#125;,失败&#123;&#125;&quot;</span>,success,result.size()-success);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码只是大概的底层思路，真实的项目会在此思路之上加上请求分组，超时打断等等优化措施。</p>
<p>我们来看一下执行的结果:<br><img src="http://img.mukewang.com/5dc386a80001238109010819.png" alt="图片描述"></p>
<p>从执行的截图中，我们可以明显的看到 CountDownLatch 已经发挥出了作用，主线程会一直等到 30 个商品的退款结果之后才会继续执行。</p>
<p>接着我们做了一个不严谨的实验（把以上代码执行很多次，求耗时平均值），通过以上代码，30 个商品退款完成之后，整体耗时大概在 200 毫秒左右。</p>
<p>而通过 for 循环单商品进行退款，大概耗时在 1 秒左右，前后性能相差 5 倍左右，for 循环退款的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> begin1 = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (Long item : items) &#123;</span><br><span class="line">  refundDemo.refundByItem(item);</span><br><span class="line">&#125;</span><br><span class="line">log.info(<span class="string">&quot;for 循环单个退款耗时&#123;&#125;&quot;</span>,System.currentTimeMillis()-begin1);</span><br></pre></td></tr></table></figure>

<p>性能的巨大提升是线程池 + 锁两者结合的功劳。</p>
<h3 id="3-总结-8"><a href="#3-总结-8" class="headerlink" title="3 总结"></a>3 总结</h3><p>本章举了实际工作中的两个小案列，看到了 CountDownLatch 和 synchronized（ReentrantLock） 是如何结合实际需求进行落地的，特别是 CountDownLatch 的案列，使用线程池 + 锁结合的方式大大提高了生产效率，所以在工作中如果你也遇到相似的场景，可以毫不犹豫地用起来。</p>
<h2 id="36-从容不迫：重写锁的设计结构和细节"><a href="#36-从容不迫：重写锁的设计结构和细节" class="headerlink" title="36 从容不迫：重写锁的设计结构和细节"></a><strong>36 从容不迫：重写锁的设计结构和细节</strong></h2><h3 id="引导语-33"><a href="#引导语-33" class="headerlink" title="引导语"></a>引导语</h3><p>有的面试官喜欢让同学在说完锁的原理之后，让你重写一个新的锁，要求现场在白板上写出大概的思路和代码逻辑，这种面试题目，蛮难的，我个人觉得其侧重点主要是两个部分：</p>
<ol>
<li>考察一下你对锁原理的理解是如何来的，如果你对源码没有解读过的话，只是看看网上的文章，或者背面试题，也是能够说出大概的原理，但你很难现场写出一个锁的实现代码，除非你真的看过源码，或者有和锁相关的项目经验；</li>
<li>我们不需要创造，我们只需要模仿 Java 锁中现有的 API 进行重写即可。</li>
</ol>
<p>如果你看过源码，这道题真的很简单，你可以挑选一个你熟悉的锁进行模仿。</p>
<p>在锁章节中我们之前说的都是排它锁，这小节我们以共享锁作为案列，自定义一个共享锁。</p>
<h3 id="1-需求"><a href="#1-需求" class="headerlink" title="1 需求"></a>1 需求</h3><p>一般自定义锁的时候，我们都是根据需求来进行定义的，不可能凭空定义出锁来，说到共享锁，大家可能会想到很多场景，比如说对于共享资源的读锁可以是共享的，比如对于数据库链接的共享访问，比如对于 Socket 服务端的链接数是可以共享的，场景有很多，我们选择共享访问数据库链接这个场景来定义一个锁。</p>
<h3 id="2-详细设计"><a href="#2-详细设计" class="headerlink" title="2 详细设计"></a>2 详细设计</h3><p>假定(以下设想都为假定)我们的数据库是单机 mysql，只能承受 10 个链接，创建数据库链接时，我们是通过最原始 JDBC 的方式，我们用一个接口把用 JDBC 创建链接的过程进行了封装，这个接口我们命名为：创建链接接口。</p>
<p>共享访问数据库链接的整体要求如下：所有请求加在一起的 mysql 链接数，最大不能超过 10（包含 10），一旦超过 10，直接报错。</p>
<p>在这个背景下，我们进行了下图的设计：<br><img src="http://img.mukewang.com/5dc386f5000160e808680456.png" alt="图片描述"></p>
<p>这个设计最最关键的地方，就是我们通过能否获得锁，来决定是否可以得到 mysql 链接，如果能获得锁，那么就能得到链接，否则直接报错。</p>
<p>接着我们一起来看下落地的代码：</p>
<h4 id="2-1-定义锁"><a href="#2-1-定义锁" class="headerlink" title="2.1 定义锁"></a>2.1 定义锁</h4><p>首先我们需要定义一个锁出来，定义时需要有两个元素：</p>
<ol>
<li>锁的定义：同步器 Sync；</li>
<li>锁对外提供的加锁和解锁的方法。</li>
</ol>
<p>共享锁的代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 共享不公平锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShareLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">	<span class="comment">// 同步器</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">  <span class="comment">// 用于确保不能超过最大值</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxCount;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 初始化时给同步器 sync 赋值</span></span><br><span class="line"><span class="comment">   * count 代表可以获得共享锁的最大值</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ShareLock</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">    maxCount = count;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获得锁</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> true 表示成功获得锁，false 表示失败</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.acquireByShared(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 释放锁</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> true 表示成功释放锁，false 表示失败</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">unLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>从上述代码中可以看出，加锁和释放锁的实现，都依靠同步器 Sync 的底层实现。</p>
<p>唯一需要注意的是，锁需要规定好 API 的规范，主要是两方面：</p>
<ol>
<li>API 需要什么，就是锁在初始化的时候，你需要传哪些参数给我，在 ShareLock 初始化时，需要传最大可共享锁的数目；</li>
<li>需要定义自身的能力，即定义每个方法的入参和出参。在 ShareLock 的实现中，加锁和释放锁的入参都没有，是方法里面写死的 1，表示每次方法执行，只能加锁一次或释放锁一次，出参是布尔值，true 表示加锁或释放锁成功，false 表示失败，底层使用的都是 Sync 非公平锁。</li>
</ol>
<p>以上这种思考方式是有方法论的，就是我们在思考一个问题时，可以从两个方面出发：API 是什么？API 有什么能力？</p>
<h4 id="2-2-定义同步器-Sync"><a href="#2-2-定义同步器-Sync" class="headerlink" title="2.2 定义同步器 Sync"></a>2.2 定义同步器 Sync</h4><p>Sync 直接继承 AQS ，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 表示最多有 count 个共享锁可以获得</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Sync</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    setState(count);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获得 i 个锁</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">acquireByShared</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自旋保证 CAS 一定可以成功</span></span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">      <span class="keyword">if</span>(i&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> state = getState();</span><br><span class="line">      <span class="comment">// 如果没有锁可以获得，直接返回 false</span></span><br><span class="line">      <span class="keyword">if</span>(state &lt;=<span class="number">0</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> expectState = state - i;</span><br><span class="line">      <span class="comment">// 如果要得到的锁不够了，直接返回 false</span></span><br><span class="line">      <span class="keyword">if</span>(expectState &lt; <span class="number">0</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// CAS 尝试得到锁,CAS 成功获得锁，失败继续 for 循环</span></span><br><span class="line">      <span class="keyword">if</span>(compareAndSetState(state,expectState))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 释放 i 个锁</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arg&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> state = getState();</span><br><span class="line">      <span class="keyword">int</span> expectState = state + arg;</span><br><span class="line">      <span class="comment">// 超过了 int 的最大值，或者 expectState 超过了我们的最大预期</span></span><br><span class="line">      <span class="keyword">if</span>(expectState &lt; <span class="number">0</span> || expectState &gt; maxCount)&#123;</span><br><span class="line">        log.error(<span class="string">&quot;state 超过预期，当前 state is &#123;&#125;,计算出的 state is &#123;&#125;&quot;</span>,state</span><br><span class="line">        ,expectState);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(compareAndSetState(state, expectState))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个代码比较清晰，我们需要注意的是：</p>
<ol>
<li>边界的判断，比如入参是否非法，释放锁时，会不会出现预期的 state 非法等边界问题，对于此类问题我们都需要加以判断，体现出思维的严谨性；</li>
<li>加锁和释放锁，需要用 for 自旋 + CAS 的形式，来保证当并发加锁或释放锁时，可以重试成功。写 for 自旋时，我们需要注意在适当的时机要 return，不要造成死循环，CAS 的方法 AQS 已经提供了，不要自己写，我们自己写的 CAS 方法是无法保证原子性的。</li>
</ol>
<h4 id="2-3-通过能否获得锁来决定能否得到链接"><a href="#2-3-通过能否获得锁来决定能否得到链接" class="headerlink" title="2.3 通过能否获得锁来决定能否得到链接"></a>2.3 通过能否获得锁来决定能否得到链接</h4><p>锁定义好了，我们需要把锁和获取 Mysql 链接结合起来，我们写了一个 Mysql 链接的工具类，叫做 MysqlConnection，其主要负责两大功能：</p>
<ol>
<li>通过 JDBC 建立和 Mysql 的链接；</li>
<li>结合锁，来防止请求过大时，Mysql 的总链接数不能超过 10 个。</li>
</ol>
<p>首先我们看下 MysqlConnection 初始化的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MysqlConnection</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ShareLock lock;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// maxConnectionSize 表示最大链接数</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MysqlConnection</span><span class="params">(<span class="keyword">int</span> maxConnectionSize)</span> </span>&#123;</span><br><span class="line">    lock = <span class="keyword">new</span> ShareLock(maxConnectionSize);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，在初始化时，需要制定最大的链接数是多少，然后把这个数值传递给锁，因为最大的链接数就是 ShareLock 锁的 state 值。</p>
<p>接着为了完成 1，我们写了一个 private 的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到一个 mysql 链接，底层实现省略</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Connection <span class="title">getConnection</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们实现 2，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对外获取 mysql 链接的接口</span></span><br><span class="line"><span class="comment">// 这里不用try finally 的结构，获得锁实现底层不会有异常</span></span><br><span class="line"><span class="comment">// 即使出现未知异常，也无需释放锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getLimitConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (lock.lock()) &#123;</span><br><span class="line">    <span class="keyword">return</span> getConnection();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对外释放 mysql 链接的接口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">releaseLimitConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> lock.unLock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑也比较简单，加锁时，如果获得了锁，就能返回 Mysql 的链接，释放锁时，在链接关闭成功之后，调用 releaseLimitConnection 方法即可，此方法会把锁的 state 状态加一，表示链接被释放了。</p>
<p>以上步骤，针对 Mysql 链接限制的场景锁就完成了。</p>
<h3 id="3-测试-1"><a href="#3-测试-1" class="headerlink" title="3 测试"></a>3 测试</h3><p>锁写好了，接着我们来测试一下，我们写了一个测试的 demo，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  log.info(<span class="string">&quot;模仿开始获得 mysql 链接&quot;</span>);</span><br><span class="line">  MysqlConnection mysqlConnection = <span class="keyword">new</span> MysqlConnection(<span class="number">10</span>);</span><br><span class="line">  log.info(<span class="string">&quot;初始化 Mysql 链接最大只能获取 10 个&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;i&lt;<span class="number">12</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> != mysqlConnection.getLimitConnection())&#123;</span><br><span class="line">      log.info(<span class="string">&quot;获得第&#123;&#125;个数据库链接成功&quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      log.info(<span class="string">&quot;获得第&#123;&#125;个数据库链接失败：数据库连接池已满&quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  log.info(<span class="string">&quot;模仿开始释放 mysql 链接&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;i&lt;<span class="number">12</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(mysqlConnection.releaseLimitConnection())&#123;</span><br><span class="line">      log.info(<span class="string">&quot;释放第&#123;&#125;个数据库链接成功&quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      log.info(<span class="string">&quot;释放第&#123;&#125;个数据库链接失败&quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  log.info(<span class="string">&quot;模仿结束&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码逻辑如下：</p>
<ol>
<li>获得 Mysql 链接逻辑：for 循环获取链接，1<del>10 都可以获得链接，11</del>12 获取不到链接，因为链接被用完了；</li>
<li>释放锁逻辑：for 循环释放链接，1<del>10 都可以释放成功，11</del>12 释放失败。</li>
</ol>
<p>我们看下运行结果，如下图：<br><img src="http://img.mukewang.com/5dc3870a0001d0bd10370766.png" alt="图片描述"></p>
<p>从运行的结果，可以看出，我们实现的 ShareLock 锁已经完成了 Mysql 链接共享的场景了。</p>
<h3 id="4-总结-6"><a href="#4-总结-6" class="headerlink" title="4 总结"></a>4 总结</h3><p>同学们阅读到这里不知道有没有两点感受：</p>
<ol>
<li>重写锁真的很简单，最关键的是要和场景完美贴合，能满足业务场景的锁才是好锁；</li>
<li>锁其实只是来满足业务场景的，本质都是 AQS，所以只要 AQS 学会了，在了解清楚场景的情况下，重写锁都不难的。</li>
</ol>
<p>锁章节最核心的就是 AQS 源码解析的两章，只要我们把 AQS 弄懂了，其余锁的实现，只要稍微看下源码实现，几乎马上就能知道其底层实现的原理，大多数都是通过操作 state 来完成不同的场景需求，所以还是建议大家多看 AQS 源码，多 debug AQS 源码，只要 AQS 弄清楚了，锁都很简单。</p>
<h1 id="第7章-线程池"><a href="#第7章-线程池" class="headerlink" title="第7章 线程池"></a><strong>第7章 线程池</strong></h1><h2 id="37-ThreadPoolExecutor-源码解析"><a href="#37-ThreadPoolExecutor-源码解析" class="headerlink" title="37 ThreadPoolExecutor 源码解析"></a><strong>37 ThreadPoolExecutor 源码解析</strong></h2><h3 id="引导语-34"><a href="#引导语-34" class="headerlink" title="引导语"></a>引导语</h3><p>线程池我们在工作中经常会用到。在请求量大时，使用线程池，可以充分利用机器资源，增加请求的处理速度，本章节我们就和大家一起来学习线程池。</p>
<p>本章的基础是第四章队列和第五章线程，没有看过这两章的同学可以先看一看。</p>
<p>本章的顺序，先说源码，弄懂原理，接着看一看面试题，最后看看实际工作中是如何运用线程池的。</p>
<h3 id="1-整体架构图"><a href="#1-整体架构图" class="headerlink" title="1 整体架构图"></a>1 整体架构图</h3><p>我们画了线程池的整体图，如下：<br><img src="http://img.mukewang.com/5dd217480001b8bf20181042.png" alt="图片描述"></p>
<p>本小节主要就按照这个图来进行 ThreadPoolExecutor 源码的讲解，大家在看各个方法时，可以结合这个图一起看。</p>
<h4 id="1-1-类结构"><a href="#1-1-类结构" class="headerlink" title="1.1 类结构"></a>1.1 类结构</h4><p>首先我们来看一下 ThreadPoolExecutor 的类结构，如下图：<br><img src="http://img.mukewang.com/5dd21737000158ad06020618.png" alt="图片描述"></p>
<p>从上图中，我们从命名上来看，都有 Executor 的共同命名，Executor 的中文意思为执行的意思，表示对提供的任务进行执行，我们在第五章线程中学习到了几种任务：Runnable、Callable、FutureTask，之前我们都是使用 Thread 来执行这些任务的，除了 Thread，这些 Executor 命名的类和接口也是可以执行这几种任务的，接下来我们大概的看下这几个类的大概含义：</p>
<ol>
<li>Executor：定义 execute 方法来执行任务，入参是 Runnable，无出参：<br><img src="http://img.mukewang.com/5dd217240001c99515280682.png" alt="图片描述"></li>
<li>ExecutorService：Executor 的功能太弱，ExecutorService 丰富了对任务的执行和管理的功能，主要代码如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关闭，不会接受新的任务，也不会等待未完成的任务</span></span><br><span class="line"><span class="comment">// 如果需要等待未完成的任务，可以使用 awaitTermination 方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// executor 是否已经关闭了，返回值 true 表示已关闭</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 所有的任务是否都已经终止，是的话，返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 在超时时间内，等待剩余的任务终止</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="comment">// 提交有返回值的任务，使用 get 方法可以阻塞等待任务的执行结果返回</span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"><span class="comment">// 提交没有返回值的任务，如果使用 get 方法的话，任务执行完之后得到的是 null 值</span></span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br><span class="line"><span class="comment">// 给定任务集合，返回已经执行完成的 Future 集合，每个返回的 Future 都是 isDone = true 的状态</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">    <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">// 给定任务中有一个执行成功就返回，如果抛异常，其余未完成的任务将被取消</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>AbstractExecutorService 是一个抽象类，封装了 Executor 的很多通用功能，比如：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把 Runnable 转化成 RunnableFuture</span></span><br><span class="line"><span class="comment">// RunnableFuture 是一个接口，实现了 Runnable 和 Future</span></span><br><span class="line"><span class="comment">// FutureTask 是 RunnableFuture 的实现类，主要是对任务进行各种管理</span></span><br><span class="line"><span class="comment">// Runnable + Future =&gt; RunnableFuture =&gt; FutureTask</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 提交无返回值的任务</span></span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// ftask 其实是 FutureTask</span></span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 提交有返回值的任务</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// ftask 其实是 FutureTask</span></span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有几个点需要注意下：</p>
<ol>
<li>FutureTask 我们在第五章有说，其本身就是一个任务，而且具备对任务管理的功能，比如可以通过 get 方法拿到任务的执行结果；</li>
<li>submit 方法是我们平时使用线程池时提交任务的方法，支持 Runable 和 Callable 两种任务的提交，方法中 execute 方法是其子类 ThreadPoolExecutor 实现的，不管是那种任务入参，execute 方法最终执行的任务都是 FutureTask；</li>
<li>ThreadPoolExecutor 继承了 AbstractExecutorService 抽象类，具备以上三个类的所有功能。</li>
</ol>
<h4 id="1-2-类注释-1"><a href="#1-2-类注释-1" class="headerlink" title="1.2 类注释"></a>1.2 类注释</h4><p>ThreadPoolExecutor 的类注释有很多，我们选取关键的注释如下：</p>
<ol>
<li>ExecutorService 使用线程池中的线程执行提交的任务，线程池我们可以使用 Executors 进行配置；</li>
<li>线程池解决两个问题：1：通过减少任务间的调度开销 (主要是通过线程池中的线程被重复使用的方式)，来提高大量任务时的执行性能；2：提供了一种方式来管理线程和消费，维护基本数据统计等工作，比如统计已完成的任务数；</li>
<li>Executors 为常用的场景设定了可直接初始化线程池的方法，比如 Executors#newCachedThreadPool 无界的线程池，并且可以自动回收；Executors#newFixedThreadPool 固定大小线程池；Executors#newSingleThreadExecutor 单个线程的线程池；</li>
<li>为了在各种上下文中使用线程池，线程池提供可供扩展的参数设置：1：coreSize：当新任务提交时，发现运行的线程数小于 coreSize，一个新的线程将被创建，即使这时候其它工作线程是空闲的，可以通过 getCorePoolSize 方法获得 coreSize；2：maxSize: 当任务提交时，coreSize &lt; 运行线程数 &lt;= maxSize，但队列没有满时，任务提交到队列中，如果队列满了，在 maxSize 允许的范围内新建线程；</li>
<li>一般来说，coreSize 和 maxSize 在线程池初始化时就已经设定了，但我们也可以通过 setCorePoolSize、setMaximumPoolSize 方法动态的修改这两个值；</li>
<li>默认的，core threads 需要到任务提交后才创建的，但我们可以分别使用 prestartCoreThread、prestartAllCoreThreads 两个方法来提前创建一个、所有的 core threads；</li>
<li>新的线程被默认 ThreadFactory 创建时，优先级会被限制成 NORM_PRIORITY，默认会被设置成非守护线程，这个和新建线程的继承是不同的；</li>
<li>Keep-alive times 参数的作用：1：如果当前线程池中有超过 coreSize 的线程；2：并且线程空闲的时间超过 keepAliveTime，当前线程就会被回收，这样可以避免线程没有被使用时的资源浪费；</li>
<li>通过 setKeepAliveTime 方法可以动态的设置 keepAliveTime 的值；</li>
<li>如果设置 allowCoreThreadTimeOut 为 ture 的话，core thread 空闲时间超过 keepAliveTime 的话，也会被回收；</li>
<li>线程池新建时，有多种队列可供选择，比如：1：SynchronousQueue，为了避免任务被拒绝，要求线程池的 maxSize 无界，缺点是当任务提交的速度超过消费的速度时，可能出现无限制的线程增长；2：LinkedBlockingQueue，无界队列，未消费的任务可以在队列中等待；3：ArrayBlockingQueue，有界队列，可以防止资源被耗尽；</li>
<li>队列的维护：提供了 getQueue () 方法方便我们进行监控和调试，严禁用于其他目的，remove 和 purge 两个方法可以对队列中的元素进行操作；</li>
<li>在 Executor 已经关闭或对最大线程和最大队列都使用饱和时，可以使用 RejectedExecutionHandler 类进行异常捕捉，有如下四种处理策略：ThreadPoolExecutor.AbortPolicy、ThreadPoolExecutor.DiscardPolicy、ThreadPoolExecutor.CallerRunsPolicy、ThreadPoolExecutor.DiscardOldestPolicy；</li>
<li>线程池提供了很多可供扩展的钩子函数，比如有：1：提供在每个任务执行之前 beforeExecute 和执行之后 afterExecute 的钩子方法，主要用于操作执行环境，比如初始化 ThreadLocals、收集统计数据、添加日志条目等；2: 如果在执行器执行完成之后想干一些事情，可以实现 terminated 方法，如果钩子方法执行时发生异常，工作线程可能会失败并立即终止。</li>
</ol>
<p>可以看到 ThreadPoolExecutor 的注释是非常多的，也是非常重要的，我们很多面试的题目，在注释上都能找到答案。</p>
<h4 id="1-3-ThreadPoolExecutor-重要属性"><a href="#1-3-ThreadPoolExecutor-重要属性" class="headerlink" title="1.3 ThreadPoolExecutor 重要属性"></a>1.3 ThreadPoolExecutor 重要属性</h4><p>接下来我们来看一看 ThreadPoolExecutor 都有哪些重要属性，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ctl 线程池状态控制字段，由两部分组成：</span></span><br><span class="line"><span class="comment">//1:workerCount  wc 工作线程数，我们限制 workerCount 最大到(2^29)-1，大概 5 亿个线程</span></span><br><span class="line"><span class="comment">//2:runState rs 线程池的状态，提供了生命周期的控制，源码中有很多关于状态的校验，状态枚举如下：</span></span><br><span class="line"><span class="comment">//RUNNING（-536870912）：接受新任务或者处理队列里的任务。</span></span><br><span class="line"><span class="comment">//SHUTDOWN（0）：不接受新任务，但仍在处理已经在队列里面的任务。</span></span><br><span class="line"><span class="comment">//STOP（-536870912）：不接受新任务，也不处理队列中的任务，对正在执行的任务进行中断。</span></span><br><span class="line"><span class="comment">//TIDYING（1073741824）： 所以任务都被中断，workerCount 是 0，整理状态</span></span><br><span class="line"><span class="comment">//TERMINATED（1610612736）： terminated() 已经完成的时候</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//runState 之间的转变过程：</span></span><br><span class="line"><span class="comment">//RUNNING -&gt; SHUTDOWN：调用 shudown(),finalize()</span></span><br><span class="line"><span class="comment">//(RUNNING or SHUTDOWN) -&gt; STOP：调用shutdownNow()</span></span><br><span class="line"><span class="comment">//SHUTDOWN -&gt; TIDYING -&gt; workerCount ==0</span></span><br><span class="line"><span class="comment">//STOP -&gt; TIDYING -&gt; workerCount ==0</span></span><br><span class="line"><span class="comment">//TIDYING -&gt; TERMINATED -&gt; terminated() 执行完成之后</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;<span class="comment">// 29</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;<span class="comment">// =(2^29)-1=536870911</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Packing and unpacking ctl</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;<span class="comment">//-536870912</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;<span class="comment">//0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;<span class="comment">//-536870912</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;<span class="comment">//1073741824</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;<span class="comment">//1610612736</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 已完成任务的计数</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"><span class="comment">// 线程池最大容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;</span><br><span class="line"><span class="comment">// 已经完成的任务数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> completedTaskCount;</span><br><span class="line"><span class="comment">// 用户可控制的参数都是 volatile 修饰的</span></span><br><span class="line"><span class="comment">// 可以使用 threadFactory 创建 thread</span></span><br><span class="line"><span class="comment">// 创建失败一般不抛出异常，只有在 OutOfMemoryError 时候才会</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;</span><br><span class="line"><span class="comment">// 饱和或者运行中拒绝任务的 handler 处理类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line"><span class="comment">// 线程存活时间设置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime;</span><br><span class="line"><span class="comment">// 设置 true 的话，核心线程空闲 keepAliveTime 时间后，也会被回收</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut;</span><br><span class="line"><span class="comment">// coreSize</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line"><span class="comment">// maxSize 最大限制 (2^29)-1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maximumPoolSize;</span><br><span class="line"><span class="comment">// 默认的拒绝策略</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RejectedExecutionHandler defaultHandler =</span><br><span class="line">    <span class="keyword">new</span> AbortPolicy();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列会 hold 住任务，并且利用队列的阻塞的特性，来保持线程的存活周期</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大多数情况下是控制对 workers 的访问权限</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition termination = mainLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包含线程池中所有的工作线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br></pre></td></tr></table></figure>

<p>属性也是非常多，为了方便理解线程池的状态扭转，画了一个图：<br><img src="http://img.mukewang.com/5dd217040001096216760424.png" alt="图片描述"></p>
<p>Worker 我们可以理解成线程池中任务运行的最小单元，Worker 的大致结构如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线程池中任务执行的最小单元</span></span><br><span class="line"><span class="comment">// Worker 继承 AQS，具有锁功能</span></span><br><span class="line"><span class="comment">// Worker 实现 Runnable，本身是一个可执行的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 任务运行的线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要执行的任务</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非常巧妙的设计,Worker本身是个 Runnable,把自己作为任务传递给 thread</span></span><br><span class="line">    <span class="comment">// 内部有个属性又设置了 Runnable</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="comment">// 把 Worker 自己作为 thread 运行的任务</span></span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Worker 本身是 Runnable，run 方法是 Worker 执行的入口， runWorker 是外部的方法 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lock methods</span></span><br><span class="line">    <span class="comment">// 0 代表没有锁住，1 代表锁住</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试加锁，CAS 赋值为 1，表示锁住</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试释放锁，释放锁没有 CAS 校验，可以任意的释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理解 Worker 非常关键，主要有以下几点：</p>
<ol>
<li>Worker 很像是任务的代理，在线程池中，最小的执行单位就是 Worker，所以 Worker 实现了 Runnable 接口，实现了 run 方法；</li>
<li>在 Worker 初始化时 this.thread = getThreadFactory ().newThread (this) 这行代码比较关键，它把当前 Worker 作为线程的构造器入参，我们在后续的实现中会发现这样的代码：Thread t = w.thread;t.start ()，此时的 w 是 Worker 的引用申明，此处 t.start 实际上执行的就是 Worker 的 run 方法；</li>
<li>Worker 本身也实现了 AQS，所以其本身也是一个锁，其在执行任务的时候，会锁住自己，任务执行完成之后，会释放自己。</li>
</ol>
<h3 id="2-线程池的任务提交"><a href="#2-线程池的任务提交" class="headerlink" title="2 线程池的任务提交"></a>2 线程池的任务提交</h3><p>线程池的任务提交从 submit 方法说起，submit 方法是 AbstractExecutorService 抽象类定义的，主要做了两件事情：</p>
<ol>
<li>把 Runnable 和 Callable 都转化成 FutureTask，这个我们之前看过源码了；</li>
<li>使用 execute 方法执行 FutureTask。</li>
</ol>
<p>execute 方法是 ThreadPoolExecutor 中的方法，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 工作的线程小于核心线程数，创建新的线程，成功返回，失败不抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 线程池状态可能发生变化</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 工作的线程大于等于核心线程数，或者新建线程失败</span></span><br><span class="line">    <span class="comment">// 线程池状态正常，并且可以入队的话，尝试入队列</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 如果线程池状态异常 尝试从队列中移除任务，可以移除的话就拒绝掉任务</span></span><br><span class="line">        <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 发现可运行的线程数是 0，就初始化一个线程，这里是个极限情况，入队的时候，突然发现</span></span><br><span class="line">        <span class="comment">// 可用线程都被回收了</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// Runnable是空的，不会影响新增线程，但是线程在 start 的时候不会运行</span></span><br><span class="line">            <span class="comment">// Thread.run() 里面有判断</span></span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 队列满了，开启线程到 maxSize，如果失败直接拒绝,</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>execute 方法执行的就是整体架构图的左半边的逻辑，其中多次调用 addWorker 方法，addWorker 方法的作用是新建一个 Worker，我们一起来看下源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结合线程池的情况看是否可以添加新的 worker</span></span><br><span class="line"><span class="comment">// firstTask 不为空可以直接执行，为空执行不了，Thread.run()方法有判断，Runnable为空不执行</span></span><br><span class="line"><span class="comment">// core 为 true 表示线程最大新增个数是 coresize，false 表示最大新增个数是 maxsize</span></span><br><span class="line"><span class="comment">// 返回 true 代表成功，false 失败</span></span><br><span class="line"><span class="comment">// break retry 跳到retry处，且不再进入循环</span></span><br><span class="line"><span class="comment">// continue retry 跳到retry处，且再次进入循环</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="comment">// 先是各种状态的校验</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="comment">// rs &gt;= SHUTDOWN 说明线程池状态不正常</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">// 工作中的线程数大于等于容量，或者大于等于 coreSize or maxSize</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="comment">// break 结束 retry 的 for 循环</span></span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="comment">// 线程池状态被更改</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="comment">// 跳转到retry位置</span></span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 巧妙的设计，Worker 本身是个 Runnable.</span></span><br><span class="line">        <span class="comment">// 在初始化的过程中，会把 worker 丢给 thread 去初始化</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                <span class="comment">// 启动线程，实际上去执行 Worker.run 方法</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>addWorker 方法首先是执行了一堆校验，然后使用 new Worker (firstTask) 新建了 Worker，最后使用 t.start () 执行 Worker，上文我们说了 Worker 在初始化时的关键代码：this.thread = getThreadFactory ().newThread (this)，Worker（this） 是作为新建线程的构造器入参的，所以 t.start () 会执行到 Worker 的 run 方法上，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    runWorker(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>runWorker 方法是非常重要的方法，我们一起看下源码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    <span class="comment">//帮助gc回收</span></span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// task 为空的情况：</span></span><br><span class="line">        <span class="comment">// 1：任务入队列了，极限情况下，发现没有运行的线程，于是新增一个线程；</span></span><br><span class="line">        <span class="comment">// 2：线程执行完任务执行，再次回到 while 循环。</span></span><br><span class="line">        <span class="comment">// 如果 task 为空，会使用 getTask 方法阻塞从队列中拿数据，如果拿不到数据，会阻塞住</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//锁住 worker</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// 线程池 stop 中,但是线程没有到达中断状态，帮助线程中断</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//执行 before 钩子函数</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//同步执行任务</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//执行 after 钩子函数,如果这里抛出异常，会覆盖 catch 的异常</span></span><br><span class="line">                    <span class="comment">//所以这里异常最好不要抛出来</span></span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//任务执行完成，计算解锁</span></span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//做一些抛出异常的善后工作</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法执行的逻辑是架构图中的标红部分：<br><img src="http://img.mukewang.com/5dd216d900012bde09340436.png" alt="图片描述"></p>
<p>我们聚焦一下这行代码：task.run () 此时的 task 是什么呢？此时的 task 是 FutureTask 类，所以我们继续追索到 FutureTask 类的 run 方法的源码，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * run 方法可以直接被调用</span></span><br><span class="line"><span class="comment"> * 也可以由线程池进行调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 状态不是任务创建，或者当前任务已经有线程在执行了</span></span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                     <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="comment">// Callable 不为空，并且已经初始化完成</span></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            <span class="keyword">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 调用执行</span></span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">                ran = <span class="keyword">false</span>;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 给 outcome 赋值</span></span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">        <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">        runner = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">        <span class="comment">// leaked interrupts</span></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>run 方法中有两行关键代码：</p>
<ol>
<li>result = c.call () 这行代码是真正执行业务代码的地方；</li>
<li>set (result) 这里是给 outCome 赋值，这样 Future.get 方法执行时，就可以从 outCome 中拿值，这个我们在《Future、ExecutorService 源码解析》章节中都有说到。</li>
</ol>
<p>至此，submit 方法就执行完成了，整体流程比较复杂，我们画一个图释义一下任务提交执行的主流<img src="http://img.mukewang.com/5dd216c00001511716040222.png" alt="图片描述">程：</p>
<h3 id="3-线程执行完任务之后都在干啥"><a href="#3-线程执行完任务之后都在干啥" class="headerlink" title="3 线程执行完任务之后都在干啥"></a>3 线程执行完任务之后都在干啥</h3><p>线程执行完任务之后，是消亡还是干什么呢？这是一个值得思考的问题，我们可以从源码中找到答案，从 ThreadPoolExecutor 的 runWorker 方法中，不知道有没有同学注意到一个 while 循环，我们截图释义一下：<br><img src="http://img.mukewang.com/5dd216af0001d19319661304.png" alt="图片描述"><br>这个 while 循环有个 getTask 方法，getTask 的主要作用是阻塞从队列中拿任务出来，如果队列中有任务，那么就可以拿出来执行，如果队列中没有任务，这个线程会一直阻塞到有任务为止（或者超时阻塞），下面我们一起来看下 getTask 方法，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从阻塞队列中拿任务</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程池关闭 &amp;&amp; 队列为空，不需要在运行了，直接放回</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="comment">// true  运行的线程数大于 coreSize || 核心线程也可以被灭亡</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列以 LinkedBlockingQueue 为例，timedOut 为 true 的话说明下面 poll 方法执行返回的是 null</span></span><br><span class="line">        <span class="comment">// 说明在等待 keepAliveTime 时间后，队列中仍然没有数据</span></span><br><span class="line">        <span class="comment">// 说明此线程已经空闲了 keepAliveTime 了</span></span><br><span class="line">        <span class="comment">// 再加上 wc &gt; 1 || workQueue.isEmpty() 的判断</span></span><br><span class="line">        <span class="comment">// 所以使用 compareAndDecrementWorkerCount 方法使线程池数量减少 1</span></span><br><span class="line">        <span class="comment">// 并且直接 return，return 之后，此空闲的线程会自动被回收</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 从队列中阻塞拿 worker</span></span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            <span class="comment">// 设置已超时，说明此时队列没有数据</span></span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码有两处关键：</p>
<ol>
<li>使用队列的 poll 或 take 方法从队列中拿数据，根据队列的特性，队列中有任务可以返回，队列中无任务会阻塞；</li>
<li>方法中的第二个 if 判断，说的是在满足一定条件下（条件看注释），会减少空闲的线程，减少的手段是使可用线程数减一，并且直接 return，直接 return 后，该线程就执行结束了，JVM 会自动回收该线程。</li>
</ol>
<h3 id="4-总结-7"><a href="#4-总结-7" class="headerlink" title="4 总结"></a>4 总结</h3><p>本章节主要以 submit 方法为主线阐述了 ThreadPoolExecutor 的整体架构和底层源码，只要有队列和线程的基础知识的话，理解 ThreadPoolExecutor 并不复杂。ThreadPoolExecutor 还有一些其他的源码，比如说拒绝请求的策略、得到各种属性、设置各种属性等等方法，这些方法都比较简单，感兴趣的同学可以自己去看一看。</p>
<h2 id="38-线程池源码面试题"><a href="#38-线程池源码面试题" class="headerlink" title="38 线程池源码面试题"></a><strong>38 线程池源码面试题</strong></h2><h3 id="引导语-35"><a href="#引导语-35" class="headerlink" title="引导语"></a>引导语</h3><p>线程池在日常面试中占比很大，主要是因为线程池内容涉及的知识点较广，比如涉及到队列、线程、锁等等，所以很多面试官喜欢把线程池作为问题的起点，然后延伸到其它内容，由于我们专栏已经说过队列、线程、锁面试题了，所以本章面试题还是以线程池为主。</p>
<h3 id="1：说说你对线程池的理解？"><a href="#1：说说你对线程池的理解？" class="headerlink" title="1：说说你对线程池的理解？"></a>1：说说你对线程池的理解？</h3><p>答：答题思路从大到小，从全面到局部，总的可以这么说，线程池结合了锁、线程、队列等元素，在请求量较大的环境下，可以多线程的处理请求，充分的利用了系统的资源，提高了处理请求的速度，细节可以从以下几个方面阐述：</p>
<ol>
<li>ThreadPoolExecutor 类结构；</li>
<li>ThreadPoolExecutor coreSize、maxSize 等重要属性；</li>
<li>Worker 的重要作用；</li>
<li>submit 的整个过程。</li>
</ol>
<p>通过以上总分的描述，应该可以说清楚对线程池的理解了，如果是面对面面试的话，可以边说边画出线程池的整体架构图（见《ThreadPoolExecutor 源码解析》）。</p>
<h3 id="2：ThreadPoolExecutor、Executor、ExecutorService、Runnable、Callable、FutureTask-之间的关系？"><a href="#2：ThreadPoolExecutor、Executor、ExecutorService、Runnable、Callable、FutureTask-之间的关系？" class="headerlink" title="2：ThreadPoolExecutor、Executor、ExecutorService、Runnable、Callable、FutureTask 之间的关系？"></a>2：ThreadPoolExecutor、Executor、ExecutorService、Runnable、Callable、FutureTask 之间的关系？</h3><p>答：以上 6 个类可以分成两大类：一种是定义任务类，一种是执行任务类。</p>
<ol>
<li>定义任务类：Runnable、Callable、FutureTask。Runnable 是定义无返回值的任务，Callable 是定义有返回值的任务，FutureTask 是对 Runnable 和 Callable 两种任务的统一，并增加了对任务的管理功能；</li>
<li>执行任务类：ThreadPoolExecutor、Executor、ExecutorService。Executor 定义最基本的运行接口，ExecutorService 是对其功能的补充，ThreadPoolExecutor 提供真正可运行的线程池类，三个类定义了任务的运行机制。</li>
</ol>
<p>日常的做法都是先根据定义任务类定义出任务来，然后丢给执行任务类去执行。</p>
<h3 id="3：说一说队列在线程池中起的作用？"><a href="#3：说一说队列在线程池中起的作用？" class="headerlink" title="3：说一说队列在线程池中起的作用？"></a>3：说一说队列在线程池中起的作用？</h3><p>答：作用如下：</p>
<ol>
<li>当请求数大于 coreSize 时，可以让任务在队列中排队，让线程池中的线程慢慢的消费请求，实际工作中，实际线程数不可能等于请求数，队列提供了一种机制让任务可排队，起一个缓冲区的作用；</li>
<li>当线程消费完所有的线程后，会阻塞的从队列中拿数据，通过队列阻塞的功能，使线程不消亡，一旦队列中有数据产生后，可立马被消费。</li>
</ol>
<h3 id="4：结合请求不断增加时，说一说线程池构造器参数的含义和表现？"><a href="#4：结合请求不断增加时，说一说线程池构造器参数的含义和表现？" class="headerlink" title="4：结合请求不断增加时，说一说线程池构造器参数的含义和表现？"></a>4：结合请求不断增加时，说一说线程池构造器参数的含义和表现？</h3><p>答：线程池构造器各个参数的含义如下：</p>
<ol>
<li>coreSize 核心线程数；</li>
<li>maxSize 最大线程数；</li>
<li>keepAliveTime 线程空闲的最大时间；</li>
<li>queue 有多种队列可供选择，比如：1：SynchronousQueue，为了避免任务被拒绝，要求线程池的 maxSize 无界，缺点是当任务提交的速度超过消费的速度时，可能出现无限制的线程增长；2：LinkedBlockingQueue，无界队列，未消费的任务可以在队列中等待；3：ArrayBlockingQueue，有界队列，可以防止资源被耗尽；</li>
<li>线程新建的 ThreadFactory 可以自定义，也可以使用默认的 DefaultThreadFactory，DefaultThreadFactory 创建线程时，优先级会被限制成 NORM_PRIORITY，默认会被设置成非守护线程；</li>
<li>在 Executor 已经关闭或对最大线程和最大队列都使用饱和时，可以使用 RejectedExecutionHandler 类进行异常捕捉，有如下四种处理策略：ThreadPoolExecutor.AbortPolicy、ThreadPoolExecutor.DiscardPolicy、ThreadPoolExecutor.CallerRunsPolicy、ThreadPoolExecutor.DiscardOldestPolicy。</li>
</ol>
<p>当请求不断增加时，各个参数起的作用如下：</p>
<ol>
<li>请求数 &lt; coreSize：创建新的线程来处理任务；</li>
<li>coreSize &lt;= 请求数 &amp;&amp; 能够成功入队列：任务进入到队列中等待被消费；</li>
<li>队列已满 &amp;&amp; 请求数 &lt; maxSize：创建新的线程来处理任务；</li>
<li>队列已满 &amp;&amp; 请求数 &gt;= maxSize：使用 RejectedExecutionHandler 类拒绝请求。</li>
</ol>
<h3 id="5：coreSize-和-maxSize-可以动态设置么，有没有规则限制？"><a href="#5：coreSize-和-maxSize-可以动态设置么，有没有规则限制？" class="headerlink" title="5：coreSize 和 maxSize 可以动态设置么，有没有规则限制？"></a>5：coreSize 和 maxSize 可以动态设置么，有没有规则限制？</h3><p>答：一般来说，coreSize 和 maxSize 在线程池初始化时就已经设定了，但我们也可以通过 setCorePoolSize、setMaximumPoolSize 方法动态的修改这两个值。</p>
<p>setCorePoolSize 的限制见如下源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果新设置的值小于 coreSize,多余的线程在空闲时会被回收（不保证一定可以回收成功）</span></span><br><span class="line"><span class="comment">// 如果大于 coseSize，会新创建线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCorePoolSize</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">int</span> delta = corePoolSize - <span class="keyword">this</span>.corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="comment">// 活动的线程大于新设置的核心线程数</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(ctl.get()) &gt; corePoolSize)</span><br><span class="line">        <span class="comment">// 尝试将可以获得锁的 worker 中断，只会循环一次</span></span><br><span class="line">        <span class="comment">// 最后并不能保证活动的线程数一定小于核心线程数</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">    <span class="comment">// 设置的核心线程数大于原来的核心线程数</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delta &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 并不清楚应该新增多少线程，取新增核心线程数和等待队列数据的最小值，够用就好</span></span><br><span class="line">        <span class="keyword">int</span> k = Math.min(delta, workQueue.size());</span><br><span class="line">        <span class="comment">// 新增线程直到k，如果期间等待队列空了也不会再新增</span></span><br><span class="line">        <span class="keyword">while</span> (k-- &gt; <span class="number">0</span> &amp;&amp; addWorker(<span class="keyword">null</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (workQueue.isEmpty())</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>setMaximumPoolSize 的限制见如下源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果 maxSize 大于原来的值，直接设置。</span></span><br><span class="line"><span class="comment">// 如果 maxSize 小于原来的值，尝试干掉一些 worker</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaximumPoolSize</span><span class="params">(<span class="keyword">int</span> maximumPoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maximumPoolSize &lt;= <span class="number">0</span> || maximumPoolSize &lt; corePoolSize)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(ctl.get()) &gt; maximumPoolSize)</span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6：说一说对于线程空闲回收的理解，源码中如何体现的？"><a href="#6：说一说对于线程空闲回收的理解，源码中如何体现的？" class="headerlink" title="6：说一说对于线程空闲回收的理解，源码中如何体现的？"></a>6：说一说对于线程空闲回收的理解，源码中如何体现的？</h3><p>答：空闲线程回收的时机：如果线程超过 keepAliveTime 时间后，还从阻塞队列中拿不到任务（这种情况我们称为线程空闲），当前线程就会被回收，如果 allowCoreThreadTimeOut 设置成 true，core thread 也会被回收，直到还剩下一个线程为止，如果 allowCoreThreadTimeOut 设置成 false，只会回收非 core thread 的线程。</p>
<p>线程在任务执行完成之后，之所有没有消亡，是因为阻塞的从队列中拿任务，在 keepAliveTime 时间后都没有拿到任务的话，就会打断阻塞，线程直接返回，线程的生命周期就结束了，JVM 会回收掉该线程对象，所以我们说的线程回收源码体现就是让线程不在队列中阻塞，直接返回了，可以见 ThreadPoolExecutor 源码解析章节第三小节的源码解析。</p>
<h3 id="7：如果我想在线程池任务执行之前和之后，做一些资源清理的工作，可以么，如何做？"><a href="#7：如果我想在线程池任务执行之前和之后，做一些资源清理的工作，可以么，如何做？" class="headerlink" title="7：如果我想在线程池任务执行之前和之后，做一些资源清理的工作，可以么，如何做？"></a>7：如果我想在线程池任务执行之前和之后，做一些资源清理的工作，可以么，如何做？</h3><p>答：可以的，ThreadPoolExecutor 提供了一些钩子函数，我们只需要继承 ThreadPoolExecutor 并实现这些钩子函数即可。在线程池任务执行之前实现 beforeExecute 方法，执行之后实现 afterExecute 方法。</p>
<h3 id="8：线程池中的线程创建，拒绝请求可以自定义实现么？如何自定义？"><a href="#8：线程池中的线程创建，拒绝请求可以自定义实现么？如何自定义？" class="headerlink" title="8：线程池中的线程创建，拒绝请求可以自定义实现么？如何自定义？"></a>8：线程池中的线程创建，拒绝请求可以自定义实现么？如何自定义？</h3><p>答：可以自定义的，线程创建默认使用的是 DefaultThreadFactory，自定义话的只需要实现 ThreadFactory 接口即可；拒绝请求也是可以自定义的，实现 RejectedExecutionHandler 接口即可；在 ThreadPoolExecutor 初始化时，将两个自定义类作为构造器的入参传递给 ThreadPoolExecutor 即可。</p>
<h3 id="9：说说你对-Worker-的理解？"><a href="#9：说说你对-Worker-的理解？" class="headerlink" title="9：说说你对 Worker 的理解？"></a>9：说说你对 Worker 的理解？</h3><p>答：详见《ThreadPoolExecutor 源码解析》中 1.4 小节。</p>
<h3 id="10：说一说-submit-方法执行的过程？"><a href="#10：说一说-submit-方法执行的过程？" class="headerlink" title="10：说一说 submit 方法执行的过程？"></a>10：说一说 submit 方法执行的过程？</h3><p>答：详见《ThreadPoolExecutor 源码解析》中 2 小节。</p>
<h3 id="11：说一说线程执行任务之后，都在干啥？"><a href="#11：说一说线程执行任务之后，都在干啥？" class="headerlink" title="11：说一说线程执行任务之后，都在干啥？"></a>11：说一说线程执行任务之后，都在干啥？</h3><p>答：线程执行任务完成之后，有两种结果：</p>
<ol>
<li>线程会阻塞从队列中拿任务，没有任务的话无限阻塞；</li>
<li>线程会阻塞从队列中拿任务，没有任务的话阻塞一段时间后，线程返回，被 JVM 回收。</li>
</ol>
<h3 id="12：keepAliveTime-设置成负数或者是-0，表示无限阻塞？"><a href="#12：keepAliveTime-设置成负数或者是-0，表示无限阻塞？" class="headerlink" title="12：keepAliveTime 设置成负数或者是 0，表示无限阻塞？"></a>12：keepAliveTime 设置成负数或者是 0，表示无限阻塞？</h3><p>答：这种是不对的，如果 keepAliveTime 设置成负数，在线程池初始化时，就会直接报 IllegalArgumentException 的异常，而设置成 0，队列如果是 LinkedBlockingQueue 的话，执行 workQueue.poll (keepAliveTime, TimeUnit.NANOSECONDS) 方法时，如果队列中没有任务，会直接返回 null，导致线程立马返回，不会无限阻塞。</p>
<p>如果想无限阻塞的话，可以把 keepAliveTime 设置的很大，把 TimeUnit 也设置的很大，接近于无限阻塞。</p>
<h3 id="13：说一说-Future-get-方法是如何拿到线程的执行结果的？"><a href="#13：说一说-Future-get-方法是如何拿到线程的执行结果的？" class="headerlink" title="13：说一说 Future.get 方法是如何拿到线程的执行结果的？"></a>13：说一说 Future.get 方法是如何拿到线程的执行结果的？</h3><p>答：我们需要明确几点：</p>
<ol>
<li>submit 方法的返回结果实际上是 FutureTask，我们平时都是针对接口编程，所以使用的是 Future.get 来拿到线程的执行结果，实际上是 FutureTask.get ，其方法底层是从 FutureTask 的 outcome 属性拿值的；</li>
<li>《ThreadPoolExecutor 源码解析》中 2 小节中详细说明了 submit 方法最终会把线程的执行结果赋值给 outcome。</li>
</ol>
<p>结合 1、2，当线程执行完成之后，自然就可以从 FutureTask 的 outcome 属性中拿到值。</p>
<h3 id="14：总结"><a href="#14：总结" class="headerlink" title="14：总结"></a>14：总结</h3><p>如果我们弄清楚 ThreadPoolExecutor 的原理之后，线程池的面试题都很简单，所以建议大家多看看 《ThreadPoolExecutor 源码解析》这小节。</p>
<h2 id="39-经验总结：不同场景，如何使用线程池"><a href="#39-经验总结：不同场景，如何使用线程池" class="headerlink" title="39 经验总结：不同场景，如何使用线程池"></a><strong>39 经验总结：不同场景，如何使用线程池</strong></h2><h3 id="引导语-36"><a href="#引导语-36" class="headerlink" title="引导语"></a>引导语</h3><p>ThreadPoolExecutor 初始化时，主要有如下几个参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<p>大家对这几个参数应该都很熟悉了，虽然参数很少，但实际工作中却有很多门道，大多数的问题主要集中在线程大小的设置，队列大小的设置两方面上，接下来我们一起看看工作中，如何初始化 ThreadPoolExecutor。</p>
<h3 id="1-coreSize-maxSize"><a href="#1-coreSize-maxSize" class="headerlink" title="1 coreSize == maxSize"></a>1 coreSize == maxSize</h3><p>我相信很多人都看过，或自己写过这样的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>, <span class="number">10</span>, <span class="number">600000L</span>, TimeUnit.DAYS,</span><br><span class="line">                                                     <span class="keyword">new</span> LinkedBlockingQueue());</span><br></pre></td></tr></table></figure>

<p>这行代码主要展示了在初始化 ThreadPoolExecutor 的时候，coreSize 和 maxSize 是相等的，这样设置的话，随着请求的不断增加，会是这样的现象：</p>
<ol>
<li>请求数 &lt; coreSize 时，新增线程；</li>
<li>请求数 &gt;= coreSize &amp;&amp; 队列不满时，添加任务入队；</li>
<li>队列满时，此时因为 coreSize 和 maxSize 相等，任务会被直接拒绝。</li>
</ol>
<p>这么写的最大目的：是想让线程一下子增加到 maxSize，并且不要回收线程，防止线程回收，避免不断增加回收的损耗，一般来说业务流量都有波峰低谷，在流量低谷时，线程不会被回收；流量波峰时，maxSize 的线程可以应对波峰，不需要慢慢初始化到 maxSize 的过程。</p>
<p>这样设置有两个前提条件：</p>
<ol>
<li>allowCoreThreadTimeOut 我们采取默认 false，而不会主动设置成 true，allowCoreThreadTimeOut 是 false 的话，当线程空闲时，就不会回收核心线程；</li>
<li>keepAliveTime 和 TimeUnit 我们都会设置很大，这样线程空闲的时间就很长，线程就不会轻易的被回收。</li>
</ol>
<p>我们现在机器的资源都是很充足的，我们不用去担心线程空闲会浪费机器的资源，所以这种写法目前是很常见的。</p>
<h3 id="2-maxSize-无界-SynchronousQueue"><a href="#2-maxSize-无界-SynchronousQueue" class="headerlink" title="2 maxSize 无界 + SynchronousQueue"></a>2 maxSize 无界 + SynchronousQueue</h3><p>在线程池选择队列时，我们也会看到有同学选择 SynchronousQueue，SynchronousQueue 我们在 《SynchronousQueue 源码解析》章节有说过，其内部有堆栈和队列两种形式，默认是堆栈的形式，其内部是没有存储的容器的，放元素和拿元素是一一对应的，比如我使用 put 方法放元素，如果此时没有对应的 take 操作的话，put 操作就会阻塞，需要有线程过来执行 take 操作后，put 操作才会返回。</p>
<p>基于此特点，如果要使用 SynchronousQueue 的话，我们需要尽量将 maxSize 设置大一点，这样就可以接受更多的请求。</p>
<p>假设我们设置 maxSize 是 10 的话，选择 SynchronousQueue 队列，假设所有请求都执行 put 操作，没有请求执行 take 操作，前 10 个 put 请求会消耗 10 个线程，都阻塞在 put 操作上，第 11 个请求过来后，请求就会被拒绝，所以我们才说尽量把 maxSize 设置大一点，防止请求被拒绝。</p>
<p>maxSize 无界 + SynchronousQueue 这样的组合方式优缺点都很明显：</p>
<p>优点：当任务被消费时，才会返回，这样请求就能够知道当前请求是已经在被消费了，如果是其他的队列的话，我们只知道任务已经被提交成功了，但无法知道当前任务是在被消费中，还是正在队列中堆积。</p>
<p>缺点：</p>
<ol>
<li>比较消耗资源，大量请求到来时，我们会新建大量的线程来处理请求；</li>
<li>如果请求的量难以预估的话，maxSize 的大小也很难设置。</li>
</ol>
<h3 id="3-maxSize-有界-Queue-无界"><a href="#3-maxSize-有界-Queue-无界" class="headerlink" title="3 maxSize 有界 + Queue 无界"></a>3 maxSize 有界 + Queue 无界</h3><p>在一些对实时性要求不大，但流量忽高忽低的场景下，可以使用 maxSize 有界 + Queue 无界的组合方式。</p>
<p>比如我们设置 maxSize 为 20，Queue 选择默认构造器的 LinkedBlockingQueue，这样做的优缺点如下：</p>
<p>优点：</p>
<ol>
<li>电脑 cpu 固定的情况下，每秒能同时工作的线程数是有限的，此时开很多的线程其实也是浪费，还不如把这些请求放到队列中去等待，这样可以减少线程之间的 CPU 的竞争；</li>
<li>LinkedBlockingQueue 默认构造器构造出来的链表的最大容量是 Integer 的最大值，非常适合流量忽高忽低的场景，当流量高峰时，大量的请求被阻塞在队列中，让有限的线程可以慢慢消费。</li>
</ol>
<p>缺点：流量高峰时，大量的请求被阻塞在队列中，对于请求的实时性难以保证，所以当对请求的实时性要求较高的场景，不能使用该组合。</p>
<h3 id="4-maxSize-有界-Queue-有界"><a href="#4-maxSize-有界-Queue-有界" class="headerlink" title="4 maxSize 有界 + Queue 有界"></a>4 maxSize 有界 + Queue 有界</h3><p>这种组合是对 3 缺点的补充，我们把队列从无界修改成有界，只要排队的任务在要求的时间内，能够完成任务即可。</p>
<p>这种组合需要我们把线程和队列的大小进行配合计算，保证大多数请求都可以在要求的时间内，有响应返回。</p>
<h3 id="5-keepAliveTime-设置无穷大"><a href="#5-keepAliveTime-设置无穷大" class="headerlink" title="5 keepAliveTime 设置无穷大"></a>5 keepAliveTime 设置无穷大</h3><p>有些场景下我们不想让空闲的线程被回收，于是就把 keepAliveTime 设置成 0，实际上这种设置是错误的，当我们把 keepAliveTime 设置成 0 时，线程使用 poll 方法在队列上进行超时阻塞时，会立马返回 null，也就是空闲线程会立马被回收。</p>
<p>所以如果我们想要空闲的线程不被回收，我们可以设置 keepAliveTime 为无穷大值，并且设置 TimeUnit 为时间的大单位，比如我们设置 keepAliveTime 为 365，TimeUnit 为 TimeUnit.DAYS，意思是线程空闲 1 年内都不会被回收。</p>
<p>在实际的工作中，机器的内存一般都够大，我们合理设置 maxSize 后，即使线程空闲，我们也不希望线程被回收，我们常常也会设置 keepAliveTime 为无穷大。</p>
<h3 id="6-线程池的公用和独立"><a href="#6-线程池的公用和独立" class="headerlink" title="6 线程池的公用和独立"></a>6 线程池的公用和独立</h3><p>在实际工作中，某一个业务下的所有场景，我们都不会公用一个线程池，一般有以下几个原则：</p>
<ol>
<li>查询和写入不公用线程池，互联网应用一般来说，查询量远远大于写入的量，如果查询和写入都要走线程池的话，我们一定不要公用线程池，也就是说查询走查询的线程池，写入走写入的线程池，如果公用的话，当查询量很大时，写入的请求可能会到队列中去排队，无法及时被处理；</li>
<li>多个写入业务场景看情况是否需要公用线程池，原则上来说，每个业务场景都独自使用自己的线程池，绝不共用，这样在业务治理、限流、熔断方面都比较容易，一旦多个业务场景公用线程池，可能就会造成业务场景之间的互相影响，现在的机器内存都很大，每个写入业务场景独立使用自己的线程池也是比较合理的；</li>
<li>多个查询业务场景是可以公用线程池的，查询的请求一般来说有几个特点：查询的场景多、rt 时间短、查询的量比较大，如果给每个查询场景都弄一个单独的线程池的话，第一个比较耗资源，第二个很难定义线程池中线程和队列的大小，比较复杂，所以多个相似的查询业务场景是可以公用线程池的。</li>
</ol>
<h3 id="7-如何算线程大小和队列大小"><a href="#7-如何算线程大小和队列大小" class="headerlink" title="7 如何算线程大小和队列大小"></a>7 如何算线程大小和队列大小</h3><p>在实际的工作中，我们使用线程池时，需要慎重考虑线程的大小和队列的大小，主要从几个方面入手：</p>
<ol>
<li>根据业务进行考虑，初始化线程池时，我们需要考虑所有业务涉及的线程池，如果目前所有的业务同时都有很大流量，那么在对于当前业务设置线程池时，我们尽量把线程大小、队列大小都设置小，如果所有业务基本上都不会同时有流量，那么就可以稍微设置大一点；</li>
<li>根据业务的实时性要求，如果实时性要求高的话，我们把队列设置小一点，coreSize == maxSize，并且设置 maxSize 大一点，如果实时性要求低的话，就可以把队列设置大一点。</li>
</ol>
<p>假设现在机器上某一时间段只会运行一种业务，业务的实时性要求较高，每个请求的平均 rt 是 200ms，请求超时时间是 2000ms，机器是 4 核 CPU，内存 16G，一台机器的 qps 是 100，这时候我们可以模拟一下如何设置：</p>
<ol>
<li>4 核 CPU，假设 CPU 能够跑满，每个请求的 rt 是 200ms，就是 200 ms 能执行 4 条请求，2000ms 内能执行 2000/200 * 4 = 40 条请求；</li>
<li>200 ms 能执行 4 条请求，实际上 4 核 CPU 的性能远远高于这个，我们可以拍脑袋加 10 条，也就是说 2000ms 内预估能够执行 50 条；</li>
<li>一台机器的 qps 是 100，此时我们计算一台机器 2 秒内最多处理 50 条请求，所以此时如果不进行 rt 优化的话，我们需要加至少一台机器。</li>
</ol>
<p>线程池可以大概这么设置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">15</span>, <span class="number">15</span>, <span class="number">365L</span>, TimeUnit.DAYS,</span><br><span class="line">                                                     <span class="keyword">new</span> LinkedBlockingQueue(<span class="number">35</span>));</span><br></pre></td></tr></table></figure>

<p>线程数最大为 15，队列最大为 35，这样机器差不多可以在 2000ms 内处理最大的请求 50 条，当然根据你机器的性能和实时性要求，你可以调整线程数和队列的大小占比，只要总和小于 50 即可。</p>
<p>以上只是很粗糙的设置，在实际的工作中，还需要根据实际情况不断的观察和调整。</p>
<h3 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h3><p>线程池设置非常重要，我们尽量少用 Executors 类提供的各种初始化线程池的方法，多根据业务的量，实时性要求来计算机器的预估承载能力，设置预估的线程和队列大小，并且根据实时请求不断的调整线程池的大小值。</p>
<h2 id="40-打动面试官：线程池流程编排中的运用实战"><a href="#40-打动面试官：线程池流程编排中的运用实战" class="headerlink" title="40 打动面试官：线程池流程编排中的运用实战"></a><strong>40 打动面试官：线程池流程编排中的运用实战</strong></h2><h3 id="引导语-37"><a href="#引导语-37" class="headerlink" title="引导语"></a>引导语</h3><p>在线程池的面试中，面试官除了喜欢问 ThreadPoolExecutor 的底层源码外，还喜欢问你有没有在实际的工作中用过 ThreadPoolExecutor，我们在并发集合类的《场景集合：并发 List、Map 的应用场景》一文中说过一种简单的流程引擎，如果没有看过的同学，可以返回去看一下。</p>
<p>本章就在流程引擎的基础上运用 ThreadPoolExecutor，使用线程池实现 SpringBean 的异步执行。</p>
<h3 id="1-流程引擎关键代码回顾"><a href="#1-流程引擎关键代码回顾" class="headerlink" title="1 流程引擎关键代码回顾"></a>1 流程引擎关键代码回顾</h3><p>《场景集合：并发 List、Map 的应用场景》文中流程引擎执行 SpringBean 的核心代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 批量执行 Spring Bean</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stageInvoke</span><span class="params">(String flowName, StageEnum stage, FlowContent content)</span> </span>&#123;</span><br><span class="line">  List&lt;DomainAbilityBean&gt;</span><br><span class="line">      domainAbilitys =</span><br><span class="line">      FlowCenter.flowMap.getOrDefault(flowName, Maps.newHashMap()).get(stage);</span><br><span class="line">  <span class="keyword">if</span> (CollectionUtils.isEmpty(domainAbilitys)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;找不到该流程对应的领域行为&quot;</span> + flowName);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (DomainAbilityBean domainAbility : domainAbilitys) &#123;</span><br><span class="line">    <span class="comment">// 执行 Spring Bean</span></span><br><span class="line">    domainAbility.invoke(content);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>入参是 flowName（流程名称）、stage（阶段）、content（上下文），其中 stage 中会执行很多 SpringBean，SpringBean 被执行的代码是 domainAbility.invoke(content)。</p>
<h3 id="2-异步执行-SpringBean"><a href="#2-异步执行-SpringBean" class="headerlink" title="2 异步执行 SpringBean"></a>2 异步执行 SpringBean</h3><p>从上述代码中，我们可以看到所有的 SpringBean 都是串行执行的，效率较低，我们在实际业务中发现，有的 SpringBean 完全可以异步执行，这样既能完成业务请求，又能减少业务处理的 rt，对于这个需求，我们条件反射的有了两个想法：</p>
<ol>
<li>需要新开线程来异步执行 SpringBean，可以使用 Runable 或者 Callable；</li>
<li>业务请求量很大，我们不能每次来一个请求，就开一个线程，我们应该让线程池来管理异步执行的线程。</li>
</ol>
<p>于是我们决定使用线程池来完成这个需求。</p>
<h3 id="3-如何区分异步的-SpringBean"><a href="#3-如何区分异步的-SpringBean" class="headerlink" title="3 如何区分异步的 SpringBean"></a>3 如何区分异步的 SpringBean</h3><p>我们的 SpringBean 都是实现 DomainAbilityBean 这个接口的，接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DomainAbilityBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 领域行为的方法入口</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">FlowContent <span class="title">invoke</span><span class="params">(FlowContent content)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从接口定义上来看，没有预留任何地方来标识该 SpringBean 应该是同步执行还是异步执行，这时候我们可以采取注解的方式，我们新建一个注解，只要 SpringBean 上有该注解，表示该 SpringBean 应该异步执行，否则应该同步执行，新建的注解如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 异步 SpringBean 执行注解</span></span><br><span class="line"><span class="comment"> * SpringBean 需要异步执行的话，就打上该注解</span></span><br><span class="line"><span class="comment">*author  wenhe</span></span><br><span class="line"><span class="comment">*date 2019/10/7</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span><span class="comment">// 表示该注解应该打在类上</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AsyncComponent &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们新建了两个 SpringBean，并在其中一个 SpringBean 上打上异步的注解，并且打印出执行 SpringBean 的线程名称，如下图：<br><img src="http://img.mukewang.com/5dd5fd640001cd7618201354.png" alt="图片描述"></p>
<p>图中实现了两个 SpringBean：BeanOne 和 BeanTwo，其中 BeanTwo 被打上了 AsyncComponent 注解，表明 BeanTwo 应该被异步执行，两个 SpringBean 都打印出执行的线程的名称。</p>
<h3 id="4-mock-流程引擎数据中心"><a href="#4-mock-流程引擎数据中心" class="headerlink" title="4 mock 流程引擎数据中心"></a>4 mock 流程引擎数据中心</h3><p>《场景集合：并发 List、Map 的应用场景》一文中，我们说可以从数据库中加载出流程引擎需要的数据，此时我们 mock 一下，mock 的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowCenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * flowMap 是共享变量，方便访问</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Map&lt;StageEnum, List&lt;DomainAbilityBean&gt;&gt;&gt; flowMap</span><br><span class="line">      = Maps.newConcurrentMap();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * PostConstruct 注解的意思就是</span></span><br><span class="line"><span class="comment">   * 在容器启动成功之后，初始化 flowMap</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@PostConstruct</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 初始化 flowMap mock</span></span><br><span class="line">    Map&lt;StageEnum, List&lt;DomainAbilityBean&gt;&gt; stageMap = flowMap.getOrDefault(<span class="string">&quot;flow1&quot;</span>,Maps.newConcurrentMap());</span><br><span class="line">    <span class="keyword">for</span> (StageEnum value : StageEnum.values()) &#123;</span><br><span class="line">      List&lt;DomainAbilityBean&gt; domainAbilitys = stageMap.getOrDefault(value, Lists.newCopyOnWriteArrayList());</span><br><span class="line">      <span class="keyword">if</span>(CollectionUtils.isEmpty(domainAbilitys))&#123;</span><br><span class="line">        domainAbilitys.addAll(ImmutableList.of(</span><br><span class="line">            ApplicationContextHelper.getBean(BeanOne.class),</span><br><span class="line">            ApplicationContextHelper.getBean(BeanTwo.class)</span><br><span class="line">        ));</span><br><span class="line">        stageMap.put(value,domainAbilitys);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    flowMap.put(<span class="string">&quot;flow1&quot;</span>,stageMap);</span><br><span class="line">    <span class="comment">// 打印出加载完成之后的数据结果</span></span><br><span class="line">    log.info(<span class="string">&quot;init success,flowMap is &#123;&#125;&quot;</span>, JSON.toJSONString(flowMap));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-新建线程池"><a href="#5-新建线程池" class="headerlink" title="5 新建线程池"></a>5 新建线程池</h3><p>在以上操作完成之后，只剩下最后一步了，之前我们执行 SpringBean 时，是这行代码：domainAbility.invoke(content);</p>
<p>现在我们需要区分 SpringBean 是否是异步的，如果是异步的，丢到线程池中去执行，如果是同步的，仍然使用原来的方法进行执行，于是我们把这些逻辑封装到一个工具类中，工具类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 组件执行器</span></span><br><span class="line"><span class="comment"> * author  wenhe</span></span><br><span class="line"><span class="comment"> * date 2019/10/7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComponentExecutor</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 我们新建了一个线程池</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">15</span>, <span class="number">15</span>,</span><br><span class="line">                                                                   <span class="number">365L</span>, TimeUnit.DAYS,</span><br><span class="line">                                                                   <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;());</span><br><span class="line">	<span class="comment">// 如果 SpringBean 上有 AsyncComponent 注解，表示该 SpringBean 需要异步执行，就丢到线程池中去</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(DomainAbilityBean component, FlowContent content)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断类上是否有 AsyncComponent 注解</span></span><br><span class="line">    <span class="keyword">if</span> (AnnotationUtils.isAnnotationPresent(AsyncComponent.class, AopUtils.getTargetClass(component))) &#123;</span><br><span class="line">      <span class="comment">// 提交到线程池中</span></span><br><span class="line">      executor.submit(() -&gt; &#123; component.invoke(content); &#125;);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同步 SpringBean 直接执行。</span></span><br><span class="line">    component.invoke(content);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们把原来的执行代码替换成使用组件执行器执行，如下图：<br><img src="http://img.mukewang.com/5dd5fd4a0001878c16481102.png" alt="图片描述"></p>
<h3 id="6-测试"><a href="#6-测试" class="headerlink" title="6 测试"></a>6 测试</h3><p>以上步骤完成之后，简单的流程引擎就已经完成了，我们简单地在项目启动的时候加上测试，代码如下：<br><img src="http://img.mukewang.com/5dd5fd3d0001c5c416681156.png" alt="图片描述"></p>
<p>更严谨的做法，是会写单元测试来测试流程引擎，为了快一点，我们直接在项目启动类上加上了测试代码。</p>
<p>运行之后的关键结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[main] demo.sixth.SynchronizedDemo: SynchronizedDemo init begin</span><br><span class="line">[main] demo.sixth.SynchronizedDemo: SynchronizedDemo init end</span><br><span class="line">[main] demo.three.flow.FlowCenter : init success,flowMap is &#123;<span class="string">&quot;flow1&quot;</span>:&#123;<span class="string">&quot;PARAM_VALID&quot;</span>:[&#123;&#125;,&#123;&#125;],<span class="string">&quot;AFTER_TRANSACTION&quot;</span>:[&#123;<span class="string">&quot;$ref&quot;</span>:<span class="string">&quot;$.flow1.PARAM_VALID[0]&quot;</span>&#125;,&#123;<span class="string">&quot;$ref&quot;</span>:<span class="string">&quot;$.flow1.PARAM_VALID[1]&quot;</span>&#125;],<span class="string">&quot;BUSINESS_VALID&quot;</span>:[&#123;<span class="string">&quot;$ref&quot;</span>:<span class="string">&quot;$.flow1.PARAM_VALID[0]&quot;</span>&#125;,&#123;<span class="string">&quot;$ref&quot;</span>:<span class="string">&quot;$.flow1.PARAM_VALID[1]&quot;</span>&#125;],<span class="string">&quot;IN_TRANSACTION&quot;</span>:[&#123;<span class="string">&quot;$ref&quot;</span>:<span class="string">&quot;$.flow1.PARAM_VALID[0]&quot;</span>&#125;,&#123;<span class="string">&quot;$ref&quot;</span>:<span class="string">&quot;$.flow1.PARAM_VALID[1]&quot;</span>&#125;]&#125;&#125;</span><br><span class="line">o.s.j.e.a.AnnotationMBeanExporter  : Registering beans <span class="keyword">for</span> JMX exposure on startup</span><br><span class="line">[main] s.b.c.e.t.TomcatEmbeddedServletContainer : <span class="function">Tomcat started on <span class="title">port</span><span class="params">(s)</span>: 8080 <span class="params">(http)</span></span></span><br><span class="line"><span class="function">[main] demo.DemoApplication : Started DemoApplication in 5.377 <span class="title">seconds</span> <span class="params">(JVM running <span class="keyword">for</span> <span class="number">6.105</span>)</span></span></span><br><span class="line"><span class="function">[main] demo.three.flow.BeanOne : BeanOne is run,thread name is main</span></span><br><span class="line"><span class="function">[main] demo.three.flow.BeanOne : BeanOne is run,thread name is main</span></span><br><span class="line"><span class="function">[pool-1-thread-1] demo.three.flow.BeanTwo : BeanTwo is run,thread name is pool-1-thread-1</span></span><br><span class="line"><span class="function">[main] demo.three.flow.BeanOne : BeanOne is run,thread name is main</span></span><br><span class="line"><span class="function">[pool-1-thread-2] demo.three.flow.BeanTwo : BeanTwo is run,thread name is pool-1-thread-2</span></span><br><span class="line"><span class="function">[pool-1-thread-3] demo.three.flow.BeanTwo : BeanTwo is run,thread name is pool-1-thread-3</span></span><br><span class="line"><span class="function">[main] demo.three.flow.BeanOne : BeanOne is run,thread name is main</span></span><br><span class="line"><span class="function">[pool-1-thread-4] demo.three.flow.BeanTwo : BeanTwo is run,thread name is pool-1-thread-4</span></span><br></pre></td></tr></table></figure>

<p>从运行结果中，我们可以看到 BeanTwo 已经被多个不同的线程异步执行了。</p>
<h3 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h3><p>这是一个线程池在简单流程引擎上的运用实站，虽然这个流程引擎看起来比较简单，但在实际工作中，还是非常好用的，大家可以把代码拉下来，自己尝试一下，调试一下参数，比如当我新增 SpringBean 的时候，流程引擎的表现如何。</p>
<h1 id="第8章-Lambda-流"><a href="#第8章-Lambda-流" class="headerlink" title="第8章 Lambda 流"></a><strong>第8章 Lambda 流</strong></h1><h2 id="41-突破难点：如何看-Lambda-源码"><a href="#41-突破难点：如何看-Lambda-源码" class="headerlink" title="41 突破难点：如何看 Lambda 源码"></a><strong>41 突破难点：如何看 Lambda 源码</strong></h2><h3 id="引导语-38"><a href="#引导语-38" class="headerlink" title="引导语"></a>引导语</h3><p>大家都知道 Java8 中新增了 Lambda 表达式，使用 Lambda 表达式可以对代码进行大量的优化，用几行代码就可以做很多事情，本章以 Lambda 为例，第一小节说明一下其底层的执行原理，第二小节说明一下 Lambda 流在工作中常用的姿势。</p>
<h3 id="1-Demo"><a href="#1-Demo" class="headerlink" title="1 Demo"></a>1 Demo</h3><p>首先我们来看一个 Lambda 表达式的 Demo，如下图：<br><img src="http://img.mukewang.com/5dd5fe830001211007440492.png" alt="图片描述"></p>
<p>代码比较简单，就是新起一个线程打印一句话，但对于图中 () -&gt; System.out.println ( “ lambda is run “ ) 这种代码，估计很多同学都感觉到很困惑，Java 是怎么识别这种代码的？</p>
<p>如果我们修改成匿名内部类的写法，就很清楚，大家都能看懂，如下图：<br><img src="http://img.mukewang.com/5dd5fe980001358906980558.png" alt="图片描述"></p>
<p>那是不是说 () -&gt; System.out.println ( “ lambda is run “ ) 这种形式的代码，其实就是建立了内部类呢？其实这就是最简单 Lambda 表达式，我们是无法通过 IDEA 看到源码和其底层结构的，下面我们就来介绍几种可看到其底层实现的方式。</p>
<h3 id="2-异常判断法"><a href="#2-异常判断法" class="headerlink" title="2 异常判断法"></a>2 异常判断法</h3><p>我们可以在代码执行中主动抛出异常，打印出堆栈，堆栈会说明其运行轨迹，一般这种方法简单高效，基本上可以看到很多情况下的隐藏代码，我们来试一下，如下图：<br><img src="http://img.mukewang.com/5dd5fea9000187c107670699.png" alt="图片描述"></p>
<p>从异常的堆栈中，我们可以看到 JVM 自动给当前类建立了内部类（错误堆栈中出现多次的 $ 表示有内部类），内部类的代码在执行过程中，抛出了异常，但这里显示的代码是 Unknown Source，所以我们也无法 debug 进去，一般情况下，异常都能暴露出代码执行的路径，我们可以打好断点后再次运行，但对于 Lambda 表达式而言，通过异常判断法我们只清楚有内部类，但无法看到内部类中的源码。</p>
<h3 id="3-javap-命令法"><a href="#3-javap-命令法" class="headerlink" title="3 javap 命令法"></a>3 javap 命令法</h3><p>javap 是 Java 自带的可以查看 class 字节码文件的工具，安装过 Java 基础环境的电脑都可以直接执行 javap 命令，如下图：<br><img src="http://img.mukewang.com/5dd5fec0000181d909200570.png" alt="图片描述"></p>
<p>命令选项中，我们主要是用-v -verbose 这个命令，可以完整输出字节码文件的内容。</p>
<p>接下来我们使用 javap 命令查看下 Lambda.class 文件，在讲解的过程中，我们会带上一些关于 class 文件的知识。</p>
<p>我们在命令窗口中找到 Lambda.class 所在的位置，执行命令：javap -verbose Lambda.class，然后你会看到一长串的东西，这些叫做汇编指令，接下来我们来一一讲解下（ 所有的参考资料来自 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4">Java 虚拟机规范</a>，不再一一引用说明）：</p>
<p>汇编指令中我们很容易找到 Constant pool 打头的一长串类型，我们叫做常量池，官方英文叫做 Run-Time Constant Pool，我们简单理解成一个装满常量的 table ，table 中包含编译时明确的数字和文字，类、方法和字段的类型信息等等。table 中的每个元素叫做 cp<em>info，cp</em>info 由唯一标识 ( tag ) + 名称组成，目前 tag 的类型一共有：<br><img src="http://img.mukewang.com/5dd5fedc00012eb605020734.png" alt="图片描述"></p>
<p>贴出我们解析出来的部分图：<br><img src="http://img.mukewang.com/5dd5fee90001bf8118760941.png" alt="图片描述"></p>
<ol>
<li>图中 Constant pool 字样代表当前信息是常量池；</li>
<li>每行都是一个 <code>cp_info</code> ，第一列的 #1 代表是在常量池下标为 1 的位置 ；</li>
<li>每行的第二列，是 <code>cp_info</code> 的唯一标识 ( tag ) ，比如 Methodref 对应着上表中的 CONSTANT_Methodref（上上图中表格中 value 对应 10 的 tag），代表当前行是表示方法的描述信息的，比如说方法的名称，入参类型，出参数类型等，具体的含义在 Java 虚拟机规范中都可以查询到，Methodref 的截图如下：<br><img src="http://img.mukewang.com/5dd5ff070001ff6219441450.png" alt="图片描述"></li>
<li>每行的第三列，如果是具体的值的话，直接显示具体的值，如果是复杂的值的话，会显示 <code>cp_info</code> 的引用，比如说图中标红 2 处，引用两个 13 和 14 位置的 <code>cp_info</code>，13 表示方法名字是 init，14 表示方法无返回值，结合起来表示方法的名称和返回类型，就是一个无参构造器；</li>
<li>每行的第四列，就是具体的值了。</li>
</ol>
<p>对于比较重要的 cp_info 类型我们说明下其含义：</p>
<ol>
<li>InvokeDynamic 表示动态的调用方法，后面我们会详细说明；</li>
<li>Fieldref 表示字段的描述信息，如字段的名称、类型；</li>
<li>NameAndType 是对字段和方法类型的描述；</li>
<li>MethodHandle 方法句柄，动态调用方法的统称，在编译时我们不知道具体是那个方法，但运行时肯定会知道调用的是那个方法；</li>
<li>MethodType 动态方法类型，只有在动态运行时才会知道其方法类型是什么。</li>
</ol>
<p>我们从上上图中标红的 3 处，发现 Ljava/lang/invoke/MethodHandles$Lookup，java/lang/invoke/LambdaMetafactory.metafactory 类似这样的代码，MethodHandles 和 LambdaMetafactory 都是 java.lang.invoke 包下面的重要方法，invoke 包主要实现了动态语言的功能，我们知道 java 语言属于静态编译语言，在编译的时候，类、方法、字段等等的类型都已经确定了，而 invoke 实现的是一种动态语言，也就是说编译的时候并不知道类、方法、字段是什么类型，只有到运行的时候才知道。</p>
<p>比如这行代码：Runnable runnable = () -&gt; System.out.println(“lambda is run”); 在编译器编译的时候 () 这个括号编译器并不知道是干什么的，只有在运行的时候，才会知道原来这代表着的是 Runnable.run() 方法。invoke 包里面很多类，都是为了代表这些 () 的，我们称作为方法句柄（ MethodHandler ），在编译的时候，编译器只知道这里是个方法句柄，并不知道实际上执行什么方法，只有在执行的时候才知道，那么问题来了，JVM 执行的时候，是如何知道 () 这个方法句柄，实际上是执行 Runnable.run() 方法的呢？</p>
<p>首先我们看下 simple 方法的汇编指令：<br><img src="http://img.mukewang.com/5dd5ff170001644407650528.png" alt="图片描述"></p>
<p>从上图中就可以看出 simple 方法中的 () -&gt; System.out.println(“lambda is run”) 代码中的 ()，实际上就是 Runnable.run 方法。</p>
<p>我们追溯到 # 2 常量池，也就是上上图中标红 1 处，InvokeDynamic 表示这里是个动态调用，调用的是两个常量池的 cp_info，位置是 #0:#37 ，我们往下找 #37 代表着是 // run:()Ljava/lang/Runnable，这里表明了在 JVM 真正执行的时候，需要动态调用 Runnable.run() 方法，从汇编指令上我们可以看出 () 实际上就是 Runnable.run()，下面我们 debug 来证明一下。</p>
<p>我们在上上图中 3 处发现了 LambdaMetafactory.metafactory 的字样，通过查询官方文档，得知该方法正是执行时， 链接到真正代码的关键，于是我们在 metafactory 方法中打个断点 debug 一下，如下图：<br><img src="http://img.mukewang.com/5dd5ff2d0001ae9417980859.png" alt="图片描述"></p>
<p>metafactory 方法入参 caller 代表实际发生动态调用的位置，invokedName 表示调用方法名称，invokedType 表示调用的多个入参和出参，samMethodType 表示具体的实现者的参数，implMethod 表示实际上的实现者，instantiatedMethodType 等同于 implMethod。</p>
<p>以上内容总结一下：</p>
<p>1：从汇编指令的 simple 方法中，我们可以看到会执行 Runnable.run 方法；</p>
<p>2：在实际的运行时，JVM 碰到 simple 方法的 invokedynamic 指令，会动态调用 LambdaMetafactory.metafactory 方法，执行具体的 Runnable.run 方法。</p>
<p>所以可以把 Lambda 表达值的具体执行归功于 invokedynamic JVM 指令，正是因为这个指令，才可以做到虽然编译时不知道要干啥，但动态运行时却能找到具体要执行的代码。</p>
<p>接着我们看一下在汇编指令输出的最后，我们发现了异常判断法中发现的内部类，如下图：<br><img src="http://img.mukewang.com/5dd5ff450001783a13491048.png" alt="图片描述"></p>
<p>上图中箭头很多，一层一层的表达清楚了当前内部类的所有信息。</p>
<h3 id="4-总结-8"><a href="#4-总结-8" class="headerlink" title="4 总结"></a>4 总结</h3><p>我们总结一下，Lambda 表达式执行主要是依靠 invokedynamic 的 JVM 指令来实现，咱们演示的类的全路径为：demo.eight.Lambda 感兴趣的同学可以自己尝试一下。</p>
<h2 id="42-常用的-Lambda-表达式使用场景解析和应用"><a href="#42-常用的-Lambda-表达式使用场景解析和应用" class="headerlink" title="42 常用的 Lambda 表达式使用场景解析和应用"></a><strong>42 常用的 Lambda 表达式使用场景解析和应用</strong></h2><h3 id="引导语-39"><a href="#引导语-39" class="headerlink" title="引导语"></a>引导语</h3><p>我们日常工作中，Lambda 使用比较多的场景，就是 List 或 Map 下的 Lambda 流操作，往往几行代码可以帮助我们实现多层 for 循环嵌套的复杂代码，接下来我们把 Lambda 流的常用方法用案列讲解一下。</p>
<h3 id="1-数据准备"><a href="#1-数据准备" class="headerlink" title="1 数据准备"></a>1 数据准备</h3><p>本文演示的所有代码都在 demo.eight.LambdaExpressionDemo 中，首先我们需要准备一些测试的数据，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="comment">// 学生数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentDTO</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">7716352032236707189L</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">StudentDTO</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">StudentDTO</span><span class="params">(Long id, String code, String name, String sex, Double scope,</span></span></span><br><span class="line"><span class="function"><span class="params">                    List&lt;Course&gt; learningCources)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">    <span class="keyword">this</span>.code = code;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    <span class="keyword">this</span>.scope = scope;</span><br><span class="line">    <span class="keyword">this</span>.learningCources = learningCources;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * id</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 学号 唯一标识</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> String code;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 学生名字</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 性别</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> String sex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 分数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> Double scope;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 要学习的课程</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> List&lt;Course&gt; learningCources;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="comment">// 课程数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Course</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2896201730223729591L</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 课程 ID</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 课程 name</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Course</span><span class="params">(Long id, String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化数据</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;StudentDTO&gt; students = <span class="keyword">new</span> ArrayList&lt;StudentDTO&gt;()&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 添加学生数据</span></span><br><span class="line">    add(<span class="keyword">new</span> StudentDTO(<span class="number">1L</span>,<span class="string">&quot;W199&quot;</span>,<span class="string">&quot;小美&quot;</span>,<span class="string">&quot;WM&quot;</span>,<span class="number">100D</span>,<span class="keyword">new</span> ArrayList&lt;Course&gt;()&#123;</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 添加学生学习的课程</span></span><br><span class="line">        add(<span class="keyword">new</span> Course(<span class="number">300L</span>,<span class="string">&quot;语文&quot;</span>));</span><br><span class="line">        add(<span class="keyword">new</span> Course(<span class="number">301L</span>,<span class="string">&quot;数学&quot;</span>));</span><br><span class="line">        add(<span class="keyword">new</span> Course(<span class="number">302L</span>,<span class="string">&quot;英语&quot;</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;));</span><br><span class="line">    add(<span class="keyword">new</span> StudentDTO(<span class="number">2L</span>,<span class="string">&quot;W25&quot;</span>,<span class="string">&quot;小美&quot;</span>,<span class="string">&quot;WM&quot;</span>,<span class="number">100D</span>,Lists.newArrayList()));</span><br><span class="line">    add(<span class="keyword">new</span> StudentDTO(<span class="number">3L</span>,<span class="string">&quot;W3&quot;</span>,<span class="string">&quot;小名&quot;</span>,<span class="string">&quot;M&quot;</span>,<span class="number">90D</span>,<span class="keyword">new</span> ArrayList&lt;Course&gt;()&#123;</span><br><span class="line">      &#123;</span><br><span class="line">        add(<span class="keyword">new</span> Course(<span class="number">300L</span>,<span class="string">&quot;语文&quot;</span>));</span><br><span class="line">        add(<span class="keyword">new</span> Course(<span class="number">304L</span>,<span class="string">&quot;体育&quot;</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;));</span><br><span class="line">    add(<span class="keyword">new</span> StudentDTO(<span class="number">4L</span>,<span class="string">&quot;W1&quot;</span>,<span class="string">&quot;小蓝&quot;</span>,<span class="string">&quot;M&quot;</span>,<span class="number">10D</span>,<span class="keyword">new</span> ArrayList&lt;Course&gt;()&#123;</span><br><span class="line">      &#123;</span><br><span class="line">        add(<span class="keyword">new</span> Course(<span class="number">301L</span>,<span class="string">&quot;数学&quot;</span>));</span><br><span class="line">        add(<span class="keyword">new</span> Course(<span class="number">305L</span>,<span class="string">&quot;美术&quot;</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>请大家稍微看下数据结构，不然看下面案例跑出来的结果会有些吃力。</p>
<h3 id="2-常用方法"><a href="#2-常用方法" class="headerlink" title="2 常用方法"></a>2 常用方法</h3><h4 id="2-1-Filter"><a href="#2-1-Filter" class="headerlink" title="2.1 Filter"></a>2.1 Filter</h4><p>Filter 为过滤的意思，只要满足 Filter 表达式的数据就可以留下来，不满足的数据被过滤掉，源码如下图：<br><img src="http://img.mukewang.com/5dd6009100012e5d20500742.png" alt="图片描述"></p>
<p>我们写了一个 demo，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// list 在下图中进行了初始化</span></span><br><span class="line">  List&lt;String&gt; newList = list.stream()</span><br><span class="line">      <span class="comment">// 过滤掉我们希望留下来的值</span></span><br><span class="line">      <span class="comment">// StringUtils.equals(str,&quot;hello&quot;) 表示我们希望字符串是 hello 能留下来</span></span><br><span class="line">      <span class="comment">// 其他的过滤掉</span></span><br><span class="line">      .filter(str -&gt; StringUtils.equals(str, <span class="string">&quot;hello&quot;</span>))</span><br><span class="line">      <span class="comment">// Collectors.toList() 帮助我们构造最后的返回结果</span></span><br><span class="line">      .collect(Collectors.toList());</span><br><span class="line">  log.info(<span class="string">&quot;TestFilter result is &#123;&#125;&quot;</span>, JSON.toJSONString(newList));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：<br><img src="http://img.mukewang.com/5dd6007d0001804022520840.png" alt="图片描述"></p>
<h4 id="2-2-map"><a href="#2-2-map" class="headerlink" title="2.2 map"></a>2.2 map</h4><p>map 方法可以让我们进行一些流的转化，比如原来流中的元素是 A，通过 map 操作，可以使返回的流中的元素是 B，源码如下图：<br><img src="http://img.mukewang.com/5dd6006b00015baf20920956.png" alt="图片描述"></p>
<p>我们写了一个 demo，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 得到所有学生的学号</span></span><br><span class="line">  <span class="comment">// 这里 students.stream() 中的元素是 StudentDTO，通过 map 方法转化成 String 的流</span></span><br><span class="line">  List&lt;String&gt; codes = students.stream()</span><br><span class="line">      <span class="comment">//StudentDTO::getCode 是 s-&gt;s.getCode() 的简写</span></span><br><span class="line">      .map(StudentDTO::getCode)</span><br><span class="line">      .collect(Collectors.toList());</span><br><span class="line">  log.info(<span class="string">&quot;TestMap 所有学生的学号为 &#123;&#125;&quot;</span>, JSON.toJSONString(codes));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果为：TestMap 所有学生的学号为 [&quot;W199&quot;,&quot;W25&quot;,&quot;W3&quot;,&quot;W1&quot;]</span></span><br></pre></td></tr></table></figure>



<h4 id="2-3-mapToInt"><a href="#2-3-mapToInt" class="headerlink" title="2.3 mapToInt"></a>2.3 mapToInt</h4><p>mapToInt 方法的功能和 map 方法一样，只不过 mapToInt 返回的结果已经没有泛型，已经明确是 int 类型的流了，源码如下：<br><img src="http://img.mukewang.com/5dd600580001e53d19820916.png" alt="图片描述"></p>
<p>我们写了一个 demo，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMapToInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  List&lt;Integer&gt; ids = students.stream()</span><br><span class="line">      .mapToInt(s-&gt;Integer.valueOf(s.getId()+<span class="string">&quot;&quot;</span>))</span><br><span class="line">      <span class="comment">// 一定要有 mapToObj，因为 mapToInt 返回的是 IntStream，因为已经确定是 int 类型了</span></span><br><span class="line">      <span class="comment">// 所有没有泛型的，而 Collectors.toList() 强制要求有泛型的流，所以需要使用 mapToObj</span></span><br><span class="line">      <span class="comment">// 方法返回有泛型的流</span></span><br><span class="line">      .mapToObj(s-&gt;s)</span><br><span class="line">      .collect(Collectors.toList());</span><br><span class="line">  log.info(<span class="string">&quot;TestMapToInt result is &#123;&#125;&quot;</span>, JSON.toJSONString(ids));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算学生总分</span></span><br><span class="line">  Double sumScope = students.stream()</span><br><span class="line">      .mapToDouble(s-&gt;s.getScope())</span><br><span class="line">      <span class="comment">// DoubleStream/IntStream 有许多 sum（求和）、min（求最小值）、max（求最大值）、average（求平均值）等方法</span></span><br><span class="line">      .sum();</span><br><span class="line">  log.info(<span class="string">&quot;TestMapToInt 学生总分为： is &#123;&#125;&quot;</span>, sumScope);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p>TestMapToInt result is [1,2,3,4]<br>TestMapToInt 学生总分为： is 300.0</p>
<h4 id="2-4-flatMap"><a href="#2-4-flatMap" class="headerlink" title="2.4 flatMap"></a>2.4 flatMap</h4><p>flatMap 方法也是可以做一些流的转化，和 map 方法不同的是，其明确了 Function 函数的返回值的泛型是流，源码如下：<br><img src="http://img.mukewang.com/5dd6002d0001f35415580441.png" alt="图片描述"></p>
<p>写了一个 demo，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFlatMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 计算学生所有的学习课程，flatMap 返回 List&lt;课程&gt; 格式</span></span><br><span class="line">  List&lt;Course&gt; courses = students.stream().flatMap(s-&gt;s.getLearningCources().stream())</span><br><span class="line">      .collect(Collectors.toList());</span><br><span class="line">  log.info(<span class="string">&quot;TestMapToInt flatMap 计算学生的所有学习课程如下 &#123;&#125;&quot;</span>, JSON.toJSONString(courses));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算学生所有的学习课程，map 返回两层课程嵌套格式</span></span><br><span class="line">  List&lt;List&lt;Course&gt;&gt; courses2 = students.stream().map(s-&gt;s.getLearningCources())</span><br><span class="line">      .collect(Collectors.toList());</span><br><span class="line">  log.info(<span class="string">&quot;TestMapToInt map 计算学生的所有学习课程如下 &#123;&#125;&quot;</span>, JSON.toJSONString(courses2));</span><br><span class="line"></span><br><span class="line">  List&lt;Stream&lt;Course&gt;&gt; courses3 = students.stream().map(s-&gt;s.getLearningCources().stream())</span><br><span class="line">      .collect(Collectors.toList());</span><br><span class="line">  log.info(<span class="string">&quot;TestMapToInt map 计算学生的所有学习课程如下  &#123;&#125;&quot;</span>, JSON.toJSONString(courses3));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：<br><img src="http://img.mukewang.com/5dd6000a00011d6317510627.png" alt="图片描述"></p>
<h4 id="2-5-distinct"><a href="#2-5-distinct" class="headerlink" title="2.5 distinct"></a>2.5 distinct</h4><p>distinct 方法有去重的功能，我们写了一个 demo，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDistinct</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 得到学生所有的名字，要求是去重过的</span></span><br><span class="line">  List&lt;String&gt; beforeNames = students.stream().map(StudentDTO::getName).collect(Collectors.toList());</span><br><span class="line">  log.info(<span class="string">&quot;TestDistinct 没有去重前的学生名单 &#123;&#125;&quot;</span>,JSON.toJSONString(beforeNames));</span><br><span class="line"></span><br><span class="line">  List&lt;String&gt; distinctNames = beforeNames.stream().distinct().collect(Collectors.toList());</span><br><span class="line">  log.info(<span class="string">&quot;TestDistinct 去重后的学生名单 &#123;&#125;&quot;</span>,JSON.toJSONString(distinctNames));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 连起来写</span></span><br><span class="line">  List&lt;String&gt; names = students.stream()</span><br><span class="line">      .map(StudentDTO::getName)</span><br><span class="line">      .distinct()</span><br><span class="line">      .collect(Collectors.toList());</span><br><span class="line">  log.info(<span class="string">&quot;TestDistinct 去重后的学生名单 &#123;&#125;&quot;</span>,JSON.toJSONString(names));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：<br><img src="http://img.mukewang.com/5dd5fff000012e9a14840706.png" alt="图片描述"></p>
<h4 id="2-6-Sorted"><a href="#2-6-Sorted" class="headerlink" title="2.6 Sorted"></a>2.6 Sorted</h4><p>Sorted 方法提供了排序的功能，并且允许我们自定义排序，demo 如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSorted</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 学生按照学号排序</span></span><br><span class="line">  List&lt;String&gt; beforeCodes = students.stream().map(StudentDTO::getCode).collect(Collectors.toList());</span><br><span class="line">  log.info(<span class="string">&quot;TestSorted 按照学号排序之前 &#123;&#125;&quot;</span>,JSON.toJSONString(beforeCodes));</span><br><span class="line"></span><br><span class="line">  List&lt;String&gt; sortedCodes = beforeCodes.stream().sorted().collect(Collectors.toList());</span><br><span class="line">  log.info(<span class="string">&quot;TestSorted 按照学号排序之后 is &#123;&#125;&quot;</span>,JSON.toJSONString(sortedCodes));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 直接连起来写</span></span><br><span class="line">  List&lt;String&gt; codes = students.stream()</span><br><span class="line">      .map(StudentDTO::getCode)</span><br><span class="line">      <span class="comment">// 等同于 .sorted(Comparator.naturalOrder()) 自然排序</span></span><br><span class="line">      .sorted()</span><br><span class="line">      .collect(Collectors.toList());</span><br><span class="line">  log.info(<span class="string">&quot;TestSorted 自然排序 is &#123;&#125;&quot;</span>,JSON.toJSONString(codes));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 自定义排序器</span></span><br><span class="line">  List&lt;String&gt; codes2 = students.stream()</span><br><span class="line">      .map(StudentDTO::getCode)</span><br><span class="line">      <span class="comment">// 反自然排序</span></span><br><span class="line">      .sorted(Comparator.reverseOrder())</span><br><span class="line">      .collect(Collectors.toList());</span><br><span class="line">  log.info(<span class="string">&quot;TestSorted 反自然排序 is &#123;&#125;&quot;</span>,JSON.toJSONString(codes2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：<br><img src="http://img.mukewang.com/5dd5ffd300010f9711840242.png" alt="图片描述"></p>
<h4 id="2-7-peek"><a href="#2-7-peek" class="headerlink" title="2.7 peek"></a>2.7 peek</h4><p>peek 方法很简单，我们在 peek 方法里面做任意没有返回值的事情，比如打印日志，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">students.stream().map(StudentDTO::getCode)</span><br><span class="line">    .peek(s -&gt; log.info(<span class="string">&quot;当前循环的学号是&#123;&#125;&quot;</span>,s))</span><br><span class="line">    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>



<h4 id="2-8-limit"><a href="#2-8-limit" class="headerlink" title="2.8 limit"></a>2.8 limit</h4><p>limit 方法会限制输出值个数，入参是限制的个数大小，demo 如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLimit</span><span class="params">()</span></span>&#123;</span><br><span class="line">  List&lt;String&gt; beforeCodes = students.stream().map(StudentDTO::getCode).collect(Collectors.toList());</span><br><span class="line">  log.info(<span class="string">&quot;TestLimit 限制之前学生的学号为 &#123;&#125;&quot;</span>,JSON.toJSONString(beforeCodes));</span><br><span class="line"></span><br><span class="line">  List&lt;String&gt; limitCodes = beforeCodes.stream()</span><br><span class="line">      .limit(<span class="number">2L</span>)</span><br><span class="line">      .collect(Collectors.toList());</span><br><span class="line">  log.info(<span class="string">&quot;TestLimit 限制最大限制 2 个学生的学号 &#123;&#125;&quot;</span>,JSON.toJSONString(limitCodes));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 直接连起来写</span></span><br><span class="line">  List&lt;String&gt; codes = students.stream()</span><br><span class="line">      .map(StudentDTO::getCode)</span><br><span class="line">      .limit(<span class="number">2L</span>)</span><br><span class="line">      .collect(Collectors.toList());</span><br><span class="line">  log.info(<span class="string">&quot;TestLimit 限制最大限制 2 个学生的学号 &#123;&#125;&quot;</span>,JSON.toJSONString(codes));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：<br><img src="http://img.mukewang.com/5dd5ffc00001238213120222.png" alt="图片描述"></p>
<h4 id="2-9-reduce"><a href="#2-9-reduce" class="headerlink" title="2.9 reduce"></a>2.9 reduce</h4><p>reduce 方法允许我们在循环里面叠加计算值，我们写了 demo 如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReduce</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 计算一下学生的总分数</span></span><br><span class="line">  Double sum = students.stream()</span><br><span class="line">      .map(StudentDTO::getScope)</span><br><span class="line">      <span class="comment">// scope1 和 scope2 表示循环中的前后两个数</span></span><br><span class="line">      .reduce((scope1,scope2) -&gt; scope1+scope2)</span><br><span class="line">      .orElse(<span class="number">0D</span>);</span><br><span class="line">  log.info(<span class="string">&quot;总成绩为 &#123;&#125;&quot;</span>,sum);</span><br><span class="line"></span><br><span class="line">  Double sum1 = students.stream()</span><br><span class="line">      .map(StudentDTO::getScope)</span><br><span class="line">      <span class="comment">// 第一个参数表示成绩的基数，会从 100 开始加</span></span><br><span class="line">      .reduce(<span class="number">100D</span>,(scope1,scope2) -&gt; scope1+scope2);</span><br><span class="line">  log.info(<span class="string">&quot;总成绩为 &#123;&#125;&quot;</span>,sum1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：<br><img src="http://img.mukewang.com/5dd5ffaa00012ffc10480667.png" alt="图片描述"></p>
<p>第二个计算出来的总成绩多了 100，是因为第二个例子中 reduce 是从基数 100 开始累加的。</p>
<h4 id="2-10-findFirst"><a href="#2-10-findFirst" class="headerlink" title="2.10 findFirst"></a>2.10 findFirst</h4><p>findFirst 表示匹配到第一个满足条件的值就返回，demo 如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 找到第一个叫小美同学的 ID</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindFirst</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Long id = students.stream()</span><br><span class="line">      .filter(s-&gt;StringUtils.equals(s.getName(),<span class="string">&quot;小美&quot;</span>))</span><br><span class="line">       <span class="comment">// 同学中有两个叫小美的，这里匹配到第一个就返回</span></span><br><span class="line">      .findFirst()</span><br><span class="line">      .get().getId();</span><br><span class="line">  </span><br><span class="line">  log.info(<span class="string">&quot;testFindFirst 小美同学的 ID &#123;&#125;&quot;</span>,id);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 防止空指针</span></span><br><span class="line">  Long id2 = students.stream()</span><br><span class="line">      .filter(s-&gt;StringUtils.equals(s.getName(),<span class="string">&quot;小天&quot;</span>))</span><br><span class="line">      .findFirst()</span><br><span class="line">      <span class="comment">// orElse 表示如果 findFirst 返回 null 的话，就返回 orElse 里的内容</span></span><br><span class="line">      .orElse(<span class="keyword">new</span> StudentDTO()).getId();</span><br><span class="line">  log.info(<span class="string">&quot;testFindFirst 小天同学的 ID &#123;&#125;&quot;</span>,id2);</span><br><span class="line"></span><br><span class="line">  Optional&lt;StudentDTO&gt; student= students.stream()</span><br><span class="line">      .filter(s-&gt;StringUtils.equals(s.getName(),<span class="string">&quot;小天&quot;</span>))</span><br><span class="line">      .findFirst();</span><br><span class="line">  <span class="comment">// isPresent 为 true 的话，表示 value != null，即 student.get() != null</span></span><br><span class="line">  <span class="keyword">if</span>(student.isPresent())&#123;</span><br><span class="line">    log.info(<span class="string">&quot;testFindFirst 小天同学的 ID &#123;&#125;&quot;</span>,student.get().getId());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  log.info(<span class="string">&quot;testFindFirst 找不到名为小天的同学&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：<br><img src="http://img.mukewang.com/5dd5ff9300014ba507750842.png" alt="图片描述"></p>
<h4 id="2-11-groupingBy-amp-amp-toMap"><a href="#2-11-groupingBy-amp-amp-toMap" class="headerlink" title="2.11 groupingBy &amp;&amp; toMap"></a>2.11 groupingBy &amp;&amp; toMap</h4><p>groupingBy 是能够根据字段进行分组，toMap 是把 List 的数据格式转化成 Map 的格式，我们写了一个 demo，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testListToMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 学生根据名字进行分类</span></span><br><span class="line">  Map&lt;String, List&lt;StudentDTO&gt;&gt; map1 = students.stream()</span><br><span class="line">      .collect(Collectors.groupingBy(StudentDTO::getName));</span><br><span class="line">  log.info(<span class="string">&quot;testListToMap groupingBy 学生根据名字进行分类 result is Map&lt;String,List&lt;StudentDTO&gt;&gt; &#123;&#125;&quot;</span>,</span><br><span class="line">           JSON.toJSONString(map1));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 统计姓名重名的学生有哪些</span></span><br><span class="line">  Map&lt;String, Set&lt;String&gt;&gt; map2 = students.stream()</span><br><span class="line">      .collect(Collectors.groupingBy(StudentDTO::getName,</span><br><span class="line">                                  Collectors.mapping(StudentDTO::getCode,Collectors.toSet())));</span><br><span class="line">  log.info(<span class="string">&quot;testListToMap groupingBy 统计姓名重名结果 is &#123;&#125;&quot;</span>,</span><br><span class="line">           JSON.toJSONString(map2));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 学生转化成学号为 key 的 map</span></span><br><span class="line">  Map&lt;String, StudentDTO&gt; map3 = students.stream()</span><br><span class="line">       <span class="comment">//第一个入参表示 map 中 key 的取值</span></span><br><span class="line">       <span class="comment">//第二个入参表示 map 中 value 的取值</span></span><br><span class="line">       <span class="comment">//第三个入参表示，如果前后的 key 是相同的，是覆盖还是不覆盖，(s1,s2)-&gt;s1 表示不覆盖，(s1,s2)-&gt;s2 表示覆盖</span></span><br><span class="line">      .collect(Collectors.toMap(s-&gt;s.getCode(),s-&gt;s,(s1,s2)-&gt;s1));</span><br><span class="line">  log.info(<span class="string">&quot;testListToMap groupingBy 学生转化成学号为 key 的 map result is&#123;&#125;&quot;</span>,</span><br><span class="line">           JSON.toJSONString(map3));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：<br><img src="http://img.mukewang.com/5dd5ff7900011ff615250743.png" alt="图片描述"></p>
<h3 id="3-总结-9"><a href="#3-总结-9" class="headerlink" title="3 总结"></a>3 总结</h3><p>本文我们介绍了 12 种 Lambda 表达式常用的方法，大家可以找到 LambdaExpressionDemo 类，自己 debug 下，这样你在工作中遇到复杂数据结构转化时，肯定会得心应手了。</p>
<h1 id="第9章-其他"><a href="#第9章-其他" class="headerlink" title="第9章 其他"></a><strong>第9章 其他</strong></h1><h2 id="43-ThreadLocal-源码解析"><a href="#43-ThreadLocal-源码解析" class="headerlink" title="43 ThreadLocal 源码解析"></a><strong>43 ThreadLocal 源码解析</strong></h2><h3 id="引导语-40"><a href="#引导语-40" class="headerlink" title="引导语"></a>引导语</h3><p>ThreadLocal 提供了一种方式，让在多线程环境下，每个线程都可以拥有自己独特的数据，并且可以在整个线程执行过程中，从上而下的传递。</p>
<h3 id="1-用法演示"><a href="#1-用法演示" class="headerlink" title="1 用法演示"></a>1 用法演示</h3><p>可能很多同学没有使用过 ThreadLocal，我们先来演示下 ThreadLocal 的用法，demo 如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ThreadLocal 中保存的数据是 Map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Map&lt;String, String&gt;&gt; context = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 从上下文中拿出 Map</span></span><br><span class="line">  Map&lt;String, String&gt; contextMap = context.get();</span><br><span class="line">  <span class="keyword">if</span> (CollectionUtils.isEmpty(contextMap)) &#123;</span><br><span class="line">    contextMap = Maps.newHashMap();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  contextMap.put(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">  context.set(contextMap);</span><br><span class="line">  log.info(<span class="string">&quot;key1，value1被放到上下文中&quot;</span>);</span><br><span class="line">	<span class="comment">// 从上下文中拿出刚才放进去的数据</span></span><br><span class="line">  getFromComtext();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getFromComtext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  String value1 = context.get().get(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">  log.info(<span class="string">&quot;从 ThreadLocal 中取出上下文，key1 对应的值为：&#123;&#125;&quot;</span>, value1);</span><br><span class="line">  <span class="keyword">return</span> value1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果:</span></span><br><span class="line">demo.ninth.ThreadLocalDemo - key1，value1被放到上下文中</span><br><span class="line">demo.ninth.ThreadLocalDemo - 从 ThreadLocal 中取出上下文，key1 对应的值为：value1</span><br></pre></td></tr></table></figure>

<p>从运行结果中可以看到，key1 对应的值已经从上下文中拿到了。</p>
<p>getFromComtext 方法是没有接受任何入参的，通过 context.get().get(“key1”) 这行代码就从上下文中拿到了 key1 的值，接下来我们一起来看下 ThreadLocal 底层是如何实现上下文的传递的。</p>
<h3 id="2-类结构-1"><a href="#2-类结构-1" class="headerlink" title="2 类结构"></a>2 类结构</h3><h4 id="2-1-类泛型"><a href="#2-1-类泛型" class="headerlink" title="2.1 类泛型"></a>2.1 类泛型</h4><p>ThreadLocal 定义类时带有泛型，说明 ThreadLocal 可以储存任意格式的数据，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-2-关键属性"><a href="#2-2-关键属性" class="headerlink" title="2.2 关键属性"></a>2.2 关键属性</h4><p>ThreadLocal 有几个关键属性，我们一一看下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// threadLocalHashCode 表示当前 ThreadLocal 的 hashCode，用于计算当前 ThreadLocal 在 ThreadLocalMap 中的索引位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"><span class="comment">// 计算 ThreadLocal 的 hashCode 值(就是递增)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// static + AtomicInteger 保证了在一台机器中每个 ThreadLocal 的 threadLocalHashCode 是唯一的</span></span><br><span class="line"><span class="comment">// 被 static 修饰非常关键，因为一个线程在处理业务的过程中，ThreadLocalMap 是会被 set 多个 ThreadLocal 的，多个 ThreadLocal 就依靠 threadLocalHashCode 进行区分</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br></pre></td></tr></table></figure>

<p>还有一个重要属性：ThreadLocalMap，当一个线程有多个 ThreadLocal 时，需要一个容器来管理多个 ThreadLocal，ThreadLocalMap 的作用就是这个，管理线程中多个 ThreadLocal。</p>
<h4 id="2-2-1-ThreadLocalMap"><a href="#2-2-1-ThreadLocalMap" class="headerlink" title="2.2.1 ThreadLocalMap"></a>2.2.1 ThreadLocalMap</h4><p>ThreadLocalMap 本身就是一个简单的 Map 结构，key 是 ThreadLocal，value 是 ThreadLocal 保存的值，底层是数组的数据结构，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 数组中的每个节点值，WeakReference 是弱引用，当没有引用指向时，会直接被回收</span></span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            <span class="comment">// 当前 ThreadLocal 关联的值</span></span><br><span class="line">            Object value;</span><br><span class="line">            <span class="comment">// WeakReference 的引用 referent 就是 ThreadLocal</span></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数组的初始化大小</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line">        <span class="comment">// 存储 ThreadLocal 的数组</span></span><br><span class="line">        <span class="keyword">private</span> Entry[] table;</span><br><span class="line">        <span class="comment">// 扩容的阈值，默认是数组大小的三分之二</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> threshold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中看到 ThreadLocalMap 其实就是一个简单的 Map 结构，底层是数组，有初始化大小，也有扩容阈值大小，数组的元素是 Entry，Entry 的 key 就是 ThreadLocal 的引用，value 是 ThreadLocal 的值。</p>
<h3 id="3-ThreadLocal-是如何做到线程之间数据隔离的"><a href="#3-ThreadLocal-是如何做到线程之间数据隔离的" class="headerlink" title="3 ThreadLocal 是如何做到线程之间数据隔离的"></a>3 ThreadLocal 是如何做到线程之间数据隔离的</h3><p>ThreadLocal 是线程安全的，我们可以放心使用，主要因为是 ThreadLocalMap 是线程的属性，我们看下线程 Thread 的源码，如下：<br><img src="http://img.mukewang.com/5dd600f00001758909700419.png" alt="图片描述"></p>
<p>从上图中，我们可以看到 ThreadLocals.ThreadLocalMap 和 InheritableThreadLocals.ThreadLocalMap 分别是线程的属性，所以每个线程的 ThreadLocals 都是隔离独享的。</p>
<p>父线程在创建子线程的情况下，会拷贝 inheritableThreadLocals 的值，但不会拷贝 threadLocals 的值，源码如下：<br><img src="http://img.mukewang.com/5dd600e30001251418360590.png" alt="图片描述"></p>
<p>从上图中我们可以看到，在线程创建时，会把父线程的 inheritableThreadLocals 属性值进行拷贝。</p>
<h3 id="4-set-方法"><a href="#4-set-方法" class="headerlink" title="4 set 方法"></a>4 set 方法</h3><p>set 方法的主要作用是往当前 ThreadLocal 里面 set 值，假如当前 ThreadLocal 的泛型是 Map，那么就是往当前 ThreadLocal 里面 set map，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// set 操作每个线程都是串行的，不会有线程安全的问题</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// 当前 thradLocal 之前有设置值，直接设置，否则初始化</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="comment">// 初始化ThreadLocalMap</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码逻辑比较清晰，我们在一起来看下 ThreadLocalMap.set 的源码，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="comment">// 计算 key 在数组中的下标，其实就是 ThreadLocal 的 hashCode 和数组大小-1取余</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 整体策略：查看 i 索引位置有没有值，有值的话，索引位置 + 1，直到找到没有值的位置</span></span><br><span class="line">    <span class="comment">// 这种解决 hash 冲突的策略，也导致了其在 get 时查找策略有所不同，体现在 getEntryAfterMiss 中</span></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         <span class="comment">// nextIndex 就是让在不超过数组长度的基础上，把数组的索引位置 + 1</span></span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 找到内存地址一样的 ThreadLocal，直接替换</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前 key 是 null，说明 ThreadLocal 被清理了，直接替换掉</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前 i 位置是无值的，可以被当前 thradLocal 使用</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="comment">// 当数组大小大于等于扩容阈值(数组大小的三分之二)时，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面源码我们注意几点：</p>
<ol>
<li>是通过递增的 AtomicInteger 作为 ThreadLocal 的 hashCode 的；</li>
<li>计算数组索引位置的公式是：hashCode 取模数组大小，由于 hashCode 不断自增，所以不同的 hashCode 大概率上会计算到同一个数组的索引位置（但这个不用担心，在实际项目中，ThreadLocal 都很少，基本上不会冲突）；</li>
<li>通过 hashCode 计算的索引位置 i 处如果已经有值了，会从 i 开始，通过 +1 不断的往后寻找，直到找到索引位置为空的地方，把当前 ThreadLocal 作为 key 放进去。</li>
</ol>
<p>好在日常工作中使用 ThreadLocal 时，常常只使用 1~2 个 ThreadLocal，通过 hash 计算出重复的数组的概率并不是很大。</p>
<p>set 时的解决数组元素位置冲突的策略，也对 get 方法产生了影响，接着我们一起来看一下 get 方法。</p>
<h3 id="5-get-方法"><a href="#5-get-方法" class="headerlink" title="5 get 方法"></a>5 get 方法</h3><p>get 方法主要是从 ThreadLocalMap 中拿到当前 ThreadLocal 储存的值，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 因为 threadLocal 属于线程的属性，所以需要先把当前线程拿出来</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 从线程中拿到 ThreadLocalMap</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从 map 中拿到 entry，由于 ThreadLocalMap 在 set 时的 hash 冲突的策略不同，导致拿的时候逻辑也不太一样</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 如果不为空，读取当前 ThreadLocal 中保存的值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则给当前线程的 ThreadLocal 初始化，并返回初始值 null</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们来看下 ThreadLocalMap 的 getEntry 方法，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到当前 thradLocal 对应的值，值的类型是由 thradLocal 的泛型决定的</span></span><br><span class="line"><span class="comment">// 由于 thradLocalMap set 时解决数组索引位置冲突的逻辑，导致 thradLocalMap get 时的逻辑也是对应的</span></span><br><span class="line"><span class="comment">// 首先尝试根据 hashcode 取模数组大小-1 = 索引位置 i 寻找，找不到的话，自旋把 i+1，直到找到索引位置不为空为止</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算索引位置：ThreadLocal 的 hashCode 取模数组大小-1</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="comment">// e 不为空，并且 e 的 ThreadLocal 的内存地址和 key 相同，直接返回，否则就是没有找到，继续通过 getEntryAfterMiss 方法找</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="comment">// 这个取数据的逻辑，是因为 set 时数组索引位置冲突造成的  </span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自旋 i+1，直到找到为止</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="comment">// 在大量使用不同 key 的 ThreadLocal 时，其实还蛮耗性能的</span></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 内存地址一样，表示找到了</span></span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="comment">// 删除没用的 key</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="comment">// 继续使索引位置 + 1</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>get 逻辑源码中注释已经写的很清楚了，我们就不重复说了。</p>
<h3 id="6-扩容"><a href="#6-扩容" class="headerlink" title="6 扩容"></a>6 扩容</h3><p>ThreadLocalMap 中的 ThreadLocal 的个数超过阈值时，ThreadLocalMap 就要开始扩容了，我们一起来看下扩容的逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//扩容</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 拿出旧的数组</span></span><br><span class="line">    Entry[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line">    <span class="comment">// 新数组的大小为老数组的两倍</span></span><br><span class="line">    <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 初始化新数组</span></span><br><span class="line">    Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 老数组的值拷贝到新数组上</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">        Entry e = oldTab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.value = <span class="keyword">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 计算 ThreadLocal 在新数组中的位置</span></span><br><span class="line">                <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 如果索引 h 的位置值不为空，往后+1，直到找到值为空的索引位置</span></span><br><span class="line">                <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, newLen);</span><br><span class="line">                <span class="comment">// 给新数组赋值</span></span><br><span class="line">                newTab[h] = e;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 给新数组初始化下次扩容阈值，为数组长度的三分之二</span></span><br><span class="line">    setThreshold(newLen);</span><br><span class="line">    size = count;</span><br><span class="line">    table = newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码注解也比较清晰，我们注意两点：</p>
<ol>
<li>扩容后数组大小是原来数组的两倍；</li>
<li>扩容时是绝对没有线程安全问题的，因为 ThreadLocalMap 是线程的一个属性，一个线程同一时刻只能对 ThreadLocalMap 进行操作，因为同一个线程执行业务逻辑必然是串行的，那么操作 ThreadLocalMap 必然也是串行的。</li>
</ol>
<h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7 总结"></a>7 总结</h3><p>ThreadLocal 是非常重要的 API，我们在写一个中间件的时候经常会用到，比如说流程引擎中上下文的传递，调用链ID的传递等等，非常好用，但坑也很多。</p>
<h2 id="44-场景实战：ThreadLocal-在上下文传值场景下的实践"><a href="#44-场景实战：ThreadLocal-在上下文传值场景下的实践" class="headerlink" title="44 场景实战：ThreadLocal 在上下文传值场景下的实践"></a><strong>44 场景实战：ThreadLocal 在上下文传值场景下的实践</strong></h2><h3 id="开篇语"><a href="#开篇语" class="headerlink" title="开篇语"></a>开篇语</h3><p>我们在 《打动面试官：线程池流程编排中的运用实战》一文中将流程引擎简单地完善了一下，本文在其基础上继续进行改造，建议同学可以先看看 GitHub 上的代码，或者看看之前的文章。</p>
<h3 id="1-回顾"><a href="#1-回顾" class="headerlink" title="1 回顾"></a>1 回顾</h3><p>流程引擎编排的对象，我们称为组件（就是 SpringBean），之前我们给组件定义了通用的接口，组件实现时就实现这个接口，代码如下：<br><img src="http://img.mukewang.com/5dd603980001289a16401246.png" alt="图片描述"></p>
<p>我们定义了 DomainAbilityBean 接口，入参和出参都是 FlowContent，FlowContent 我们称为上下文。</p>
<h3 id="2-ThreadLocal-实现"><a href="#2-ThreadLocal-实现" class="headerlink" title="2 ThreadLocal 实现"></a>2 ThreadLocal 实现</h3><p>上下文传参除了 FlowContent 实现外，ThreadLocal 也是可以实现的，我们来演示一下：</p>
<h4 id="2-1-定义-ThreadLocal-上下文工具类"><a href="#2-1-定义-ThreadLocal-上下文工具类" class="headerlink" title="2.1 定义 ThreadLocal 上下文工具类"></a>2.1 定义 ThreadLocal 上下文工具类</h4><p>首先我们使用 ThreadLocal 定义了上下文工具类，并且定义了 put、get 方法，方便使用，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextCache</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2136539028591849277L</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 ThreadLocal 缓存上下文信息</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Map&lt;String,String&gt;&gt; CACHE = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 放数据</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> sourceKey</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putAttribute</span><span class="params">(String sourceKey,String value)</span></span>&#123;</span><br><span class="line">    Map&lt;String,String&gt; cacheMap = CACHE.get();</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> == cacheMap)&#123;</span><br><span class="line">      cacheMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    cacheMap.put(sourceKey,value);</span><br><span class="line">    CACHE.set(cacheMap);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 拿数据</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> sourceKey</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String <span class="title">getAttribute</span><span class="params">(String sourceKey)</span></span>&#123;</span><br><span class="line">    Map&lt;String,String&gt; cacheMap = CACHE.get();</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> == cacheMap)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cacheMap.get(sourceKey);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你想往 ThreadLocal 放数据，调用 ContextCache.putAttribute 方法，如果想从 ThreadLocal 拿数据，调用 ContextCache.getAttribute 方法即可。</p>
<p>我们写了两个组件，一个组件放数据，一个组件拿数据，如下：</p>
<p><img src="http://img.mukewang.com/5dd6037500016aa914521260.png" alt="图片描述"><br>我们把两个 SpringBean 注册到流程注册中心中，让其按照先执行 BeanThree 再执行 BeanFive 的顺序进行执行，运行 DemoApplication 类的 main 方法进行执行，执行结果如下：</p>
<p><img src="http://img.mukewang.com/5dd6033f0001448417820228.png" alt="图片描述"></p>
<p>从打印的日志可以看到，在 Spring 容器管理的 SpringBean 中，ThreadLocal 也是可以储存中间缓存值的。</p>
<h3 id="3-开启子线程"><a href="#3-开启子线程" class="headerlink" title="3 开启子线程"></a>3 开启子线程</h3><p>我们做一个实验，我们在 BeanFive 中开启子线程，然后再从 ThreadLocal 中拿值，看看能否拿到值，BeanFive 的代码修改成如下：</p>
<p><img src="http://img.mukewang.com/5dd6031e000120b717060666.png" alt="图片描述"><br>我们再来运行一下，打印的日志如下：<br><img src="http://img.mukewang.com/5dd602f60001501620040500.png" alt="图片描述"></p>
<p>从打印的日志中，我们发现在子线程中从 ThreadLocal 取值时，并没有取得值，这个原因主要是我们之前说的，线程在创建的时候，并不会把父线程的 ThreadLocal 中的值拷贝给子线程的 ThreadLocal，解决方案就是把 ThreadLocal 修改成 InheritableThreadLocal，代码修改如下：</p>
<p><img src="http://img.mukewang.com/5dd602b800013f6f20360392.png" alt="图片描述"></p>
<p>我们再次运行，结果如下：</p>
<p><img src="http://img.mukewang.com/5dd602950001394415020216.png" alt="图片描述"><br>从运行结果看，我们成功的在子线程中拿到值。</p>
<h3 id="4-线程池-ThreadLocal"><a href="#4-线程池-ThreadLocal" class="headerlink" title="4 线程池 + ThreadLocal"></a>4 线程池 + ThreadLocal</h3><p>如果是拿数据的 springBean 是丢给线程池执行的，我们能够成功的从 ThreadLocal 中拿到数据么？</p>
<p>首先我们在放数据的 springBean 中，把放的值修改成随机的，接着拿数据的 SpringBean 修改成异步执行，代码修改如下：</p>
<p><img src="http://img.mukewang.com/5dd6026f0001812a19221304.png" alt="图片描述"><br>为了能快速看到效果，我们把线程池的 coreSize 和 maxSize 全部修改成 3，并让任务沉睡一段时间，这样三个线程肯定消费不完任务，大量任务都会到队列中去排队，我们修改一下测试脚本，如下：<br><img src="http://img.mukewang.com/5dd602380001a82413940340.png" alt="图片描述"></p>
<p>我们期望的结果：</p>
<ol>
<li>线程池中执行的 BeanFive 可以成功从 ThreadLocal 中拿到数据；</li>
<li>能够从 ThreadLocal 拿到正确的数据，比如 BeanThree 刚放进 key1，value5，那么期望在 BeanFive 中根据 key1 能拿出 value5，而不是其它值。</li>
</ol>
<p>我们运行一下，结果如下：</p>
<p><img src="http://img.mukewang.com/5dd6021f00010d9a20260874.png" alt="图片描述"><br>从结果中可以看到，并没有符合我们的预期，我们往 ThreadLocal 中 put 进很多值，但最后拿出来的值却很多都是 value379，都为最后 put 到 ThreadLocal 中的值。</p>
<p>这个原因主要是 ThreadLocal 存储的 HashMap 的引用都是同一个，main 主线程可以修改 HashMap 中的值，子线程从 ThreadLocal 中拿值时，也是从 HashMap 中拿值，从而导致不能把 put 的值通过 ThreadLocal 正确的传递给子线程。</p>
<p>为了证明是这个原因，我们在从 ThreadLocal 放、拿值的地方，把 HashMap 的内存地址都打印出来，改动代码如下：<br><img src="http://img.mukewang.com/5dd601ed00012b0118101350.png" alt="图片描述"></p>
<p>我们再次运行测试代码，运行的结果如下：</p>
<p><img src="http://img.mukewang.com/5dd601cf0001c0bd10150820.png" alt="图片描述"><br>从测试结果中可以看到，不管是主线程还是子线程和 ThreadLocal 进行交互时，HashMap 都是同一个，也就是说 ThreadLocal 中保存的 HashMap 是共享的，这就导致了线程安全的问题，子线程读取到的值就会混乱掉。</p>
<h3 id="5-解决方案"><a href="#5-解决方案" class="headerlink" title="5 解决方案"></a>5 解决方案</h3><p>针对这个问题，我们提出了一种解决方案，在把任务提交到线程池时，我们进行 HashMap 的拷贝，这样子线程的 HashMap 和 main 线程的 HashMap 就不同了，可以解决上面的问题。</p>
<p>我们提交任务时， 使用的是 Runnable，要实现 HashMap 的拷贝的话，我们需要把 Runnable 进行一层包装，包装的代码如下：</p>
<p><img src="http://img.mukewang.com/5dd601610001af8b08020916.png" alt="图片描述"><br>运行结果如下:<br><img src="http://img.mukewang.com/5dd6013f0001763b09370823.png" alt="图片描述"></p>
<p>从运行结果中可以看出，线程池拿出来的 value 已经是正确的了。</p>
<h3 id="6-总结-3"><a href="#6-总结-3" class="headerlink" title="6 总结"></a>6 总结</h3><p>本文通过 ThreadLocal 来改造流程引擎中的上下文传递，希望能够加深大家对 ThreadLocal 的认识和使用技巧，有兴趣的同学可以把我们的代码下载下来，跑跑看。</p>
<h2 id="45-Socket-源码及面试题"><a href="#45-Socket-源码及面试题" class="headerlink" title="45 Socket 源码及面试题"></a><strong>45 Socket 源码及面试题</strong></h2><h3 id="引导语-41"><a href="#引导语-41" class="headerlink" title="引导语"></a>引导语</h3><p>Socket 中文翻译叫套接字，可能很多工作四五年的同学都没有用过这个 API，但只要用到这个 API 时，必然是在重要的工程的核心代码处。</p>
<p>大家平时基本都在用开源的各种 rpc 框架，比如说 Dubbo、gRPC、Spring Cloud 等等，很少需要手写网络调用，以下三小节可以帮助大家补充这块的内容，当你真正需要的时候，可以作为手册示例。</p>
<p>本文和《ServerSocket 源码及面试题》一文主要说 Socket 和 ServerSocket 的源码，《工作实战：Socket 结合线程池的使用》这章主要说两个 API 在实际工作中如何落地。</p>
<h3 id="1-Socket-整体结构"><a href="#1-Socket-整体结构" class="headerlink" title="1 Socket 整体结构"></a>1 Socket 整体结构</h3><p>Socket 的结构非常简单，Socket 就像一个壳一样，将套接字初始化、创建连接等各种操作包装了一下，其底层实现都是 SocketImpl 实现的，Socket 本身的业务逻辑非常简单。</p>
<p>Socket 的属性不多，有套接字的状态，SocketImpl，读写的状态等等，源码如下图：<br><img src="http://img.mukewang.com/5dd60470000164ca04960264.png" alt="图片描述"></p>
<p>套接字的状态变更都是有对应操作方法的，比如套接字新建（createImpl 方法）后，状态就会更改成 created = true，连接（connect）之后，状态更改成 connected = true 等等。</p>
<h3 id="2-初始化-1"><a href="#2-初始化-1" class="headerlink" title="2 初始化"></a>2 初始化</h3><p>Socket 的构造器比较多，可以分成两大类：</p>
<ol>
<li>指定代理类型（Proxy）创建套节点，一共有三种类型为：DIRECT（直连）、HTTP（HTTP、FTP 高级协议的代理）、SOCKS（SOCKS 代理），三种不同的代码方式对应的 SocketImpl 不同，分别是：PlainSocketImpl、HttpConnectSocketImpl、SocksSocketImpl，除了类型之外 Proxy 还指定了地址和端口；</li>
<li>默认 SocksSocketImpl 创建，并且需要在构造器中传入地址和端口，源码如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// address 代表IP地址，port 表示套接字的端口</span></span><br><span class="line"><span class="comment">// address 我们一般使用 InetSocketAddress，InetSocketAddress 有 ip+port、域名+port、InetAddress 等初始化方式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Socket</span><span class="params">(InetAddress address, <span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(address != <span class="keyword">null</span> ? <span class="keyword">new</span> InetSocketAddress(address, port) : <span class="keyword">null</span>,</span><br><span class="line">         (SocketAddress) <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 address 可以是 ip 地址或者域名，比如说 127.0.0.1 或者 <a href="http://www.wenhe.com./">www.wenhe.com。</a></p>
<p>我们一起看一下这个构造器调用的 this 底层构造器的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// stream 为 true 时，表示为stream socket 流套接字，使用 TCP 协议，比较稳定可靠，但占用资源多</span></span><br><span class="line"><span class="comment">// stream 为 false 时，表示为datagram socket 数据报套接字，使用 UDP 协议，不稳定，但占用资源少</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Socket</span><span class="params">(SocketAddress address, SocketAddress localAddr,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> stream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    setImpl();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// backward compatibility</span></span><br><span class="line">    <span class="keyword">if</span> (address == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 socket</span></span><br><span class="line">        createImpl(stream);</span><br><span class="line">        <span class="comment">// 如果 ip 地址不为空，绑定地址</span></span><br><span class="line">        <span class="keyword">if</span> (localAddr != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// create、bind、connect 也是 native 方法</span></span><br><span class="line">            bind(localAddr);</span><br><span class="line">        connect(address);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | IllegalArgumentException | SecurityException e) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ce) &#123;</span><br><span class="line">            e.addSuppressed(ce);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中可以看出：</p>
<ol>
<li>在构造 Socket 的时候，你可以选择 TCP 或 UDP，默认是 TCP；</li>
<li>如果构造 Socket 时，传入地址和端口，那么在构造的时候，就会尝试在此地址和端口上创建套接字；</li>
<li>Socket 的无参构造器只会初始化 SocksSocketImpl，并不会和当前地址端口绑定，需要我们手动的调用 connect 方法，才能使用当前地址和端口；</li>
<li>Socket 我们可以理解成网络沟通的语言层次的抽象，底层网络创建、连接和关闭，仍然是 TCP 或 UDP 本身网络协议指定的标准，Socket 只是使用 Java 语言做了一层封装，从而让我们更方便地使用。</li>
</ol>
<h3 id="3-connect-连接服务端"><a href="#3-connect-连接服务端" class="headerlink" title="3 connect 连接服务端"></a>3 connect 连接服务端</h3><p>connect 方法主要用于 Socket 客户端连接上服务端，如果底层是 TCP 层协议的话，就是通过三次握手和服务端建立连接，为客户端和服务端之间的通信做好准备，底层源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(SocketAddress endpoint, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>connect 方法要求有两个入参，第一个入参是 SocketAddress，表示服务端的地址，我们可以使用 InetSocketAddress 进行初始化，比如：new InetSocketAddress(“<a href="http://www.wenhe.com”/">www.wenhe.com”</a>, 2000)。</p>
<p>第二入参是超时时间的意思（单位毫秒），表示客户端连接服务端的最大等待时间，如果超过当前等待时间，仍然没有成功建立连接，抛 SocketTimeoutException 异常，如果是 0 的话，表示无限等待。</p>
<h3 id="4-Socket-常用设置参数"><a href="#4-Socket-常用设置参数" class="headerlink" title="4 Socket 常用设置参数"></a>4 Socket 常用设置参数</h3><p>Socket 的常用设置参数在 SocketOptions 类中都可以找到，接下来我们来一一分析下，以下理解大多来自类注释和网络。</p>
<h4 id="4-1-setTcpNoDelay"><a href="#4-1-setTcpNoDelay" class="headerlink" title="4.1 setTcpNoDelay"></a>4.1 setTcpNoDelay</h4><p>此方法是用来设置 TCP_NODELAY 属性的，属性的注释是这样的：此设置仅仅对 TCP 生效，主要为了禁止使用 Nagle 算法，true 表示禁止使用，false 表示使用，默认是 false。</p>
<p>对于 Nagle 算法，我们引用维基百科上的解释：</p>
<blockquote>
<p><strong>纳格算法</strong>是以减少数据包发送量来增进 [TCP/IP] 网络的性能，它由约翰·纳格任职于<a href="https://zh.wikipedia.org/w/index.php?title=Ford_Aerospace&action=edit&redlink=1">Ford Aerospace</a>时命名。</p>
<p>纳格的文件[<a href="https://zh.wikipedia.org/wiki/%E7%B4%8D%E6%A0%BC%E7%AE%97%E6%B3%95#cite_note-1">注 1]</a>描述了他所谓的“小数据包问题”－某个应用程序不断地提交小单位的数据，且某些常只占1<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82">字节</a>大小。因为<a href="https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E6%8E%A7%E5%88%B6%E5%8D%94%E8%AD%B0">TCP</a>数据包具有40<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82">字节</a>的标头信息（TCP与IPv4各占20字节），这导致了41字节大小的数据包只有1字节的可用信息，造成庞大的浪费。这种状况常常发生于<a href="https://zh.wikipedia.org/wiki/Telnet">Telnet</a>工作阶段－大部分的键盘操作会产生1字节的数据并马上提交。更糟的是，在慢速的网络连线下，这类的数据包会大量地在同一时点传输，造成<a href="https://zh.wikipedia.org/w/index.php?title=%E5%A3%85%E5%A1%9E%E7%A2%B0%E6%92%9E&action=edit&redlink=1">壅塞碰撞</a>。</p>
<p>纳格算法的工作方式是合并（<a href="https://zh.wiktionary.org/wiki/en:Coalesce">coalescing</a>）一定数量的输出数据后一次提交。特别的是，只要有已提交的数据包尚未确认，发送者会持续缓冲数据包，直到累积一定数量的数据才提交。</p>
</blockquote>
<p>总结算法开启关闭的场景：</p>
<ol>
<li>如果 Nagle 算法关闭，对于小数据包，比如一次鼠标移动，点击，客户端都会立马和服务端交互，实时响应度非常高，但频繁的通信却很占用不少网络资源；</li>
<li>如果 Nagle 算法开启，算法会自动合并小数据包，等到达到一定大小（MSS）后，才会和服务端交互，优点是减少了通信次数，缺点是实时响应度会低一些。</li>
</ol>
<p>Socket 创建时，默认是开启 Nagle 算法的，可以根据实时性要求来选择是否关闭 Nagle 算法。</p>
<h4 id="4-2-setSoLinger"><a href="#4-2-setSoLinger" class="headerlink" title="4.2 setSoLinger"></a>4.2 setSoLinger</h4><p>setSoLinger 方法主要用来设置 SO_LINGER 属性值的。</p>
<p>注释上大概是这个意思：在我们调用 close 方法时，默认是直接返回的，但如果给 SO_LINGER 赋值，就会阻塞 close 方法，在 SO_LINGER 时间内，等待通信双方发送数据，如果时间过了，还未结束，将发送 TCP RST 强制关闭 TCP 。</p>
<p>我们看一下 setSoLinger 源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// on 为 false，表示不启用延时关闭，true 的话表示启用延时关闭</span></span><br><span class="line"><span class="comment">// linger 为延时的时间，单位秒</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSoLinger</span><span class="params">(<span class="keyword">boolean</span> on, <span class="keyword">int</span> linger)</span> <span class="keyword">throws</span> SocketException </span>&#123;</span><br><span class="line">    <span class="comment">// 检查是否已经关闭</span></span><br><span class="line">    <span class="keyword">if</span> (isClosed())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">&quot;Socket is closed&quot;</span>);</span><br><span class="line">    <span class="comment">// 不启用延时关闭</span></span><br><span class="line">    <span class="keyword">if</span> (!on) &#123;</span><br><span class="line">        getImpl().setOption(SocketOptions.SO_LINGER, <span class="keyword">new</span> Boolean(on));</span><br><span class="line">    <span class="comment">// 启用延时关闭，如果 linger 为 0，那么会立即关闭</span></span><br><span class="line">    <span class="comment">// linger 最大为 65535 秒，约 18 小时</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (linger &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;invalid value for SO_LINGER&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (linger &gt; <span class="number">65535</span>)</span><br><span class="line">            linger = <span class="number">65535</span>;</span><br><span class="line">        getImpl().setOption(SocketOptions.SO_LINGER, <span class="keyword">new</span> Integer(linger));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-3-setOOBInline"><a href="#4-3-setOOBInline" class="headerlink" title="4.3 setOOBInline"></a>4.3 setOOBInline</h4><p>setOOBInline 方法主要使用设置 SO_OOBINLINE 属性。</p>
<p>注释上说：如果希望接受 TCP urgent data（TCP 紧急数据）的话，可以开启该选项，默认该选项是关闭的，我们可以通过 Socket#sendUrgentData 方法来发送紧急数据。</p>
<p>查询了很多资料，都建议尽可能的去避免设置该值，禁止使用 TCP 紧急数据。</p>
<h4 id="4-4-setSoTimeout"><a href="#4-4-setSoTimeout" class="headerlink" title="4.4 setSoTimeout"></a>4.4 setSoTimeout</h4><p>setSoTimeout 方法主要是用来设置 SO_TIMEOUT 属性的。</p>
<p>注释上说：用来设置阻塞操作的超时时间，阻塞操作主要有：</p>
<ol>
<li>ServerSocket.accept() 服务器等待客户端的连接；</li>
<li>SocketInputStream.read() 客户端或服务端读取输入超时；</li>
<li>DatagramSocket.receive()。</li>
</ol>
<p>我们必须在必须在阻塞操作之前设置该选项， 如果时间到了，操作仍然在阻塞，会抛出 InterruptedIOException 异常（Socket 会抛出 SocketTimeoutException 异常，不同的套接字抛出的异常可能不同）。</p>
<p>对于 Socket 来说，超时时间如果设置成 0，表示没有超时时间，阻塞时会无限等待。</p>
<h4 id="4-5-setSendBufferSize"><a href="#4-5-setSendBufferSize" class="headerlink" title="4.5 setSendBufferSize"></a>4.5 setSendBufferSize</h4><p>setSendBufferSize 方法主要用于设置 SO_SNDBUF 属性的，入参是 int 类型，表示设置发送端（输出端）的缓冲区的大小，单位是字节。</p>
<p>入参 size 必须大于 0，否则会抛出 IllegalArgumentException 异常。</p>
<p>一般我们都是采取默认的，如果值设置太小，很有可能导致网络交互过于频繁，如果值设置太大，那么交互变少，实时性就会变低。</p>
<h4 id="4-6-setReceiveBufferSize"><a href="#4-6-setReceiveBufferSize" class="headerlink" title="4.6 setReceiveBufferSize"></a>4.6 setReceiveBufferSize</h4><p>setReceiveBufferSize 方法主要用来设置 SO_RCVBUF 属性的，入参是 int 类型，表示设置接收端的缓冲区的大小，单位是字节。</p>
<p>入参 size 必须大于 0，否则会抛出 IllegalArgumentException 异常。</p>
<p>一般来说，在套接字建立连接之后，我们可以随意修改窗口大小，但是当窗口大小大于 64k 时，需要注意：</p>
<ol>
<li>必须在 Socket 连接客户端之前设置缓冲值；</li>
<li>必须在 ServerSocket 绑定本地地址之前设置缓冲值。</li>
</ol>
<h4 id="4-7-setKeepAlive"><a href="#4-7-setKeepAlive" class="headerlink" title="4.7 setKeepAlive"></a>4.7 setKeepAlive</h4><p>setKeepAlive 方法主要用来设置 SO_KEEPALIVE 属性，主要是用来探测服务端的套接字是否还是存活状态，默认设置是 false，不会触发这个功能。</p>
<p>如果 SO_KEEPALIVE 开启的话，TCP 自动触发功能：如果两小时内，客户端和服务端的套接字之间没有任何通信，TCP 会自动发送 keepalive 探测给对方，对方必须响应这个探测（假设是客户端发送给服务端），预测有三种情况：</p>
<ol>
<li>服务端使用预期的 ACK 回复，说明一切正常；</li>
<li>服务端回复 RST，表示服务端处于死机或者重启状态，终止连接；</li>
<li>没有得到服务端的响应（会尝试多次），表示套接字已经关闭了。</li>
</ol>
<h4 id="4-8-setReuseAddress"><a href="#4-8-setReuseAddress" class="headerlink" title="4.8 setReuseAddress"></a>4.8 setReuseAddress</h4><p>setReuseAddress 方法主要用来设置 SO_REUSEADDR 属性，入参是布尔值，默认是 false。</p>
<p>套接字在关闭之后，会等待一段时间之后才会真正的关闭，如果此时有新的套接字前来绑定同样的地址和端口时，如果 setReuseAddress 为 true 的话，就可以绑定成功，否则绑定失败。</p>
<h3 id="5-总结-2"><a href="#5-总结-2" class="headerlink" title="5 总结"></a>5 总结</h3><p>如果平时一直在做业务代码，Socket 可能用到的很少，但面试问到网络协议时，或者以后有机会做做中间件的时候，就会有大概率会接触到 Socket，所以多学学，作为知识储备也蛮好的。</p>
<h2 id="46-ServerSocket-源码及面试题"><a href="#46-ServerSocket-源码及面试题" class="headerlink" title="46 ServerSocket 源码及面试题"></a><strong>46 ServerSocket 源码及面试题</strong></h2><h3 id="引导语-42"><a href="#引导语-42" class="headerlink" title="引导语"></a>引导语</h3><p>上一小节我们学习了 Socket，本文我们来看看服务端套接字 API：ServerSocket，本文学习完毕之后，我们就可以把客服端 Socket 和服务端 ServerSocket 串联起来，做一个真实的网络通信的 demo 了。</p>
<h3 id="1-类属性"><a href="#1-类属性" class="headerlink" title="1 类属性"></a>1 类属性</h3><p>ServerSocket 的主要作用，是作为服务端的套接字，接受客户端套接字传递过来的信息，并把响应回传给客户端，其属性非常简单，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> created = <span class="keyword">false</span>;<span class="comment">// 已创建</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> bound = <span class="keyword">false</span>;<span class="comment">// 绑定</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> closed = <span class="keyword">false</span>;<span class="comment">// 已关闭</span></span><br><span class="line"><span class="comment">// 底层的功能都依靠 SocketImpl 来实现</span></span><br><span class="line"><span class="keyword">private</span> SocketImpl impl;</span><br></pre></td></tr></table></figure>

<p>ServerSocket 和 Socket 一样，底层都是依靠 SocketImpl 的能力，而 SocketImpl 底层能力的实现基本上都是 native 方法实现的。</p>
<h3 id="2-初始化-2"><a href="#2-初始化-2" class="headerlink" title="2 初始化"></a>2 初始化</h3><p>初始化大概可以分成两类：无参构造器和有参构造器。</p>
<ol>
<li>无参构造器做的事情比较简单，只指定了 SocketImpl 为 SocksSocketImpl 类；</li>
<li>有参构造器有几种初始化的形式，我们一起来看一下参数最多的构造器的源码。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServerSocket</span><span class="params">(<span class="keyword">int</span> port, <span class="keyword">int</span> backlog, InetAddress bindAddr)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 默认是 SocksSocketImpl 实现</span></span><br><span class="line">    setImpl();</span><br><span class="line">    <span class="comment">// 端口必须大于 0，小于 65535</span></span><br><span class="line">    <span class="keyword">if</span> (port &lt; <span class="number">0</span> || port &gt; <span class="number">0xFFFF</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                   <span class="string">&quot;Port value out of range: &quot;</span> + port);</span><br><span class="line">    <span class="comment">// 最大可连接数如果小于1，那么采取默认的 50</span></span><br><span class="line">    <span class="keyword">if</span> (backlog &lt; <span class="number">1</span>)</span><br><span class="line">      backlog = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 底层 navtive 方法</span></span><br><span class="line">        bind(<span class="keyword">new</span> InetSocketAddress(bindAddr, port), backlog);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(SecurityException e) &#123;</span><br><span class="line">        close();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">        close();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>入参 port 指的是 ServerSocket 需要绑定本地那个端口。</p>
<p>入参 backlog 指的是服务端接受客户端连接队列的最大长度，这里需要注意的是，这里并不是限制客户端连接的个数，我们在 JDK8 版本下做过实验，我们把服务端的 backlog 设置成 1，并且变慢服务端的处理速度，当服务端并发请求过来时，并不是第二个请求过来就拒绝连接，我们在实际工作中，最好也不要用 backlog 来限制客户端连接的个数。</p>
<p>还有点需要注意的是 backlog 小于 1 时，backlog 会被设置成默认的 50。</p>
<p>入参 InetAddress 表示 ip 地址。</p>
<h3 id="3-bind"><a href="#3-bind" class="headerlink" title="3 bind"></a>3 bind</h3><p>bind 方法主要作用是把 ServerSocket 绑定到本地的端口上，只有当我们使用无参构造器初始化 ServerSocket 时，才会用到这个方法，如果使用有参构造器的话，在初始化时就已经绑定到本地的端口上了。</p>
<p>配合无参构造器，一般我们这么用：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 进行初始化</span></span><br><span class="line">ServerSocket serverSocket = <span class="keyword">new</span> <span class="type">ServerSocket</span>();</span><br><span class="line"><span class="comment">// 进行绑定</span></span><br><span class="line">serverSocket.bind(<span class="keyword">new</span> <span class="type">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">7007</span>));</span><br></pre></td></tr></table></figure>



<h3 id="4-accept"><a href="#4-accept" class="headerlink" title="4 accept"></a>4 accept</h3><p>accept 方法主要是用来 ServerSocket 接受来自客户端的套接字的，如果此时没有来自客户端的请求时，该方法就会一直阻塞，如果有通过 setSoTimeout 方法设置超时时间，那么 accept 只会在超时间内阻塞，过了超时时间就会抛出异常。</p>
<p>bind 和 accept 方法底层都是 native 方法实现，我们就不看源码了。</p>
<h3 id="5-面试题-1"><a href="#5-面试题-1" class="headerlink" title="5 面试题"></a>5 面试题</h3><h4 id="5-1-说说你对-Socket-和-ServerSocket-的理解？"><a href="#5-1-说说你对-Socket-和-ServerSocket-的理解？" class="headerlink" title="5.1 说说你对 Socket 和 ServerSocket 的理解？"></a>5.1 说说你对 Socket 和 ServerSocket 的理解？</h4><p>答：两者我们都可以称为套接字，底层基于 TCP/UDP 协议，套接字对底层协议进行了封装，让我们使用时更加方便，Socket 常被使用在客户端，用于向服务端请求数据和接受响应，ServerSocket 常用于在服务端，用于接受客户端的请求并进行处理，两者其底层使用都是依靠 SocketImpl 的子类的 native 方法。</p>
<h4 id="5-2-说说对-SocketOptions-中的-SO-TIMEOUT-的理解？"><a href="#5-2-说说对-SocketOptions-中的-SO-TIMEOUT-的理解？" class="headerlink" title="5.2 说说对 SocketOptions 中的 SO_TIMEOUT 的理解？"></a>5.2 说说对 SocketOptions 中的 SO_TIMEOUT 的理解？</h4><p>答：SocketOptions 类有很多属性设置，比如 SO_TIMEOUT 、SO_LINGER 等等，这些问题说一下自己的理解即可，可以参考 《Socket 源码及面试题》 中对各种属性的解析。</p>
<h4 id="5-3-在构造-Socket-的时候，我可以选择-TCP-或-UDP-么？应该如何选择？"><a href="#5-3-在构造-Socket-的时候，我可以选择-TCP-或-UDP-么？应该如何选择？" class="headerlink" title="5.3 在构造 Socket 的时候，我可以选择 TCP 或 UDP 么？应该如何选择？"></a>5.3 在构造 Socket 的时候，我可以选择 TCP 或 UDP 么？应该如何选择？</h4><p>答：可以的，Socket 有三个参数的构造器，第三个参数表示你想使用 TCP 还是 UDP。</p>
<h4 id="5-4-TCP-有自动检测服务端是否存活的机制么？有没有更好的办法？"><a href="#5-4-TCP-有自动检测服务端是否存活的机制么？有没有更好的办法？" class="headerlink" title="5.4 TCP 有自动检测服务端是否存活的机制么？有没有更好的办法？"></a>5.4 TCP 有自动检测服务端是否存活的机制么？有没有更好的办法？</h4><p>答：有的，我们可以通过 setKeepAlive 方法来激活该功能，如果两小时内，客户端和服务端的套接字之间没有任何通信，TCP 会自动发送 keepalive 探测给服务端，预测服务端有三种情况：</p>
<ol>
<li>服务端使用预期的 ACK 回复，说明一切正常；</li>
<li>服务端回复 RST，表示服务端处于死机或者重启状态，终止连接；</li>
<li>没有得到服务端的响应（会尝试多次），表示套接字已经关闭了。</li>
</ol>
<p>但我们并不建议使用这种方式，我们可以自己起一个定时任务，定时的访问服务端的特殊接口，如果服务端返回的数据和预期一致，说明服务端是存活的。</p>
<h3 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h3><p>Socket 和 ServerSocket 在源码方面没啥特别可说的地方，基本都是一些设置，底层实现都是 native 的方法，但面试官会从此延伸到一些网络协议方面的知识，因为这已经超出本专栏的范畴了，感兴趣的同学可以自行百度。</p>
<h2 id="47-工作实战：Socket-结合线程池的使用"><a href="#47-工作实战：Socket-结合线程池的使用" class="headerlink" title="47 工作实战：Socket 结合线程池的使用"></a><strong>47 工作实战：Socket 结合线程池的使用</strong></h2><h3 id="引导语-43"><a href="#引导语-43" class="headerlink" title="引导语"></a>引导语</h3><p>Socket 面试最终题一般都是让你写一个简单的客户端和服务端通信的例子，本文就带大家一起来写这个 demo。</p>
<h3 id="1-要求"><a href="#1-要求" class="headerlink" title="1 要求"></a>1 要求</h3><ol>
<li>可以使用 Socket 和 ServiceSocket 以及其它 API；</li>
<li>写一个客户端和服务端之间 TCP 通信的例子；</li>
<li>服务端处理任务需要异步处理；</li>
<li>因为服务端处理能力很弱，只能同时处理 5 个请求，当第六个请求到达服务器时，需要服务器返回明确的错误信息：服务器太忙了，请稍后重试~。</li>
</ol>
<p>需求比较简单，唯一复杂的地方在于第四点，我们需要对客户端的请求量进行控制，首先我们需要确认的是，我们是无法控制客户端发送的请求数的，所以我们只能从服务端进行改造，比如从服务端进行限流。</p>
<p>有的同学可能很快想到，我们应该使用 ServerSocket 的 backlog 的属性，把其设置成 5，但我们在上一章中说到 backlog 并不能准确代表限制的客户端连接数，而且我们还要求服务端返回具体的错误信息，即使 backlog 生效，也只会返回固定的错误信息，不是我们定制的错误信息。</p>
<p>我们好好想想，线程池似乎可以做这个事情，我们可以把线程池的 coreSize 和 maxSize 都设置成 4，把队列大小设置成 1，这样服务端每次收到请求后，会先判断一下线程池中的队列有没有数据，如果有的话，说明当前服务器已经马上就要处理第五个请求了，当前请求就是第六个请求，应该被拒绝。</p>
<p>正好线程池的加入也可以满足第三点，服务端的任务可以异步执行。</p>
<h3 id="2-客户端代码"><a href="#2-客户端代码" class="headerlink" title="2 客户端代码"></a>2 客户端代码</h3><p>客户端的代码比较简单，直接向服务器请求数据即可，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketClient</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer SIZE = <span class="number">1024</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadPoolExecutor socketPoll = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">50</span>, <span class="number">50</span>,</span><br><span class="line">                                                                               <span class="number">365L</span>,</span><br><span class="line">                                                                               TimeUnit.DAYS,</span><br><span class="line">                                                                               <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">400</span>));</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟客户端同时向服务端发送 6 条消息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">      socketPoll.submit(() -&gt; &#123;</span><br><span class="line">        send(<span class="string">&quot;localhost&quot;</span>, <span class="number">7007</span>, <span class="string">&quot;nihao&quot;</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">1000000000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 发送tcp</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> domainName 域名</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> port       端口</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> content    发送内容</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">send</span><span class="params">(String domainName, <span class="keyword">int</span> port, String content)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;客户端开始运行&quot;</span>);</span><br><span class="line">    Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    OutputStream outputStream = <span class="keyword">null</span>;</span><br><span class="line">    InputStreamReader isr = <span class="keyword">null</span>;</span><br><span class="line">    BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">    InputStream is = <span class="keyword">null</span>;</span><br><span class="line">    StringBuffer response = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.isBlank(domainName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 无参构造器初始化 Socket，默认底层协议是 TCP</span></span><br><span class="line">      socket = <span class="keyword">new</span> Socket();</span><br><span class="line">      socket.setReuseAddress(<span class="keyword">true</span>);</span><br><span class="line">      <span class="comment">// 客户端准备连接服务端，设置超时时间 10 秒</span></span><br><span class="line">      socket.connect(<span class="keyword">new</span> InetSocketAddress(domainName, port), <span class="number">10000</span>);</span><br><span class="line">      log.info(<span class="string">&quot;TCPClient 成功和服务端建立连接&quot;</span>);</span><br><span class="line">      <span class="comment">// 准备发送消息给服务端</span></span><br><span class="line">      outputStream = socket.getOutputStream();</span><br><span class="line">      <span class="comment">// 设置 UTF 编码，防止乱码</span></span><br><span class="line">      <span class="keyword">byte</span>[] bytes = content.getBytes(Charset.forName(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">      <span class="comment">// 输出字节码</span></span><br><span class="line">      segmentWrite(bytes, outputStream);</span><br><span class="line">      <span class="comment">// 关闭输出</span></span><br><span class="line">      socket.shutdownOutput();</span><br><span class="line">      log.info(<span class="string">&quot;TCPClient 发送内容为 &#123;&#125;&quot;</span>,content);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 等待服务端的返回</span></span><br><span class="line">      socket.setSoTimeout(<span class="number">50000</span>);<span class="comment">//50秒还没有得到数据，直接断开连接</span></span><br><span class="line">      <span class="comment">// 得到服务端的返回流</span></span><br><span class="line">      is = socket.getInputStream();</span><br><span class="line">      isr = <span class="keyword">new</span> InputStreamReader(is);</span><br><span class="line">      br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">      <span class="comment">// 从流中读取返回值</span></span><br><span class="line">      response = segmentRead(br);</span><br><span class="line">      <span class="comment">// 关闭输入流</span></span><br><span class="line">      socket.shutdownInput();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//关闭各种流和套接字</span></span><br><span class="line">      close(socket, outputStream, isr, br, is);</span><br><span class="line">      log.info(<span class="string">&quot;TCPClient 接受到服务端返回的内容为 &#123;&#125;&quot;</span>,response);</span><br><span class="line">      <span class="keyword">return</span> response.toString();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ConnectException e) &#123;</span><br><span class="line">      log.error(<span class="string">&quot;TCPClient-send socket连接失败&quot;</span>, e);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;socket连接失败&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      log.error(<span class="string">&quot;TCPClient-send unkown errror&quot;</span>, e);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;socket连接失败&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        close(socket, outputStream, isr, br, is);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// do nothing</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 关闭各种流</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> socket</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> outputStream</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> isr</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> br</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> is</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Socket socket, OutputStream outputStream, InputStreamReader isr,</span></span></span><br><span class="line"><span class="function"><span class="params">                           BufferedReader br, InputStream is)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != socket &amp;&amp; !socket.isClosed()) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        socket.shutdownInput();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        socket.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != outputStream) &#123;</span><br><span class="line">      outputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != br) &#123;</span><br><span class="line">      br.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != isr) &#123;</span><br><span class="line">      isr.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != is) &#123;</span><br><span class="line">      is.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 分段读</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> br</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title">segmentRead</span><span class="params">(BufferedReader br)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      sb.append(line);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 分段写</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> bytes</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> outputStream</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">segmentWrite</span><span class="params">(<span class="keyword">byte</span>[] bytes, OutputStream outputStream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = bytes.length;</span><br><span class="line">    <span class="keyword">int</span> start, end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; end != bytes.length; i++) &#123;</span><br><span class="line">      start = i == <span class="number">0</span> ? <span class="number">0</span> : i * SIZE;</span><br><span class="line">      end = length &gt; SIZE ? start + SIZE : bytes.length;</span><br><span class="line">      length -= SIZE;</span><br><span class="line">      outputStream.write(bytes, start, end - start);</span><br><span class="line">      outputStream.flush();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端代码中我们也用到了线程池，主要是为了并发模拟客户端一次性发送 6 个请求，按照预期服务端在处理第六个请求的时候，会返回特定的错误信息给客户端。</p>
<p>以上代码主要方法是 send 方法，主要处理像服务端发送数据，并处理服务端的响应。</p>
<h3 id="3-服务端代码"><a href="#3-服务端代码" class="headerlink" title="3 服务端代码"></a>3 服务端代码</h3><p>服务端的逻辑分成两个部分，第一部分是控制客户端的请求个数，当超过服务端的能力时，拒绝新的请求，当服务端能力可响应时，放入新的请求，第二部分是服务端任务的执行逻辑。</p>
<h4 id="3-1-对客户端请求进行控制"><a href="#3-1-对客户端请求进行控制" class="headerlink" title="3.1 对客户端请求进行控制"></a>3.1 对客户端请求进行控制</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketServiceStart</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 服务端的线程池，两个作用</span></span><br><span class="line"><span class="comment">   * 1：让服务端的任务可以异步执行</span></span><br><span class="line"><span class="comment">   * 2：管理可同时处理的服务端的请求数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadPoolExecutor collectPoll = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">4</span>, <span class="number">4</span>,</span><br><span class="line">                                                                               <span class="number">365L</span>,</span><br><span class="line">                                                                               TimeUnit.DAYS,</span><br><span class="line">                                                                               <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(</span><br><span class="line">                                                                                   <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 启动服务端</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;SocketServiceStart 服务端开始启动&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// backlog  serviceSocket处理阻塞时，客户端最大的可创建连接数，超过客户端连接不上</span></span><br><span class="line">      <span class="comment">// 当线程池能力处理满了之后，我们希望尽量阻塞客户端的连接</span></span><br><span class="line"><span class="comment">//      ServerSocket serverSocket = new ServerSocket(7007,1,null);</span></span><br><span class="line">      <span class="comment">// 初始化服务端</span></span><br><span class="line">      ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket();</span><br><span class="line">      serverSocket.setReuseAddress(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//      serverSocket.bind(new InetSocketAddress(InetAddress.getLocalHost().getHostAddress(), 80));</span></span><br><span class="line">      serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">7007</span>));</span><br><span class="line">      log.info(<span class="string">&quot;SocketServiceStart 服务端启动成功&quot;</span>);</span><br><span class="line">      <span class="comment">// 自旋，让客户端一直在取客户端的请求，如果客户端暂时没有请求，会一直阻塞</span></span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 接受客户端的请求</span></span><br><span class="line">        Socket socket = serverSocket.accept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果队列中有数据了，说明服务端已经到了并发处理的极限了，此时需要返回客户端有意义的信息</span></span><br><span class="line">        <span class="keyword">if</span> (collectPoll.getQueue().size() &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">          log.info(<span class="string">&quot;SocketServiceStart 服务端处理能力到顶，需要控制客户端的请求&quot;</span>);</span><br><span class="line">          <span class="comment">//返回处理结果给客户端</span></span><br><span class="line">          rejectRequest(socket);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 异步处理客户端提交上来的任务</span></span><br><span class="line">          collectPoll.submit(<span class="keyword">new</span> SocketService(socket));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          socket.close();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      log.error(<span class="string">&quot;SocketServiceStart - start error&quot;</span>, e);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">      log.error(<span class="string">&quot;SocketServiceStart - start error&quot;</span>, e);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// 返回特定的错误码给客户端</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rejectRequest</span><span class="params">(Socket socket)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    OutputStream outputStream = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      outputStream = socket.getOutputStream();</span><br><span class="line">      <span class="keyword">byte</span>[] bytes = <span class="string">&quot;服务器太忙了，请稍后重试~&quot;</span>.getBytes(Charset.forName(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">      SocketClient.segmentWrite(bytes, outputStream);</span><br><span class="line">      socket.shutdownOutput();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">//关闭流</span></span><br><span class="line">      SocketClient.close(socket,outputStream,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用 collectPoll.getQueue().size() &gt;= 1 来判断目前服务端是否已经到达处理的极限了，如果队列中有一个任务正在排队，说明当前服务端已经超负荷运行了，新的请求应该拒绝掉，如果队列中没有数据，说明服务端还可以接受新的请求。</p>
<p>以上代码注释详细，就不累赘说了。</p>
<h4 id="3-2-服务端任务的处理逻辑"><a href="#3-2-服务端任务的处理逻辑" class="headerlink" title="3.2 服务端任务的处理逻辑"></a>3.2 服务端任务的处理逻辑</h4><p>服务端的处理逻辑比较简单，主要步骤是：从客户端的 Socket 中读取输入，进行处理，把响应返回给客户端。</p>
<p>我们使用线程沉睡 2 秒来模拟服务端的处理逻辑，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketService</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SocketService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SocketService</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.socket = socket;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;SocketService 服务端任务开始执行&quot;</span>);</span><br><span class="line">    OutputStream outputStream = <span class="keyword">null</span>;</span><br><span class="line">    InputStream is = <span class="keyword">null</span>;</span><br><span class="line">    InputStreamReader isr = <span class="keyword">null</span>;</span><br><span class="line">    BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//接受消息</span></span><br><span class="line">      socket.setSoTimeout(<span class="number">10000</span>);<span class="comment">// 10秒还没有得到数据，直接断开连接</span></span><br><span class="line">      is = socket.getInputStream();</span><br><span class="line">      isr = <span class="keyword">new</span> InputStreamReader(is,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">      br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">      StringBuffer sb = SocketClient.segmentRead(br);</span><br><span class="line">      socket.shutdownInput();</span><br><span class="line">      log.info(<span class="string">&quot;SocketService accept info is &#123;&#125;&quot;</span>, sb.toString());</span><br><span class="line"></span><br><span class="line">      <span class="comment">//服务端处理 模拟服务端处理耗时</span></span><br><span class="line">      Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">      String response  = sb.toString();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//返回处理结果给客户端</span></span><br><span class="line">      outputStream = socket.getOutputStream();</span><br><span class="line">      <span class="keyword">byte</span>[] bytes = response.getBytes(Charset.forName(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">      SocketClient.segmentWrite(bytes, outputStream);</span><br><span class="line">      socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//关闭流</span></span><br><span class="line">      SocketClient.close(socket,outputStream,isr,br,is);</span><br><span class="line">      log.info(<span class="string">&quot;SocketService 服务端任务执行完成&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      log.error(<span class="string">&quot;SocketService IOException&quot;</span>, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      log.error(<span class="string">&quot;SocketService Exception&quot;</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        SocketClient.close(socket,outputStream,isr,br,is);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;SocketService IOException&quot;</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-测试"><a href="#4-测试" class="headerlink" title="4 测试"></a>4 测试</h3><p>测试的时候，我们必须先启动服务端，然后再启动客户端，首先我们启动服务端，打印日志如下：<br><img src="http://img.mukewang.com/5dd604f40001b33022720244.png" alt="图片描述"></p>
<p>接着我们启动客户端，打印日志如下：<br><img src="http://img.mukewang.com/5dd604e50001dc9423161292.png" alt="图片描述"></p>
<p>我们最后看一下服务端的运行日志：<br><img src="http://img.mukewang.com/5dd604d40001040e22901054.png" alt="图片描述"></p>
<p>从以上运行结果中，我们可以看出得出的结果是符合我们预期的，服务端在请求高峰时，能够并发处理5个请求，其余请求可以用正确的提示进行拒绝。</p>
<h3 id="5-总结-3"><a href="#5-总结-3" class="headerlink" title="5 总结"></a>5 总结</h3><p>所以代码集中在 SocketClient、SocketServiceStart、SocketService 中，启动的顺序为先启动 SocketServiceStart，后运行 SocketClient，感兴趣的同学可以自己 debug 下，加深印象。</p>
<h1 id="第10章-专栏总结"><a href="#第10章-专栏总结" class="headerlink" title="第10章 专栏总结"></a><strong>第10章 专栏总结</strong></h1><h2 id="48-一起看过的-Java-源码和面试真题"><a href="#48-一起看过的-Java-源码和面试真题" class="headerlink" title="48 一起看过的 Java 源码和面试真题"></a><strong>48 一起看过的 Java 源码和面试真题</strong></h2><h3 id="不为了源码而读源码，只为了更好的实践-1"><a href="#不为了源码而读源码，只为了更好的实践-1" class="headerlink" title="不为了源码而读源码，只为了更好的实践"></a>不为了源码而读源码，只为了更好的实践</h3><p>持续几个月，我们的专栏终于结束了，这篇总结篇，我们又想回到当初写这篇专栏的初心：我们不为读源码而读源码，只是为了更好的实践。</p>
<p>我刚工作的时候，就有一些大佬推荐我来阅读 Java 源码，那时候的我懵懵懂懂，只觉得大佬说的是对的，于是就去读，当时的目的很简单，主要是两个：一个是应付面试，一个是想让自己更强。</p>
<p>当时边工作边读源码，一开始真心是一点都看不懂，逻辑都看得很迷糊，更不用说去探究作者为什么这么写，用到哪些设计模式了，但也不知道为什么，还是咬牙把源码都读完了。</p>
<p>读完之后，还是比较骄傲的，虽然说读完之后，很多细节都不记得了，但不知道为啥，总是有股莫名的自信，原来自己已经是读过源码的人了，而且在平时的工作中，用到一些 API 时，脑海中突然就会蹦出一些火花来：比如说初始化 List、Map 时如何初始化其大小；比如说如何根据场景来设置线程池；比如说如何根据业务写出优雅的锁，这时候就会自我感觉代码写的好，其实我一直有个理念：只有紧密贴合业务，能帮助解决业务复杂度的代码才是好代码，读了第一遍 Java 源码之后，突然就有了这种感觉，对自己写的代码也越来越有自信了。</p>
<p>随着工作年龄的增加，又陆续读过几次 Java 源码，现在除了对自己写代码的自信，还多了一种帮助别人的自信，在同事遇到困难，或者 代码 review 时，一些漏洞，你很容易就看出来，不知不觉你就会成为团队中的技术专家。</p>
<p>所以我们才一直强调，我们读源码真心是为了更好的实践，这种好处当你认真读完源码之后，慢慢就会感受到了。</p>
<h3 id="同学们的问题"><a href="#同学们的问题" class="headerlink" title="同学们的问题"></a>同学们的问题</h3><p>在这几个月内，我收到很多问题，但比较频繁的是两类问题，第一类问题主要是说自己看不懂源码，问我怎么办？这个问题其实我也没有答案，Java 源码本身就很枯燥，它并不是电视剧，也不是小说，它是需要我们静下心来，一行一行琢磨思考的东西，同学们都很聪明，不是看不懂，只是不想静下心来罢了。当然当代码太复杂时，我们只看也是不行的，需要亲自动手 debug。</p>
<p>第二类问题主要是作者为什么这么写？这个问题其实也很难回答，但问这些问题的同学，我基本都一一作答了，在和这些同学交流的过程中，发现一小部分同学的确对源码很有研究，我也受益匪浅，但大部分同学其实并没有搞懂源码本身的逻辑，试想如果在没有搞懂源码本身的逻辑下，又如何去猜测并理解原作者用代码的本意呢？恐怕很难，所以还是建议大家先把源码本身逻辑弄懂后，再去推测本意和设计模型，不然这又会成为你阅读源码的阻碍（话虽然难听，但是真心的建议）。</p>
<h3 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h3><p>这是我第一篇在慕课网的专栏，非常感谢慕课网的编辑和商务，给我了很多帮助。</p>
<p>当然最要感激的是各位同学，虽然我们一直内部强调，专栏不求快，只求质量和内容，但 Java 源码实在博大精深，由于我个人的理解问题和笔误，的确出现了一些理解不当的地方和笔误，在同学们的包容和指正下，我们也一起做了更正，所以非常感谢同学的包容和指正，真心的感谢大家的包容，谢谢。</p>
<p>最后留下我的个人微信（luanqiu0）吧，真心想交流后端技术和架构的可以加我，当然其它的我也不会了，再次谢谢各位同学一起走过我们的专栏，来过，看过，希望你能有所收获，谢谢。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
