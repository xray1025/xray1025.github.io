<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>0001.两数之和</title>
    <url>/2020/09/11/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/two-sum/">https://leetcode-cn.com/problems/two-sum/</a></p>
<p><strong>一遍哈希表</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">      Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">          <span class="keyword">int</span> temp = target - nums[i];</span><br><span class="line">          <span class="keyword">if</span>(map.containsKey(temp))&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;map.get(temp), i&#125;; </span><br><span class="line">          &#125;</span><br><span class="line">          map.put(nums[i], i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(n)，<br>只遍历了包含有 n 个元素的列表一次。在表中进行的每次查找只花费 O(1) 的时间。</p>
</li>
<li><p>空间复杂度：O(n)，<br>所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 n 个元素。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>0002.两数相加</title>
    <url>/2020/09/11/0002.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/add-two-numbers/">https://leetcode-cn.com/problems/add-two-numbers/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    	ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    	ListNode p = l1, q = l2, curr = dummyHead;</span><br><span class="line">    	<span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">while</span> (p != <span class="keyword">null</span> || q != <span class="keyword">null</span>) &#123;</span><br><span class="line">        	<span class="keyword">int</span> x = (p != <span class="keyword">null</span>) ? p.val : <span class="number">0</span>;</span><br><span class="line">        	<span class="keyword">int</span> y = (q != <span class="keyword">null</span>) ? q.val : <span class="number">0</span>;</span><br><span class="line">        	<span class="keyword">int</span> sum = carry + x + y;</span><br><span class="line">        	carry = sum / <span class="number">10</span>;</span><br><span class="line">        	curr.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">        	curr = curr.next;</span><br><span class="line">        	<span class="keyword">if</span> (p != <span class="keyword">null</span>) p = p.next;</span><br><span class="line">        	<span class="keyword">if</span> (q != <span class="keyword">null</span>) q = q.next;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        	curr.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> dummyHead.next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(max⁡(m,n))，假设 m 和 n 分别表示 l1 和 l2 的长度，上面的算法最多重复 max⁡(m,n) 次。</li>
<li>空间复杂度：O(max⁡(m,n))， 新列表的长度最多为 max(m,n)+1。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>ListNode</tag>
      </tags>
  </entry>
  <entry>
    <title>0015.三数之和</title>
    <url>/2020/10/05/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/3sum/">https://leetcode-cn.com/problems/3sum/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> target = - nums[i];</span><br><span class="line">            <span class="keyword">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[left] + nums[right] == target)&#123;</span><br><span class="line">                    res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(nums[i], nums[left], nums[right])));</span><br><span class="line"></span><br><span class="line">                    ++left;</span><br><span class="line">                    --right;</span><br><span class="line">                    <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left - <span class="number">1</span>])&#123;</span><br><span class="line">                        ++left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right + <span class="number">1</span>])&#123;</span><br><span class="line">                        --right;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[left] + nums[right] &lt; target)&#123;</span><br><span class="line">                    ++left;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    --right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(N^2)，其中 NN 是数组 nums 的长度。</p>
</li>
<li><p>空间复杂度：O(logN)。我们忽略存储答案的空间，额外的排序的空间复杂度为 O(logN)。然而我们修改了输入的数组 nums，在实际情况下不一定允许，因此也可以看成使用了一个额外的数组存储了 nums 的副本并进行排序，空间复杂度为 O(N)。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>0032.最长有效括号</title>
    <url>/2020/09/14/0032.%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/">https://leetcode-cn.com/problems/longest-valid-parentheses/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">                maxLength = Math.max(maxLength, l * <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l &lt; r)&#123;</span><br><span class="line">                l = <span class="number">0</span>;</span><br><span class="line">                r = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        l = <span class="number">0</span>;</span><br><span class="line">        r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">                maxLength = Math.max(maxLength, l * <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l &gt; r)&#123;</span><br><span class="line">                l = <span class="number">0</span>;</span><br><span class="line">                r = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><input disabled="" type="checkbox"> 时间复杂度：o(n)</li>
<li><input disabled="" type="checkbox"> 空间复杂度：o(1)</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>0033.搜索旋转排序数组</title>
    <url>/2020/09/14/0033.%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">https://leetcode-cn.com/problems/search-in-rotated-sorted-array/</a></p>
<p><strong>二分查找：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[l] &lt;= nums[mid])&#123;</span><br><span class="line">                <span class="keyword">if</span>(target &gt;= nums[l] &amp;&amp; target &lt; nums[mid])&#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(target &gt; nums[mid] &amp;&amp; target &lt;= nums[r])&#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：o(logn)</li>
<li>空间复杂度：o(1)</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>0034.在排序数组中查找元素的第一个和最后一个位置</title>
    <url>/2020/09/14/0034.%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/</a></p>
<p><strong>二分查找：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l_index = <span class="number">0</span>,r_index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= target)&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        l_index = nums[left] != target ? -<span class="number">1</span>:left;</span><br><span class="line"></span><br><span class="line">        left = <span class="number">0</span>;</span><br><span class="line">        right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;= target)&#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        r_index = nums[right] != target ? -<span class="number">1</span>:right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;l_index,r_index&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：o(logn)</li>
<li>空间复杂度：o(1)</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>0039.组合总和</title>
    <url>/2020/09/14/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/combination-sum">https://leetcode-cn.com/problems/combination-sum</a></p>
<p><strong>回溯法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; combine = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        dfs(candidates, target, ans, combine, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; combine, <span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(idx == candidates.length)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(combine));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(candidates, target, ans, combine, idx + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(target - candidates[idx] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            combine.add(candidates[idx]);</span><br><span class="line">            dfs(candidates, target - candidates[idx], ans, combine, idx);</span><br><span class="line">            combine.remove(combine.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(S)，其中 S 为所有可行解的长度之和。从分析给出的搜索树我们可以看出时间复杂度取决于搜索树所有叶子节点的深度之和，即所有可行解的长度之和。在这题中，我们很难给出一个比较紧的上界，我们知道 O(n×2^n)是一个比较松的上界，即在这份代码中，n 个位置每次考虑选或者不选，如果符合条件，就加入答案的时间代价。但是实际运行的时候，因为不可能所有的解都满足条件，递归的时候我们还会用 target - candidates[idx] &gt;= 0 进行剪枝，所以实际运行情况是远远小于这个上界的。</li>
<li>空间复杂度：O(target)。除答案数组外，空间复杂度取决于递归的栈深度，在最差情况下需要递归 O(target)层。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title>0046.全排列</title>
    <url>/2020/09/18/0046.%E5%85%A8%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/permutations">https://leetcode-cn.com/problems/permutations</a></p>
<p><strong>回溯法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        backtrack(nums, res, tmp, visited);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; tmp, <span class="keyword">int</span>[] visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp.size() == nums.length)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(tmp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            visited[i] = <span class="number">1</span>;</span><br><span class="line">            tmp.add(nums[i]);</span><br><span class="line">            backtrack(nums, res, tmp, visited);</span><br><span class="line">            visited[i] = <span class="number">0</span>;</span><br><span class="line">            tmp.remove(tmp.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title>0047.全排列2</title>
    <url>/2020/09/18/0047.%E5%85%A8%E6%8E%92%E5%88%972/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/permutations-ii">https://leetcode-cn.com/problems/permutations-ii</a></p>
<p><strong>回溯法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] vis;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; perm = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backtrack(nums, ans, <span class="number">0</span>, perm);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, List&lt;List&lt;Integer&gt;&gt; ans, <span class="keyword">int</span> idx, List&lt;Integer&gt; perm)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == nums.length) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(perm));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[i] || (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !vis[i - <span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            perm.add(nums[i]);</span><br><span class="line">            vis[i] = <span class="keyword">true</span>;</span><br><span class="line">            backtrack(nums, ans, idx + <span class="number">1</span>, perm);</span><br><span class="line">            vis[i] = <span class="keyword">false</span>;</span><br><span class="line">            perm.remove(idx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n×n!)，其中 n 为序列的长度。</li>
<li>空间复杂度：O(n)。我们需要 O(n) 的标记数组，同时在递归的时候栈深度会达到 O(n)，因此总空间复杂度为 O(n+n)=O(2n)=O(n)。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title>0094.二叉树的中序遍历</title>
    <url>/2020/09/14/0094.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal">https://leetcode-cn.com/problems/binary-tree-inorder-traversal</a></p>
<p><strong>递归：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        inorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root.left, res);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        inorder(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</li>
<li>空间复杂度：O(n)。空间复杂度取决于递归的栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。</li>
</ul>
<p><strong>利用栈迭代：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stk = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span> || !stk.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stk.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.pop();</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</li>
<li>空间复杂度：O(n)。空间复杂度取决于栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n)。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>0104.二叉树的最大深度</title>
    <url>/2020/09/18/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree</a></p>
<p><strong>递归</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = maxDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> r = maxDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(l, r) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(n)，</p>
</li>
<li><p>空间复杂度：O(height)。</p>
</li>
</ul>
<p><strong>非递归</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中 n 为二叉树的节点个数。与方法一同样的分析，每个节点只会被访问一次。</li>
<li>空间复杂度：此方法空间的消耗取决于队列存储的元素数量，其在最坏情况下会达到 O(n)。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>0106. 从中序与后序遍历序列构造二叉树</title>
    <url>/2020/09/25/0106.%20%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal">https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal</a></p>
<p><strong>递归</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> build(inorder, postorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>, <span class="number">0</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">build</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder, <span class="keyword">int</span> il, <span class="keyword">int</span> ir, <span class="keyword">int</span> pl, <span class="keyword">int</span> pr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(il &gt; ir)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(il == ir)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(inorder[il]);</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(postorder[pr]);</span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = il; i &lt;= ir; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == root.val)&#123;</span><br><span class="line">                index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = build(inorder, postorder, il, index - <span class="number">1</span>, pl, pl + index - il - <span class="number">1</span>);</span><br><span class="line">        root.right = build(inorder, postorder, index + <span class="number">1</span>, ir, pl + index - il, pr - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>0116. 填充每个节点的下一个右侧节点指针</title>
    <url>/2020/09/28/0116.%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node">https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        Node leftmost = root;</span><br><span class="line">        <span class="keyword">while</span> (leftmost.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node head = leftmost;</span><br><span class="line">            <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">                head.left.next = head.right;</span><br><span class="line">                <span class="keyword">if</span> (head.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    head.right.next = head.next.left;</span><br><span class="line">                &#125;</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            leftmost = leftmost.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</li>
<li>空间复杂度：O(1)。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>0117. 填充每个节点的下一个右侧节点指针2</title>
    <url>/2020/09/28/0117.%20%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%882/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii">https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Node last, nextStart;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        Node start = root;</span><br><span class="line">        <span class="keyword">while</span>(start != <span class="keyword">null</span>)&#123;</span><br><span class="line">            last = <span class="keyword">null</span>;</span><br><span class="line">            nextStart = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span>(Node p = start; p != <span class="keyword">null</span>; p = p.next)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    handle(p.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(p.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    handle(p.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            start = nextStart;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Node p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(last != <span class="keyword">null</span>)&#123;</span><br><span class="line">            last.next = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nextStart == <span class="keyword">null</span>)&#123;</span><br><span class="line">            nextStart = p;</span><br><span class="line">        &#125;</span><br><span class="line">        last = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</li>
<li>空间复杂度：O(1)。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>0154.二叉树的后序遍历</title>
    <url>/2020/09/29/0145.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal">https://leetcode-cn.com/problems/binary-tree-postorder-traversal</a></p>
<p><strong>递归：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        postorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode node, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        postorder(node.left, res);</span><br><span class="line">        postorder(node.right, res);</span><br><span class="line">        res.add(node.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</li>
<li>空间复杂度：O(n)。空间复杂度取决于递归的栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。</li>
</ul>
<p><strong>利用栈迭代：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (root.right == <span class="keyword">null</span> || root.right == prev) &#123;</span><br><span class="line">                res.add(root.val);</span><br><span class="line">                prev = root;</span><br><span class="line">                root = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</li>
<li>空间复杂度：O(n)。空间复杂度取决于栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n)。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>0189.旋转数组</title>
    <url>/2020/09/16/0189.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/rotate-array">https://leetcode-cn.com/problems/rotate-array</a></p>
<p><strong>三次反转</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k = k % nums.length;</span><br><span class="line">        reverse(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, k, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[start];</span><br><span class="line">            nums[start] = nums[end];</span><br><span class="line">            nums[end] = temp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(n)，</p>
</li>
<li><p>空间复杂度：O(1)。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>0198.打家劫舍</title>
    <url>/2020/09/22/0198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/house-robber">https://leetcode-cn.com/problems/house-robber</a></p>
<p><strong>动态规划 + 滚动数组：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> first = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> second = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = second;</span><br><span class="line">            second = Math.max(first + nums[i], tmp);</span><br><span class="line">            first = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中 n 是数组长度。只需要对数组遍历一次。</li>
<li>空间复杂度：O(1)。使用滚动数组，可以只存储前两间房屋的最高总金额，而不需要存储整个数组的结果，因此空间复杂度是 O(1)。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>0200.岛屿数量</title>
    <url>/2020/09/18/0200.%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/number-of-islands">https://leetcode-cn.com/problems/number-of-islands</a></p>
<p><strong>dfs</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r &gt;= nr || c &gt;= nc || grid[r][c] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        grid[r][c] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">        dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">        dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">        dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> nr = grid.length;</span><br><span class="line">        <span class="keyword">int</span> nc = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> num_islands = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; nr; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; nc; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    ++num_islands;</span><br><span class="line">                    dfs(grid, r, c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num_islands;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(MN)，其中 M 和 N 分别为行数和列数。</p>
</li>
<li><p>空间复杂度：O(MN)，在最坏情况下，整个网格均为陆地，深度优先搜索的深度达到 MN。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>0206.反转链表</title>
    <url>/2020/09/24/0206.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/reverse-linked-list">https://leetcode-cn.com/problems/reverse-linked-list</a></p>
<p><strong>非递归</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode tmp = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度： O(n) 。总共有 n 个节点，我们每个遍历一次。</li>
<li>空间复杂度： O(1) 。</li>
</ul>
<p><strong>递归</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode tmp = head.next;</span><br><span class="line">        head.next = pre;</span><br><span class="line">        pre = head;</span><br><span class="line">        reverseList(tmp);</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度： O(n) 。总共有 n 个节点，我们每个遍历一次。</li>
<li>空间复杂度： O(n) 。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>0213.打家劫舍2</title>
    <url>/2020/09/22/0213.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D2/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/house-robber-ii">https://leetcode-cn.com/problems/house-robber-ii</a></p>
<p><strong>动态规划 + 滚动数组：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(myRob(nums, <span class="number">0</span>, len - <span class="number">2</span>), myRob(nums, <span class="number">1</span>, len - <span class="number">1</span>)); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myRob</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> second = nums[start];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = second;</span><br><span class="line">            second = Math.max(first + nums[i], tmp);</span><br><span class="line">            first = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中 n 是数组长度。只需要对数组遍历一次。</li>
<li>空间复杂度：O(1)。使用滚动数组，可以只存储前两间房屋的最高总金额，而不需要存储整个数组的结果，因此空间复杂度是 O(1)。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>0328.奇偶链表</title>
    <url>/2020/09/18/0328.%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/odd-even-linked-list">https://leetcode-cn.com/problems/odd-even-linked-list</a></p>
<p><strong>奇偶链表</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode dummyNode1 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode dummyNode2 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">        ListNode p = head, p1 = dummyNode1, p2 = dummyNode2;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                p1.next = p;</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p2.next = p;</span><br><span class="line">                p2 = p2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">            index ++;</span><br><span class="line">        &#125;</span><br><span class="line">        p2.next = <span class="keyword">null</span>; </span><br><span class="line">        p1.next = dummyNode2.next;</span><br><span class="line">        <span class="keyword">return</span> dummyNode1.next;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度： O(n) 。总共有 n 个节点，我们每个遍历一次。</p>
<p>空间复杂度： O(1) 。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>0300.最长子序列</title>
    <url>/2020/09/23/0300.%E6%9C%80%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence">https://leetcode-cn.com/problems/longest-increasing-subsequence</a></p>
<p><strong>动态规划：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &lt; nums[i])&#123;</span><br><span class="line">                    tmp = Math.max(tmp, dp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i] = tmp + <span class="number">1</span>;</span><br><span class="line">                maxLength = Math.max(maxLength, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n^2)，其中 n 为数组 nums 的长度。动态规划的状态数为 nn，计算状态 dp[i] 时，需要 O(n) 的时间遍历 dp[0…i−1] 的所有状态，所以总时间复杂度为 O(n^2)。</li>
<li>空间复杂度：O(n)，需要额外使用长度为 n 的 dp 数组。</li>
</ul>
<p><strong>贪心 + 二分查找：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> j = res;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (i + j) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(result[mid] &lt; num)&#123;</span><br><span class="line">                    i = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    j = mid; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result[i] = num;</span><br><span class="line">            <span class="keyword">if</span>(res == j)&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度 O(NlogN) ： 遍历 nums 列表需 O(N)，在每个 nums[i] 二分法需 O(logN)。</li>
<li>空间复杂度 O(N) ： result 列表占用线性大小额外空间。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>0337.打家劫舍3</title>
    <url>/2020/09/22/0337.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D3/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/house-robber-iii">https://leetcode-cn.com/problems/house-robber-iii</a></p>
<p><strong>动态规划</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = dfs(root);</span><br><span class="line">        <span class="keyword">return</span> Math.max(res[<span class="number">0</span>], res[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] dfs(TreeNode node)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] l = dfs(node.left);</span><br><span class="line">        <span class="keyword">int</span>[] r = dfs(node.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> selected = node.val + l[<span class="number">1</span>] + r[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> notSelected = Math.max(l[<span class="number">0</span>], l[<span class="number">1</span>]) + Math.max(r[<span class="number">0</span>], r[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;selected, notSelected&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)。</li>
<li>空间复杂度：O(n)。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Tree</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>0404.左叶子之和</title>
    <url>/2020/09/19/0404.%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/sum-of-left-leaves">https://leetcode-cn.com/problems/sum-of-left-leaves</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span> &amp;&amp; root.left.left == <span class="keyword">null</span> &amp;&amp; root.left.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            sum += root.left.val;</span><br><span class="line">        &#125;</span><br><span class="line">        sumOfLeftLeaves(root.left); </span><br><span class="line">        sumOfLeftLeaves(root.right);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度： O(n) 。总共有 n 个节点，我们每个遍历一次。</li>
<li>空间复杂度： O(1) 。空间复杂度与深度优先搜索使用的栈的最大深度相关。在最坏的情况下，树呈现链式结构，深度为 O(n)，对应的空间复杂度也为 O(n)。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>0538. 把二叉搜索树转换为累加树</title>
    <url>/2020/09/21/0538.%20%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree">https://leetcode-cn.com/problems/convert-bst-to-greater-tree</a></p>
<p><strong>反中序遍历：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        convertBST(root.right);</span><br><span class="line">        sum += root.val;</span><br><span class="line">        root.val = sum;</span><br><span class="line">        convertBST(root.left);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(n)，其中 nn 是二叉搜索树的节点数。每一个节点恰好被遍历一次。</p>
</li>
<li><p>空间复杂度：O(n)，为递归过程中栈的开销，平均情况下为 O(logn)，最坏情况下树呈现链状，为 O(n)。</p>
</li>
</ul>
<p><strong>Morris遍历：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        </span><br><span class="line">        whille(rode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                sum += node.val;</span><br><span class="line">                node.val = sum;</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                TreeNode suc = getSuccessor(node);</span><br><span class="line">                <span class="keyword">if</span>(suc.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    suc.left = node;</span><br><span class="line">                    node = node.right;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    suc.left = <span class="keyword">null</span>;</span><br><span class="line">                    sum += node.val;</span><br><span class="line">                    node.val = sum;</span><br><span class="line">                    node = node.left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">getSuccessor</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        TreeNode suc = node.right;</span><br><span class="line">        <span class="keyword">while</span>(suc.left != <span class="keyword">null</span> &amp;&amp; suc.left != node)&#123;</span><br><span class="line">            suc = suc.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> suc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)，其中 n 是二叉搜索树的节点数。没有左子树的节点只被访问一次，有左子树的节点被访问两次。</p>
<p>空间复杂度：O(1)。只操作已经存在的指针（树的空闲指针），因此只需要常数的额外空间。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>0617.合并二叉树</title>
    <url>/2020/09/23/0617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/merge-two-binary-trees">https://leetcode-cn.com/problems/merge-two-binary-trees</a></p>
<p><strong>递归</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        TreeNode t = <span class="keyword">new</span> TreeNode(); </span><br><span class="line">        <span class="keyword">if</span>(t1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> t = t2;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> t =t1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            t.val = t1.val + t2.val;</span><br><span class="line">        &#125;</span><br><span class="line">        t.left = mergeTrees(t1.left, t2.left);</span><br><span class="line">        t.right = mergeTrees(t1.right, t2.right);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(min(m,n))，其中 m 和 n 分别是两个二叉树的节点个数。对两个二叉树同时进行深度优先搜索，只有当两个二叉树中的对应节点都不为空时才会对该节点进行显性合并操作，因此被访问到的节点数不会超过较小的二叉树的节点数。</li>
<li>空间复杂度：O(min(m,n))，其中 m 和 n 分别是两个二叉树的节点个数。空间复杂度取决于递归调用的层数，递归调用的层数不会超过较小的二叉树的最大高度，最坏情况下，二叉树的高度等于节点数。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>0701.二叉搜索树中的插入操作</title>
    <url>/2020/09/30/0701.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree">https://leetcode-cn.com/problems/insert-into-a-binary-search-tree</a></p>
<p><strong>递归：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; val) &#123;</span><br><span class="line">            root.right = insertIntoBST(root.right, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root.left = insertIntoBST(root.left, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>迭代：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode pos = root;</span><br><span class="line">        <span class="keyword">while</span>(pos != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(val &lt; pos.val)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pos.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    pos = pos.left;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    pos.left = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(pos.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    pos = pos.right;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    pos.right = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(N)，其中 N 为树中节点的数目。最坏情况下，我们需要将值插入到树的最深的叶子结点上，而叶子节点最深为 O(N)。</li>
<li>空间复杂度：O(1)。我们只使用了常数大小的空间。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>0068.监控二叉树</title>
    <url>/2020/09/22/0968.%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-tree-cameras">https://leetcode-cn.com/problems/binary-tree-cameras</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCameraCover</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lrd(root) == <span class="number">0</span>)&#123;</span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 0代表结点待覆盖</span></span><br><span class="line"><span class="comment">    	1代表结点已覆盖</span></span><br><span class="line"><span class="comment">    	2代表结点已安装监控</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lrd</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = lrd(node.left);</span><br><span class="line">        <span class="keyword">int</span> r = lrd(node.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l == <span class="number">0</span> || r == <span class="number">0</span>)&#123;</span><br><span class="line">            sum++;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l == <span class="number">1</span> &amp;&amp; r == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l + r &gt;= <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>1295. 统计位数为偶数的数字</title>
    <url>/2020/10/03/1295.%E7%BB%9F%E8%AE%A1%E4%BD%8D%E6%95%B0%E4%B8%BA%E5%81%B6%E6%95%B0%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-numbers-with-even-number-of-digits">https://leetcode-cn.com/problems/find-numbers-with-even-number-of-digits</a></p>
<p><strong>最佳：对数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>((<span class="keyword">int</span>)(Math.log10(num) + <span class="number">1</span>) % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>把数字转成字符串</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (String.valueOf(nums[i]).length() % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>循环除以10</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(nums[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                nums[i] /= <span class="number">10</span>;</span><br><span class="line">                tmp++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>直接比较</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> findNumbers(<span class="built_in">int</span>[] nums) &#123;</span><br><span class="line">    <span class="built_in">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>((nums[i]&gt;=<span class="number">10</span>&amp;&amp;nums[i]&lt;<span class="number">100</span>)||(nums[i]&gt;=<span class="number">1000</span>&amp;&amp;nums[i]&lt;<span class="number">10000</span>))</span><br><span class="line">            count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>String</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/08/24/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2020/09/14/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="1-遍历二叉树"><a href="#1-遍历二叉树" class="headerlink" title="1 遍历二叉树"></a>1 遍历二叉树</h2><h3 id="1-1-先序遍历"><a href="#1-1-先序遍历" class="headerlink" title="1.1 先序遍历"></a>1.1 先序遍历</h3><h4 id="1-1-1-递归实现"><a href="#1-1-1-递归实现" class="headerlink" title="1.1.1 递归实现"></a>1.1.1 递归实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderRecur</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     System.put.print(treeNode.Data); </span><br><span class="line">     preOrderRecur(treeNode.left);</span><br><span class="line">     preOrderRecur(treeNode.right);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-2-非递归方式实现"><a href="#1-1-2-非递归方式实现" class="headerlink" title="1.1.2 非递归方式实现"></a>1.1.2 非递归方式实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty)&#123;</span><br><span class="line">        TreeNode res = stack.Pop();</span><br><span class="line">        <span class="keyword">if</span> (res.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(res.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(res.right);</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(res.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="1-2-中序遍历"><a href="#1-2-中序遍历" class="headerlink" title="1.2 中序遍历"></a>1.2 中序遍历</h3><h4 id="1-2-1-递归实现"><a href="#1-2-1-递归实现" class="headerlink" title="1.2.1 递归实现"></a>1.2.1 递归实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">MidTraversal</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;  </span><br><span class="line">		MidTraversa(node.left);</span><br><span class="line">     	System.out.print(node.val+<span class="string">&quot; &quot;</span>);</span><br><span class="line">     	MidTraversa(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-2-非递归实现"><a href="#1-2-2-非递归实现" class="headerlink" title="1.2.2 非递归实现"></a>1.2.2 非递归实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode curr = root;</span><br><span class="line">    <span class="keyword">while</span>(curr != <span class="keyword">null</span> || !(stack.isEmpty()))&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr!= <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(curr);</span><br><span class="line">            curr = curr.left;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            curr = stack.pop();</span><br><span class="line">            list.add(curr.val);</span><br><span class="line">            curr = curr.right;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-后序遍历"><a href="#1-3-后序遍历" class="headerlink" title="1.3 后序遍历"></a>1.3 后序遍历</h3><h4 id="1-3-1-递归实现"><a href="#1-3-1-递归实现" class="headerlink" title="1.3.1 递归实现"></a>1.3.1 递归实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postTraversal</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123; </span><br><span class="line">        postTraversal(node.left);</span><br><span class="line">        postTraversal(node.right);</span><br><span class="line">        System.out.print(node.val+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-2-非递归实现"><a href="#1-3-2-非递归实现" class="headerlink" title="1.3.2 非递归实现"></a>1.3.2 非递归实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode curr = root;</span><br><span class="line">    TreeNode last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(curr);</span><br><span class="line">            curr = curr.left;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = stack.peek();</span><br><span class="line">        <span class="keyword">if</span> (curr.right == <span class="keyword">null</span> || curr.right == last) &#123;</span><br><span class="line">            res.add(curr.val);</span><br><span class="line">            stack.pop();</span><br><span class="line">            last = curr;</span><br><span class="line">            curr = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curr = curr.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-层次遍历"><a href="#1-4-层次遍历" class="headerlink" title="1.4 层次遍历"></a>1.4 层次遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;()；</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        List&lt;Integer&gt; level = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= queue.size(); ++i) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            level.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(node.left)；</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(level);</span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-常见算法"><a href="#2-常见算法" class="headerlink" title="2 常见算法"></a>2 常见算法</h2><h3 id="2-1-二叉树的最大深度"><a href="#2-1-二叉树的最大深度" class="headerlink" title="2.1 二叉树的最大深度"></a>2.1 二叉树的最大深度</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = maxDepth(root.left);</span><br><span class="line">    <span class="keyword">int</span> right = maxDepth(root.right);</span><br><span class="line">    <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-二叉树的镜像"><a href="#2-2-二叉树的镜像" class="headerlink" title="2.2 二叉树的镜像"></a>2.2 二叉树的镜像</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode l = mirrorTree(root.right);</span><br><span class="line">    TreeNode r = mirrorTree(root.left);</span><br><span class="line">    root.left = l;</span><br><span class="line">    root.right = r;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-判断二叉树是否对称"><a href="#2-3-判断二叉树是否对称" class="headerlink" title="2.3 判断二叉树是否对称"></a>2.3 判断二叉树是否对称</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> real(pRoot.left,pRoot.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">real</span><span class="params">(TreeNode root1,TreeNode root2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root1 == <span class="keyword">null</span> &amp;&amp; root2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root1 ==<span class="keyword">null</span> || root2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root1.val != root2.val)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> real(root1.left,root2.right)&amp;&amp;real(root1.right,root2.left);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="2-4-路径总和"><a href="#2-4-路径总和" class="headerlink" title="2.4 路径总和"></a>2.4 路径总和</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listAll = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> listAll;</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        target -= root.val;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span> &amp;&amp; root.left==<span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            listAll.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(list));</span><br><span class="line">        &#125;</span><br><span class="line">        FindPath(root.left,target);</span><br><span class="line">        FindPath(root.right,target);</span><br><span class="line">        list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> listAll;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-重建二叉树"><a href="#2-5-重建二叉树" class="headerlink" title="2.5 重建二叉树"></a>2.5 重建二叉树</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> reConstructBinaryTree(pre,<span class="number">0</span>,pre.length-<span class="number">1</span>,in,<span class="number">0</span>,in.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> startpre,<span class="keyword">int</span> endpre,<span class="keyword">int</span> [] in,<span class="keyword">int</span> startin,<span class="keyword">int</span> endin)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(startpre &gt; endpre || startin &gt; endin)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(pre[startpre]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =startin;i&lt;=endin;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i] == pre[startpre])&#123;</span><br><span class="line">            root.left = reConstructBinaryTree(pre,startpre+<span class="number">1</span>,startpre+i-startin,in,startin,i-<span class="number">1</span>);</span><br><span class="line">            root.right = reConstructBinaryTree(pre,startpre+i-startin+<span class="number">1</span>,endpre,in,i+<span class="number">1</span>,endin);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-6-最近公共祖先"><a href="#2-6-最近公共祖先" class="headerlink" title="2.6 最近公共祖先"></a>2.6 最近公共祖先</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span> || root == p || root == q)&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    <span class="keyword">if</span>(left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left != <span class="keyword">null</span> ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-7-反序列化"><a href="#2-7-反序列化" class="headerlink" title="2.7 反序列化"></a>2.7 反序列化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="keyword">null</span> || data.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] dataArr = data.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    <span class="comment">// 层次遍历逆向还原二叉树</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    TreeNode root = toNode(dataArr[index]);</span><br><span class="line">    LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (index &lt; dataArr.length - <span class="number">2</span> &amp;&amp; !queue.isEmpty()) &#123;</span><br><span class="line">        TreeNode cur = queue.remove();</span><br><span class="line">        <span class="comment">// 添加左子节点</span></span><br><span class="line">        TreeNode leftNode = toNode(dataArr[++index]);</span><br><span class="line">        cur.left = leftNode;</span><br><span class="line">        <span class="comment">// 队列中的节点用于为其赋值孩子节点，若该节点本身为 null，</span></span><br><span class="line">        <span class="comment">// 没有孩子节点，便不再添加到队列中，下同理</span></span><br><span class="line">        <span class="keyword">if</span> (leftNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(leftNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加右子节点</span></span><br><span class="line">        TreeNode rightNode = toNode(dataArr[++index]);</span><br><span class="line">        cur.right = rightNode;</span><br><span class="line">        <span class="keyword">if</span> (rightNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(rightNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">toNode</span><span class="params">(String val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="string">&quot;null&quot;</span>.equals(val)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(Integer.parseInt(val));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer27.二叉树的镜像</title>
    <url>/2020/09/16/%E5%89%91%E6%8C%87Offer27.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof">https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode l = mirrorTree(root.right);</span><br><span class="line">        TreeNode r = mirrorTree(root.left);</span><br><span class="line">        root.left = l;</span><br><span class="line">        root.right = r;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(n)，</p>
</li>
<li><p>空间复杂度：O(n)。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer46. 把数字翻译成字符串</title>
    <url>/2020/09/28/%E5%89%91%E6%8C%87Offer46.%20%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof">https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof</a></p>
<p><strong>dp</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        String s = String.valueOf(num);</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= s.length(); i++)&#123;</span><br><span class="line">            String tmp = s.substring(i - <span class="number">2</span>, i);</span><br><span class="line">            <span class="keyword">int</span> c = tmp.compareTo(<span class="string">&quot;10&quot;</span>) &gt;= <span class="number">0</span> &amp;&amp; tmp.compareTo(<span class="string">&quot;25&quot;</span>) &lt;= <span class="number">0</span> ? a + b : b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度 O(N) ： N 为字符串 s 的长度（即数字 num 的位数 log(num) ），其决定了循环次数。</li>
<li>空间复杂度 O(N) ： 字符串 s 使用 O(N) 大小的额外空间。</li>
</ul>
<p><strong>求余</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num &lt; <span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num % <span class="number">100</span> &gt;= <span class="number">10</span> &amp;&amp; num % <span class="number">100</span> &lt;= <span class="number">25</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> translateNum(num / <span class="number">10</span>) + translateNum(num / <span class="number">100</span>); </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> translateNum(num / <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, x, y = num % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span>(num != <span class="number">0</span>) &#123;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">            x = num % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">10</span> * x + y;</span><br><span class="line">            <span class="keyword">int</span> c = (tmp &gt;= <span class="number">10</span> &amp;&amp; tmp &lt;= <span class="number">25</span>) ? a + b : a;</span><br><span class="line">            b = a;</span><br><span class="line">            a = c;</span><br><span class="line">            y = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>时间复杂度 O(N) ： N 为字符串 s 的长度（即数字 num 的位数 log(num) ），其决定了循环次数。</p>
</li>
<li><p>空间复杂度 O(1) ： 几个变量使用常数大小的额外空间。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>反转链表</title>
    <url>/2020/09/03/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，反转链表后，输出新链表的表头。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment">	ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">    this.val = val;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode p = <span class="keyword">null</span>;</span><br><span class="line">        ListNode q = head;</span><br><span class="line">        ListNode temp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(q!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            temp = q.next;</span><br><span class="line">            q.next = p;</span><br><span class="line">            p = q;</span><br><span class="line">            q = temp;          </span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LinkedList</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>小红书笔试题2.笔记草稿</title>
    <url>/2020/09/22/%E5%B0%8F%E7%BA%A2%E4%B9%A6%E7%AC%94%E8%AF%95%E9%A2%982.%E7%AC%94%E8%AE%B0%E8%8D%89%E7%A8%BF/</url>
    <content><![CDATA[<p>1.输入字符包括，”(“  ,  “)”  和  “&lt;”和其他字符。 </p>
<p>2.其他字符表示笔记内容。 </p>
<p>3.()之间表示注释内容，任何字符都无效。  括号保证成对出现。 </p>
<p> 4.”&lt;”表示退格,  删去前面一个笔记内容字符。括号不受”&lt;”影响  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xiaohongshuCode2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        stringBuffer = <span class="keyword">new</span> StringBuffer(sc.nextLine());</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stringBuffer.length();)&#123;</span><br><span class="line">            <span class="keyword">if</span>(stringBuffer.charAt(i) == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                list.add(i);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(stringBuffer.charAt(i) == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> end = list.size() - <span class="number">1</span>;</span><br><span class="line">                stringBuffer.delete(list.get(end), i + <span class="number">1</span>);</span><br><span class="line">                i = list.get(end);</span><br><span class="line">                list.remove(end);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(stringBuffer.charAt(i) == <span class="string">&#x27;&lt;&#x27;</span>)&#123;</span><br><span class="line">                stringBuffer.delete(i - <span class="number">1</span>, i + <span class="number">1</span>);</span><br><span class="line">                i--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(stringBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>StringBuffer：</strong></p>
<ul>
<li>delete（int begin,int end）有两个参数，使用时删除索引从begin开始（包含begin）到end（不包含end）的所有字符；</li>
<li>deleteCharAt（int index）只有一个参数，使用时删除索引为index的字符；</li>
</ul>
<p><a href="https://www.nowcoder.com/questionTerminal/0823ca800ee04706a7e2dafc837dc236">https://www.nowcoder.com/questionTerminal/0823ca800ee04706a7e2dafc837dc236</a></p>
]]></content>
      <categories>
        <category>笔试</category>
      </categories>
      <tags>
        <tag>笔试</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>小红书笔试题3.笔记精选</title>
    <url>/2020/09/22/%E5%B0%8F%E7%BA%A2%E4%B9%A6%E7%AC%94%E8%AF%95%E9%A2%983.%E7%AC%94%E8%AE%B0%E7%B2%BE%E9%80%89/</url>
    <content><![CDATA[<p>1.不能出现连续编号的笔记。 </p>
<p>2.总点赞总数最多 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xiaohongshuCode3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            nums[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(nums[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pre = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> cur = nums[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = cur;</span><br><span class="line">            <span class="keyword">if</span> (pre + nums[i] &gt; tmp)&#123;</span><br><span class="line">                cur = pre + nums[i];</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(cur + <span class="string">&quot; &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔试</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>度小满笔试1.涂色</title>
    <url>/2020/09/21/%E5%BA%A6%E5%B0%8F%E6%BB%A1%E7%AC%94%E8%AF%951.%E6%B6%82%E8%89%B2/</url>
    <content><![CDATA[<ul>
<li><p>给定两个字符串，判断相同字符的个数</p>
<ul>
<li><p>输入：</p>
<p>ABC</p>
<p>ACC</p>
</li>
<li><p>输出：</p>
<p>2</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DuXiaoManCode1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str1 = sc.next();</span><br><span class="line">        String str2 = sc.next();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str1.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hashMap.containsKey(str1.charAt(i)))&#123;</span><br><span class="line">                hashMap.put(str1.charAt(i), hashMap.get(str1.charAt(i)) + <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                hashMap.put(str1.charAt(i), <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str2.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hashMap.containsKey(str2.charAt(i)))&#123;</span><br><span class="line">                <span class="keyword">if</span>(hashMap.get(str2.charAt(i)) == <span class="number">1</span>)&#123;</span><br><span class="line">                    hashMap.remove(str2.charAt(i));</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    hashMap.put(str2.charAt(i), hashMap.get(str2.charAt(i)) - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔试</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>度小满笔试2.昆虫走迷宫</title>
    <url>/2020/09/21/%E5%BA%A6%E5%B0%8F%E6%BB%A1%E7%AC%94%E8%AF%952.%E6%98%86%E8%99%AB%E8%B5%B0%E8%BF%B7%E5%AE%AB/</url>
    <content><![CDATA[<ul>
<li><p>@代表昆虫位置，.代表可以通行，#代表不可越过的墙壁，*代表可以越过的墙壁，求昆虫走出迷宫最小破壁次数</p>
<ul>
<li><p>输入：</p>
<p>3</p>
<p>3 3</p>
<p>###</p>
<p>*@#</p>
<p>.##</p>
<p>3 3</p>
<p>@##</p>
<p>…</p>
<p>#**</p>
<p>3 3</p>
<p>#.#</p>
<p>*@#</p>
<p>###</p>
</li>
<li><p>输出：</p>
<p>1</p>
<p>0</p>
<p>1</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> nums = sc.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> m = sc.nextInt();</span><br><span class="line">            <span class="keyword">int</span> n = sc.nextInt();</span><br><span class="line">            <span class="keyword">char</span>[][] input = <span class="keyword">char</span>[m][n];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">                String s = sc.next();</span><br><span class="line">                <span class="keyword">char</span>[] sctmp = s.toCharArray();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; sctmp.length; k++)&#123;</span><br><span class="line">                    input[j][k] = sctmp[k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b.length; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; a[<span class="number">0</span>].length; k++)&#123;</span><br><span class="line">                    res[i][j] = Integer.MAX_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span>[][] visited = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; input.length; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k =<span class="number">0</span>; k &lt; input[<span class="number">0</span>].length; k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[j][k] == <span class="string">&#x27;@&#x27;</span>)&#123;</span><br><span class="line">                        <span class="keyword">new</span> Main().dfs(input, res, visited, m, n, j, k, <span class="number">0</span>);</span><br><span class="line">                        System.out.println(b[j][k] == Integer.MAX_VALUE ? -<span class="number">1</span> : b[j][k]);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] input, <span class="keyword">int</span>[][] res, <span class="keyword">int</span>[][] visited, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> countNew = count;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt; m || j &gt; m)&#123;</span><br><span class="line">            retrun <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res[i][j] != Integer.MAX_VALUE &amp;&amp; res[i][j] &lt;= countNew)&#123;</span><br><span class="line">            <span class="keyword">return</span> res[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(visited[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(input[i][j] == <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(input[i][j] == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> countNew++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        visited[i][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> a = dfs(input, res, visited, m, n, i + <span class="number">1</span>, j, countNew);</span><br><span class="line">        <span class="keyword">int</span> b = dfs(input, res, visited, m, n, i - <span class="number">1</span>, j, countNew);</span><br><span class="line">        <span class="keyword">int</span> c = dfs(input, res, visited, m, n, i, j + <span class="number">1</span>, countNew);</span><br><span class="line">        <span class="keyword">int</span> d = dfs(input, res, visited, m, n, i, j - <span class="number">1</span>, countNew);</span><br><span class="line">        visited[i][j] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> min = Math,min(res[i][j], Math.min(Math.min(a, b), Math.min(c, d)));</span><br><span class="line">        <span class="keyword">if</span>(input[i][j] == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">            min++;</span><br><span class="line">        &#125;</span><br><span class="line">        res[i][j] = Math.min(min, res[i][j]);</span><br><span class="line">        <span class="keyword">return</span> res[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔试</category>
      </categories>
      <tags>
        <tag>笔试</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>排序</title>
    <url>/2020/09/17/%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><table>
<thead>
<tr>
<th align="center">排序算法</th>
<th align="center">平均时间复杂度</th>
<th align="center">最好情况</th>
<th align="center">最坏情况</th>
<th align="center">空间复杂度</th>
<th align="center">排序方式</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">冒泡排序</td>
<td align="center">O(n^2)</td>
<td align="center">O(n)</td>
<td align="center">O(n^2)</td>
<td align="center">O(1)</td>
<td align="center">In-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">选择排序</td>
<td align="center">O(n^2)</td>
<td align="center">O(n^2)</td>
<td align="center">O(n^2)</td>
<td align="center">O(1)</td>
<td align="center">In-place</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">插入排序</td>
<td align="center">O(n^2)</td>
<td align="center">O(n)</td>
<td align="center">O(n^2)</td>
<td align="center">O(1)</td>
<td align="center">In-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">希尔排序</td>
<td align="center">O(nlogn)</td>
<td align="center">O(nlog^2 n)</td>
<td align="center">O(n^1.5)</td>
<td align="center">O(1)</td>
<td align="center">In-place</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">归并排序</td>
<td align="center">O(nlogn)</td>
<td align="center">O(nlogn)</td>
<td align="center">O(nlogn)</td>
<td align="center">O(n)</td>
<td align="center">Out-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">快速排序</td>
<td align="center">O(nlogn)</td>
<td align="center">O(nlogn)</td>
<td align="center">O(n^2)</td>
<td align="center">O(nlogn)</td>
<td align="center">In-place</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">堆排序</td>
<td align="center">O(nlogn)</td>
<td align="center">O(nlogn)</td>
<td align="center">O(nlogn)</td>
<td align="center">O(1)</td>
<td align="center">In-place</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">计数排序</td>
<td align="center">O(n+k)</td>
<td align="center">O(n+k)</td>
<td align="center">O(n+k)</td>
<td align="center">O(k)</td>
<td align="center">Out-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">桶排序</td>
<td align="center">O(n+k)</td>
<td align="center">O(n+k)</td>
<td align="center">O(n^2)</td>
<td align="center">O(n+k)</td>
<td align="center">Out-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">基数排序</td>
<td align="center">O(n*k)</td>
<td align="center">O(n*k)</td>
<td align="center">O(n*k)</td>
<td align="center">O(n+k)</td>
<td align="center">Out-place</td>
<td align="center">稳定</td>
</tr>
</tbody></table>
<a id="more"></a>

<ul>
<li>平均情况下，快些归队的时间复杂度好O(nlogn)</li>
<li>最坏情况下，除快速排序外，都与平均情况相同</li>
<li>快些选队不稳定</li>
<li>插入排序和冒泡排序适合基本有序的序列</li>
<li>经过一趟排序就可以保证一个关键字到达最终位置的是：冒泡、快速、堆</li>
<li>选择排序和折半插入与原始序列无关</li>
</ul>
<h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1 冒泡排序"></a>1 冒泡排序</h2><ul>
<li>比较相邻的元素，如果前一个大于后一个，就交换位置；</li>
<li>每循环一次，最大的元素会位于数列的最后一个位置</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bubbleSort(<span class="keyword">int</span>[] array)&#123;</span><br><span class="line">    <span class="keyword">if</span>(array.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - <span class="number">1</span> - i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[j] &gt; array[j + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = array[j];</span><br><span class="line">                array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">                array[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2 选择排序"></a>2 选择排序</h2><ul>
<li>遍历数列，选择最小值放到第一个位置</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] selectSort(<span class="keyword">int</span>[] array)&#123;</span><br><span class="line">    <span class="keyword">if</span>(array.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; array.length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[j] &lt; array[minIndex])&#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = array[minIndex];</span><br><span class="line">        array[minIndex] = array[j];</span><br><span class="line">        array[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3 插入排序"></a>3 插入排序</h2><ul>
<li>从第二个元素开始，将其插入到合适的位置</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] insertSort(<span class="keyword">int</span>[] array)&#123;</span><br><span class="line">    <span class="keyword">if</span>(array.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> current;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i ++)&#123;</span><br><span class="line">        current = array[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> preIndex = i;</span><br><span class="line">        <span class="keyword">while</span>(preIndex &gt; <span class="number">0</span> &amp;&amp; current &lt; array[preIndex])&#123;</span><br><span class="line">            array[preIndex + <span class="number">1</span>] = array[preIndex];</span><br><span class="line">            preIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        array[preIndex + <span class="number">1</span>] = currentl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4 希尔排序"></a>4 希尔排序</h2><ul>
<li>将整个数列分组进行插入排序</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] shellSort(<span class="keyword">int</span>[] array)&#123;</span><br><span class="line">    <span class="keyword">if</span>(array.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">int</span> gap = array.length / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(gap &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = gap; i &lt; array.length; i++)&#123;</span><br><span class="line">            temp = array[i];</span><br><span class="line">            <span class="keyword">int</span> pre = i - gap;</span><br><span class="line">            <span class="keyword">while</span>(pre &gt; <span class="number">0</span> &amp;&amp; temp &lt; array[pre])&#123;</span><br><span class="line">                array[pre + <span class="number">1</span>] = array[pre];</span><br><span class="line">                pre -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            array[pre + gap] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        gap /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5 归并排序"></a>5 归并排序</h2><ul>
<li>将数列等分为两个数列递归进行归并排序</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mergeSort(<span class="keyword">int</span>[] array)&#123;</span><br><span class="line">    <span class="keyword">if</span>(array.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = array.length / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span>[] left = Arrays.vopyOfRange(array, <span class="number">0</span>, mid);</span><br><span class="line">    <span class="keyword">int</span>[] right = Arrays.copyOfRange(array, mid, array.length);</span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] merge(<span class="keyword">int</span>[] l, <span class="keyword">int</span>[] r)&#123;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[l.length + r.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>; k &lt; res.length; k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; l.length)&#123;</span><br><span class="line">            res[k] = r[j++];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j &gt; r.length)&#123;</span><br><span class="line">            res[k] = l[i++];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(l[i] &gt; r[j])&#123;</span><br><span class="line">            res[k] = r[j++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res[k] = l[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6 快速排序"></a>6 快速排序</h2><ul>
<li>遍历数列，把基准排到合适位置后，递归</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] quickSort(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)&#123;</span><br><span class="line">    <span class="keyword">if</span>(array.length &lt; <span class="number">1</span> || start &lt; <span class="number">0</span> || end &gt; array.length || start &gt; end)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> parIndex = partition(array, start, end);</span><br><span class="line">    quickSort(array, start, parIndex - <span class="number">1</span>);</span><br><span class="line">    quickSort(array, parIndex + <span class="number">1</span>, end);</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] partition(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = start;</span><br><span class="line">    <span class="keyword">int</span> index = pivot + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt;= end; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i] &lt; array[pivot])&#123;</span><br><span class="line">            swap(array, i, index);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(array, pivot, index - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> index - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pulic <span class="keyword">void</span> <span class="title">swap</span><span class="params">()</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = array[i];</span><br><span class="line">    array[i] = array[j];</span><br><span class="line">    array[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7 堆排序"></a>7 堆排序</h2><ul>
<li>取大顶堆的堆顶元素作为数列的最后一个值，递归</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] HeapSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">    len = array.length;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">1</span>) <span class="keyword">return</span> array;</span><br><span class="line">    buildMaxHeap(array);</span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        swap(array, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">        len--;</span><br><span class="line">        adjustHeap(array, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (len/<span class="number">2</span> - <span class="number">1</span>); i &gt;= <span class="number">0</span>; i--) &#123; </span><br><span class="line">        adjustHeap(array, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxIndex = i;</span><br><span class="line">    <span class="comment">//如果有左子树，且左子树大于父节点，则将最大指针指向左子树</span></span><br><span class="line">    <span class="keyword">if</span> (i * <span class="number">2</span> &lt; len &amp;&amp; array[i * <span class="number">2</span>] &gt; array[maxIndex])</span><br><span class="line">        maxIndex = i * <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//如果有右子树，且右子树大于父节点，则将最大指针指向右子树</span></span><br><span class="line">    <span class="keyword">if</span> (i * <span class="number">2</span> + <span class="number">1</span> &lt; len &amp;&amp; array[i * <span class="number">2</span> + <span class="number">1</span>] &gt; array[maxIndex])</span><br><span class="line">        maxIndex = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。</span></span><br><span class="line">    <span class="keyword">if</span> (maxIndex != i) &#123;</span><br><span class="line">        swap(array, maxIndex, i);</span><br><span class="line">        adjustHeap(array, maxIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pulic <span class="keyword">void</span> <span class="title">swap</span><span class="params">()</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = array[i];</span><br><span class="line">    array[i] = array[j];</span><br><span class="line">    array[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-计数排序"><a href="#8-计数排序" class="headerlink" title="8 计数排序"></a>8 计数排序</h2><ul>
<li>统计每个值出现的次数，反向填充数组</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] CountingSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array.length == <span class="number">0</span>) <span class="keyword">return</span> array;</span><br><span class="line">    <span class="keyword">int</span> bias, min = array[<span class="number">0</span>], max = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i] &gt; max)</span><br><span class="line">            max = array[i];</span><br><span class="line">        <span class="keyword">if</span> (array[i] &lt; min)</span><br><span class="line">            min = array[i];</span><br><span class="line">    &#125;</span><br><span class="line">    bias = <span class="number">0</span> - min;</span><br><span class="line">    <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(bucket, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        bucket[array[i] + bias]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; array.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bucket[i] != <span class="number">0</span>) &#123;</span><br><span class="line">        	array[index] = i - bias;</span><br><span class="line">            bucket[i]--;</span><br><span class="line">            index++;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-桶排序"><a href="#9-桶排序" class="headerlink" title="9 桶排序"></a>9 桶排序</h2><ul>
<li>遍历数列，将其放到不同的桶中排序后拼接</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">BucketSort</span><span class="params">(ArrayList&lt;Integer&gt; array, <span class="keyword">int</span> bucketSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.size() &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    <span class="keyword">int</span> max = array.get(<span class="number">0</span>), min = array.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array.get(i) &gt; max)</span><br><span class="line">            max = array.get(i);</span><br><span class="line">        <span class="keyword">if</span> (array.get(i) &lt; min)</span><br><span class="line">            min = array.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> bucketCount = (max - min) / bucketSize + <span class="number">1</span>;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = <span class="keyword">new</span> ArrayList&lt;&gt;(bucketCount);</span><br><span class="line">    ArrayList&lt;Integer&gt; resultArr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketCount; i++) &#123;</span><br><span class="line">        bucketArr.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.size(); i++) &#123;</span><br><span class="line">        bucketArr.get((array.get(i) - min) / bucketSize).add(array.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketCount; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bucketSize == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucketArr.get(i).size(); j++)</span><br><span class="line">                resultArr.add(bucketArr.get(i).get(j));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucketCount == <span class="number">1</span>)</span><br><span class="line">                bucketSize--;</span><br><span class="line">            ArrayList&lt;Integer&gt; temp = BucketSort(bucketArr.get(i), bucketSize);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; temp.size(); j++)</span><br><span class="line">                resultArr.add(temp.get(j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-基数排序"><a href="#10-基数排序" class="headerlink" title="10 基数排序"></a>10 基数排序</h2><ul>
<li>先根据数据的位数分桶，再进行计数排序</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] RadixSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        max = Math.max(max, array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxDigit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (max != <span class="number">0</span>) &#123;</span><br><span class="line">        max /= <span class="number">10</span>;</span><br><span class="line">        maxDigit++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">10</span>, div = <span class="number">1</span>;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        bucketList.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxDigit; i++, mod *= <span class="number">10</span>, div *= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = (array[j] % mod) / div;</span><br><span class="line">            bucketList.get(num).add(array[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucketList.size(); j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; bucketList.get(j).size(); k++)</span><br><span class="line">                array[index++] = bucketList.get(j).get(k);</span><br><span class="line">            bucketList.get(j).clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>































]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>携程笔试题1.订单记录</title>
    <url>/2020/09/23/%E6%90%BA%E7%A8%8B%E7%AC%94%E8%AF%95%E9%A2%981.%E8%AE%A2%E5%8D%95%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>输入一个时间值A，需要在这批记录中找到符合入离店时间范围（A大于等于入店时间，并且A小于等于离店时间）内的所有记录。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xiechengCode1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span> a = sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = sc.nextInt();</span><br><span class="line">            <span class="keyword">int</span> low = sc.nextInt();</span><br><span class="line">            <span class="keyword">int</span> high = sc.nextInt();</span><br><span class="line">            <span class="keyword">if</span>(a &gt;= low &amp;&amp; a &lt;= high)&#123;</span><br><span class="line">                res[i] = index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(res);</span><br><span class="line">        <span class="keyword">if</span>(res[n - <span class="number">1</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(res[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(res[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔试</category>
      </categories>
      <tags>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>携程笔试题2.LRU Cache</title>
    <url>/2020/09/28/%E6%90%BA%E7%A8%8B%E7%AC%94%E8%AF%95%E9%A2%982.LRU%20Cache/</url>
    <content><![CDATA[<p>设计一个数据结构，实现LRU Cache的功能(Least Recently Used – 最近最少使用缓存)。它支持如下2个操作： get 和 put。</p>
<ul>
<li>int get(int key) <ul>
<li>如果key已存在，则返回key对应的值value（始终大于0）；</li>
<li>如果key不存在，则返回-1。</li>
</ul>
</li>
<li>void put(int key, int value) <ul>
<li>如果key不存在，将value插入；</li>
<li>如果key已存在，则使用value替换原先已经存在的值。如果容量达到了限制，LRU Cache需要在插入新元素之前，将最近最少使用的元素删除。</li>
</ul>
</li>
</ul>
<p>请特别注意“使用”的定义：新插入或获取key视为被使用一次；而将已经存在的值替换更新，不算被使用。</p>
<p>限制：请在O(1)的时间复杂度内完成上述2个操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xiechengCode2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LRUCache</span><span class="params">(Scanner sc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = Integer.parseInt(sc.nextLine());</span><br><span class="line">        LinkedHashMap&lt;Integer,Integer&gt; mmap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        String[] temp;</span><br><span class="line">        <span class="keyword">int</span> key,value;</span><br><span class="line">        <span class="keyword">while</span> (sc.hasNext())&#123;</span><br><span class="line">            temp = sc.nextLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            key = Integer.parseInt(temp[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;p&quot;</span>.equals(temp[<span class="number">0</span>]))&#123;</span><br><span class="line">                value = Integer.parseInt(temp[<span class="number">2</span>]);</span><br><span class="line">                <span class="keyword">if</span> (mmap.containsKey(key))&#123;<span class="comment">//覆盖已有，其它什么都不做</span></span><br><span class="line">                    mmap.put(key,value);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (curr==n)&#123;<span class="comment">//如果队满了，插入新值并删除队首元素。</span></span><br><span class="line">                    mmap.put(key,value);</span><br><span class="line">                    key = mmap.entrySet().iterator().next().getKey();<span class="comment">//队首元素key</span></span><br><span class="line">                    mmap.remove(key);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    mmap.put(key,value);</span><br><span class="line">                    curr++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (mmap.containsKey(key))&#123;<span class="comment">//查询已有值，然后删除再插入在队尾</span></span><br><span class="line">                    value = mmap.get(key);</span><br><span class="line">                    System.out.println(value);</span><br><span class="line">                    mmap.remove(key);</span><br><span class="line">                    mmap.put(key,value);</span><br><span class="line">                &#125;<span class="keyword">else</span> System.out.println(-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        LRUCache(sc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔试</category>
      </categories>
      <tags>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>携程笔试题3.bit count</title>
    <url>/2020/09/28/%E6%90%BA%E7%A8%8B%E7%AC%94%E8%AF%95%E9%A2%983.bit%20count/</url>
    <content><![CDATA[<p>输入一个long类型的数值, 求该数值的二进制表示中的1的个数 .</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> xiecheng;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xiechengCode3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">long</span> n = sc.nextLong();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            n &amp;= n - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        sc.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔试</category>
      </categories>
      <tags>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题 08.11. 硬币</title>
    <url>/2020/09/21/%E9%9D%A2%E8%AF%95%E9%A2%98%2008.11.%20%E7%A1%AC%E5%B8%81/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/coin-lcci">https://leetcode-cn.com/problems/coin-lcci</a></p>
<p><strong>动态规划：无限背包</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">waysToChange</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] coins = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">25</span>&#125;;</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> coin : coins)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = coin; i &lt;= n; i++)&#123;</span><br><span class="line">                dp[i] = (dp[i] + dp[i - coin]) % <span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>0018.四数之和</title>
    <url>/2020/10/05/0018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/4sum/">https://leetcode-cn.com/problems/4sum/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; quadruplets = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> quadruplets;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>] + nums[i + <span class="number">3</span>] &gt; target) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[length - <span class="number">3</span>] + nums[length - <span class="number">2</span>] + nums[length - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; length - <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] + nums[j + <span class="number">1</span>] + nums[j + <span class="number">2</span>] &gt; target) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] + nums[length - <span class="number">2</span>] + nums[length - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> left = j + <span class="number">1</span>, right = length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                    <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                        quadruplets.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));</span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                            left++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        left++;</span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                            right--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> quadruplets;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(n^3)，其中 nn 是数组的长度。排序的时间复杂度是 O(n \log n)O(nlogn)，枚举四元组的时间复杂度是 O(n^3)，因此总时间复杂度为 O(n^3+nlogn)=O(n3)。</p>
</li>
<li><p>空间复杂度：O(logN)。我们忽略存储答案的空间，额外的排序的空间复杂度为 O(logN)。然而我们修改了输入的数组 nums，在实际情况下不一定允许，因此也可以看成使用了一个额外的数组存储了 nums 的副本并进行排序，空间复杂度为 O(N)。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>0201.数组范围按位与</title>
    <url>/2020/10/06/0201.%E6%95%B0%E7%BB%84%E8%8C%83%E5%9B%B4%E6%8C%89%E4%BD%8D%E4%B8%8E/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/bitwise-and-of-numbers-range">https://leetcode-cn.com/problems/bitwise-and-of-numbers-range</a></p>
<p><strong>位移</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(m != n)&#123;</span><br><span class="line">            m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m &lt;&lt; count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(logn)。算法的时间复杂度取决于 mm 和 nn 的二进制位数，由于 m≤n，因此时间复杂度取决于 n 的二进制位数。</li>
<li>空间复杂度：O(1)。我们只需要常数空间存放若干变量。</li>
</ul>
<p><strong>Brian Kernighan 算法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (m &lt; n) &#123;</span><br><span class="line">            <span class="comment">// 抹去最右边的 1</span></span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(logn)。和位移方法类似，算法的时间复杂度取决于 m 和 n 二进制展开的位数。尽管和位移方法具有相同的渐近复杂度，但 Brian Kernighan 的算法需要的迭代次数会更少，因为它跳过了两个数字之间的所有零位。</li>
<li>空间复杂度：O(1)。我们只需要常数空间存放若干变量。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>0769.最多能完成排序的块</title>
    <url>/2020/10/05/0769.%E6%9C%80%E5%A4%9A%E8%83%BD%E5%AE%8C%E6%88%90%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9D%971/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/max-chunks-to-make-sorted">https://leetcode-cn.com/problems/max-chunks-to-make-sorted</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxChunksToSorted</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            max = Math.max(arr[i], max);</span><br><span class="line">            <span class="keyword">if</span>(max == i) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(N)，其中 N 为数组 <code>arr</code> 的长度。</li>
<li>空间复杂度: O(1)。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>0091. 解码方法</title>
    <url>/2020/10/07/0091.%20%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/decode-ways">https://leetcode-cn.com/problems/decode-ways</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = s.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> c = b;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;1&#x27;</span> || s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;2&#x27;</span> &amp;&amp; s.charAt(i) &lt; <span class="string">&#x27;7&#x27;</span>)&#123; </span><br><span class="line">                c = s.charAt(i) != <span class="string">&#x27;0&#x27;</span> ? a + b : a; <span class="comment">// a + b : 11 ~ 19, 21 ~ 26; a : 10, 20</span></span><br><span class="line">                a = b;</span><br><span class="line">                b = c;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;0&#x27;</span>)&#123; <span class="comment">// 00, 30, 40...</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// 01, 02, 03...; 27, 28, 29, 31...</span></span><br><span class="line">                a = b;</span><br><span class="line">                b = c;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度 O(N) ： N 为字符串 s 的长度，其决定了循环次数。</li>
<li>空间复杂度 O(1) ： 字符串 s 使用常量大小的额外空间。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>0075.颜色分类</title>
    <url>/2020/10/07/0075.%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/sort-colors">https://leetcode-cn.com/problems/sort-colors</a></p>
<p><strong>两趟扫描法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">1</span>)&#123;</span><br><span class="line">                w++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                b++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; r)&#123;</span><br><span class="line">                nums[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i &gt;= r &amp;&amp; i &lt; r + w)&#123;</span><br><span class="line">                nums[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums[i] = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(N)。</li>
<li>空间复杂度：O(N)。</li>
</ul>
<p><strong>双指针：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                swap(nums, i, l);</span><br><span class="line">                l++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == <span class="number">2</span>)&#123;</span><br><span class="line">                swap(nums, i, r);</span><br><span class="line">                r--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(N)。</li>
<li>空间复杂度：O(1)。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>0008.字符串转换整数（atoi）</title>
    <url>/2020/10/07/0008.%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0%EF%BC%88atoi%EF%BC%89/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/">https://leetcode-cn.com/problems/string-to-integer-atoi/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> state = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(state == <span class="number">0</span> &amp;&amp; c == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                state = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(state == <span class="number">0</span> &amp;&amp; (c == <span class="string">&#x27;-&#x27;</span> || c == <span class="string">&#x27;+&#x27;</span>))&#123;</span><br><span class="line">                state = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(state != <span class="number">3</span> &amp;&amp; c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                state = <span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                state = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(state == <span class="number">1</span>)&#123;</span><br><span class="line">                sign = c == <span class="string">&#x27;-&#x27;</span> ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(state == <span class="number">2</span>)&#123;</span><br><span class="line">                ans = ans * <span class="number">10</span> + (c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span>(ans * sign &gt;= Integer.MAX_VALUE)&#123;</span><br><span class="line">                    <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(ans * sign &lt;= Integer.MIN_VALUE)&#123;</span><br><span class="line">                    <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(state == <span class="number">3</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = ans != <span class="number">0</span> ? ans * sign : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中 nn 为字符串的长度。我们只需要依次处理所有的字符，处理每个字符需要的时间为 O(1)。</li>
<li>空间复杂度：O(1)，自动机的状态只需要常数空间存储。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>01431.拥有最多糖果的孩子</title>
    <url>/2020/10/07/1431.%E6%8B%A5%E6%9C%89%E6%9C%80%E5%A4%9A%E7%B3%96%E6%9E%9C%E7%9A%84%E5%AD%A9%E5%AD%90/</url>
    <content><![CDATA[<p>拥有最多糖果的孩子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Boolean&gt; <span class="title">kidsWithCandies</span><span class="params">(<span class="keyword">int</span>[] candies, <span class="keyword">int</span> extraCandies)</span> </span>&#123;</span><br><span class="line">        List&lt;Boolean&gt; res = <span class="keyword">new</span> ArrayList&lt;Boolean&gt;();</span><br><span class="line">        <span class="keyword">int</span> maxCandy = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> candy : candies)&#123;</span><br><span class="line">            maxCandy = Math.max(maxCandy, candy);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; candies.length; i++)&#123;</span><br><span class="line">            res.add(candies[i] + extraCandies &gt;= maxCandy);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(n)。</p>
</li>
<li><p>空间复杂度：O(1)。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 47. 礼物的最大价值</title>
    <url>/2020/10/07/%E5%89%91%E6%8C%87Offer47.%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof">https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = grid.length;</span><br><span class="line">        <span class="keyword">int</span> c = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[r + <span class="number">1</span>][c + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= c; j++)&#123;</span><br><span class="line">                dp[i][j] = grid[i - <span class="number">1</span>][j - <span class="number">1</span>] + Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[r][c];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(mn)。</li>
<li>空间复杂度：O(1)。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 48.最长不含重复字符的子字符串</title>
    <url>/2020/10/07/%E5%89%91%E6%8C%87Offer48.%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof">https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof</a></p>
<p><strong>滑动窗口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(r &lt; s.length())&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(r++);</span><br><span class="line">            <span class="keyword">while</span>(set.contains(c))&#123;</span><br><span class="line">                set.remove(s.charAt(l++));</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(c);</span><br><span class="line">            res = Math.max(res, r - l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)。</li>
<li>空间复杂度：O(<em>n</em>)。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>HashSet</tag>
      </tags>
  </entry>
  <entry>
    <title>0344.反转字符串</title>
    <url>/2020/10/08/0344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/reverse-string">https://leetcode-cn.com/problems/reverse-string</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">char</span> tmp = s[l];</span><br><span class="line">            s[l] = s[r];</span><br><span class="line">            s[r] = tmp;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(n)。</p>
</li>
<li><p>空间复杂度：O(1)。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 40.最小的k个数</title>
    <url>/2020/10/07/%E5%89%91%E6%8C%87Offer40.%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof">https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof</a></p>
<p><strong>暴力法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(arr, <span class="number">0</span>, k);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(nlogn)，其中 n 是数组 arr 的长度。算法的时间复杂度即排序的时间复杂度。</li>
<li>空间复杂度：O(logn)，排序所需额外的空间复杂度为 O(logn)。</li>
</ul>
<p><strong>小顶堆</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span> || arr.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125; </span><br><span class="line">        Queue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;((v1, v2) -&gt; v2 - v1);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a : arr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pq.size() &lt; k)&#123;</span><br><span class="line">                pq.offer(a);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a &lt; pq.peek())&#123;</span><br><span class="line">                pq.poll();</span><br><span class="line">                pq.offer(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p : pq)&#123;</span><br><span class="line">            res[idx++] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(nlogk)，其中 n 是数组 arr 的长度。由于大根堆实时维护前 k 小值，所以插入删除都是 O(logk) 的时间复杂度，最坏情况下数组里 n 个数都会插入，所以一共需要 O(nlogk) 的时间复杂度。</p>
</li>
<li><p>空间复杂度：O(k)，因为大根堆里最多 k 个数。</p>
</li>
</ul>
<p><strong>快速排序</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li><p>时间复杂度 </p>
</li>
<li><p>空间复杂度</p>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>堆</tag>
        <tag>快速排序</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 45. 把数组排成最小的数</title>
    <url>/2020/10/08/%E5%89%91%E6%8C%87Offer45.%E6%8A%8A%E6%95%B0%E7%BB%84%E7%BB%84%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof">https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        String[] str = <span class="keyword">new</span> String[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            str[i] = String.valueOf(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(str, (x, y) -&gt; (x + y).compareTo(y + x));</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(String s : str)&#123;</span><br><span class="line">            res.append(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度 O(NlogN) ： N 为最终返回值的字符数量（strs 列表的长度≤N）；使用快排或内置函数的平均时间复杂度为 O(NlogN) ，最差为 O(N^2) 。</li>
<li>空间复杂度 O(N) ： 字符串列表 strs 占用线性大小的额外空间。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>0048.旋转图像</title>
    <url>/2020/10/08/0048.%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/rotate-image">https://leetcode-cn.com/problems/rotate-image</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (n + <span class="number">1</span>)/ <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n / <span class="number">2</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[n - j - <span class="number">1</span>][i];</span><br><span class="line">                matrix[n - j - <span class="number">1</span>][i] = matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>];</span><br><span class="line">                matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>] = matrix[j][n - i - <span class="number">1</span>];</span><br><span class="line">                matrix[j][n - i - <span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(N^2) 是两重循环的复杂度。</li>
<li>空间复杂度：O(1) 由于旋转操作是 <em>就地</em> 完成的。</li>
</ul>
<p><strong>转置加翻转</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = matrix.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// transpose matrix</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = matrix[j][i];</span><br><span class="line">        matrix[j][i] = matrix[i][j];</span><br><span class="line">        matrix[i][j] = tmp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// reverse each row</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n / <span class="number">2</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = matrix[i][j];</span><br><span class="line">        matrix[i][j] = matrix[i][n - j - <span class="number">1</span>];</span><br><span class="line">        matrix[i][n - j - <span class="number">1</span>] = tmp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(N^2).</li>
<li>空间复杂度：O(1) 由于旋转操作是 <em>就地</em> 完成的。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>0283.移动零</title>
    <url>/2020/10/08/0283.%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/move-zeroes">https://leetcode-cn.com/problems/move-zeroes</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                nums[count++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = count; i &lt;= n; i++)&#123;</span><br><span class="line">            nums[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(n)。</p>
</li>
<li><p>空间复杂度：O(1)。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>0529.扫雷游戏</title>
    <url>/2020/10/08/0529.%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/minesweeper/">https://leetcode-cn.com/problems/minesweeper/</a></p>
<p><strong>dfs</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dirX = &#123;-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] dirY = &#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span>[][] updateBoard(<span class="keyword">char</span>[][] board, <span class="keyword">int</span>[] click) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = click[<span class="number">0</span>], y = click[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(board[x][y] == <span class="string">&#x27;M&#x27;</span>)&#123;</span><br><span class="line">            board[x][y] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dfs(board, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> board;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tx = x + dirX[i];</span><br><span class="line">            <span class="keyword">int</span> ty = y + dirY[i];</span><br><span class="line">            <span class="keyword">if</span>(tx &lt; <span class="number">0</span> || tx &gt;= board.length || ty &lt; <span class="number">0</span> || ty &gt;= board[<span class="number">0</span>].length)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(board[tx][ty] == <span class="string">&#x27;M&#x27;</span>)&#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            board[x][y] = (<span class="keyword">char</span>)(cnt + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            board[x][y] = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tx = x + dirX[i];</span><br><span class="line">                <span class="keyword">int</span> ty = y + dirY[i];</span><br><span class="line">                <span class="keyword">if</span>(tx &lt; <span class="number">0</span> || tx &gt;= board.length || ty &lt; <span class="number">0</span> || ty &gt;= board[<span class="number">0</span>].length || board[tx][ty] != <span class="string">&#x27;E&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dfs(board, tx, ty);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(nm)，其中 n 和 m 分别代表面板的宽和高。最坏情况下会遍历整个面板。</li>
<li>空间复杂度：O(nm)。空间复杂度取决于递归的栈深度，而递归栈深度在最坏情况下有可能遍历整个面板而达到 O(nm)。</li>
</ul>
<p><strong>bfs</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dirX = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] dirY = &#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span>[][] updateBoard(<span class="keyword">char</span>[][] board, <span class="keyword">int</span>[] click) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = click[<span class="number">0</span>], y = click[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (board[x][y] == <span class="string">&#x27;M&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 规则 1</span></span><br><span class="line">            board[x][y] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            bfs(board, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> board;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> sx, <span class="keyword">int</span> sy)</span> </span>&#123;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">boolean</span>[][] vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[board.length][board[<span class="number">0</span>].length];</span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;sx, sy&#125;);</span><br><span class="line">        vis[sx][sy] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] pos = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>, x = pos[<span class="number">0</span>], y = pos[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> tx = x + dirX[i];</span><br><span class="line">                <span class="keyword">int</span> ty = y + dirY[i];</span><br><span class="line">                <span class="keyword">if</span> (tx &lt; <span class="number">0</span> || tx &gt;= board.length || ty &lt; <span class="number">0</span> || ty &gt;= board[<span class="number">0</span>].length) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 不用判断 M，因为如果有 M 的话游戏已经结束了</span></span><br><span class="line">                <span class="keyword">if</span> (board[tx][ty] == <span class="string">&#x27;M&#x27;</span>) &#123;</span><br><span class="line">                    ++cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 规则 3</span></span><br><span class="line">                board[x][y] = (<span class="keyword">char</span>) (cnt + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 规则 2</span></span><br><span class="line">                board[x][y] = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tx = x + dirX[i];</span><br><span class="line">                    <span class="keyword">int</span> ty = y + dirY[i];</span><br><span class="line">                    <span class="comment">// 这里不需要在存在 B 的时候继续扩展，因为 B 之前被点击的时候已经被扩展过了</span></span><br><span class="line">                    <span class="keyword">if</span> (tx &lt; <span class="number">0</span> || tx &gt;= board.length || ty &lt; <span class="number">0</span> || ty &gt;= board[<span class="number">0</span>].length || board[tx][ty] != <span class="string">&#x27;E&#x27;</span> || vis[tx][ty]) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;tx, ty&#125;);</span><br><span class="line">                    vis[tx][ty] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>0461.汉明距离</title>
    <url>/2020/10/06/0461.%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/hamming-distance">https://leetcode-cn.com/problems/hamming-distance</a></p>
<p><strong>位移</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> xor = x ^ y;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(xor != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(xor % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">                ++count;</span><br><span class="line">            xor &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(1)，在 Python 和 Java 中 Integer 的大小是固定的，处理时间也是固定的。 32 位整数需要 32 次迭代。</li>
<li>空间复杂度：O(1)，使用恒定大小的空间。</li>
</ul>
<p><strong>Brian Kernighan 算法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> xor = x ^ y;</span><br><span class="line">    <span class="keyword">int</span> distance = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (xor != <span class="number">0</span>) &#123;</span><br><span class="line">      distance += <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// remove the rightmost bit of &#x27;1&#x27;</span></span><br><span class="line">      xor = xor &amp; (xor - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> distance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(1)。</li>
<li>空间复杂度：O(1)。我们只需要常数空间存放若干变量。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>0547.朋友圈</title>
    <url>/2020/10/08/0547.%E6%9C%8B%E5%8F%8B%E5%9C%88/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/friend-circles/">https://leetcode-cn.com/problems/friend-circles/</a></p>
<p><strong>dfs</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[M.length];</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">                dfs(M, visited, i);   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] M, <span class="keyword">int</span>[] visited, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M.length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(M[i][j] == <span class="number">1</span> &amp;&amp; visited[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                visited[j] = <span class="number">1</span>;</span><br><span class="line">                dfs(M, visited, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(N^2)。</p>
</li>
<li><p>空间复杂度：O(N)。</p>
</li>
</ul>
<p><strong>bfs</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[M.length];</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                queue.add(i);</span><br><span class="line">                <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">                    <span class="keyword">int</span> t = queue.remove();</span><br><span class="line">                    visited[t] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M.length; j++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(M[t][j] == <span class="number">1</span> &amp;&amp; visited[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                            queue.add(j);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自己仿照 <a href="https://xray1025.top/2020/09/18/0200.%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/">#200.岛屿数量</a> 写的特别慢</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(M == <span class="keyword">null</span> || M.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> r = M.length;</span><br><span class="line">        <span class="keyword">int</span> c = M[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(M[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    ++cnt;</span><br><span class="line">                    dfs(M, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] M, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(M[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                M[i][j] = <span class="number">0</span>;</span><br><span class="line">                dfs(M, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>0872.叶子相似的树</title>
    <url>/2020/10/08/0872.%E5%8F%B6%E5%AD%90%E7%9B%B8%E4%BC%BC%E7%9A%84%E6%A0%91/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/leaf-similar-trees/">https://leetcode-cn.com/problems/leaf-similar-trees/</a></p>
<p><strong>dfs</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">leafSimilar</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; leaves1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; leaves2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root1, leaves1);</span><br><span class="line">        dfs(root2, leaves2);</span><br><span class="line">        <span class="keyword">return</span> leaves1.equals(leaves2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode node, List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                list.add(node.val);</span><br><span class="line">            &#125;</span><br><span class="line">            dfs(node.left, list);</span><br><span class="line">            dfs(node.right, list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(T1 + T2)，其中 T1, T2 是给定的树的长度。</li>
<li>空间复杂度：O(T1 + T2)，存储叶值所使用的空间。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>0141.环形链表</title>
    <url>/2020/10/09/0141.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/linked-list-cycle/">https://leetcode-cn.com/problems/linked-list-cycle/</a></p>
<p><strong>HashSet</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Set&lt;ListNode&gt; nodeSeen = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nodeSeen.contains(head))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nodeSeen.add(head);</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度： O(n) 。</li>
<li>空间复杂度： O(n) 。</li>
</ul>
<p><strong>双指针</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head.next;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度： O(n) 。</li>
<li>空间复杂度： O(1) 。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>0142.环形链表2</title>
    <url>/2020/10/09/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A82/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">https://leetcode-cn.com/problems/linked-list-cycle-ii/</a></p>
<p><strong>HashSet</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        ListNode node = head;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(node))&#123;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                set.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度： O(n) 。</li>
<li>空间复杂度： O(n) 。</li>
</ul>
<p><strong>双指针</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度： O(n) 。</li>
<li>空间复杂度： O(1) 。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>0217.存在重复元素</title>
    <url>/2020/10/12/0217.%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/contains-duplicate/">https://leetcode-cn.com/problems/contains-duplicate/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(num))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(n)。</p>
</li>
<li><p>空间复杂度：O(n)。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>ArrayList</tag>
        <tag>HashSet</tag>
      </tags>
  </entry>
  <entry>
    <title>0219.存在重复元素2</title>
    <url>/2020/10/12/0219.%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A02/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/contains-duplicate-ii/">https://leetcode-cn.com/problems/contains-duplicate-ii/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(nums[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">            <span class="keyword">if</span>(map.size() &gt; k)&#123;</span><br><span class="line">                map.remove(nums[i - k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(nlog(min(n,k)))，我们需要遍历这个 n 长度的数组。对于每次遍历，在 BST 中 搜索，插入 或者 删除 都需要花费 O(logmin(k,n)) 的时间。</li>
<li>空间复杂度：O(min(n,k))，空间复杂度由 BST 的大小决定，其大小的上限由 k 和 n 共同决定。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>HashMap</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>0220.存在重复元素3</title>
    <url>/2020/10/12/0220.%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A03/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/contains-duplicate-iii/">https://leetcode-cn.com/problems/contains-duplicate-iii/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        TreeSet&lt;Long&gt; treeSet = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            Long c = treeSet.ceiling((<span class="keyword">long</span>)nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(c != <span class="keyword">null</span> &amp;&amp; c &lt;= nums[i] + t)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Long f = treeSet.floor((<span class="keyword">long</span>)nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(f != <span class="keyword">null</span> &amp;&amp; nums[i] &lt;= f + t)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            treeSet.add((<span class="keyword">long</span>)nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(treeSet.size() &gt; k)&#123;</span><br><span class="line">                treeSet.remove((<span class="keyword">long</span>)nums[i - k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(nlog(min(n,k)))，我们需要遍历这个 n 长度的数组。对于每次遍历，在 BST 中 搜索，插入或者删除都需要花O(logmin(k,n)) 的时间。</li>
<li>空间复杂度：O(min(n,k))，空间复杂度由 BST 的大小决定，其大小的上限由 k 和 n 共同决定。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>ArrayList</tag>
        <tag>TreeSet</tag>
      </tags>
  </entry>
  <entry>
    <title>0530.二叉搜索树的最小绝对差</title>
    <url>/2020/10/12/0530.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/">https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pre;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ans = Integer.MAX_VALUE;</span><br><span class="line">        pre = -<span class="number">1</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(node.left);</span><br><span class="line">        <span class="keyword">if</span>(pre == -<span class="number">1</span>)&#123;</span><br><span class="line">            pre = node.val;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans = Math.min(ans, node.val - pre);</span><br><span class="line">            pre = node.val;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</li>
<li>空间复杂度：O(n)。空间复杂度取决于递归的栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis</title>
    <url>/2020/10/15/0000.Mybatis/</url>
    <content><![CDATA[<h1 id="Mybatis面试题"><a href="#Mybatis面试题" class="headerlink" title="Mybatis面试题"></a>Mybatis面试题</h1><h1 id="1、-和-的区别是什么？"><a href="#1、-和-的区别是什么？" class="headerlink" title="1、#{}和${}的区别是什么？"></a>1、#{}和${}的区别是什么？</h1><ul>
<li><code>$&#123;&#125;</code>是 Properties 文件中的变量占位符，它可以用于标签属性值和 sql 内部，属于静态文本替换，比如${driver}会被静态替换为<code>com.mysql.jdbc.Driver</code>。</li>
<li><code>#&#123;&#125;</code>是 sql 的参数占位符，Mybatis 会将 sql 中的<code>#&#123;&#125;</code>替换为?号，在 sql 执行前会使用 PreparedStatement 的参数设置方法，按序给 sql 的?号占位符设置参数值，比如 ps.setInt(0, parameterValue)，<code>#&#123;item.name&#125;</code> 的取值方式为使用反射从参数对象中获取 item 对象的 name 属性值，相当于 <code>param.getItem().getName()</code>。</li>
</ul>
<h1 id="2、Xml-映射文件中，除了常见的-select-insert-updae-delete-标签之外，还有哪些标签？"><a href="#2、Xml-映射文件中，除了常见的-select-insert-updae-delete-标签之外，还有哪些标签？" class="headerlink" title="2、Xml 映射文件中，除了常见的 select|insert|updae|delete 标签之外，还有哪些标签？"></a>2、Xml 映射文件中，除了常见的 select|insert|updae|delete 标签之外，还有哪些标签？</h1><p>还有很多其他的标签，<code>&lt;resultMap&gt;</code>、<code>&lt;parameterMap&gt;</code>、<code>&lt;sql&gt;</code>、<code>&lt;include&gt;</code>、<code>&lt;selectKey&gt;</code>，加上动态 sql 的 9 个标签，<code>trim|where|set|foreach|if|choose|when|otherwise|bind</code>等，其中为 sql 片段标签，通过<code>&lt;include&gt;</code>标签引入 sql 片段，<code>&lt;selectKey&gt;</code>为不支持自增的主键生成策略标签。</p>
<h1 id="3、通常一个-Xml-映射文件，都会写一个-Dao-接口与之对应，请问，这个-Dao-接口的工作原理是什么？Dao-接口里的方法，参数不同时，方法能重载吗？"><a href="#3、通常一个-Xml-映射文件，都会写一个-Dao-接口与之对应，请问，这个-Dao-接口的工作原理是什么？Dao-接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="3、通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？"></a>3、通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？</h1><p>Dao 接口，就是人们常说的 <code>Mapper</code>接口，接口的全限名，就是映射文件中的 namespace 的值，接口的方法名，就是映射文件中<code>MappedStatement</code>的 id 值，接口方法内的参数，就是传递给 sql 的参数。<code>Mapper</code>接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个<code>MappedStatement</code>，举例：<code>com.mybatis3.mappers.StudentDao.findStudentById</code>，可以唯一找到 namespace 为<code>com.mybatis3.mappers.StudentDao</code>下面<code>id = findStudentById</code>的<code>MappedStatement</code>。在 Mybatis 中，每一个<code>&lt;select&gt;</code>、<code>&lt;insert&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;delete&gt;</code>标签，都会被解析为一个<code>MappedStatement</code>对象。</p>
<p>Dao 接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</p>
<p>Dao 接口的工作原理是 JDK 动态代理，Mybatis 运行时会使用 JDK 动态代理为 Dao 接口生成代理 proxy 对象，代理对象 proxy 会拦截接口方法，转而执行<code>MappedStatement</code>所代表的 sql，然后将 sql 执行结果返回。</p>
<h1 id="4、Mybatis-是如何进行分页的？分页插件的原理是什么？"><a href="#4、Mybatis-是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="4、Mybatis 是如何进行分页的？分页插件的原理是什么？"></a>4、Mybatis 是如何进行分页的？分页插件的原理是什么？</h1><p>Mybatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页，而非物理分页，可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p>
<p>分页插件的基本原理是使用 Mybatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。</p>
<p>举例：<code>select _ from student</code>，拦截 sql 后重写为：<code>select t._ from （select \* from student）t limit 0，10</code></p>
<h1 id="5、简述-Mybatis-的插件运行原理，以及如何编写一个插件。"><a href="#5、简述-Mybatis-的插件运行原理，以及如何编写一个插件。" class="headerlink" title="5、简述 Mybatis 的插件运行原理，以及如何编写一个插件。"></a>5、简述 Mybatis 的插件运行原理，以及如何编写一个插件。</h1><p>Mybatis 仅可以编写针对 <code>ParameterHandler</code>、<code>ResultSetHandler</code>、<code>StatementHandler</code>、<code>Executor</code> 这 4 种接口的插件，Mybatis 使用 JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 <code>InvocationHandler</code> 的 <code>invoke()</code>方法，当然，只会拦截那些指定需要拦截的方法。</p>
<p>实现 Mybatis 的 Interceptor 接口并复写<code>intercept()</code>方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，在配置文件中配置编写的插件。</p>
<h1 id="6、Mybatis-执行批量插入，能返回数据库主键列表吗？"><a href="#6、Mybatis-执行批量插入，能返回数据库主键列表吗？" class="headerlink" title="6、Mybatis 执行批量插入，能返回数据库主键列表吗？"></a>6、Mybatis 执行批量插入，能返回数据库主键列表吗？</h1><p>能，JDBC 都能，Mybatis 当然也能。</p>
<h1 id="7、Mybatis-动态-sql-是做什么的？都有哪些动态-sql？能简述一下动态-sql-的执行原理不？"><a href="#7、Mybatis-动态-sql-是做什么的？都有哪些动态-sql？能简述一下动态-sql-的执行原理不？" class="headerlink" title="7、Mybatis 动态 sql 是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？"></a>7、Mybatis 动态 sql 是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？</h1><p>Mybatis 动态 sql 可以在 Xml 映射文件内，以标签的形式编写动态 sql，完成逻辑判断和动态拼接 sql 的功能，Mybatis 提供了 9 种动态 sql 标签 <code>trim|where|set|foreach|if|choose|when|otherwise|bind</code>。</p>
<p>其执行原理为，使用 OGNL 从 sql 参数对象中计算表达式的值，根据表达式的值动态拼接 sql，以此来完成动态 sql 的功能。</p>
<h1 id="8、Mybatis-是如何将-sql-执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#8、Mybatis-是如何将-sql-执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="8、Mybatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>8、Mybatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？</h1><p>第一种是使用<code>&lt;resultMap&gt;</code>标签，逐一定义列名和对象属性名之间的映射关系。第二种是使用 sql 列的别名功能，将列别名书写为对象属性名，比如 T_NAME AS NAME，对象属性名一般是 name，小写，但是列名不区分大小写，Mybatis 会忽略列名大小写，智能找到与之对应对象属性名，甚至可以写成 T_NAME AS NaMe，Mybatis 一样可以正常工作。</p>
<p>有了列名与属性名的映射关系后，Mybatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p>
<h1 id="9、Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#9、Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="9、Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？"></a>9、Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？</h1><p>Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载，association 指的就是一对一，collection 指的就是一对多查询。在 Mybatis 配置文件中，可以配置是否启用延迟加载 <code>lazyLoadingEnabled=true|false。</code></p>
<p>它的原理是，使用<code>CGLIB</code> 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 <code>a.getB().getName()</code>，拦截器 <code>invoke()</code>方法发现 <code>a.getB()</code>是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 <code>a.getB().getName()</code>方法的调用。这就是延迟加载的基本原理。</p>
<p>当然了，不光是 Mybatis，几乎所有的包括 Hibernate，支持延迟加载的原理都是一样的。</p>
<h1 id="10、Mybatis-的-Xml-映射文件中，不同的-Xml-映射文件，id-是否可以重复？"><a href="#10、Mybatis-的-Xml-映射文件中，不同的-Xml-映射文件，id-是否可以重复？" class="headerlink" title="10、Mybatis 的 Xml 映射文件中，不同的 Xml 映射文件，id 是否可以重复？"></a>10、Mybatis 的 Xml 映射文件中，不同的 Xml 映射文件，id 是否可以重复？</h1><p>不同的 Xml 映射文件，如果配置了 namespace，那么 id 可以重复；如果没有配置 namespace，那么 id 不能重复；毕竟 namespace 不是必须的，只是最佳实践而已。</p>
<p>原因就是 namespace+id 是作为 <code>Map&lt;String, MappedStatement&gt;</code>的 key 使用的，如果没有 namespace，就剩下 id，那么，id 重复会导致数据互相覆盖。有了 namespace，自然 id 就可以重复，namespace 不同，namespace+id 自然也就不同。</p>
<h1 id="11、Mybatis-中如何执行批处理？"><a href="#11、Mybatis-中如何执行批处理？" class="headerlink" title="11、Mybatis 中如何执行批处理？"></a>11、Mybatis 中如何执行批处理？</h1><p>使用 BatchExecutor 完成批处理。</p>
<h1 id="12、Mybatis-都有哪些-Executor-执行器？它们之间的区别是什么？"><a href="#12、Mybatis-都有哪些-Executor-执行器？它们之间的区别是什么？" class="headerlink" title="12、Mybatis 都有哪些 Executor 执行器？它们之间的区别是什么？"></a>12、Mybatis 都有哪些 Executor 执行器？它们之间的区别是什么？</h1><p>Mybatis 有三种基本的 Executor 执行器，**<code>SimpleExecutor</code>、<code>ReuseExecutor</code>、<code>BatchExecutor</code>。**</p>
<p><strong><code>SimpleExecutor</code>：</strong>每执行一次 update 或 select，就开启一个 Statement 对象，用完立刻关闭 Statement 对象。</p>
<p><strong><code>ReuseExecutor</code>：</strong>执行 update 或 select，以 sql 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后，不关闭 Statement 对象，而是放置于 Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用 Statement 对象。</p>
<p><strong><code>BatchExecutor</code>：</strong>执行 update（没有 select，JDBC 批处理不支持 select），将所有 sql 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理。与 JDBC 批处理相同。</p>
<p>作用范围：Executor 的这些特点，都严格限制在 SqlSession 生命周期范围内。</p>
<h1 id="13、Mybatis-中如何指定使用哪一种-Executor-执行器？"><a href="#13、Mybatis-中如何指定使用哪一种-Executor-执行器？" class="headerlink" title="13、Mybatis 中如何指定使用哪一种 Executor 执行器？"></a>13、Mybatis 中如何指定使用哪一种 Executor 执行器？</h1><p>在 Mybatis 配置文件中，可以指定默认的 ExecutorType 执行器类型，也可以手动给 <code>DefaultSqlSessionFactory</code> 的创建 SqlSession 的方法传递 ExecutorType 类型参数。</p>
<h1 id="14、Mybatis-是否可以映射-Enum-枚举类？"><a href="#14、Mybatis-是否可以映射-Enum-枚举类？" class="headerlink" title="14、Mybatis 是否可以映射 Enum 枚举类？"></a>14、Mybatis 是否可以映射 Enum 枚举类？</h1><p>Mybatis 可以映射枚举类，不单可以映射枚举类，Mybatis 可以映射任何对象到表的一列上。映射方式为自定义一个 <code>TypeHandler</code>，实现 <code>TypeHandler</code> 的 <code>setParameter()</code>和 <code>getResult()</code>接口方法。<code>TypeHandler</code> 有两个作用，一是完成从 javaType 至 jdbcType 的转换，二是完成 jdbcType 至 javaType 的转换，体现为 <code>setParameter()</code>和 <code>getResult()</code>两个方法，分别代表设置 sql 问号占位符参数和获取列查询结果。</p>
<h1 id="15、Mybatis-映射文件中，如果-A-标签通过-include-引用了-B-标签的内容，请问，B-标签能否定义在-A-标签的后面，还是说必须定义在-A-标签的前面？"><a href="#15、Mybatis-映射文件中，如果-A-标签通过-include-引用了-B-标签的内容，请问，B-标签能否定义在-A-标签的后面，还是说必须定义在-A-标签的前面？" class="headerlink" title="15、Mybatis 映射文件中，如果 A 标签通过 include 引用了 B 标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在 A 标签的前面？"></a>15、Mybatis 映射文件中，如果 A 标签通过 include 引用了 B 标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在 A 标签的前面？</h1><p>虽然 Mybatis 解析 Xml 映射文件是按照顺序解析的，但是，被引用的 B 标签依然可以定义在任何地方，Mybatis 都可以正确识别。</p>
<p>原理是，Mybatis 解析 A 标签，发现 A 标签引用了 B 标签，但是 B 标签尚未解析到，尚不存在，此时，Mybatis 会将 A 标签标记为未解析状态，然后继续解析余下的标签，包含 B 标签，待所有标签解析完毕，Mybatis 会重新解析那些被标记为未解析的标签，此时再解析 A 标签时，B 标签已经存在，A 标签也就可以正常解析完成了。</p>
<h1 id="16、简述-Mybatis-的-Xml-映射文件和-Mybatis-内部数据结构之间的映射关系？"><a href="#16、简述-Mybatis-的-Xml-映射文件和-Mybatis-内部数据结构之间的映射关系？" class="headerlink" title="16、简述 Mybatis 的 Xml 映射文件和 Mybatis 内部数据结构之间的映射关系？"></a>16、简述 Mybatis 的 Xml 映射文件和 Mybatis 内部数据结构之间的映射关系？</h1><p>Mybatis 将所有 Xml 配置信息都封装到 All-In-One 重量级对象 Configuration 内部。在 Xml 映射文件中，<code>&lt;parameterMap&gt;</code>标签会被解析为 <code>ParameterMap</code> 对象，其每个子元素会被解析为 ParameterMapping 对象。<code>&lt;resultMap&gt;</code>标签会被解析为 <code>ResultMap</code> 对象，其每个子元素会被解析为 <code>ResultMapping</code> 对象。每一个<code>&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;</code>标签均会被解析为 <code>MappedStatement</code> 对象，标签内的 sql 会被解析为 BoundSql 对象。</p>
<h1 id="17、为什么说-Mybatis-是半自动-ORM-映射工具？它与全自动的区别在哪里？"><a href="#17、为什么说-Mybatis-是半自动-ORM-映射工具？它与全自动的区别在哪里？" class="headerlink" title="17、为什么说 Mybatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？"></a>17、为什么说 Mybatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？</h1><p>Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而 Mybatis 在查询关联对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自动 ORM 映射工具。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Mynatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/2020/10/15/0000.Redis/</url>
    <content><![CDATA[<h1 id="Redis面试题"><a href="#Redis面试题" class="headerlink" title="Redis面试题"></a>Redis面试题</h1><h1 id="1、Redis支持的数据类型？"><a href="#1、Redis支持的数据类型？" class="headerlink" title="1、Redis支持的数据类型？"></a>1、Redis支持的数据类型？</h1><h2 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h2><p>格式: <code>set key value</code></p>
<p>string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。</p>
<p>string类型是Redis最基本的数据类型，一个键最大能存储512MB。</p>
<h2 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h2><p>格式: <code>hmset name key1 value1 key2 value2</code></p>
<p>Redis hash 是一个键值(key=&gt;value)对集合。</p>
<p>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p>
<h2 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h2><p>Redis 列表是简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部（左边）或者尾部（右边）</p>
<p>格式: <code>lpush name value</code></p>
<p>在 key 对应 list 的头部添加字符串元素</p>
<p>格式: <code>rpush name value</code></p>
<p>在 key 对应 list 的尾部添加字符串元素</p>
<p>格式: <code>lrem name index</code></p>
<p>key 对应 list 中删除 count 个和 value 相同的元素</p>
<p>格式: <code>llen name</code></p>
<p>返回 key 对应 list 的长度</p>
<h2 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h2><p>格式: <code>sadd name value</code></p>
<p>Redis的Set是string类型的无序集合。</p>
<p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p>
<h2 id="zset-sorted-set：有序集合"><a href="#zset-sorted-set：有序集合" class="headerlink" title="zset(sorted set：有序集合)"></a>zset(sorted set：有序集合)</h2><p>格式: <code>zadd name score value</code></p>
<p>Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。</p>
<p>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p>
<p>zset的成员是唯一的,但分数(score)却可以重复。</p>
<h2 id="Redis-优点"><a href="#Redis-优点" class="headerlink" title="Redis 优点"></a>Redis 优点</h2><ol>
<li><p>速度快：数据存在内存中，不像MySQL那样需要从外存中进行IO操作</p>
</li>
<li><p>支持的数据类型很多，单个value 的最大限制为 1 GB</p>
</li>
<li><p>持久化的存储：RDB 和 AOF</p>
</li>
<li><p>支持高可用：</p>
</li>
<li><ol>
<li>①Redis Sentinel，提供高可用方案，实现主从故障的自动转移；<ol start="2">
<li>②Redis Cluster，提供集群方案，实现基于槽的分片方案，支持更大的 Redis 规模</li>
</ol>
</li>
</ol>
</li>
<li><p>丰富的特性：</p>
</li>
<li><ol>
<li>①订阅发布功能 pub/sub<ol start="2">
<li>②Key的过期策略</li>
<li>③事务</li>
<li>④支持多个 DB</li>
<li>⑤计数</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="Redis-缺点"><a href="#Redis-缺点" class="headerlink" title="Redis 缺点"></a>Redis 缺点</h2><ol>
<li>Redis 是内存数据库，存储的数据量容易收到机器内存大小的限制</li>
<li>如果进行完整重同步，由于需要生成 RDB 文件并传输，会占用主机的 CPU。Redis 2.8中，已经有了部分重同步功能，但还是有可能出现完整重同步的（新上线的备机）</li>
<li>修改配置文件，进行重启，将硬盘中的数据加载进内存，时间比较久。在这个过程中，Redis 不能提供服务</li>
</ol>
<h2 id="（X）跳表的实现"><a href="#（X）跳表的实现" class="headerlink" title="（X）跳表的实现"></a>（X）跳表的实现</h2><blockquote>
<p>在<strong>有序双向链表（从小到大排列）</strong>的基础上，增加了多层索引链表。在查找时，就可以在不同索引链表间跳跃，达到快速查询的目的。</p>
</blockquote>
<ul>
<li>查询</li>
</ul>
<p>从最高层（设定的Max_level）第一个元素开始向右遍历</p>
<p>找到最后一个小于目标节点值的节点，向下层移动</p>
<p>重复这个步骤，直到找到相应的节点为止。 （途中经过的一系列节点称之为搜索路径）</p>
<ul>
<li>随机层数</li>
</ul>
<p>跳跃表会记录当前的最高层数maxLevel，遍历时从maxLevel开始遍历，性能会高很多</p>
<ul>
<li><p>插入</p>
</li>
<li><ul>
<li>在搜索插入点的过程中，将搜索路径找出来，然后创建一个新节点（分配一个层数）<ul>
<li>将搜索路径上的节点和新节点通过前向后向指针连接起来。</li>
<li>如果新节点的高度h高于maxLevel，就更新maxLevel</li>
</ul>
</li>
</ul>
</li>
<li><p>删除</p>
</li>
<li><ul>
<li>先找到搜索路径，删除节点<ul>
<li>对于每层的相关节点，重排一下前向后向的指针</li>
<li>更新maxLevel</li>
</ul>
</li>
</ul>
</li>
<li><p>更新</p>
</li>
<li><ul>
<li>先删除节点<ul>
<li>再插入节点</li>
<li>不判断位置是否需要调整</li>
</ul>
</li>
</ul>
</li>
<li><p>若Score一样，怎么办</p>
</li>
<li><ul>
<li>比较value</li>
</ul>
</li>
<li><p>元素排名的计算</p>
</li>
<li><ul>
<li>每个forward指针有一个跨度属性：表示前一个节点通过forward指针跳到当前节点，中间经过多少节点。<ul>
<li>计算元素排名时，将 搜索路径 所有节点的跨度相加，就可以得出最终的rank值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="为什么用跳表而不是平衡树"><a href="#为什么用跳表而不是平衡树" class="headerlink" title="为什么用跳表而不是平衡树"></a>为什么用跳表而不是平衡树</h2><ul>
<li><p>范围查找时，平衡树比跳表复杂。</p>
</li>
<li><ul>
<li>在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。<ul>
<li>而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。</li>
</ul>
</li>
</ul>
</li>
<li><p>插入调整问题：</p>
</li>
<li><ul>
<li>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂<ul>
<li>而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="2、什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？"><a href="#2、什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？" class="headerlink" title="2、什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？"></a>2、什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？</h1><h2 id="Redis-的持久化方式"><a href="#Redis-的持久化方式" class="headerlink" title="Redis 的持久化方式"></a>Redis 的持久化方式</h2><ul>
<li><p>【全量】RDB 持久化：在指定的时间间隔内将内存中的数据集快照写入磁盘。</p>
</li>
<li><ul>
<li>实际操作过程：fork 一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储</li>
</ul>
</li>
<li><p>【增量】AOF 持久化：以日志的形式记录每一个 写、删、改操作（不记录查询操作）。以文本的形式记录，可以打开文件看到详细的操作记录</p>
</li>
</ul>
<h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>【优点】</p>
<ul>
<li>备份的频率、周期可以灵活的设置</li>
<li>非常适合冷备份，可以将一个单独的文件压缩后转移到其它存储介质上</li>
<li>性能最大话：开始持久化时，Redis 服务进程只需 fork 出子进程，之后再由子进程完成这些持久化的工作，这样避免了服务器进程执行 IO 操作</li>
<li>恢复速度快：相对于 AOF 机制，RDB 的恢复速度更快，更适合恢复数据，特别时数据集非常大的情况下</li>
</ul>
<p>【缺点】</p>
<ul>
<li>若系统未在持久化之前出现宕机，从宕机到上一次备份后的数据全部丢失</li>
<li>RDB 通过fork 子进程来协助完成数据持久化的操作，因此，数据集较大时，可能会导致服务器停止服务几百毫秒（建议在业务低估，即半夜时执行）</li>
</ul>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>【优点】</p>
<ol>
<li>相比于 RDB ，有更高的数据安全性。提供了3中同步策略，每秒同步，每修改(执行一个命令)同步、不同步</li>
</ol>
<ul>
<li><ul>
<li>每秒同步：每秒进行一次同步，是异步完成的，效率很高，系统一旦出现宕机，一秒内的数据就会将会丢失<ul>
<li>每修改同步：可以视为同步持久化，每次发生数据变化都会被立即记录到磁盘中，效率最低</li>
<li>不同步：</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li>该机制对日志文件的写入操作是append模式，因此在写入过程中即使发生宕机，也不会破坏日志文件已经存在的内容</li>
</ol>
<ul>
<li><ul>
<li>使用 append-only 模式写入，没有任何磁盘寻址开销，写入性能高<ul>
<li>如果写入一半数据系统崩溃，在 Redis 下一次启动前，可以通过 redis-check-aof 工具来帮助我们解决数据一致性问题</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li>如果 AOF 文件过大，可以使用 rewrite 机制，</li>
<li>AOF 日志文件记录了所有的修改操作。可以修改这个文件完成数据的重建</li>
</ol>
<p>【缺点】</p>
<ol>
<li>相同数量的数据集，AOF 文件比 RDB 文件大；恢复时速度比 RDB 慢</li>
<li>AOF 在运行效率上往往会慢于 RDB。总之，每秒的同步策略比较高，同步禁用策略的效率和 RDB 一样高</li>
</ol>
<h2 id="持久化方式如何选择"><a href="#持久化方式如何选择" class="headerlink" title="持久化方式如何选择"></a>持久化方式如何选择</h2><ul>
<li>仅使用 RDB：万一服务器宕机，会丢失很多数据</li>
<li>仅使用 AOF：恢复速度很慢</li>
<li>RDB-AOF混合方案：bgsave 做全量持久化，AOF 做增量持久化。Redis 实例重启时，会使用 bgsave 重新构建内存，再使用 AOF 读取最近使用的指令，使 Redis 恢复到重启之前的状态</li>
</ul>
<h2 id="突然掉电怎么办"><a href="#突然掉电怎么办" class="headerlink" title="突然掉电怎么办"></a>突然掉电怎么办</h2><p>取决于 AOF 的 sync 属性，如果每次写指令都同步，就不会丢失数据；如果每秒同步，最多就丢失1秒数据</p>
<h1 id="3、Redis-有哪些架构模式？讲讲各自的特点"><a href="#3、Redis-有哪些架构模式？讲讲各自的特点" class="headerlink" title="3、Redis 有哪些架构模式？讲讲各自的特点"></a>3、Redis 有哪些架构模式？讲讲各自的特点</h1><h2 id="单机版"><a href="#单机版" class="headerlink" title="单机版"></a>单机版</h2><ul>
<li><p>特点：</p>
<ul>
<li>简单</li>
</ul>
</li>
<li><p>问题：</p>
<ul>
<li>内存容量有限</li>
<li>处理能力有限</li>
<li>无法高可用。</li>
</ul>
</li>
</ul>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>Redis 的复制（replication）功能允许用户根据一个 Redis 服务器来创建任意多个该服务器的复制品，其中被复制的服务器为主服务器（master），而通过复制创建出来的服务器复制品则为从服务器（slave）。</p>
<p>只要主从服务器之间的网络连接正常，主从服务器两者会具有相同的数据，主服务器就会一直将发生在自己身上的数据更新同步 给从服务器，从而一直保证主从服务器的数据相同。</p>
<p>特点：</p>
<ul>
<li>master/slave 角色</li>
<li>master/slave 数据相同</li>
<li>降低 master 读压力在转交从库</li>
</ul>
<p>问题：</p>
<ul>
<li>无法保证高可用</li>
<li>没有解决 master 写的压力</li>
</ul>
<h2 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h2><p>Redis sentinel 是一个分布式系统中监控 redis 主从服务器，并在主服务器下线时自动进行故障转移。其中三个特性：</p>
<ul>
<li>监控（Monitoring）：Sentinel 会不断地检查主服务器和从服务器是否运作正常。</li>
<li>提醒（Notification）：当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</li>
<li>自动故障迁移（Automatic failover）：当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作。</li>
</ul>
<p>特点：</p>
<ul>
<li>保证高可用</li>
<li>监控各个节点</li>
<li>自动故障迁移</li>
</ul>
<p>缺点：</p>
<ul>
<li>主从模式，切换需要时间丢数据</li>
<li>没有解决 master 写的压力</li>
</ul>
<h2 id="集群（proxy-型）"><a href="#集群（proxy-型）" class="headerlink" title="集群（proxy 型）"></a>集群（proxy 型）</h2><p>Twemproxy 是一个 Twitter 开源的一个 redis 和 memcache 快速/轻量级代理服务器；Twemproxy 是一个快速的单线程代理程序，支持 Memcached ASCII 协议和 redis 协议。</p>
<p>特点：</p>
<ul>
<li>多种 hash 算法：MD5、CRC16、CRC32、CRC32a、hsieh、murmur、Jenkins</li>
<li>支持失败节点自动删除</li>
<li>后端 Sharding 分片逻辑对业务透明，业务方的读写方式和操作单个 Redis 一致</li>
</ul>
<p>缺点：</p>
<ul>
<li>增加了新的 proxy，需要维护其高可用。</li>
<li>failover 逻辑需要自己实现，其本身不能支持故障的自动转移可扩展性差，进行扩缩容都需要手动干预</li>
</ul>
<h2 id="集群（直连型）："><a href="#集群（直连型）：" class="headerlink" title="集群（直连型）："></a>集群（直连型）：</h2><p>从redis 3.0之后版本支持redis-cluster集群，Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。</p>
<p>特点：</p>
<ul>
<li>无中心架构（不存在哪个节点影响性能瓶颈），少了 proxy 层。</li>
<li>数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布。</li>
<li>可扩展性，可线性扩展到 1000 个节点，节点可动态添加或删除。</li>
<li>高可用性，部分节点不可用时，集群仍可用。通过增加 Slave 做备份数据副本<br>  -实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave到 Master 的角色提升。</li>
</ul>
<p>缺点：</p>
<ul>
<li>资源隔离性较差，容易出现相互影响的情况。</li>
<li>数据通过异步复制,不保证数据的强一致性</li>
</ul>
<h1 id="4、使用过Redis分布式锁么，它是怎么实现的？"><a href="#4、使用过Redis分布式锁么，它是怎么实现的？" class="headerlink" title="4、使用过Redis分布式锁么，它是怎么实现的？"></a>4、使用过Redis分布式锁么，它是怎么实现的？</h1><p>先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。</p>
<p>如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？</p>
<p>set指令有非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的！</p>
<h1 id="5、使用过Redis做异步队列么，怎么用的？有什么缺点？"><a href="#5、使用过Redis做异步队列么，怎么用的？有什么缺点？" class="headerlink" title="5、使用过Redis做异步队列么，怎么用的？有什么缺点？"></a>5、使用过Redis做异步队列么，怎么用的？有什么缺点？</h1><p>一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。</p>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li>在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。</li>
</ul>
<p>能不能生产一次消费多次呢？</p>
<p>使用pub/sub主题订阅者模式，可以实现1:N的消息队列。</p>
<h1 id="6、什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？"><a href="#6、什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？" class="headerlink" title="6、什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？"></a>6、什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？</h1><ul>
<li><h2 id="穿透、雪崩、击穿的思维导图"><a href="#穿透、雪崩、击穿的思维导图" class="headerlink" title="穿透、雪崩、击穿的思维导图"></a>穿透、雪崩、击穿的思维导图</h2></li>
</ul>
<pre><code>![img](https://cdn.nlark.com/yuque/0/2020/svg/1200640/1587200664360-7c300f02-d01c-4559-899a-9cb66430a32a.svg)



## 缓存“穿透”是什么

穿透：指查询一个**不存在**的数据，由于缓存中没有，就会被动写，从数据库中查询数据，数据库中也不存在这个数据，就无法写入缓存。这导致每次查询这个不存在的数据时，都要去DB中去查询，缓存失去了它的意义。



## 缓存“穿透”如何避免

方案一：缓存空对象

- - 从数据库中查询到的数据为空时，将这个空结果进行缓存，具体的值要使用特殊的标识（能和真正的缓存数据区分开）
    - 对这个数据设置较短的过期时间（例如：5分钟）

&gt; 为什么设置较短的过期时间？因为缓存久了没有意义，浪费缓存的内存



方案二：BloomFilter 布隆过滤器

构建布隆过滤器，在布隆过滤器中存储对应的 key 是否存在，若存在 ，说明 key 对应的值不为空（未必存在）

1. 1. 根据 key 查询布隆过滤器。如果值不存在，直接返回；如果值存在，继续向下执行
    2. 根据 key 查询缓存中的值。若存在，就返回；若不存在，继续向下执行
    3. 查询 DB 对应的值，存在，就更新到缓存，并返回该值



两个方案的优缺点：



## 缓存“雪崩”是什么

缓存雪崩：缓存由于某些原因无法提供服务（例如：缓存挂掉），所有请求打到 DB 中，导致 DB 负荷增大，最终挂掉的情况



## 缓存“雪崩”如何避免

一、缓存高可用：通过搭建缓存的高可用，避免缓存挂掉，导致无法提供服务的情况，降低缓存雪崩的情况

二、本地缓存：即使 Redis 缓存挂了，也可以将 DB 查询到的结果缓存到本地，避免后序的请求全部到达 DB中。

但是使用本地缓存也会出现相关的问题：

1. 如何保证本地缓存的实时性？

1. 1. 消息队列：数据更新时，发布数据更新的信息；会有相应的消费者消费消息，从而更新本地缓存
    2. 过期时间：设置较短的过期时间，过期之后从 DB 重新查询数据
    3. 手动过期：【如何避免缓存击穿——方案二】

1. 每个进程可能会本地缓存相同的数据，导致数据浪费

1. 1. 配置本地缓存的过期策略和缓存数量上限

三、请求 DB 限流：通过限制 DB 的每秒请求数，避免把 DB 也打挂。

这样有两个好处：

1. 有一部分用户还是可以正常使用的
2. 未来缓存服务恢复后，整个系统可以正常使用，不用处理 DB 也挂了的情况

四、提前演练：在项目上线前，对缓存挂掉的情况进行演练，看看后端的负载情况以及可能出现的问题，在这个基础上进行一些预案设定



## 缓存“击穿”是什么

缓存击穿：指某个热度非常高的数据，在某个时间点过期，在这个时间点，恰好有对这个key的大量请求，这些请求发现缓存数据过期，会从 DB 中查询数据并写回缓存，但是这时候的请求量太大可能使DB挂掉

- 对于一些设置了过期时间的 key，如果这些 key 可能会在某些时间点会被高并发的访问，是一种非常“热点”的数据，需要考虑这个问题。
- 区别：

- - 和缓存“穿透”的区别：这个 key 是真实存在对应值的
    - 和缓存“雪崩”的区别：前者针对某一个 key，后者针对很多 key



## 缓存“击穿”如何避免

一、互斥锁：请求发现缓存中数据不存在时，去查 DB 前，使用分布式锁，保证有且只有一个线程去查询 DB，并更新到缓存。流程如下：

1. 获取分布式锁：若超时，则抛出异常，返回；若成功，继续执行
2. 查询缓存：若缓存中存在值，就直接返回；若不存在，就继续向下执行。（获取到锁的时候，可能已经被前面的线程查询过数据库，并将数据更新到缓存中了）
3. 查询 DB，并更新到缓存中，返回值

二、手动过期：在缓存上，不设置过期时间；在功能上，将过期时间存在 key 对应的 value 中。流程如下：

1. 获取缓存：通过 value 的过期时间，判断是否过期，若没有过期，则直接返回；若过期，继续执行
2. 通过后台的一个异步线程进行缓存的构建，也就是“手动过期”。通过后台的异步线程，保证有且只有一个线程查询 DB
3. 返回数据：同时，虽然数据已经过期，但还是直接返回。通过这样的方式，保证服务的可用性，但是损失了一定的时效性

两个方案的优缺点：

|      | 互斥锁                             | 手动过期       |
| ---- | ---------------------------------- | -------------- |
| 优点 | 保证一致性                         | 用户无需等待   |
| 缺点 | 1、代码复杂度增加2、存在死锁的风险 | 无法保证一致性 |

## 缓存预热是什么？如何实现？

缓存预热

缓存系统刚启动时，没有任何数据，如果依靠用户请求的方式来重建缓存数据，对数据库的压力会非常大。

此时最好是在启动时，把热点数据加载好。这样，用户在请求时，读取的是缓存的数据，无需读取 DB 来重建缓存数据。

如何实现

1. 数据量不大时，项目启动时，自动进行初始化
2. 写一个脚本，手动执行它，加载热点数据
3. 写一个管理界面，手动点击，将相应的热点数据写到缓存中</code></pre>
<h1 id="7、Redis常用命令"><a href="#7、Redis常用命令" class="headerlink" title="7、Redis常用命令"></a>7、Redis常用命令</h1><p>管理命令</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta"># dbsize 返回当前数据库 key 的数量。</span></span><br><span class="line"><span class="meta"># info 返回当前 redis 服务器状态和一些统计信息。</span></span><br><span class="line"><span class="meta"># monitor 实时监听并返回redis服务器接收到的所有请求信息。</span></span><br><span class="line"><span class="meta"># shutdown 把数据同步保存到磁盘上，并关闭redis服务。</span></span><br><span class="line"><span class="meta"># config get parameter 获取一个 redis 配置参数信息。（个别参数可能无法获取）</span></span><br><span class="line"><span class="meta"># config set parameter value 设置一个 redis 配置参数信息。（个别参数可能无法获取）</span></span><br><span class="line"><span class="meta"># config resetstat 重置 info 命令的统计信息。（重置包括：keyspace 命中数、</span></span><br><span class="line"><span class="meta"># keyspace 错误数、 处理命令数，接收连接数、过期 key 数）</span></span><br><span class="line"><span class="meta"># debug object key 获取一个 key 的调试信息。</span></span><br><span class="line"><span class="meta"># debug segfault 制造一次服务器当机。</span></span><br><span class="line"><span class="meta"># flushdb 删除当前数据库中所有 key,此方法不会失败。小心慎用</span></span><br><span class="line"><span class="meta"># flushall 删除全部数据库中所有 key，此方法不会失败。小心慎用</span></span><br></pre></td></tr></table></figure>

<h2 id="工具命令"><a href="#工具命令" class="headerlink" title="工具命令"></a>工具命令</h2><figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta">#redis-server：Redis 服务器的 daemon 启动程序</span></span><br><span class="line"><span class="meta">#redis-cli：Redis 命令行操作工具。当然，你也可以用 telnet 根据其纯文本协议来操作</span></span><br><span class="line"><span class="meta">#redis-benchmark：Redis 性能测试工具，测试 Redis 在你的系统及你的配置下的读写性能</span></span><br><span class="line">$redis-benchmark -n <span class="number">100000</span> –c <span class="number">50</span></span><br><span class="line"><span class="meta">#模拟同时由 50 个客户端发送 100000 个 SETs/GETs 查询</span></span><br><span class="line"><span class="meta">#redis-check-aof：更新日志检查</span></span><br><span class="line"><span class="meta">#redis-check-dump：本地数据库检查</span></span><br></pre></td></tr></table></figure>

<h1 id="8、Redis单例、主从模式、sentinel以及集群的配置方式及优缺点对比"><a href="#8、Redis单例、主从模式、sentinel以及集群的配置方式及优缺点对比" class="headerlink" title="8、Redis单例、主从模式、sentinel以及集群的配置方式及优缺点对比"></a>8、Redis单例、主从模式、sentinel以及集群的配置方式及优缺点对比</h1><h1 id="9、为什么Redis-单线程却能支撑高并发？"><a href="#9、为什么Redis-单线程却能支撑高并发？" class="headerlink" title="9、为什么Redis 单线程却能支撑高并发？"></a>9、为什么Redis 单线程却能支撑高并发？</h1><p>1.redis是基于内存的，内存的读写速度非常快（纯内存）。</p>
<p>2.redis是单线程的，省去了很多上下文切换线程的时间（避免线程切换和竞态消耗）。</p>
<p>3.Redis全程使用hash结构，读取速度快，还有一些特殊的数据结构，对数据存储进行了优化，如压缩表，对短数据进行压缩存储，再如，跳表，使用有序的数据结构加快读取的速度。</p>
<p>4.redis使用多路复用技术，可以处理并发的连接（非阻塞IO）。</p>
<p>多路I/O复用模型是利用select、poll、epoll可以同时监察多个流的IO事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或者多个流的IO事件时，就从阻塞状态中唤醒，于是程序就会轮训一遍所有的流（epoll是只轮训发出了事件的流），并且只一次按顺序的处理就绪的流，这种做法就避免了大量的无用操作，这里的“多路”是指多个网络连接，“复用”是指复用同一个线程，采用多路IO复用技术可以让单个线程高效的处理多个连接请求</p>
<h1 id="10、Redis常见性能问题和解决方案："><a href="#10、Redis常见性能问题和解决方案：" class="headerlink" title="10、Redis常见性能问题和解决方案："></a>10、Redis常见性能问题和解决方案：</h1><p>1).Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以Master最好不要写内存快照。</p>
<p>2).Master AOF持久化，如果不重写AOF文件，这个持久化方式对性能的影响是最小的，但是AOF文件会不断增大，AOF文件过大会影响Master重启的恢复速度。Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化，如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。</p>
<p>3).Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。</p>
<p>4).Redis主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内</p>
<p>Redis性能分析相关问题，限于篇幅，给出文章链接：</p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247491923&idx=1&sn=09526c6ee214ee4179500d13282ed5f0&chksm=ebd5de7fdca25769d0c6b7af5b51b13c7238c72cbf35a35a01173344b6ae5d69985334bbb86d&scene=21#wechat_redirect">Redis 性能问题分析（好文推荐）</a></p>
<h3 id="11、Redis的并发竞争问题如何解决"><a href="#11、Redis的并发竞争问题如何解决" class="headerlink" title="11、Redis的并发竞争问题如何解决?"></a>11、Redis的并发竞争问题如何解决?</h3><p>Redis为单进程单线程模式，采用队列模式将并发访问变为串行访问。Redis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争，但是在Jedis客户端对Redis进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成。对此有2种解决方法：</p>
<ul>
<li>客户端角度，为保证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。</li>
<li>服务器角度，利用setnx实现锁。</li>
</ul>
<p>注：对于第一种，需要应用程序自己处理资源的同步，可以使用的方法比较通俗，可以使用synchronized也可以使用lock；第二种需要用到Redis的setnx命令，但是需要注意一些问题。</p>
<h1 id="12、说说Redis的内存淘汰策略"><a href="#12、说说Redis的内存淘汰策略" class="headerlink" title="12、说说Redis的内存淘汰策略"></a>12、说说Redis的内存淘汰策略</h1><p><strong>redis 提供 6种数据淘汰策略：</strong></p>
<ol>
<li><strong>volatile-lru</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li>
<li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li>
<li><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li>
<li><strong>allkeys-lru</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）</li>
<li><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</li>
<li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。</li>
</ol>
<p>4.0版本后增加以下两种：</p>
<ol>
<li><strong>volatile-lfu</strong>：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰</li>
<li><strong>allkeys-lfu</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key</li>
</ol>
<h1 id="13、Redis最适合的场景"><a href="#13、Redis最适合的场景" class="headerlink" title="13、Redis最适合的场景"></a>13、Redis最适合的场景</h1><p>Redis最适合所有数据in-momory的场景，虽然Redis也提供持久化功能，但实际更多的是一个disk-backed的功能，跟传统意义上的持久化有比较大的差别，那么可能大家就会有疑问，似乎Redis更像一个加强版的Memcached，那么何时使用Memcached，何时使用Redis呢?</p>
<p>如果简单地比较Redis与Memcached的区别，大多数都会得到以下观点：</p>
<ul>
<li>Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li>
<li>Redis支持数据的备份，即master-slave模式的数据备份。</li>
<li>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</li>
</ul>
<h2 id="会话缓存（Session-Cache）"><a href="#会话缓存（Session-Cache）" class="headerlink" title="会话缓存（Session Cache）"></a>会话缓存（Session Cache）</h2><p>最常用的一种使用Redis的情景是会话缓存（session cache）。用Redis缓存会话比其他存储（如Memcached）的优势在于：Redis提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？</p>
<p>幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用Redis来缓存会话的文档。甚至广为人知的商业平台Magento也提供Redis的插件。</p>
<h2 id="全页缓存（FPC）"><a href="#全页缓存（FPC）" class="headerlink" title="全页缓存（FPC）"></a>全页缓存（FPC）</h2><p>除基本的会话token之外，Redis还提供很简便的FPC平台。回到一致性问题，即使重启了Redis实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似PHP本地FPC。</p>
<p>再次以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。</p>
<p>此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助以最快速度加载曾浏览过的页面。</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。Redis作为队列使用的操作，就类似于本地程序语言（如Python）对 list 的 push/pop 操作。</p>
<p>如果快速的在Google中搜索“Redis queues”，马上就能找到大量的开源项目，这些项目的目的就是利用Redis创建非常好的后端工具，以满足各种队列需求。例如，Celery有一个后台就是使用Redis作为broker，可以从这里去查看。</p>
<h2 id="排行榜-计数器"><a href="#排行榜-计数器" class="headerlink" title="排行榜/计数器"></a>排行榜/计数器</h2><p>Redis在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得在执行这些操作的时候变的非常简单，Redis只是正好提供了这两种数据结构。所以，要从排序集合中获取到排名最靠前的10个用户–称之为“user_scores”。</p>
<p>当然，这是假定是根据用户的分数做递增的排序。如果想返回用户及用户的分数，需要这样执行：ZRANGE user_scores 0 10 WITHSCORES</p>
<p>Agora Games就是一个很好的例子，用Ruby实现的，它的排行榜就是使用Redis来存储数据的。</p>
<h2 id="发布-订阅"><a href="#发布-订阅" class="headerlink" title="发布/订阅"></a>发布/订阅</h2><p>最后（但肯定不是最不重要的）是Redis的发布/订阅功能。发布/订阅的使用场景确实非常多。人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用Redis的发布/订阅功能来建立聊天系统！</p>
<h1 id="1、为什么要用-redis-为什么要用缓存？"><a href="#1、为什么要用-redis-为什么要用缓存？" class="headerlink" title="1、为什么要用 redis/为什么要用缓存？"></a>1、为什么要用 redis/为什么要用缓存？</h1><p>主要从“高性能”和“高并发”这两点来看待这个问题</p>
<p><strong>高性能：</strong></p>
<p>假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p>
<p><strong>高并发：</strong></p>
<p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p>
<h1 id="2、为什么要用-redis-而不用-map-guava-做缓存"><a href="#2、为什么要用-redis-而不用-map-guava-做缓存" class="headerlink" title="2、为什么要用 redis 而不用 map/guava 做缓存?"></a>2、为什么要用 redis 而不用 map/guava 做缓存?</h1><p>缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。</p>
<p>使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 或 memcached服务的高可用，整个程序架构上较为复杂。</p>
<h1 id="3、redis-的线程模型"><a href="#3、redis-的线程模型" class="headerlink" title="3、redis 的线程模型"></a>3、redis 的线程模型</h1><p>redis 内部使用文件事件处理器 <code>file event handler</code>，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。</p>
<p>文件事件处理器的结构包含 4 个部分：</p>
<ul>
<li>多个 socket</li>
<li>IO 多路复用程序</li>
<li>文件事件分派器</li>
<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li>
</ul>
<p>多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</p>
<h1 id="4、redis-和-memcached-的区别"><a href="#4、redis-和-memcached-的区别" class="headerlink" title="4、redis 和 memcached 的区别"></a>4、redis 和 memcached 的区别</h1><ol>
<li><strong>redis支持更丰富的数据类型（支持更复杂的应用场景）</strong>：Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。memcache支持简单的数据类型，String。</li>
<li><strong>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中。</strong></li>
<li><strong>集群模式</strong>：memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 redis 目前是原生支持 cluster 模式的.</li>
<li><strong>Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的多路 IO 复用模型。</strong></li>
</ol>
<table>
<thead>
<tr>
<th><strong>对比参数</strong></th>
<th><strong>Redis</strong></th>
<th><strong>Memcached</strong></th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>1、支持内存2、非关系型数据库</td>
<td>1、支持内存2、key-value键值对形式3、缓存系统</td>
</tr>
<tr>
<td>数据存储类型</td>
<td>1、String2、List3、Set4、Hash5、Sort Set [俗称ZSet]</td>
<td>1、文本型2、1进制类型[新版增加]</td>
</tr>
<tr>
<td>查询[操作]类型</td>
<td>1、批量操作2、事务支持[ 虽然是假的事务]3、每个类型不同的CRUD</td>
<td>1、CRUD2、少量的其他命令</td>
</tr>
<tr>
<td>附加功能</td>
<td>1、发布/订阅模式2、主从分区3、序列化支持4、脚本支持[Lua脚本]</td>
<td>1、多线程服务支持</td>
</tr>
<tr>
<td>网络IO模型</td>
<td>1、单进程模式</td>
<td>2、多线程、非阻塞|O模式</td>
</tr>
<tr>
<td>事件库</td>
<td>自封装简易事件库AeEvent</td>
<td>贵族血统的L ibEvent事件库</td>
</tr>
<tr>
<td>|持久化支持</td>
<td>1、RDB2、AOF</td>
<td>不支持</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring</title>
    <url>/2020/10/15/0000.Spring/</url>
    <content><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p>​        Spring 是一个开源框架，是为了解决企业应用程序开发复杂性而创建的（替代更加重量级的企业级Java技术， 尤其是EJB），它完成了大量开发中的通用步骤，留给开发者的仅仅是与特定应用相关的部分，从而大大提高了企业应用的开发效率。</p>
<a id="more"></a>

<h1 id="Spring面试题"><a href="#Spring面试题" class="headerlink" title="Spring面试题"></a>Spring面试题</h1><h1 id="1、什么是-Spring-框架"><a href="#1、什么是-Spring-框架" class="headerlink" title="1、什么是 Spring 框架?"></a>1、什么是 Spring 框架?</h1><p>Spring 是一种轻量级开发框架，旨在提高开发人员的开发效率以及系统的可维护性。Spring 官网：<a href="https://spring.io/%E3%80%82">https://spring.io/。</a></p>
<p>一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助开发。这些模块是：核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。比如：Core Container 中的 Core 组件是Spring 所有组件的核心，Beans 组件和 Context 组件是实现IOC和依赖注入的基础，AOP组件用来实现面向切面编程。</p>
<p>Spring 官网列出的 Spring 的 6 个特征:</p>
<ul>
<li><strong>核心技术</strong> ：依赖注入(DI)，AOP，事件(events)，资源，i18n，验证，数据绑定，类型转换，SpEL。</li>
<li><strong>测试</strong> ：模拟对象，TestContext框架，Spring MVC 测试，WebTestClient。</li>
<li><strong>数据访问</strong> ：事务，DAO支持，JDBC，ORM，编组XML。</li>
<li><strong>Web支持</strong> : Spring MVC和Spring WebFlux Web框架。</li>
<li><strong>集成</strong> ：远程处理，JMS，JCA，JMX，电子邮件，任务，调度，缓存。</li>
<li><strong>语言</strong> ：Kotlin，Groovy，动态语言。</li>
</ul>
<h1 id="2、Spring模块？"><a href="#2、Spring模块？" class="headerlink" title="2、Spring模块？"></a>2、Spring模块？</h1><p>下图对应的是 Spring4.x 版本。目前最新的5.x版本中 Web 模块的 Portlet 组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/spring.jpg"></p>
<ul>
<li><strong>Spring Core：</strong> 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IoC 依赖注入功能。</li>
<li><strong>Spring Aspects</strong> ： 该模块为与AspectJ的集成提供支持。</li>
<li><strong>Spring AOP</strong> ：提供了面向切面的编程实现。</li>
<li><strong>Spring JDBC</strong> : Java数据库连接。</li>
<li><strong>Spring JMS</strong> ：Java消息服务。</li>
<li><strong>Spring ORM</strong> : 用于支持Hibernate等ORM工具。</li>
<li><strong>Spring Web</strong> : 为创建Web应用程序提供支持。</li>
<li><strong>Spring Test</strong> : 提供了对 JUnit 和 TestNG 测试的支持。</li>
</ul>
<h2 id="Spring框架的优点是什么？"><a href="#Spring框架的优点是什么？" class="headerlink" title="Spring框架的优点是什么？"></a>Spring框架的优点是什么？</h2><ul>
<li>轻量：Spring 是轻量的，基本的版本大约2MB。</li>
<li>控制反转：Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。</li>
<li>面向切面的编程(AOP)：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。</li>
<li>容器：Spring 包含并管理应用中对象的生命周期和配置。</li>
<li>MVC框架：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。</li>
<li>事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。</li>
<li>异常处理：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常。</li>
</ul>
<h1 id="3、Spring-IOC-amp-AOP"><a href="#3、Spring-IOC-amp-AOP" class="headerlink" title="3、Spring IOC &amp; AOP"></a>3、Spring IOC &amp; AOP</h1><h2 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h2><p>IoC（Inverse of Control:控制反转）是一种<strong>设计思想</strong>，就是 <strong>将原本在程序中手动创建对象的控制权，交由Spring框架来管理。</strong> IoC 在其他语言中也有应用，并非 Spring 特有。 <strong>IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。</strong></p>
<p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 <strong>IoC 容器就像是一个工厂一样，当需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</strong> 在实际项目中一个 Service 类可能有几百甚至上千个类作为它的底层，假如需要实例化这个 Service，可能要每次都要搞清这个 Service 所有底层类的构造函数。如果利用 IoC 的话，只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。</p>
<p><strong>Spring IoC的初始化过程：</strong></p>
<p><strong><img src="https://cdn.nlark.com/yuque/0/2020/png/396745/1593155272608-ca3d80a4-9278-4fe5-a044-883a45bb5d6c.png?x-oss-process=image/resize,w_1500" alt="image.png"></strong></p>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</p>
<p><strong>Spring AOP就是基于动态代理的</strong>，如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用<strong>Cglib</strong> ，这时候Spring AOP会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理。</p>
<p>当然也可以使用 AspectJ ,Spring AOP 已经集成了AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p>
<p>使用 AOP 之后可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。</p>
<h2 id="Spring-AOP-和-AspectJ-AOP-有什么区别？"><a href="#Spring-AOP-和-AspectJ-AOP-有什么区别？" class="headerlink" title="Spring AOP 和 AspectJ AOP 有什么区别？"></a>Spring AOP 和 AspectJ AOP 有什么区别？</h2><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p>
<p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p>
<p>如果切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。</p>
<h1 id="4、Spring-中的-bean-的作用域有哪些"><a href="#4、Spring-中的-bean-的作用域有哪些" class="headerlink" title="4、Spring 中的 bean 的作用域有哪些?"></a>4、Spring 中的 bean 的作用域有哪些?</h1><ul>
<li>singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li>
<li>prototype : 每次请求都会创建一个新的 bean 实例。</li>
<li>request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。</li>
<li>session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。</li>
<li>global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话</li>
</ul>
<h1 id="5、Spring-中的单例-bean-的线程安全问题了解吗？"><a href="#5、Spring-中的单例-bean-的线程安全问题了解吗？" class="headerlink" title="5、Spring 中的单例 bean 的线程安全问题了解吗？"></a>5、Spring 中的单例 bean 的线程安全问题了解吗？</h1><p>大部分时候并没有在系统中使用多线程，所以很少有人会关注这个问题。单例 bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候，对这个对象的非静态成员变量的写操作会存在线程安全问题。</p>
<p>常见的有两种解决办法：</p>
<ol>
<li>在Bean对象中尽量避免定义可变的成员变量（不太现实）。</li>
<li>在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。</li>
</ol>
<h1 id="6、-Component-和-Bean-的区别是什么？"><a href="#6、-Component-和-Bean-的区别是什么？" class="headerlink" title="6、@Component 和 @Bean 的区别是什么？"></a>6、@Component 和 @Bean 的区别是什么？</h1><ol>
<li>作用对象不同: <code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</li>
<li><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中（可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。<code>@Bean</code> 注解通常是在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了Spring这是某个类的示例，当需要用它的时候Spring进行装配加载。</li>
<li><code>@Bean</code> 注解比 <code>Component</code> 注解的自定义性更强，而且很多地方只能通过 <code>@Bean</code> 注解来注册bean。比如当引用第三方库中的类需要装配到 <code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</li>
</ol>
<p><code>@Bean</code>注解使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransferService <span class="title">transferService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码相当于下面的 xml 配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transferService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.acme.TransferServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>下面这个例子是通过 <code>@Component</code> 无法实现的。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line"><span class="function"><span class="keyword">public</span> OneService <span class="title">getService</span>(<span class="params">status</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> (status)  &#123;</span><br><span class="line">        <span class="keyword">when</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> serviceImpl1();</span><br><span class="line">        <span class="keyword">when</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> serviceImpl2();</span><br><span class="line">        <span class="keyword">when</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> serviceImpl3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7、将一个类声明为Spring的-bean-的注解有哪些"><a href="#7、将一个类声明为Spring的-bean-的注解有哪些" class="headerlink" title="7、将一个类声明为Spring的 bean 的注解有哪些?"></a>7、将一个类声明为Spring的 bean 的注解有哪些?</h1><p>一般使用 <code>@Autowired</code> 注解自动装配 bean，要想把类标识成可用于 <code>@Autowired</code> 注解自动装配的 bean 的类,采用以下注解可实现：</p>
<ul>
<li><code>@Component</code> ：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个Bean不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li>
<li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li>
<li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao层。</li>
<li><code>@Controller</code> : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</li>
</ul>
<h1 id="8、Spring-中的-bean-生命周期"><a href="#8、Spring-中的-bean-生命周期" class="headerlink" title="8、Spring 中的 bean 生命周期?"></a>8、Spring 中的 bean 生命周期?</h1><ul>
<li>Bean 容器找到配置文件中 Spring Bean 的定义。</li>
<li>Bean 容器利用 Java Reflection API 创建一个Bean的实例。</li>
<li>如果涉及到一些属性值 利用 <code>set()</code>方法设置一些属性值。</li>
<li>如果 Bean 实现了 <code>BeanNameAware</code> 接口，调用 <code>setBeanName()</code>方法，传入Bean的名字。</li>
<li>如果 Bean 实现了 <code>BeanClassLoaderAware</code> 接口，调用 <code>setBeanClassLoader()</code>方法，传入 <code>ClassLoader</code>对象的实例。</li>
<li>与上面的类似，如果实现了其他 <code>*.Aware</code>接口，就调用相应的方法。</li>
<li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessBeforeInitialization()</code> 方法</li>
<li>如果Bean实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法。</li>
<li>如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。</li>
<li>如果有和加载这个 Bean的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessAfterInitialization()</code> 方法</li>
<li>当要销毁 Bean 的时候，如果 Bean 实现了 <code>DisposableBean</code> 接口，执行 <code>destroy()</code> 方法。</li>
<li>当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。</li>
</ul>
<h1 id="9、SpringMVC-工作原理"><a href="#9、SpringMVC-工作原理" class="headerlink" title="9、SpringMVC 工作原理?"></a>9、SpringMVC 工作原理?</h1><ol>
<li><p>客户端（浏览器）发送请求，直接请求到 <code>DispatcherServlet</code>。</p>
</li>
<li><p><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code>，解析请求对应的 <code>Handler</code>。</p>
</li>
<li><p>解析到对应的 <code>Handler</code>（也就是平常说的 <code>Controller</code> 控制器）后，开始由 <code>HandlerAdapter</code> 适配器处理。</p>
</li>
<li><p><code>HandlerAdapter</code> 会根据 <code>Handler</code>来调用真正的处理器开处理请求，并处理相应的业务逻辑。</p>
</li>
<li><p>处理器处理完业务后，会返回一个 <code>ModelAndView</code> 对象，<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</p>
</li>
<li><p><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</p>
</li>
<li><p><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</p>
</li>
<li><p>把 <code>View</code> 返回给请求者（浏览器）</p>
<h5 id="SpringMVC-的流程"><a href="#SpringMVC-的流程" class="headerlink" title="SpringMVC 的流程"></a>SpringMVC 的流程</h5></li>
</ol>
<pre><code>![image](https://cdn.jsdelivr.net/gh/xray1025/image01/20201015152955.png)





![image](https://cdn.jsdelivr.net/gh/xray1025/image01/20201015153017.png)</code></pre>
<h1 id="10、Spring-框架中用到了哪些设计模式？"><a href="#10、Spring-框架中用到了哪些设计模式？" class="headerlink" title="10、Spring 框架中用到了哪些设计模式？"></a>10、Spring 框架中用到了哪些设计模式？</h1><ul>
<li><strong>工厂设计模式</strong> : Spring使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li>
<li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li>
<li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li>
<li><strong>包装器设计模式</strong> : 项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让可以根据客户的需求能够动态切换不同的数据源。</li>
<li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li>
<li><strong>适配器模式</strong> :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li>
</ul>
<h1 id="11、Spring-管理事务的方式有几种？"><a href="#11、Spring-管理事务的方式有几种？" class="headerlink" title="11、Spring 管理事务的方式有几种？"></a>11、Spring 管理事务的方式有几种？</h1><ol>
<li>编程式事务，在代码中硬编码。(不推荐使用)</li>
<li>声明式事务，在配置文件中配置（推荐使用）</li>
</ol>
<p><strong>声明式事务又分为两种：</strong></p>
<ol>
<li>基于XML的声明式事务</li>
<li>基于注解的声明式事务</li>
</ol>
<h1 id="12、Spring-事务中的隔离级别有哪几种"><a href="#12、Spring-事务中的隔离级别有哪几种" class="headerlink" title="12、Spring 事务中的隔离级别有哪几种?"></a>12、Spring 事务中的隔离级别有哪几种?</h1><p><strong>TransactionDefinition 接口中定义了五个表示隔离级别的常量：</strong></p>
<ul>
<li><strong>TransactionDefinition.ISOLATION_DEFAULT:</strong> 使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.</li>
<li><strong>TransactionDefinition.ISOLATION_READ_UNCOMMITTED:</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></li>
<li><strong>TransactionDefinition.ISOLATION_READ_COMMITTED:</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li>
<li><strong>TransactionDefinition.ISOLATION_REPEATABLE_READ:</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li>
<li><strong>TransactionDefinition.ISOLATION_SERIALIZABLE:</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ul>
<h1 id="13、Spring-事务中哪几种事务传播行为"><a href="#13、Spring-事务中哪几种事务传播行为" class="headerlink" title="13、Spring 事务中哪几种事务传播行为?"></a>13、Spring 事务中哪几种事务传播行为?</h1><p><strong>支持当前事务的情况：</strong></p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_REQUIRED：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li>
<li><strong>TransactionDefinition.PROPAGATION_SUPPORTS：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li><strong>TransactionDefinition.PROPAGATION_MANDATORY：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</li>
</ul>
<p><strong>不支持当前事务的情况：</strong></p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_REQUIRES_NEW：</strong> 创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li>
<li><strong>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：</strong> 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li><strong>TransactionDefinition.PROPAGATION_NEVER：</strong> 以非事务方式运行，如果当前存在事务，则抛出异常。</li>
</ul>
<p><strong>其他情况：</strong></p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_NESTED：</strong> 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</li>
</ul>
<h1 id="14、-Transactional-rollbackFor-Exception-class-注解了解吗？"><a href="#14、-Transactional-rollbackFor-Exception-class-注解了解吗？" class="headerlink" title="14、@Transactional(rollbackFor = Exception.class)注解了解吗？"></a>14、@Transactional(rollbackFor = Exception.class)注解了解吗？</h1><p>Exception分为运行时异常RuntimeException和非运行时异常。事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以保证数据的一致性。</p>
<p>当<code>@Transactional</code>注解作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，也可以在方法级别使用该标注来覆盖类级别的定义。如果类或者方法加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。</p>
<p>在<code>@Transactional</code>注解中如果不配置<code>rollbackFor</code>属性,那么事物只会在遇到<code>RuntimeException</code>的时候才会回滚,加上<code>rollbackFor=Exception.class</code>,可以让事物在遇到非运行时异常时也回滚。</p>
<h1 id="15、Spring如何解决循环依赖"><a href="#15、Spring如何解决循环依赖" class="headerlink" title="15、Spring如何解决循环依赖"></a>15、Spring如何解决循环依赖</h1><h4 id="1、-循环依赖"><a href="#1、-循环依赖" class="headerlink" title="1、 循环依赖"></a>1、 循环依赖</h4><ul>
<li><p>–&gt;循环引用。—&gt;即2个或以上bean 互相持有对方，最终形成闭环。</p>
<p>eg：A依赖B，B依赖C，C又依赖A。【注意：这里不是函数的循环调用【是个死循环，除非有终结条件】，是对象相互依赖关系</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201015150352.png" alt="img"></p>
<h4 id="2、循环依赖的场景？"><a href="#2、循环依赖的场景？" class="headerlink" title="2、循环依赖的场景？"></a>2、循环依赖的场景？</h4><p>①构造器依赖（这个解决不了，具体原因往下看）。</p>
<p>②通过setter循环依赖。（这个可以解决）。</p>
<h4 id="3-如何发现？"><a href="#3-如何发现？" class="headerlink" title="3 如何发现？"></a>3 如何发现？</h4><ul>
<li><p>spring在创建对象之前（对象还未出现）的时候，会将放在一个Set容器里，beanName为key，表示该对象正在被创建中。</p>
</li>
<li><p>如果是构造器依赖，ABC构造器循环依赖，在创建A的时候singletonsCurrentlyInCreation中有A的beanName，然后发现需要B对象，先获取B，发现B不存在，那么继续创建B，先在singletonsCurrentlyInCreation中存放B的beanName，然后发现创建B对象的时候，需要先创建C，继续查询C，发现C不存在，那么现在singletonsCurrentlyInCreation中存放C的beanName，但是创建C的时候发现需要先创建A，获取A的时候spring发现singletonsCurrentlyInCreation存在A的beanName，那么表示A当前正在被创建中，spring抛出异常。</p>
</li>
</ul>
<h4 id="4-如何解决？"><a href="#4-如何解决？" class="headerlink" title="4.如何解决？"></a>4.如何解决？</h4><p>之前说到构造器依赖的时候，ABC创建失败的原因是因为A创建对象需要B，B创建对象需要C，C创建对象需要A，这个需求是在ABC都还未创建就彼此需要，彼此发现对象都不存在，所以才被抛出异常。</p>
<p>如但是通过setter的循环依赖，可以避免这个错误。</p>
<p>因为spring的创建分为3步。</p>
<p><img src="https://www.pianshen.com/images/544/0d52e6561321baa378f949ae43fab9e0.png" alt="img"></p>
<p>①createBeanInstance：初始化对象，类似于clazz.newInstance()</p>
<p>②populateBean：填充属性，bean的对象依赖属性就是在这一步进行填充</p>
<p>③initializeBean：调用spring配置中的init-method方法</p>
<p>经过上述三步，一个spring的bean才被完全创建。setter形式的循环依赖出现在第一步跟第二步之间，所以spring在存放bean的时候做了一点文章。</p>
<p>spring将单例bean的存放利用三个hashmap作为三个级别的缓存解决循环引用问题。</p>
<h4 id="5-三级缓存"><a href="#5-三级缓存" class="headerlink" title="5 三级缓存"></a>5 三级缓存</h4><p>三级缓存源码主要是指：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Cache of singleton objects: bean name --&gt; bean instance */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;(<span class="number">256</span>);</span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name --&gt; ObjectFactory */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;String, ObjectFactory&lt;?&gt;&gt;(<span class="number">16</span>);</span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name --&gt; bean instance */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;String, Object&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<p>这三级缓存分别指：</p>
<ul>
<li>一级缓存：singletonObjects，存放完全实例化属性赋值完成的Bean，直接可以使用。</li>
<li>二级缓存：earlySingletonObjects，存放早期Bean的引用，尚未属性装配的Bean</li>
<li>三级缓存：singletonFactories，存放实例化完成的Bean工厂。</li>
</ul>
<h4 id="6-解决"><a href="#6-解决" class="headerlink" title="6 解决"></a>6 解决</h4><ul>
<li><p>bean对象填充属性的时候，先判断该bean对象是否为单例，并且是否允许提前暴露（一般都为true），如果条件都符合，则调用addSingletonFactory方法，将创建改bean对象的工厂类存存放到第三级缓存registeredSingletons中，然后如果创建过程中，该bean对象完整创建，那么该对象会被registeredSingletons移除 然后加入到一级缓存singletonObjects中。</p>
</li>
<li><p>但是如果这个时候对象创建出现了循环引用，用之前的ABC对象举例。A对象装配之前，先讲自己的对象引用存放三级缓存中registeredSingletons然后，然后发现需要对象B，调用getSingleton(B)方法，获取B的过程，先去一级缓存中查询，如果没找到，再去二级缓存，三级缓存，这个时候因为B还没有创建，所以需要创建B对象，这个时候重复之前创建A的过程，B对象先将自己的对象引用存放到registeredSingletons中 然后，装配B对象，发现这个时候需要对象C，同理，先创建C。</p>
</li>
<li><p>注意！这个时候循环引用出现了，C的创建时需要装配A的，所以利索当然的调用getSingleton(A)方法，但是之前A虽然没有创建完全，不存在一级缓存singletonObjects,但是A的对象引用存在三级缓存registeredSingletons中，C获取到A之后，讲A从三级缓存registeredSingletons中删除，移到二级缓存earlySingletonObjects中，然后C创建完成，放置一级缓存singletonObjects中，B也创建完成，放置一级缓存singletonObjects中，随后A也创建完成，放置一级缓存singletonObjects中。</p>
</li>
</ul>
<p>循环引用的问题就此解决。</p>
<h1 id="16、Spring初始化过程？"><a href="#16、Spring初始化过程？" class="headerlink" title="16、Spring初始化过程？"></a>16、Spring初始化过程？</h1><p>在传统的Java应用中，Bean的生命周期非常简单。Java的关键词new用来实例化Bean（或许他是非序列化的）。这样就够用了。相反，Bean 的生命周期在spring容器中更加细致。理解Spring Bean的生命周期非常重要，或许要利用Spring提供的机会来订制Bean的创建过程。</p>
<p>1.容器寻找Bean的定义信息并且将其实例化。</p>
<p>2.使用依赖注入，Spring按照Bean定义信息配置Bean的所有属性。</p>
<p>3.如果Bean实现了BeanNameAware接口，工厂调用Bean的setBeanName()方法传递Bean的ID。</p>
<p>4.如果Bean实现了BeanFactoryAware接口，工厂调用setBeanFactory()方法传入工厂自身。</p>
<p>5.如果BeanPostProcessor和Bean关联，那么它们的postProcessBeforeInitialzation()方法将被调用。</p>
<p>6.如果Bean指定了init-method方法，它将被调用。</p>
<p>7.最后，如果有BeanPsotProcessor和Bean关联，那么它们的postProcessAfterInitialization()方法将被调用。</p>
<p>到这个时候，Bean已经可以被应用系统使用了，并且将被保留在Bean Factory中知道它不再需要。有两种方法可以把它从Bean Factory中删除掉。</p>
<p>1.如果Bean实现了DisposableBean接口，destory()方法被调用。</p>
<p>2.如果指定了订制的销毁方法，就调用这个方法。</p>
<p>Bean在Spring应用上下文的生命周期与在Bean工厂中的生命周期只有一点不同，唯一不同的是，如果Bean实现了ApplicationContextAwre接口，setApplicationContext()方法被调用。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2020/08/24/0000.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="0-设计模式"><a href="#0-设计模式" class="headerlink" title="0 设计模式"></a>0 设计模式</h2><pre><code>一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案

本质是面向对象设计原则的实际应用</code></pre>
<a id="more"></a>

<h3 id="0-1-分类"><a href="#0-1-分类" class="headerlink" title="0.1 分类"></a>0.1 分类</h3><p><strong>创建型模式：</strong></p>
<ul>
<li>单例模式<ul>
<li>工厂模式</li>
<li>抽象工厂模式 </li>
<li>建造者模式 </li>
<li>原型模式</li>
</ul>
</li>
</ul>
<p><strong>结构型模式：</strong></p>
<ul>
<li>适配器模式</li>
<li>桥接模式</li>
<li>装饰模式</li>
<li>组合模式</li>
<li>外观模式</li>
<li>享元模式</li>
<li>代理模式</li>
</ul>
<p><strong>行为型模式：</strong></p>
<ul>
<li>模板方法模式</li>
<li>命令模式</li>
<li>迭代器模式</li>
<li>观察者模式</li>
<li>中介者模式</li>
<li>备忘录模式</li>
<li>解释器模式</li>
<li>状态模式</li>
<li>策略模式</li>
<li>职责链模式</li>
<li>访问者模式</li>
</ul>
<h3 id="0-2-OOP七大原则"><a href="#0-2-OOP七大原则" class="headerlink" title="0.2 OOP七大原则"></a>0.2 OOP七大原则</h3><p><strong>开闭原则：</strong> 对扩展开放，对修改关闭；<br><strong>里氏替换原则：</strong> 继承必须确保超类拥有的性质在子类中仍然成立；<br><strong>依赖倒置原则：</strong> 面向接口编程，而不是面向实现编程；<br><strong>单一职责原则：</strong> 控制类的粒度大小，将对象解耦，提高内聚性；<br><strong>接口隔离原则：</strong> 为类建立需要的专用接口；<br><strong>迪米特法则：</strong> 只与直接朋友交谈；<br><strong>合成复用原则：</strong> 优先使用组合、聚合等关联关系，其次才考虑使用继承实现。</p>
<h3 id="0-3-UML类图"><a href="#0-3-UML类图" class="headerlink" title="0.3 UML类图"></a>0.3 UML类图</h3><pre><code>UML（unified modeling language） 统一建模语言</code></pre>
<ul>
<li>note 注释</li>
<li>class 类</li>
<li>interface 接口</li>
<li>dependency 依赖：一种使用的关系，即一个类的实现需要另一个类的协助</li>
<li>association 关联：一个类知道另一个类的属性和方法</li>
<li>generalization 泛化（继承）：指定子类如何特化父类所以的特征和行为</li>
<li>realization 实现：表示类是接口所有特征和行为的表现</li>
<li>aggregation 聚合：整体与部分的关系，并且部分可以离开整体而单独存在</li>
<li>composite 组合：整体与部分的关系，并且部分不可以离开整体而单独存在</li>
</ul>
<figure class="highlight fix"><table><tr><td class="code"><pre><span class="line"><span class="attr">泛化 </span>=<span class="string"> 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖</span></span><br></pre></td></tr></table></figure>

<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><h2 id="为什么用工厂模式"><a href="#为什么用工厂模式" class="headerlink" title="为什么用工厂模式"></a>为什么用工厂模式</h2><ul>
<li><p><strong>工厂模式都需要依赖接口**</strong>，主体对象通过接口规定的方法获取对象**，具体的实现逻辑由实现类完成，当实现逻辑变化时只需要修改实现类即可，达到了解耦的目的</p>
</li>
<li><p>降低重复代码，把创建过程统一管理方便维护</p>
</li>
<li><p>使用者不需要知道具体创建过程</p>
</li>
<li><p><strong>Spring源码中所有Bean的创建在源码中是简单工厂模式</strong>(不属于23种GOF设计模式之一)</p>
</li>
<li><ul>
<li>主体对象根据接口定义的方法调用，具体的实现逻辑由Spring源码完成，实现逻辑如下：</li>
<li>getBean-&gt;doGetBean-&gt;creatBean-&gt;doCreatBean-&gt;instantiateBean</li>
<li>具体的实例化操作由InstantiationStrategy接口规定，实现类调用instantiate()完成实例化，根据是否有方法需要被重写(是否使用方法注入)决定使用JDK的实例化方式(BeanUtils.<em>instantiateClass</em>(ctor))还是CGLIB的生成子类的实例化方法</li>
<li>本质还是调用某个方法返回一个对象</li>
</ul>
</li>
</ul>
<h2 id="还可以防止this引用逃逸"><a href="#还可以防止this引用逃逸" class="headerlink" title="还可以防止this引用逃逸"></a>还可以防止this引用逃逸</h2><ul>
<li><p>什么是this引用逃逸：</p>
</li>
<li><ul>
<li>在构造器构造还未彻底完成前（即实例初始化阶段还未完成），将自身this引用向外抛出并被其他线程复制（访问）了该引用，可能会问到该还未被初始化的变量，甚至可能会造成更大严重的问题</li>
<li>常见this引用逃逸错误：在构造函数中启动一个线程，当对象在其构造函数中创建一个线程时，this引用会被新创建的线程共享，在对象尚未完全构造之前，新的线程就可以看件它了。这一点和单例模式中使用不使用volatile会出现的问题类似，都是没有完全初始化好就被发现了</li>
<li>只有当构造函数返回时，this引用才应该从线程中逸出</li>
</ul>
</li>
<li><p>this引用逃逸发生的两个必要条件</p>
</li>
<li><ul>
<li>在构造函数中创建内部类</li>
<li>在构造函数中发布这个内部类</li>
</ul>
</li>
<li><p>错误示例伪码：构造过程中this逸出</p>
</li>
<li><ul>
<li>下面代码中初始化了事件监听器，事件监听器一旦注册成功，就能够监听用户的操作，调用对应的回调函数，比如监听到了e这个事件，那么就会执行doSomething()回调函数，函数中返回的是addListener的变量var，由于接受到监听事件是在构造函数中，所以很可能接受到事件时，var的值还没有在构造器中初始化完成，就会导致doSomething方法返回的值可能是0，也可能是10</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">getListener</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="keyword">var</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">getListener</span><span class="params">(EventSource source)</span></span>&#123;</span><br><span class="line">        <span class="comment">//注册事件，会一直监听，当发生事件e时，会执行回调函数doSomething</span></span><br><span class="line">        source.registerListener(</span><br><span class="line">            <span class="comment">//匿名内部类实现</span></span><br><span class="line">            <span class="keyword">new</span> EventListener()&#123;</span><br><span class="line">                <span class="comment">//此时getListener可能还未初始化完成，onEvent()中就持有this指针，有可能发生严重错误</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event e)</span></span>&#123;</span><br><span class="line">                    doSomething(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="keyword">var</span>=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doSomething</span><span class="params">(Event e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">var</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用工厂方法解决</p>
</li>
<li><ul>
<li>构造函数私有，有一个public的方法返回监听器，而不是上面的使用构造函数构造一个监听器对象</li>
</ul>
</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> SafeListener &#123;</span><br><span class="line">  <span class="keyword">private</span> final EventListener listener;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="constructor">SafeListener()</span> &#123;</span><br><span class="line">    listener = <span class="keyword">new</span> <span class="constructor">EventListener()</span> &#123;</span><br><span class="line">      public void on<span class="constructor">Event(Event <span class="params">e</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">do</span><span class="constructor">Something(<span class="params">e</span>)</span>;</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public static SafeListener <span class="keyword">new</span><span class="constructor">Instance(EventSource <span class="params">source</span>)</span> &#123;</span><br><span class="line">    SafeListener safe = <span class="keyword">new</span> <span class="constructor">SafeListener()</span>;</span><br><span class="line">    source.register<span class="constructor">Listener(<span class="params">safe</span>.<span class="params">listener</span>)</span>;</span><br><span class="line">    return safe;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h1><p><strong><a href="https://www.infoq.cn/article/double-checked-locking-with-delay-initialization/">双重检查锁定详细描述</a></strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Single</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Single instance=<span class="literal">null</span>;<span class="comment">//volatile必须有</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single</span>(<span class="params"></span>)</span>&#123;&#125;<span class="comment">//不给外界暴漏构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">null</span>)&#123;<span class="comment">//已经完成对象创建后不用再执行synchronized了，节省性能</span></span><br><span class="line">            synchronized (Single.class)&#123;</span><br><span class="line">                <span class="comment">//防止执行完if(s==null)后进入同步代码块前还有另一个线程也在同一位置，所有需要再判断一次防止写两次</span></span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="literal">null</span>)&#123;</span><br><span class="line">                    instance=<span class="keyword">new</span> Single();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">demo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String args[]</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(Single.getInstance());<span class="comment">//Single@677327b6</span></span><br><span class="line">        System.<span class="keyword">out</span>.println(Single.getInstance());<span class="comment">//Single@677327b6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="为什么使用volatile"><a href="#为什么使用volatile" class="headerlink" title="为什么使用volatile"></a>为什么使用volatile</h2><ul>
<li><p><strong>synchronized可以保证代码块的原子性和可见性，但是不能保证包裹的代码块内部的有序性</strong></p>
</li>
<li><ul>
<li>new一个对象，new Single可以分为三步</li>
</ul>
</li>
</ul>
<ol>
<li><ol>
<li><ol>
<li>分配对象的内存空间</li>
<li>初始化对象</li>
<li>设置 instance 指向刚分配的内存地址</li>
</ol>
</li>
</ol>
</li>
</ol>
<ul>
<li><ul>
<li>如果没有volatile修饰该对象，则<strong>这三步可能会发生重排序</strong>，变成</li>
</ul>
</li>
</ul>
<ol>
<li><ol>
<li><ol>
<li>分配对象的内存空间</li>
<li>设置 instance 指向刚分配的内存地址</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><strong>如果这里跳转到另外的线程了，**</strong>会发现instance!=null，那么就会return instance，但是此时instance还没有初始化**</p>
<ol>
<li><ol>
<li><ol>
<li>初始化对象</li>
</ol>
</li>
</ol>
</li>
</ol>
<ul>
<li><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1587288097853-b6000c80-20fb-4d42-b4b3-dd4c215c2ed1.png" alt="image.png"></li>
</ul>
</li>
</ul>
<h2 id="Spring中的单例设计模式"><a href="#Spring中的单例设计模式" class="headerlink" title="Spring中的单例设计模式"></a>Spring中的单例设计模式</h2><p>此处为语雀文档，点击链接查看：<a href="https://www.yuque.com/luka/note/beanfactory#EvQuu">https://www.yuque.com/luka/note/beanfactory#EvQuu</a></p>
<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><ul>
<li><p>适配器模式(adapter pattern)：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，在适配器模式中，通过增加一个新的适配器类来解决接口不兼容的问题，使得原本没有任何关系的类可以协同工作</p>
</li>
<li><p>根据适配器类与适配者类的关系不同，适配器模式可分为对象适配器和类适配器两种</p>
</li>
<li><ul>
<li>在<strong>类适配器模式</strong>中，适配器与适配者之间是<strong>继承</strong>(或实现)关系</li>
<li>在<strong>对象适配器模式</strong>中，适配器与适配者之间是<strong>关联</strong>关系</li>
</ul>
</li>
</ul>
<h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ul>
<li>Target（目标抽象类）：目标抽象类定义客户所需接口，被客户直接访问，可以是一个抽象类或接口，也可以是具体类</li>
<li>Adapter（适配器类）：适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过实现Target接口并继承/关联一个Adaptee对象使二者产生联系</li>
<li>Adaptee（适配者类）：适配者类作为被适配的角色，它定义了一个已经存在的功能接口(旧方法)，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码</li>
</ul>
<h2 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1587457070222-66c806e1-7d30-4d90-a205-b9c12643c754.png" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//已经存在的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adapteeRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;适配者的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//目标类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//适配器类模式，实现Target接口，继承Adaptee</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="comment">//Target接口中规定的方法，会被用户直接访问的</span></span><br><span class="line">    <span class="comment">//方法内部回调用Adaptee类的方法，所以起到了中转适配的作用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...一些操作...</span></span><br><span class="line">        <span class="keyword">super</span>.adapteeRequest();</span><br><span class="line">        <span class="comment">//...一些操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h2><ul>
<li>对象适配器与类适配器不同之处在于，类适配器通过继承来完成适配，对象适配器则是通过关联来完成</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1587457308209-31e42c9e-b26a-4a6a-bcf1-be0d0141f8c2.png" alt="image.png"></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="comment">// 适配者是对象适配器的一个属性</span></span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee = <span class="keyword">new</span> Adaptee();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        adaptee.adapteeRequest();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="适配器模式总结"><a href="#适配器模式总结" class="headerlink" title="适配器模式总结"></a>适配器模式总结</h2><p>优点：</p>
<ul>
<li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构</li>
<li>增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用</li>
<li>类适配器模式：由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强</li>
<li>对象适配器模式：一个对象适配器可以把多个不同的适配者适配到同一个目标，</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>类适配器模式：</p>
</li>
<li><ul>
<li>目标抽象类只能为接口，不能为类，有一定的局限性</li>
<li>Java只能单继承，类适配器模式中一次只能适配一个适配类(adaptee)</li>
</ul>
</li>
<li><p>对象适配器模式：</p>
</li>
<li><ul>
<li>与类适配器模式相比，要在适配器中置换适配者类的某些方法比较麻烦，没有子类那么方便</li>
</ul>
</li>
</ul>
<p>适用场景：</p>
<ul>
<li>系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要，甚至没有这些类的源代码</li>
</ul>
<h2 id="Spring中的适配器模式"><a href="#Spring中的适配器模式" class="headerlink" title="Spring中的适配器模式"></a>Spring中的适配器模式</h2><p>详见AOP模块</p>
<p>此处为语雀文档，点击链接查看：<a href="https://www.yuque.com/luka/note/aop#GMj1r">https://www.yuque.com/luka/note/aop#GMj1r</a></p>
<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>代理模式分为静态代理和动态代理</p>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>假设现在项目经理有一个需求：在项目现有所有类的方法前后打印日志。</p>
<p>如何在不修改已有代码的前提下，完成这个需求？</p>
<p>首先想到的是静态代理。具体做法是：</p>
<p>1.为现有的每一个类都编写一个对应的代理类，并且让它实现和目标类相同的接口（假设都有）</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1266758/1586510323777-262ad8b5-2cc2-4376-8109-057025883c6d.jpg" alt="image"></p>
<p>2.在创建代理对象时，通过<strong>构造器塞入一个目标对象</strong>，然后在<strong>代理对象的方法内部调用目标对象同名方法</strong>，并在<strong>调用前后打印日志</strong>。</p>
<p>   也就是说，代理对象 = 增强代码 + 目标对象（原对象）。有了代理对象后，就不用原对象了</p>
<p>   <img src="https://cdn.nlark.com/yuque/0/2020/jpg/1266758/1586510323900-47b5fb3f-65f3-48d3-b339-9532b54da2bb.jpg" alt="image"></p>
<h3 id="静态代理的缺陷"><a href="#静态代理的缺陷" class="headerlink" title="静态代理的缺陷"></a>静态代理的缺陷</h3><p><strong>程序员要手动为每一个目标类编写对应的代理类</strong>。如果当前系统已经有成百上千个类，工作量太大了。所以，现在我们的努力方向是：如何少写或者不写代理类，却能完成代理功能？</p>
<ul>
<li><strong>能否不写代理类，而直接得到代理Class对象，然后根据它创建代理实例（反射）。</strong></li>
</ul>
<p>Class对象包含了一个类的所有信息，比如构造器、方法、字段等。如果我们不写代理类，这些信息从哪获取呢？苦思冥想，突然灵光一现：代理类和目标类理应实现同一组接口。<strong>之所以实现相同接口，是为了尽可能保证代理对象的内部结构和目标对象一致，这样我们对代理对象的操作最终都可以转移到目标对象身上，代理对象只需专注于增强代码的编写</strong>。<strong>同时，代理类必须继承Proxy类，所以只能且必须和目标类实现同一组接口。</strong>所以，可以这样说：<strong>接口拥有代理对象和目标对象共同的类信息</strong>。所以，我们可以从接口那得到理应由代理类提供的信息。<strong>但是别忘了，接口是无法创建对象的，怎么办？</strong></p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>介绍动态代理前可以看看这个关于<a href="https://blog.csdn.net/zxysshgood/article/details/78684229">源码</a>的分析，还包括代理类的反汇编。</p>
<p>JDK提供了java.lang.reflect.InvocationHandler接口和 java.lang.reflect.Proxy类，这两个类相互配合，入口是Proxy，所以我们先聊它。</p>
<p><strong>Proxy有个静态方法：getProxyClass(ClassLoader, interfaces)，只要你给它传入类加载器和一组接口，它就给你返回代理Class对象</strong>。</p>
<p>用通俗的话说，<strong>getProxyClass()这个方法，会从你传入的接口Class中，“拷贝”类结构信息到一个新的Class对象中，但新的Class对象带有构造器，是可以创建对象的。</strong>打个比方，一个大内太监（接口Class），空有一身武艺（类信息），但是无法传给后人。现在江湖上有个妙手神医（Proxy类），发明了克隆大法（getProxyClass），不仅能克隆太监的一身武艺，还保留了小DD（构造器）…</p>
<p>所以，一旦我们明确接口，完全可以通过接口的Class对象，创建一个代理Class，通过代理Class即可创建代理对象。</p>
<p>所以，按我理解，Proxy.getProxyClass()这个方法的本质就是：以Class造Class。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1266758/1586510323966-94f8f8dd-d037-47f9-8269-d6a988902966.jpg" alt="image"></p>
<h3 id="静态代理和动态代理的区别"><a href="#静态代理和动态代理的区别" class="headerlink" title="静态代理和动态代理的区别"></a>静态代理和动态代理的区别</h3><p>静态代理</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1266758/1586510324027-f6541a6c-3bf7-4ce9-9611-e830a4c78300.jpg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<p>动态代理</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1266758/1586510324122-a22bb377-9228-49ad-bb69-8e2617ff31b3.jpg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<h3 id="使用getProxyClass完成动态代理"><a href="#使用getProxyClass完成动态代理" class="headerlink" title="使用getProxyClass完成动态代理"></a>使用getProxyClass完成动态代理</h3><p>1.基于Calculator类和Calculator接口创建的calculatorProxyClazz代理class</p>
<p>2.获取代理Class的构造器</p>
<p>3.使用构造器创建一个代理对象(构造器的参数是InvocationHandler接口的对象)</p>
<p>4.InvocationHandler接口的对象必须重写invoke方法，实现对目标对象的增强</p>
<p>5.代理对象可调用的方法与目标对象的方法一致</p>
<p>6.每次调用代理对象的方式时，最终都会调用InvocationHandler的invoke()方法</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1266758/1586510324177-6989ebdc-44f7-4d49-beee-bd9f06407339.jpg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_14,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1266758/1586510324241-fdc9029c-5865-4f3d-b6db-cbe9857f2153.jpg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_14,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<ul>
<li>怎么实现的呢？</li>
</ul>
<p>上面说的根据代理Class的构造器创建对象时，需要传入InvocationHandler。<strong>通过构造器传入一个引用，那么必然有个成员变量去接收。</strong>代理对象内部有InvocationHandler的成员变量，变量名为h(继承自父类Proxy的)，而且代理对象的每个方法内部都会调用h.invoke()。InvocationHandler对象成了代理对象和目标对象的桥梁，不像静态代理这么直接。</p>
<ul>
<li>上面超链接的代理类反汇编：</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">printSomeThing</span><span class="params">(<span class="keyword">String</span> paramString)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">new</span> Object[] &#123; paramString &#125;);</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Error|RuntimeException localError) &#123;</span><br><span class="line">        <span class="keyword">throw</span> localError;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable localThrowable) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="静态代理和动态代理调用方法的区别"><a href="#静态代理和动态代理调用方法的区别" class="headerlink" title="静态代理和动态代理调用方法的区别"></a>静态代理和动态代理调用方法的区别</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1266758/1586510324286-8efc8def-4901-446a-8c1c-d50487b09c3f.jpg" alt="image"></p>
<p>仔细看上图右侧的动态代理，我在invocationHandler的invoke()方法中并没有写目标对象。因为一开始invocationHandler的invoke()里确实没有目标对象，需要我们手动new。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1266758/1586510324328-487f763e-6177-4955-a827-b62355826b16.jpg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_14,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<p>但这种写法不够优雅，属于硬编码。我这次代理A对象，下次想代理B对象还要进来改invoke()方法，太差劲了。改进一下，让调用者把目标对象作为参数传进来：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> ProxyTest &#123;</span><br><span class="line">        public static void main(String<span class="literal">[]</span> args) throws Throwable &#123;</span><br><span class="line">            CalculatorImpl target = <span class="keyword">new</span> <span class="constructor">CalculatorImpl()</span>;</span><br><span class="line">            <span class="comment">//传入目标对象</span></span><br><span class="line">            <span class="comment">//目的：1.根据它实现的接口生成代理对象 2.代理对象调用目标对象方法</span></span><br><span class="line">            Calculator calculatorProxy = (Calculator) get<span class="constructor">Proxy(<span class="params">target</span>)</span>;</span><br><span class="line">            calculatorProxy.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">            calculatorProxy.subtract(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span> static Object get<span class="constructor">Proxy(<span class="params">final</span> Object <span class="params">target</span>)</span> throws Exception &#123;</span><br><span class="line">        <span class="comment">//参数1：随便找个类加载器给它， 参数2：目标对象实现的接口，让代理对象实现相同接口</span></span><br><span class="line">        Class proxyClazz = <span class="module-access"><span class="module"><span class="identifier">Proxy</span>.</span></span>get<span class="constructor">ProxyClass(<span class="params">target</span>.<span class="params">getClass</span>()</span>.get<span class="constructor">ClassLoader()</span>, target.get<span class="constructor">Class()</span>.get<span class="constructor">Interfaces()</span>);</span><br><span class="line">        Constructor constructor = proxyClazz.get<span class="constructor">Constructor(InvocationHandler.<span class="params">class</span>)</span>;</span><br><span class="line">        Object proxy = constructor.<span class="keyword">new</span><span class="constructor">Instance(<span class="params">new</span> InvocationHandler()</span> &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Object invoke(Object proxy, Method <span class="keyword">method</span>, Object<span class="literal">[]</span> args) throws Throwable &#123;</span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="keyword">method</span>.get<span class="constructor">Name()</span> + <span class="string">&quot;方法开始执行...&quot;</span>);</span><br><span class="line">                Object result = <span class="keyword">method</span>.invoke(target, args);</span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(result);</span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="keyword">method</span>.get<span class="constructor">Name()</span> + <span class="string">&quot;方法执行结束...&quot;</span>);</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return proxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>这样就非常灵活，非常优雅了。无论现在系统有多少类，只要你<strong>把实例传进来，getProxy()都能给你返回对应的代理对象</strong>。就这样，我们完美地跳过了代理类，直接创建了代理对象！</p>
<p>不过实际编程中，一般不用getProxyClass()，而是使用Proxy类的另一个静态方法：Proxy.newProxyInstance()，直接返回代理实例，连中间得到代理Class对象的过程都帮你隐藏：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> ProxyTest &#123;</span><br><span class="line">        <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) throws Throwable &#123;</span><br><span class="line">            CalculatorImpl target = <span class="built_in">new</span> CalculatorImpl();</span><br><span class="line">            Calculator calculatorProxy = (Calculator) getProxy(target);</span><br><span class="line">            calculatorProxy.<span class="keyword">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">            calculatorProxy.subtract(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        private static <span class="keyword">Object</span> getProxy(final <span class="keyword">Object</span> target) throws <span class="keyword">Exception</span> &#123;</span><br><span class="line">            <span class="keyword">Object</span> proxy = Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(),<span class="comment">/*类加载器*/</span></span><br><span class="line">                target.getClass().getInterfaces(),<span class="comment">/*让代理对象和目标对象实现相同接口*/</span></span><br><span class="line">                <span class="built_in">new</span> InvocationHandler()&#123;<span class="comment">/*代理对象的方法最终都会被JVM导向它的invoke方法*/</span></span><br><span class="line">                    <span class="built_in">public</span> <span class="keyword">Object</span> invoke(<span class="keyword">Object</span> proxy, <span class="keyword">Method</span> <span class="keyword">method</span>, <span class="keyword">Object</span>[] args) throws Throwable &#123;</span><br><span class="line">                        <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="keyword">method</span>.getName() + &quot;方法开始执行...&quot;);</span><br><span class="line">                        <span class="keyword">Object</span> result = <span class="keyword">method</span>.invoke(target, args);</span><br><span class="line">                        <span class="keyword">System</span>.<span class="keyword">out</span>.println(result);</span><br><span class="line">                        <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="keyword">method</span>.getName() + &quot;方法执行结束...&quot;);</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">return</span> proxy;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h3 id="动态代理总结"><a href="#动态代理总结" class="headerlink" title="动态代理总结"></a>动态代理总结</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1266758/1586510324382-164e0b9b-9a82-43fc-bdce-6bdcefa1a627.jpg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<p><strong>补充：InvocationHandler</strong></p>
<p>   0.Java动态代理机制中有两个重要的类和接口InvocationHandler（接口）和Proxy（类），这一个类Proxy和接口InvocationHandler是实现动态代理的核心</p>
<p>   1.InvocationHandler接口是proxy代理实例的调用处理程序实现的一个接口，每一个proxy代理实例都有一个关联的调用处理程序；在代理实例调用方法时，方法调用被编码分派到调用处理程序的invoke方法</p>
<p>   <img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1586510324427-b0de2672-f514-45e1-bb7d-0fc95a53396a.png" alt="image"></p>
<p>   2.<strong>每一个动态代理类的调用处理程序都必须实现InvocationHandler接口</strong>，<strong>并且每个代理类的实例都关联到了实现该接口的动态代理类调用处理程序中</strong>，当我们通过动态代理对象调用一个方法时候，这个方法的调用就会被转发到实现InvocationHandler接口类的invoke方法来调用</p>
<p>   <strong>代理对象中拥有原对象的所有方法，这些方法只少有一行，使用InvocationHandler对象h调用invoke的语句，具体的增强和调用原对象的对应方法由InvocationHandler实现类完成：</strong></p>
<p>​     <img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1586510324464-81e23b07-3745-4808-8035-f163a6540dcf.png" alt="image"></p>
<p>​     调用invoke是会携带Method信息，invoke会在增强中调用原方法</p>
<p>   3.<strong>Proxy类</strong>就是用来<strong>创建一个代理对象的类</strong>，它提供了很多方法，但是我们最常用的是newProxyInstance方法</p>
<h3 id="动态代理的应用"><a href="#动态代理的应用" class="headerlink" title="动态代理的应用"></a>动态代理的应用</h3><ul>
<li>Spring AOP</li>
<li>RPC框架 Dubbo</li>
<li>断路器 Spring Cloud Hystrix</li>
<li>Mock单元测试</li>
</ul>
<h1 id="适配器模式和代理模式的区别"><a href="#适配器模式和代理模式的区别" class="headerlink" title="适配器模式和代理模式的区别"></a>适配器模式和代理模式的区别</h1><ul>
<li>适配器模式：本质上是将一个旧接口换成一个新接口，对原有方法进行增强，用户调用时调用新接口的方法。原接口功能由新接口实现类进行调用</li>
<li>代理模式：代理模式没有产生新接口，而是实现了原接口，并且返回一个代理对象给调用者。而CGLIB创建子类代理对象的方法也是一样，用的还是原来的接口</li>
<li>目的不完全一样：除了都能原有功能进行增强外，适配器模式初心是旧接口不满足需求，使用适配器完成新旧接口的转换，而代理模式是为了不让用户直接接触原对象，返回一个代理对象给用户调用</li>
</ul>
<h2 id="适配器模式示意图"><a href="#适配器模式示意图" class="headerlink" title="适配器模式示意图"></a>适配器模式示意图</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1266758/1587472095548-2b6da71c-9bec-4cbd-bf11-a67d74f8122e.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="1.jpg"></p>
<h2 id="代理模式示意图"><a href="#代理模式示意图" class="headerlink" title="代理模式示意图"></a>代理模式示意图</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1266758/1587472117679-1440a002-1ad3-4173-ad0c-3918c0e4ee38.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="2.jpg"></p>
<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><ul>
<li>策略模式：策略模式是对算法的包装，把使用算法的责任和算法本身分隔开，委派给不同的对象管理。策略模式通常把一系列的算法包装到一系列的策略类里面，作为一个抽象策略类的子类</li>
<li>主要解决：在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护</li>
<li>使用时机：一个系统有多个类，而区分它们的只是他们直接的行为</li>
<li>解决方式：将这些算法封装成一个一个的类，任意地替换</li>
<li>关键特点：实现同一个接口</li>
<li>优点：1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好</li>
</ul>
<h2 id="Spring中的策略模式"><a href="#Spring中的策略模式" class="headerlink" title="Spring中的策略模式"></a>Spring中的策略模式</h2><h3 id="实例化的策略模式"><a href="#实例化的策略模式" class="headerlink" title="实例化的策略模式"></a>实例化的策略模式</h3><ul>
<li><p>Spring实例化Bean时会判断设置的哪种实例化策略：getInstantiationStrategy()方法，而setInstantiationStrategy()方法是public的可以由用户选择实例化策略。默认的是Cglib方式实例化，但是如果没使用方法注入则仍然使用JDK方式初始化</p>
</li>
<li><p>实例化策略有两种</p>
</li>
<li><ul>
<li>一种使用JDK的反射原理实例化对象——BeanUtils.<em>instantiateClass</em>(constructorToUse)</li>
<li>另一种是使用CGLIB生成Bean的子类对象——instantiateWithMethodInjection(bd, beanName, owner)</li>
</ul>
</li>
<li><p>策略选择点：</p>
</li>
<li><ul>
<li>createBean()–&gt;doCreateBean()–&gt;createBeanInstance–&gt;instantiateBean–&gt;SimpleInstantiationStrategy类instantiate()的↓：</li>
<li>方法中的策略选择语句：if (!bd.hasMethodOverrides()) {…}</li>
<li>根据SimpleInstantiationStrategy类中的instantiateWithMethodInjection()是否被CGLIB重写，而选择调用JDK方式还是CGLIB方式</li>
<li>在使用<strong>方法注入</strong>的时候会才会使用CglibxxxStrategy中的实例化方法，平时只会使用JDK方式实例化</li>
</ul>
</li>
<li><p>类关系图：级联结构和下面的不同</p>
</li>
<li><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1587539451277-a95ec07e-d64b-4cff-b814-54a6cbdebc19.png" alt="image.png"></li>
</ul>
</li>
</ul>
<h3 id="代理方式的策略模式"><a href="#代理方式的策略模式" class="headerlink" title="代理方式的策略模式"></a>代理方式的策略模式</h3><ul>
<li><p>Spring AOP会根据被代理对象是否有接口而选择使用JdkDynamicAopProxy类/CglibAopProxy类的算法创建代理对象</p>
</li>
<li><p>策略选择点：</p>
</li>
<li><ul>
<li>DefaultAopProxyFactory类中createAopProxy()方法的语句↓(详见<a href="https://www.yuque.com/luka/note/aop#MhJYj">堆栈调用图</a>)：</li>
<li>如果targetClass有接口则使用JDK的方式创建代理对象，否则使用CGLIB的方式创建代理对象</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1587538194215-abb3832d-a485-4926-9a70-18392f6c60a1.png" alt="image.png"></li>
</ul>
</li>
<li><p>类结构图：</p>
</li>
<li><ul>
<li>两种策略都实现AopProxy接口，是策略模式的特点之一</li>
<li>策略模式中的并列实现接口，而实例化中的策略模式是级联的方式，其中一种策略间接实现接口</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1587537883215-343a7ac1-4a41-45e7-a6cd-c982341c6f9c.png" alt="image.png"></li>
</ul>
</li>
</ul>
<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li><p>当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象</p>
</li>
<li><p><strong>意图：</strong>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新</p>
</li>
<li><p><strong>主要解决：</strong>一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作</p>
</li>
<li><p><strong>何时使用：</strong>一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知</p>
</li>
<li><p><strong>如何解决：</strong>使用面向对象技术，可以将这种依赖关系弱化</p>
</li>
<li><p><strong>关键代码：</strong>在抽象类里有一个 ArrayList 存放观察者们</p>
</li>
<li><p><strong>优点：</strong></p>
</li>
<li><ul>
<li>观察者和被观察者是抽象耦合的</li>
<li>建立一套触发机制</li>
</ul>
</li>
<li><p><strong>缺点：</strong></p>
</li>
<li><ul>
<li>如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间</li>
<li>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃</li>
<li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化</li>
</ul>
</li>
<li><p><strong>使用场景：</strong></p>
</li>
<li><ul>
<li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用</li>
<li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度</li>
<li>一个对象必须通知其他对象，而并不知道这些对象是谁</li>
<li>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制</li>
</ul>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul>
<li>观察者模式使用三个类 Subject、Observer 和 Client</li>
<li>Subject 对象带有绑定观察者到 Client 对象和从 Client 对象解绑观察者的方法</li>
<li>创建 <em>Subject</em> 类、<em>Observer</em> 抽象类和扩展了抽象类 <em>Observer</em> 的实体类</li>
<li>被观察的Subject有所有观察者的对象，而每一个观察者都有被观察的Subject对象</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1266758/1598419382702-5c19c784-9c9c-4c45-be04-e825b23b564e.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></li>
<li>Subject类</li>
</ul>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"> </span><br><span class="line">public class Subject &#123;</span><br><span class="line">   </span><br><span class="line">   private List<span class="variable">&lt;Observer&gt;</span> observers </span><br><span class="line">      = new ArrayList<span class="variable">&lt;Observer&gt;</span>();</span><br><span class="line">   private int <span class="keyword">state</span>;</span><br><span class="line"> </span><br><span class="line">   public int getState() &#123;</span><br><span class="line">      return <span class="keyword">state</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   //状态变化，通知所有观察者</span><br><span class="line">   public void <span class="built_in">set</span>State(int <span class="keyword">state</span>) &#123;</span><br><span class="line">      this.<span class="keyword">state</span> = <span class="keyword">state</span>;</span><br><span class="line">      notifyAllObservers();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void attach(Observer observer)&#123;</span><br><span class="line">      observers.add(observer);      </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void notifyAllObservers()&#123;</span><br><span class="line">      <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">         observer.update();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Observer抽象类和实现类</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">   <span class="keyword">protected</span> <span class="type">Subject</span> subject;</span><br><span class="line">   public <span class="keyword">abstract</span> void update();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">BinaryObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">   public <span class="type">BinaryObserver</span>(<span class="type">Subject</span> subject)&#123;</span><br><span class="line">      <span class="keyword">this</span>.subject = subject;</span><br><span class="line">      <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   public void update() &#123;</span><br><span class="line">      <span class="type">System</span>.out.println( <span class="string">&quot;Binary String: &quot;</span> </span><br><span class="line">      + <span class="type">Integer</span>.toBinaryString( subject.getState() ) ); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">HexaObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">   public <span class="type">HexaObserver</span>(<span class="type">Subject</span> subject)&#123;</span><br><span class="line">      <span class="keyword">this</span>.subject = subject;</span><br><span class="line">      <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   public void update() &#123;</span><br><span class="line">      <span class="type">System</span>.out.println( <span class="string">&quot;Hex String: &quot;</span> </span><br><span class="line">      + <span class="type">Integer</span>.toHexString( subject.getState() ).toUpperCase() ); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用观察者观察Subject</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> ObserverPatternDemo &#123;</span><br><span class="line">   public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">      Subject subject = <span class="keyword">new</span> <span class="constructor">Subject()</span>;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">new</span> <span class="constructor">HexaObserver(<span class="params">subject</span>)</span>;</span><br><span class="line">      <span class="keyword">new</span> <span class="constructor">BinaryObserver(<span class="params">subject</span>)</span>;</span><br><span class="line"> </span><br><span class="line">      <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;First state change: 15&quot;</span>);   </span><br><span class="line">      subject.set<span class="constructor">State(15)</span>;</span><br><span class="line">      <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;Second state change: 10&quot;</span>);  </span><br><span class="line">      subject.set<span class="constructor">State(10)</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h1><h2 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构</li>
<li><strong>意图：</strong>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活</li>
<li><strong>何时使用：</strong>在不想增加很多子类的情况下扩展类</li>
<li><strong>优点：</strong>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能</li>
<li><strong>缺点：</strong>多层装饰比较复杂</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ul>
<li><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1599488169556-29522580-220f-47c5-a4d4-78eb6c4b31fb.png" alt="image.png"></p>
</li>
<li><p>第一步：定义奶茶接口（Component）</p>
</li>
<li><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1599488027636-f9c6fea6-9991-4457-9894-553af7e53f52.png" alt="image.png"></li>
</ul>
</li>
<li><p>第二步：定义两种不同种类的奶茶：珍珠奶茶和蜂蜜奶茶（ConcreteComponent）</p>
</li>
<li><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1599488033817-6389b760-5800-4171-a7fe-3f64fcae004f.png" alt="image.png"></li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1599488041801-491feb30-1c2d-460f-88f6-8af578256d2c.png" alt="image.png"></li>
</ul>
</li>
<li><p>第三步：定义口味</p>
</li>
<li><ul>
<li>装饰类的抽象方法，实现同样的接口</li>
<li>也可以不用抽象类，用抽象类方便实现多个装饰类</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Taste</span> <span class="keyword">implements</span> <span class="title">MilkTea</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">milkTeaName</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">milkTeaPrice</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第四步：具体的装饰类：具体口味（ConcreteDecorator）：加冰和加咖啡</p>
</li>
<li><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1599488640555-e9a632f6-7aee-419b-94c4-5a5af25fe5f8.png" alt="image.png"></li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1599488665640-b07a4f7f-f182-4ec3-a5ca-fa565223df75.png" alt="image.png"></li>
</ul>
</li>
<li><p>第五步：使用：用户买奶茶</p>
</li>
<li><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1599488710347-5ebaa282-dcb5-42c8-a385-ad8066bb26e1.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image.png"></li>
</ul>
</li>
</ul>
<h1 id="装饰器模式和代理模式的区别"><a href="#装饰器模式和代理模式的区别" class="headerlink" title="装饰器模式和代理模式的区别"></a>装饰器模式和代理模式的区别</h1><ol>
<li>对装饰器模式来说，装饰者（Decorator）和被装饰者（Decoratee）都实现一个接口。对代理模式来说，代理类（Proxy Class）和真实处理的类（Real Class）都实现同一个接口</li>
<li>不论我们使用哪一个模式，都可以很容易地在真实对象的方法前面或者后面加上自定义的方法</li>
<li>上面的例子中，装饰器模式是使用的调用者从外部传入的被装饰对象（coffee），调用者只想要你把他给你的对象装饰（加强）一下。而代理模式使用的是代理对象在自己的构造方法里面new的一个被代理的对象，不是调用者传入的。代理模式中，调用者不需要也不知道是否有其他实现类</li>
<li>装饰器模式关注于在一个对象上动态地添加方法，而代理模式关注于控制对对象的访问。换句话说，用代理模式，代理类可以对它的客户隐藏一个对象的具体信息。因此当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例；当使用装饰器模式的时候，我们通常的做法是将原始对象作为一个参数传给装饰器的构造器</li>
<li>装饰器模式和代理模式的使用场景不一样，比如IO流使用的是装饰者模式，可以层层增加功能。而代理模式则一般是用于增加特殊的功能，有些动态代理不支持多层嵌套</li>
<li>代理更多的是强调对对象的访问控制，而装饰器更多的强调给对象加强功能</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java核心技术36讲</title>
    <url>/2020/10/14/0000.JAVA%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF36%E8%AE%B2/</url>
    <content><![CDATA[<h4 id="谈谈你对Java平台的理解-“Java是解释执行”-这句话正确吗"><a href="#谈谈你对Java平台的理解-“Java是解释执行”-这句话正确吗" class="headerlink" title="谈谈你对Java平台的理解?“Java是解释执行”,这句话正确吗?"></a>谈谈你对Java平台的理解?“Java是解释执行”,这句话正确吗?</h4><ul>
<li>一次编译、到处运行”说的是Java语言跨平台的特性,Java的跨平台特性与Java虚拟机的存在密不可分,可在不同的环境中运行。比如说Windows平台和Linux平台都有相应的JDK,安装 好JDK后也就有了Java语言的运行环境。其实Java语言本身与其他的编程语言没有特别大的差异,并不是说Java语言可以跨平台,而是在不同的平台都有可以让Java语言运行的环境而已,所以 才有了Java一次编译,到处运行这样的效果。</li>
<li>程序从源代码到运行的三个阶段:编码——编译——运行——调试。Java在编译阶段则体现了跨平台的特点。编译过程大概是这样的:首先是将Java源代码转化成.CLASS文件字节码,这是第 一次编译。.class文件就是可以到处运行的文件。然后Java字节码会被转化为目标机器代码,这是是由JVM来执行的,即Java的第二次编译。</li>
<li>Java是解析运行吗? 不正确! Java源代码经过Javac编译成.class文件 .class文件经JVM解析或编译运行。</li>
</ul>
<h4 id="Exception和Error有什么区别"><a href="#Exception和Error有什么区别" class="headerlink" title="Exception和Error有什么区别?"></a>Exception和Error有什么区别?</h4><ul>
<li><code>Exception</code>和<code>Error</code>都是继承了<code>Throwable</code>类,在Java中只有<code>Throwable</code>类型的实例才可以被抛出(throw)或者捕获(catch),它是异常处理机制的基本组成类型。</li>
<li><code>Exception</code>是程序正常运行中,可以预料的意外情况,可能并且应该被捕获,进行相应处理。</li>
<li><code>Error</code>是指在正常情况下,不大可能出现的情况,绝大部分的Error都会导致程序(比如JVM自身)处于非正常的、不可恢复状态。既然是非正常情况,所以不便于也不需要捕获,常 见的比如<code>OutOfMemoryError</code>之类,都是<code>Error</code>的子类。</li>
<li><code>Exception</code>又分为<code>可检查(checked)</code>异常和<code>不检查(unchecked)</code>异常,可检查异常在源代码里必须显式地进行捕获处理,这是编译期检查的一部分</li>
<li>不检查异常就是所谓的运行时异常,类似 <code>NullPointerException</code>、<code>ArrayIndexOutOfBoundsException</code>之类,通常是可以编码避免的逻辑错误,具体根据需要来判断是否需要捕 获,并不会在编译期强制要求。<br><img src="https://img-blog.csdnimg.cn/20190406111450760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70"><blockquote>
<p><code>异常处理的基本原则</code>:<br>尽量不要捕获类似Exception这样的通用异常,而是应该捕获特定异常<br>不要生吞(swallow)异常。这是异常处理中要特别注意的事情,因为很可能会导致非常难以诊断的诡异情况。</p>
</blockquote>
</li>
</ul>
<h4 id="谈fnal、fnally、-fnalize有什么不同"><a href="#谈fnal、fnally、-fnalize有什么不同" class="headerlink" title="谈fnal、fnally、 fnalize有什么不同?"></a>谈fnal、fnally、 fnalize有什么不同?</h4><ul>
<li><code>fnal</code>可以用来修饰类、方法、变量,分别有不同的意义,<code>fnal</code>修饰的<code>class</code>代表不可以继承扩展,fnal的变量是不可以修改的,而fnal的方法也是不可以重写的(override)。</li>
<li><code>fnally</code>则是Java保证重点代码一定要被执行的一种机制。我们可以使用try-fnally或者try-catch-fnally来进行类似关闭JDBC连接、保证unlock锁等动作。</li>
<li><code>fnalize</code>是基础类java.lang.Object的一个方法,它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。fnalize机制现在已经不推荐使用,并且在JDK 9开始被标记 为deprecated。</li>
</ul>
<h4 id="强引用、软引用、弱引用、幻象引用有什么区别"><a href="#强引用、软引用、弱引用、幻象引用有什么区别" class="headerlink" title="强引用、软引用、弱引用、幻象引用有什么区别?"></a>强引用、软引用、弱引用、幻象引用有什么区别?</h4><ul>
<li><code>强引用</code>:我们平常典型编码Object obj = new Object()中的obj就是强引用。通过关键字new创建的对象所关联的引用就是强引用。 当JVM内存空间不足,JVM宁愿抛出OutOfMemoryError运 行时错误(OOM),使程序异常终止,也不会靠随意回收具有强引用的“存活”对象来解决内存不足的问题。对于一个普通的对象,如果没有其他的引用关系,只要超过了引用的作用域或者显式 地将相应(强)引用赋值为 null,就是可以被垃圾收集的了,具体回收时机还是要看垃圾收集策略。</li>
<li><code>软引用</code>:软引用通过<code>SoftReference</code>类实现。 软引用的生命周期比强引用短一些。只有当 JVM 认为内存不足时,才会去试图回收软引用指向的对象:即JVM 会确保在抛出 OutOfMemoryError 之前,清理软引用指向的对象。软引用可以和一个引用队列(ReferenceQueue)联合使用,如果软引用所引用的对象被垃圾回收器回收,Java虚拟机就会把这个软引用加入到与之关联的引用 队列中。后续,我们可以调用ReferenceQueue的poll()方法来检查是否有它所关心的对象被回收。如果队列为空,将返回一个null,否则该方法返回队列中前面的一个Reference对象</li>
<li><code>弱引用</code> 弱引用通过WeakReference类实现。 弱引用的生命周期比软引用短。在垃圾回收器线程扫描它所管辖的内存区域的过程中,一旦发现了具有弱引用的对象,不管当前内存空间足够与否,都会 回收它的内存。由于垃圾回收器是一个优先级很低的线程,因此不一定会很快回收弱引用的对象。弱引用可以和一个引用队列(ReferenceQueue)联合使用,如果弱引用所引用的对象被垃圾 回收,Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。弱应用同样可用于内存敏感的缓存。</li>
<li><code>幻象引用</code>,有时候也翻译成虚引用,你不能通过它访问对象。幻象引用仅仅是提供了一种确保对象被fnalize以后,做某些事情的机制。如果 一个对象仅持有虚引用,那么它就和没有任何引用一样,在任何时候都可能被垃圾回收器回收。虚引用必须和引用队列 (ReferenceQueue)联合使用。当垃圾回收器准备回收一个对象时,如 果发现它还有虚引用,就会在回收对象的内存之前,把这个虚引用加入到与之关联的引用队列中。</li>
</ul>
<h4 id="String、StringBufer、StringBuilder有什么区别"><a href="#String、StringBufer、StringBuilder有什么区别" class="headerlink" title="String、StringBufer、StringBuilder有什么区别?"></a>String、StringBufer、StringBuilder有什么区别?</h4><ul>
<li><code>String</code>被声明成为fnal class,所有属性也都是fnal的。也由于它的不可 变性,类似拼接、裁剪字符串等动作,都会产生新的String对象。Java为了避免在一个系统中产生大量的String对象,引入了字符串常量池，创建一个字符串时,首先检查池中是否有值相同的字符串对 象,如果有则不需要创建直接从池中刚查找到的对象引用;如果没有则新建字符串对象,返回对象引用,并且将新创建的对象放入池中。但是,通过new方法创建的String对象是不检查字符串 池的,而是直接在堆区或栈区创建一个新的对象,也不会把对象放入池中。上述原则只适用于通过直接量给String对象引用赋值的情况。<code>String</code>提供了<code>inter</code>()方法。调用该方法时,如果常量池中包括了一个等于此String对象的字符串(<code>由equals方法确定</code>),则返回池中的字符串。否则,将此String对象添加到池中,并且 返回此池中对象的引用</li>
<li><code>StringBufer和StringBuilde</code>r都实现了<code>AbstractStringBuilder</code>抽象类,拥有几乎一致对外提供的调用接口;其底层在内存中的存储方式与String相同,都是以一个有序的字符序列(char类型 的数组)进行存储,不同点是<code>StringBufer/StringBuilder</code>对象的<code>值是可以改变</code>的,并且值改变以后,对象引用不会发生改变;两者对象在构造过程中,首先按照默认大小申请一个字符数组,由 于会不断加入新数据,<code>当超过默认大小后</code>,会创建一个更大的数组,并将原先的数组内容复制过来,再丢弃旧的数组。因此,对于较大对象的扩容会涉及大量的内存复制操作,如果能够预先评 估大小,可提升性能。</li>
<li>唯一需要注意的是:<code>StringBufer是线程安全</code>的,但是<code>StringBuilder</code>是<code>线程不安全</code>的。可参看Java标准类库的源代码,<code>StringBufer</code>类中方法定义前面都会有<code>synchronize</code>关键字。为 此,StringBufer的性能要远低于StringBuilder。</li>
</ul>
<h4 id="谈谈Java反射机制-动态代理是基于什么原理"><a href="#谈谈Java反射机制-动态代理是基于什么原理" class="headerlink" title="谈谈Java反射机制,动态代理是基于什么原理"></a>谈谈Java反射机制,动态代理是基于什么原理</h4><ul>
<li><code>反射机制</code>是Java语言提供的一种基础功能,赋予程序在运行时自省(introspect,官方用语)的能力。通过反射我们可以直接操作类或者对象,比如获取某个对象的类定义,获取类 声明的属性和方法,调用方法或者构造对象,甚至可以运行时修改类定义。</li>
<li><code>动态代理</code>是一种方便运行时动态构建代理、动态处理代理方法调用的机制,很多场景都是利用类似机制做到的,比如用来包装RPC调用、面向切面的编程(AOP)。</li>
<li><code>JDK</code>动态代理:基于Java反射机制实现,必须要实现了接口的业务类才能用这种办法生成代理对象。新版本也开始结合ASM机制。</li>
<li><code>cglib</code>动态代理:基于ASM机制实现,通过生成业务类的子类作为代理类。</li>
</ul>
<h4 id="int和Integer有什么区别-谈谈Integer的值缓存范围。"><a href="#int和Integer有什么区别-谈谈Integer的值缓存范围。" class="headerlink" title="int和Integer有什么区别?谈谈Integer的值缓存范围。"></a>int和Integer有什么区别?谈谈Integer的值缓存范围。</h4><ul>
<li><code>int</code>是我们常说的整形数字,是Java的8个原始数据类型(Primitive Types,boolean、byte 、short、char、int、foat、double、long)之一。Java语言虽然号称一切都是对象, 但原始数据类型是例外。</li>
<li><code>Integer</code>是int对应的包装类,它有一个int类型的字段存储数据,并且提供了基本操作,比如数学运算、int和字符串之间转换等。在Java 5中,引入了自动装箱和自动拆箱功能 (boxing/unboxing),Java可以根据上下文,自动进行转换,极大地简化了相关编程。</li>
<li>Integer的值默认缓存 是-128到127之间。缓存上限值实际是可以根据需要调整的,JVM提供了参数设置: <code>-XX:AutoBoxCacheMax=N</code>。</li>
<li>不管是Integer还Boolean等,都被声明为“private fnal”,所以,它们同样是不可变类型!</li>
</ul>
<h4 id="对比Vector、ArrayList、LinkedList有何区别"><a href="#对比Vector、ArrayList、LinkedList有何区别" class="headerlink" title="对比Vector、ArrayList、LinkedList有何区别?"></a>对比Vector、ArrayList、LinkedList有何区别?</h4><ul>
<li><code>Vector</code>是线程安全的动态数组,。<code>Vector</code>内部是使用对象数组来保存数据,可以根据需要自动增加 容量,当数组已满时,会创建新的数组,并拷贝原有数组数据。Vector在扩容时会<code>提高1倍</code></li>
<li><code>ArrayList</code>是动态数组实现,不是线程安全的,性能要好很多。与Vector近似,ArrayList也是可以根据需要调整容量,不过两者的调整逻辑有所区 别。ArrayList扩容时是增加50%。</li>
<li><code>Vector和ArrayList作为动态数组</code>,其内部元素以数组形式顺序存储的,所以非常适合随机访问的场合。除了尾部插入和删除元素,往往性能会相对较差,比如我们在中间位置插 入一个元素,需要移动后续所有元素。</li>
<li><code>LinkedList</code>是Java提供的双向链表,它不需要像上面两种那样调整容量,也不是线程安全的。LinkedList进行节点插入、删除却要高效得多,但是随机访问性能则要比动态数组慢。<blockquote>
<p><code>TreeSet</code> 支持自然顺序访问,但是添加、删除、包含等操作要相对低效(log(n)时间)。<br><code>HashSet</code>则是利用哈希算法,理想情况下,如果哈希散列正常,可以提供常数时间的添加、删除、包含等操作,但是它不保证有序。<br><code>LinkedHashSet</code>,内部构建了一个记录插入顺序的双向链表,因此提供了按照插入顺序遍历的能力,与此同时,也保证了常数时间的添加、删除、包含等操作,这些操作性能略 低于HashSet,因为需要维护链表的开销。<br>在遍历元素时,<code>HashSet</code>性能受自身容量影响,所以初始化时,除非有必要,不然不要将其背后的HashMap容量设置过大。而对于LinkedHashSet,由于其内部链表提供的方便,遍历性能只和元素多少有关系。<br><code>Java提供的默认排序算法</code>:<br>对于原始数据类型,目前使用的是所谓双轴快速排序,是一种改进的快速排序算法,早期版本是相对传统的快速排序<br>对于对象数据类型,目前则是使用TimSort,思想上也是一种归并和二分插入排序结合的优化排序算法</p>
</blockquote>
</li>
</ul>
<h4 id="对比Hashtable、HashMap、TreeMap-有什么不同"><a href="#对比Hashtable、HashMap、TreeMap-有什么不同" class="headerlink" title="对比Hashtable、HashMap、TreeMap 有什么不同?"></a>对比Hashtable、HashMap、TreeMap 有什么不同?</h4><ul>
<li><code>元素特性</code>：HashTable 中的key、value都不能为null;HashMap中的key、value可以为null,很显然只能有一个key为null的键值对,但是允许有多个值为null的键值对;TreeMap 中当未实现 Comparator 接口时,key 不可以为null;当实现 Comparator 接口时,若未对null情况进行判断,则key不可以为null,反之亦然。</li>
<li><code>顺序特性</code>：HashTable 、HashMap具有无序特性。TreeMap 是利用红黑树来实现的(树中的每个节点的值,都会大于或等于它的左子树种的所有节点的值,并且小于或等于它的右子树中的所有节点的 值),实现了SortMap接口,能够对保存的记录根据键进行排序。所以一般需要排序的情况下是选择TreeMap 来进行,默认为升序排序方式(深度优先搜索),可自定义实现Comparator接口 实现排序方式。</li>
<li><code>初始化与增长方式</code>：初始化时:HashTable 在不指定容量的情况下的默认容量为11,且不要求底层数组的容量一定要为2的整数次幂;HashMap默认容量为16,且要求容量一定为2的整数次幂。 扩容时:Hashtable将容量变为原来的2倍加1;HashMap扩容将容量变为原来的2倍。</li>
<li><code>HashMap</code>基于哈希思想,实现对数据的读写。当我们将键值对传递给<code>put()</code>方法时,它调用<code>键对象的hashCode()</code>方法来计算<code>hashcode</code>,然后找到<code>bucket</code>位置来储存值对象。当获取对象时, 通过键对象的<code>equals()方法找到正确的键值对,然后返回值对象</code>。HashMap使用<code>链表来解决碰撞问题</code>,当发生碰撞了,对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存 键值对对象。当两个不同的键对象的hashcode相同时,它们会储存在同一个bucket位置的链表中,可通过键对象的equals()方法用来找到键值对。如果链表大小超过阈值 ( 8),链表就会被改造为树形结构(红黑树)。</li>
</ul>
<blockquote>
<p>解决哈希冲突有哪些典型方法呢?<br><code>开放定址法</code>：当关键字key的哈希地址p=H(key)出现冲突时,以p为基础,产生另一个哈希地址p1,如果p1仍然冲突,再以p为基础,产生另一个哈希地址p2,…,直到找出一个不冲突的哈 希地址pi ,将相应元素存入其中。<br><code>再哈希法</code>：当哈希地址Hi=RH1(key)发生冲突时,再计算Hi=RH2(key)……,直到冲突不再产生。这种方法不易产生聚集,但增加了计算时间。<br><code>链地址法</code>：这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表,并将单链表的头指针存在哈希表的第i个单元中,因而查找、插入和删除主要在同义词链中进行。链地址法适用 于经常进行插入和删除的情况。</p>
</blockquote>
<h4 id="Java提供了哪些IO方式-NIO如何实现多路复用"><a href="#Java提供了哪些IO方式-NIO如何实现多路复用" class="headerlink" title="Java提供了哪些IO方式? NIO如何实现多路复用?"></a>Java提供了哪些IO方式? NIO如何实现多路复用?</h4><ul>
<li><code>传统的java.io包,它基于流模型实现</code>,提供了我们最熟知的一些IO功能,比如File抽象、输入输出流等。交互方式是同步、阻塞的方式。</li>
<li>很多时候,人们也把java.net下面提供的部分网络API,比如Socket、ServerSocket、HttpURLConnection也归类到同步阻塞IO类库,因为网络通信同样是IO行为。</li>
<li><code>在Java 1.4中引入了NIO框架(java.nio包)</code>,提供了Channel、Selector、Bufer等新的抽象,可以构建多路复用的、<code>同步非阻塞IO程序</code>,同时提供了更接近操作系统底层 的高性能数据操作方式。</li>
<li><code>在Java 7中,NIO有了进一步的改进,也就是NIO 2</code>,引入了异<code>步非阻塞IO方式</code>,也有很多人叫它AIO(Asynchronous IO)。异步IO操作基于事件和回调机制,可以简单 理解为,应用操作直接返回,而不会阻塞在那里,当后台处理完成,操作系统会通知相应线程进行后续工作。</li>
</ul>
<blockquote>
<p><code>NIO多路复用的局限性是什么呢?</code><br>由于nio实际上是<code>同步非阻塞io</code>,是一个线程在同步的进行事件处理,当一组事channel处理完毕以后,去检查有没有又可以处理的channel。这也就是同步+非阻塞。同步,指每个准备好 的channel处理是依次进行的,非阻塞,是指线程不会傻傻的等待读。只有当channel准备好后,才会进行。那么就会有这样一个问题,当每个channel所进行的都是耗时操作时,由于是同步操 作,就会积压很多channel任务,从而完成影响。那么就需要对nio进行类似负载均衡的操作,如用线程池去进行管理读写,将channel分给其他的线程去执行,这样既充分利用了每一个线程,又不至于都堆积在一个线程中,等待执行</p>
</blockquote>
<h4 id="谈谈接口和抽象类有什么区别？"><a href="#谈谈接口和抽象类有什么区别？" class="headerlink" title="谈谈接口和抽象类有什么区别？"></a>谈谈接口和抽象类有什么区别？</h4><ul>
<li><code>接口</code>是对行为的抽象，它是抽象方法的集合，利用接口可以达到API定义和实现分离的目的。接口，不能实例化；不能包含任何非常量成员,同时，没有非静态方法实现，也就是说要么是抽象方法，要么是静态方法。 Java标准类库中，定义了非常多的接口，比如java.util.List。</li>
<li><code>抽象类</code>是不能实例化的类，用abstract关键字修饰class，其目的主要是代码重用。除了不能实例化，形式上和一般的Java类并没有太大区别，可以有一个或者多个抽象方法，也可<br>以没有抽象方法。抽象类大多用于抽取相关Java类的共用方法实现或者是共同成员变量，然后通过继承的方式达到代码复用的目的。 Java标准库中，比如collection框架，很多通用<br>部分就被抽取成为抽象类，例如java.util.AbstractList。</li>
</ul>
<blockquote>
<p>进行面向对象编程，掌握基本的设计原则是必须的，我今天介绍最通用的部分，也就是所谓的<code>S.O.L.I.D</code>原则。<br><code>单一职责</code>类或者对象最好是只有单一职责，在程序设计中如果发现某个类承担着多种义务，可以考虑进行拆分。<br><code>开关原则</code>设计要对扩展开放，对修改关闭。换句话说，程序设计应保证平滑的扩展性，尽量避免因为新增同类功能而修改已有实现，这样可以少产出些回归（regression）问题。<br><code>里氏替换</code>这是面向对象的基本要素之一，进行继承关系抽象时，凡是可以用父类或者基类的地方，都可以用子类替换。<br><code>接口分离</code>我们在进行类和接口设计时，如果在一个接口里定义了太多方法，其子类很可能面临两难，就是只有部分方法对它是有意义的，这就破坏了程序的内聚性。对于这种情况，可以通过拆分成功能单一的多个接口，将行为进行解耦。在未来维护中，如果某个接口设计有变，不会对使用其他接口的子类构成影响<br><code>依赖反转</code>实体应该依赖于抽象而不是实现。也就是说高层次模块，不应该依赖于低层次模块，而是应该基于抽象。实践这一原则是保证产品代码之间适当耦合度的法宝</p>
</blockquote>
<h4 id="谈谈你知道的设计模式？请手动实现单例模式，-Spring等框架中使用了哪些模式？"><a href="#谈谈你知道的设计模式？请手动实现单例模式，-Spring等框架中使用了哪些模式？" class="headerlink" title="谈谈你知道的设计模式？请手动实现单例模式， Spring等框架中使用了哪些模式？"></a>谈谈你知道的设计模式？请手动实现单例模式， Spring等框架中使用了哪些模式？</h4><ul>
<li>设计模式可以分为创建型模式、结构型模式和行为型模式。</li>
<li><code>创建型模式</code>，是对对象创建过程的各种问题和解决方案的总结，包括各种工厂模式（Factory、 Abstract Factory）、单例模式（Singleton）、构建器模式（Builder）、原型模式（ProtoType）。</li>
<li><code>结构型模式</code>，是针对软件设计结构的总结，关注于类、对象继承、组合方式的实践经验。常见的结构型模式，包括桥接模式（Bridge）、适配器模式（Adapter）、装饰者模式（Decorator）、代理模式（Proxy）、组合模式（Composite）、外观模式（Facade）、享元模式（Flyweight）等。</li>
<li><code>行为型模式</code>，是从类或对象之间交互、职责划分等角度总结的模式。比较常见的行为型模式有策略模式（Strategy）、解释器模式（Interpreter）、命令模式（Command）、观察者模式（Observer）、迭代器模式（Iterator）、模板方法模式（Template Method）、访问者模式（Visitor）。更多相关内容你可以参考：<a href="https://en.wikipedia.org/wiki/Design_Patterns">https://en.wikipedia.org/wiki/Design_Patterns</a></li>
</ul>
<blockquote>
<ul>
<li><code>InputStream</code>是一个抽象类，标准类库中提供了FileInputStream、 ByteArrayInputStream等各种不同的子类，分别从不同角度对InputStream进行了功能扩展，这是典型的装饰器模式应用案例。识别装饰器模式，可以通过识别类设计特征来进行判断，也就是其类构造函数以相同的抽象类或者接口为输入参数<br><code>创建型模式</code>尤其是工厂模式，在我们的代码中随处可见，我举个相对不同的API设计实践。比如， JDK最新版本中 HTTP/2 Client API，下面这个创建HttpRequest的过程，就是典型的构建器模式（Builder），通常会被实现成fuent风格的API，也有人叫它方法链。使用构建器模式，可以比较优雅地解决构建复杂对象的麻烦，这里的“复杂”是指类似需要输入的参数组合较多，如果用构造函数，我们往往需要为每一种可能的输入参数组合实现相应的构造函数，一系列复杂的构造函数会让代码阅读性和可维护性变得很差。</li>
</ul>
</blockquote>
<blockquote>
<p><code>Spring等如何在API设计中使用设计模式</code><br>BeanFactory和ApplicationContext应用了工厂模式<br>在Bean的创建中， Spring也为不同scope定义的对象，提供了单例和原型等模式实现。<br>AOP领域则是使用了代理模式、装饰器模式、适配器模式等。<br>各种事件监听器，是观察者模式的典型应用。<br>类似JdbcTemplate等则是应用了模板模式。</p>
</blockquote>
<h4 id="synchronized和ReentrantLock有什么区别？"><a href="#synchronized和ReentrantLock有什么区别？" class="headerlink" title="synchronized和ReentrantLock有什么区别？"></a>synchronized和ReentrantLock有什么区别？</h4><ul>
<li><code>synchronized</code>是Java内建的同步机制,它提供了互斥的语义和可见性，当一个线程已经获取当前锁时，其他试图获取的线程只能等待或者阻塞在那里。</li>
<li><code>ReentrantLock</code>，通常翻译为再入锁，是Java 5提供的锁实现，它的语义和synchronized基本相同。再入锁通过代码直接调用lock()方法获取，代码书写也更加灵活。与此同时， ReentrantLock提供了很多实用的方法，能够实现很多synchronized无法做到的细节控制，比如可以控制fairness，也就是公平性，或者利用定义条件等。但是，编码中也需要注意，必须要明确调用unlock()方法释放，不然就会一直持有该锁。</li>
</ul>
<h4 id="synchronized底层如何实现？什么是锁的升级、降级？"><a href="#synchronized底层如何实现？什么是锁的升级、降级？" class="headerlink" title="synchronized底层如何实现？什么是锁的升级、降级？"></a>synchronized底层如何实现？什么是锁的升级、降级？</h4><ul>
<li><code>synchronized</code>代码块是由一对儿<code>monitorenter/monitorexit</code>指令实现的， Monitor对象是同步的基本实现单元。在Java 6之前， Monitor的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作。现代的（Oracle） JDK中， JVM对此进行了大刀阔斧地改进，提供了三种不同的Monitor实现，也就是常说的三种不同的锁：偏向锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。</li>
<li>所谓锁的升级、降级，就是JVM优化synchronized运行的机制，当JVM检测到不同的竞争状况时，会自动切换到适合的锁实现，这种切换就是锁的升级、降级。</li>
<li>当没有竞争出现时，<code>默认会使用偏斜锁</code>。 <code>JVM</code>会利用<code>CAS</code>操作，在对象头上的<code>Mark Word</code>部分设置线程ID，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁。这样做的假设是基于在很多应用场景中，大部分对象生命周期中最多会被一个线程锁定，使用偏斜锁可以降低无竞争开销。</li>
<li>如果有另外的线程试图锁定某个已经被偏斜过的对象， JVM就需要撤销（revoke）偏斜锁，并切换到轻量级锁实现。轻量级锁依赖CAS操作Mark Word来试图获取锁，如果重试成功，就使用普通的轻量级锁；否则，进一步升级为重量级锁。</li>
</ul>
<blockquote>
<p><code>你知道“自旋锁”是做什么的吗？它的使用场景是什么？</code><br><code>自旋锁</code>:竞争锁的失败的线程，并不会真实的在操作系统层面挂起等待，而是JVM会让线程做几个空循环(基于预测在不久的将来就能获得)，在经过若干次循环后，如果可以获得锁，那么进入临界区，如果还不能获得锁，才会真实的将线程在操作系统层面进行挂起。<br><code>适用场景</code>:自旋锁可以减少线程的阻塞，这对于锁竞争不激烈，且占用锁时间非常短的代码块来说，有较大的性能提升，因为自旋的消耗会小于线程阻塞挂起操作的消耗。如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用cpu做无用功，线程自旋的消耗大于线程阻塞挂起操作的消耗，造成cpu的浪费<br><code>在单核CPU上，自旋锁是无用</code>，因为当自旋锁尝试获取锁不成功会一直尝试，这会一直占用CPU，其他线程不可能运行，<br>同时由于其他线程无法运行，所以当前线程无法释放锁。</p>
</blockquote>
<h4 id="一个线程两次调用start-方法会出现什么情况？谈谈线程的生命周期和状态转移。"><a href="#一个线程两次调用start-方法会出现什么情况？谈谈线程的生命周期和状态转移。" class="headerlink" title="一个线程两次调用start()方法会出现什么情况？谈谈线程的生命周期和状态转移。"></a>一个线程两次调用start()方法会出现什么情况？谈谈线程的生命周期和状态转移。</h4><ul>
<li>Java的线程是不允许启动两次的，第二次调用必然会抛出IllegalThreadStateException，这是一种运行时异常，多次调用start被认为是编程错误。</li>
<li>新建（NEW），表示线程被创建出来还没真正启动的状态，可以认为它是个Java内部状态。</li>
<li>就绪（RUNNABLE），表示该线程已经在JVM中执行，当然由于执行需要计算资源，它可能是正在运行，也可能还在等待系统分配给它CPU片段，在就绪队列里面排队。</li>
<li>阻塞（BLOCKED），这个状态和我们前面两讲介绍的同步非常相关，阻塞表示线程在等待Monitor lock。比如，线程试图通过synchronized去获取某个锁，但是其他线程已经独占了，那么当前线程就会处于阻塞状态。</li>
<li>等待（WAITING），表示正在等待其他线程采取某些操作。一个常见的场景是类似生产者消费者模式，发现任务条件尚未满足，就让当前消费者线程等待（wait），另外的生产者线程去准备任务数据，然后通过类似notify等动作，通知消费线程可以继续工作了。 Thread.join()也会令线程进入等待状态。</li>
<li>计时等待（TIMED_WAIT），其进入条件和等待状态类似，但是调用的是存在超时条件的方法，比如wait或join等方法的指定超时版本</li>
</ul>
<h4 id="什么情况下Java程序会产生死锁-如何定位、修复"><a href="#什么情况下Java程序会产生死锁-如何定位、修复" class="headerlink" title="什么情况下Java程序会产生死锁?如何定位、修复?"></a>什么情况下Java程序会产生死锁?如何定位、修复?</h4><ul>
<li><code>死锁</code>是一种特定的程序状态,在实体之间,由于<code>循环依赖导致</code>彼此一直处于等待之中,没有任何个体可以继续前进。死锁不仅仅是在线程之间会发生,存在资源独占的进程之间同样也可能出现死锁。通常来说,我们大多是聚焦在多线程场景中的死锁,指两个或多个线程之间,由于互<code>相持有对方需要的锁</code>,而永久处于阻塞的状态。<br><img src="https://img-blog.csdnimg.cn/20190408224832820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70"></li>
<li><code>定位死锁</code>最常见的方式就是利用<code>jstack</code>等工具<code>获取线程栈</code>,然后定位互相之间的依赖关系,进而找到死锁。如果是比较明显的死锁,往往jstack等就能直接定位,类似JConsole甚至 可以在图形界面进行有限的死锁检测。</li>
<li>使用Java提供的标准管理API,ThreadMXBean,其直接就提供 fndDeadlockedThreads﻿()方法用于定位死锁。但是要注意的是,对线程进行快照本身是一个相对重量级的操作,还是要慎重选择频度和时机。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadMXBeanTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadMXBean mbean = ManagementFactory.getThreadMXBean();</span><br><span class="line"></span><br><span class="line">        Runnable dlCheck = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">long</span>[] threadIds = mbean.findDeadlockedThreads();</span><br><span class="line">                <span class="keyword">if</span> (threadIds != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ThreadInfo[] threadInfos = mbean.getThreadInfo(threadIds);</span><br><span class="line">                    System.out.println(<span class="string">&quot;Detected deadlock threads:&quot;</span>);</span><br><span class="line">                    <span class="keyword">for</span> (ThreadInfo threadInfo : threadInfos) &#123;</span><br><span class="line">                        System.out.println(threadInfo.getThreadName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ScheduledExecutorService scheduler =Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 稍等5秒,然后每10秒进行一次死锁扫描</span></span><br><span class="line">        scheduler.scheduleAtFixedRate(dlCheck, <span class="number">5L</span>, <span class="number">10L</span>, TimeUnit.SECONDS);</span><br><span class="line">        Test1  t=<span class="keyword">new</span> Test1();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                t.t1();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                t.t2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="class"><span class="keyword">class</span> <span class="title">Test1</span></span>&#123;</span><br><span class="line">        Object obj1=<span class="keyword">new</span> Object();</span><br><span class="line">        Object obj2=<span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">t1</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj1)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:    obj1--------&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (obj2)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;   obj2--------&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">t2</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj2)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;    t2  obj2--------&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (obj1)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;   t2  obj1--------&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如<code>何在编程中尽量预防死锁呢?</code><br>尽量避免使用多个锁,并且只有需要时才持有锁<br>如果必须使用多个锁,尽量设计好锁的获取顺序<br>使用带超时的方法,为程序带来更多可控性。<br><code>有时候并不是阻塞导致的死锁,只是某个线程进入了死循环,导致其他线程一直等待,这种问题如何诊断呢?</code><br>可以通过linux下top命令查看cpu使用率较高的java进程,进而用<code>top -Hp pid</code>查看该java进程下cpu使用率较高的线程。再用jstack命令查看线程具体调用情况,排查问题</p>
</blockquote>
<h4 id="Java并发包提供了哪些并发工具类？"><a href="#Java并发包提供了哪些并发工具类？" class="headerlink" title="Java并发包提供了哪些并发工具类？"></a>Java并发包提供了哪些并发工具类？</h4><ul>
<li>提供了比synchronized更加高级的各种同步结构，包括<code>CountDownLatch</code>、 <code>CyclicBarrier</code>、 <code>Semaphore</code>等。CountDownLatch，允许一个或多个线程等待某些操作完成。CyclicBarrier，一种辅助性的同步结构，允许多个线程等待到达某个屏障。Semaphore， Java版本的信号量实现，它通过控制一定数量的允许（permit）的方式，来达到限制通用资源访问的目的。</li>
<li>各种<code>线程安全的容器</code>，比如最常见的<code>ConcurrentHashMap</code>、有序的<code>ConcunrrentSkipListMap</code>，或者通过类似快照机制，实现线程安全的动态数组<code>CopyOnWriteArrayList</code>等。</li>
<li>各种<code>并发队列</code>实现，如各种<code>BlockedQueue</code>实现，比较典型的<code>ArrayBlockingQueue</code>、 <code>SynchorousQueue</code>或针对特定场景的<code>PriorityBlockingQueue</code>等。</li>
<li>强大的<code>Executor</code>框架，可以创建各种不同类型的线程池，调度任务运行等，绝大部分情况下，不再需要自己从头实现线程池和任务调度器。</li>
</ul>
<blockquote>
<p><code>你使用过类似CountDownLatch的同步结构解决实际问题吗？</code><br>一个页面有A,B,C三个网络请求，其中请求C需要请求A和请求B的返回数据作为参数，用过CountdownLatch解决。<br>需求是每个对象一个线程，分别在每个线程里计算各自的数据，最终等到所有线程计算完毕，我还需要将每个有共通的对象进行合并，所以用它很合适。</p>
</blockquote>
<h4 id="并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别？"><a href="#并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别？" class="headerlink" title="并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别？"></a>并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别？</h4><p><img src="https://img-blog.csdnimg.cn/20190409124720516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70" alt="线程安全队列一览"></p>
<ul>
<li><code>Concurrent</code>类型基于<code>lock-free</code>，在常见的多线程访问场景，一般可以提供较高吞吐量。而<code>LinkedBlockingQueue</code>内部则是<code>基于锁</code>，并提供了<code>BlockingQueue</code>的等待性方法。</li>
<li><code>ArrayBlockingQueue</code>是最典型的的有界队列，其内部以<code>fnal</code>的数组保存数据，数组的大小就决定了队列的边界，所以我们在创建ArrayBlockingQueue时，都要指定容量</li>
<li><code>LinkedBlockingQueue</code>，容易被<code>误解为无边界</code>，但其实其行为和内部代码都是<code>基于有界的逻辑实现</code>的，只不过如果我们没有在创建队列时就指定容量，那么其容量限制就自动被设置为<code>Integer.MAX_VALUE</code>，成为了无界队列。</li>
<li><code>SynchronousQueue</code>，这是一个非常奇葩的队列实现，每个删除操作都要等待插入操作，反之每个插入操作也都要等待删除动作。其内<code>部容量是0</code></li>
<li><code>PriorityBlockingQueue</code>是无边界的优先队列，虽然严格意义上来讲，其大小总归是要受系统资源影响</li>
<li><code>DelayedQueue</code>和<code>LinkedTransferQueue</code>同样是<code>无边界的队列</code>。对于无边界的队列，有一个自然的结果，就是put操作永远也不会发生其他<code>BlockingQueue</code>的那种等待情况。</li>
</ul>
<blockquote>
<p><code>在日常的应用开发中，如何进行选择呢？</code><br>考虑应用场景中<code>对队列边界的要求</code>。 ArrayBlockingQueue是有明确的容量限制的，而LinkedBlockingQueue则取决于我们是否在创建时指定， SynchronousQueue则干脆不能缓存任何元素。<br><code>从空间利用角度</code>，数组结构的ArrayBlockingQueue要比LinkedBlockingQueue紧凑，因为其不需要创建所谓节点，但是其初始分配阶段就需要一段连续的空间，所以初始内存需求更大。<br><code>通用场景中</code>， LinkedBlockingQueue的吞吐量一般优于ArrayBlockingQueue，因为它实现了更加细粒度的锁操作。<br>ArrayBlockingQueue实现比较简单，性能更好预测，属于表现稳定的“选手”。<br>如果我们需要实现的是两个线程之间接力性（handof）的场景，你可能会选择CountDownLatch，但是SynchronousQueue也是完美符合这种场景的，而且线程间协调和数据传输统一起来，代码更加规范。</p>
</blockquote>
<h4 id="Java并发类库提供的线程池有哪几种？-分别有什么特点？"><a href="#Java并发类库提供的线程池有哪几种？-分别有什么特点？" class="headerlink" title="Java并发类库提供的线程池有哪几种？ 分别有什么特点？"></a>Java并发类库提供的线程池有哪几种？ 分别有什么特点？</h4><p>Executors目前提供了5种不同的线程池创建配置：</p>
<ul>
<li><code>newCachedThreadPool()</code>，它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过60秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用<code>SynchronousQueue</code>作为工作队列。</li>
<li><code>newFixedThreadPool(int nThreads)</code>，重用<code>指定数目</code>（nThreads）的线程，其背后使用的是<code>无界的工作队列</code>，任何时候最多有nThreads个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目nThreads。</li>
<li><code>newSingleThreadExecutor()</code>，它的特点在于<code>工作线程数目被限制为1</code>，操作一个<code>无界的工作队列</code>，所以它保证了所有任务的都是被<code>顺序执行</code>，最多会有<code>一个任务处于活动状态</code>，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目。</li>
<li><code>newSingleThreadScheduledExecutor()</code>和<code>newScheduledThreadPool(int corePoolSize)</code>，创建的是<code>ScheduledExecutorService</code>，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程</li>
<li><code>newWorkStealingPool(int parallelism)</code>，这是一个经常被人忽略的线程池， <code>Java 8才加入这个创建方法</code>，其内部会构建<code>ForkJoinPool</code>，利用<code>Work-Stealing算法</code>，并行地处理任务，不保证处理顺序。</li>
</ul>
<blockquote>
<p><code>ThreadPoolExecutor参数详解</code><br>corePoolSize，所谓的核心线程数，可以大致理解为长期驻留的线程数目。于不同的线程池，这个值可能会有很大区别，比如newFixedThreadPool会将其设置为nThreads，而对于newCachedThreadPool则是为0。<br>maximumPoolSize，顾名思义，就是线程不够时能够创建的最大线程数<br>keepAliveTime和TimeUnit，这两个参数指定了额外的线程能够闲置多久，显然有些线程池不需要它。<br>workQueue，工作队列，必须是BlockingQueue。<br><code>线程池大小的选择策略：</code><br>如果我们的任务主要是进行计算，那么就意味着CPU的处理能力是稀缺的资源。如果线程太多，反倒可能导致大量<br>的上下文切换开销。所以，这种情况下，通常建议按照CPU核的数目N或者N+1。<br>如果是需要较多等待的任务，例如I/O操作比较多，可以参考Brain Goetz推荐的计算方法：<code>线程数 = CPU核数 × （1 + 平均等待时间/平均工作时间）</code></p>
</blockquote>
<h4 id="AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？"><a href="#AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？" class="headerlink" title="AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？"></a>AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？</h4><ul>
<li><code>AtomicIntger</code>是对int类型的一个封装，提供原子性的访问和更新操作，其原子性操作的实现是基于<code>CAS（compare-and-swap）</code>技术。</li>
<li>所谓CAS，表征的是一些列操作的集合，获取当前数值，进行一些运算，利用CAS指令试图进行更新。如果当前数值未变，代表没有其他线程进行并发修改，则成功更新。否则，可能出现不同的选择，要么进行重试，要么就返回一个成功或者失败的结果。</li>
<li>于CAS的使用，你可以设想这样一个场景：在数据库产品中，为保证索引的一致性，一个常见的选择是，保证只有一个线程能够排他性地修改一个索引分区，</li>
</ul>
<h4 id="请介绍类加载过程，什么是双亲委派模型？"><a href="#请介绍类加载过程，什么是双亲委派模型？" class="headerlink" title="请介绍类加载过程，什么是双亲委派模型？"></a>请介绍类加载过程，什么是双亲委派模型？</h4><ul>
<li>一般来说，我们把Java的类加载过程分为三个主要步骤：加载、链接、初始化，具体行为在Java虚拟机规范里有非常详细的定义。</li>
<li><code>首先是加载阶段</code>（Loading），它是Java将字节码数据从不同的数据源读取到JVM中，并映射为JVM认可的数据结构（Class对象），这里的数据源可能是各种各样的形态，如jar文件、 class文件，甚至是网络数据源等；如果输入数据不是ClassFile的结构，则会抛出ClassFormatError。加载阶段是用户参与的阶段，我们可以自定义类加载器，去实现自己的类加载过程。</li>
<li><code>第二阶段是链接</code>（Linking），这是核心的步骤，简单说是把原始的类定义信息平滑地转化入JVM运行的过程中。这里可进一步细分为三个步骤：<blockquote>
<p><code>验证</code>: 这是虚拟机安全的重要保障，JVM需要核验字节信息是符合Java虚拟机规范的，否则就被认为是VerifyError，这样就防止了恶意信息或者不合规的信息害JVM的运行，验证阶段有可能触发更多class的加载。<br><code>准备</code>，创建类或接口中的静态变量，并初始化静态变量的初始值。但这里的“初始化”和下面的显式初始化阶段是有区别的，侧重点在于分配所需要的内存空间，不会去执行更进一步的JVM指令<br><code>解析</code>，在这一步会将常量池中的<code>符号引用</code>替换为<code>直接引用</code>。在Java虚拟机规范中，详细介绍了类、接口、方法和字段等各个方面的解析。</p>
<ul>
<li><code>最后是初始化阶段</code>（initialization），这一步真正去执行类初始化的代码逻辑，包括静态字段赋值的动作，以及执行类定义中的静态初始化块内的逻辑，编译器在编译阶段就会把这部分逻辑整理好，父类型的初始化逻辑优先于当前类型的逻辑。</li>
</ul>
</blockquote>
</li>
<li>再来谈谈<code>双亲委派模型</code>，简单说就是当类加载器（Class-Loader）试图加载某个类型的时候，除非父加载器找不到相应类型，否则尽量将这个任务代理给当前加载器的父加载器去做。使用委派模型的目的是避免重复加载Java类型。<br><img src="https://img-blog.csdnimg.cn/20190409151248407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70" alt="双亲委派模型"></li>
</ul>
<h4 id="有哪些方法可以在运行时动态生成一个Java类？"><a href="#有哪些方法可以在运行时动态生成一个Java类？" class="headerlink" title="有哪些方法可以在运行时动态生成一个Java类？"></a>有哪些方法可以在运行时动态生成一个Java类？</h4><ul>
<li>我们可以从常见的Java类来源分析，通常的开发过程是，开发者编写Java代码，调用javac编译成class文件，然后通过类加载机制载入JVM，就成为应用运行时可以使用的Java类了。</li>
<li>有一种笨办法，直接用ProcessBuilder之类启动javac进程，并指定上面生成的文件作为输入，进行编译。最后，再利用类加载器，在运行时加载即可。</li>
<li>你可以考虑使用Java Compiler API，这是JDK提供的标准API，里面提供了与javac对等的编译器功能，具体请参考java.compiler相关文档。</li>
</ul>
<h4 id="谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError？"><a href="#谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError？" class="headerlink" title="谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError？"></a>谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError？</h4><ul>
<li>通常可以把<code>JVM</code>内存区域分为下面几个方面，其中，有的区域是<code>以线程为单位</code>，而有的区域则是<code>整个JVM</code>进程唯一的。</li>
<li><code>程序计数器</code>：在JVM规范中，每个线程都有它自己的程序计数器，并且任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行本地方法，则是未指定值（undefned）。</li>
<li><code>Java虚拟机栈</code>：早期也叫<code>Java栈</code>。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的<code>栈帧</code>（Stack Frame），对应着一次次的Java方法调用。前面谈程序计数器时，提到了当前方法；同理，在一个时间点，对应的只会有一个活动的栈帧，通常叫作<code>当前帧</code>，方法所在的类叫作当前类。如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，成为新的当前帧，一直到它返回结果或者执行结束。 JVM直接对Java栈的操作只有两个，就是对栈帧的<code>压栈和出栈</code>。栈帧中存储着<code>局部变量表</code>、<code>操作数栈</code>、<code>动态链接</code>、<code>方法正常退出</code>或者<code>异常退出</code>的定义等</li>
<li><code>堆（Heap）</code>，它是Java内存管理的核心区域，用来<code>放置Java对象实例</code>，几乎所有创建的Java<code>对象实例都是被直接分配在堆上</code>。堆被<code>所有的线程共享</code>，在虚拟机启动时，我们指定的<code>“Xmx”</code>之类参数就是用来指定最大堆空间等指标。堆也是垃圾收集器重点照顾的区域，所以堆内空间还会被不同的垃圾收集器进行进一步的细分，最有名的就是<code>新生代</code>、老<code>年代</code>的划分。</li>
<li><code>方法区（Method Area）</code>。这也是所有<code>线程共享的一块内存区域</code>，用于存储所谓的<code>元（Meta）数据</code>，例如<code>类结构信息</code>，以及对应的<code>运行时常量池</code>、<code>字段</code>、<code>方法代码</code>等。由于早期的Hotspot JVM实现，很多人习惯于将方法区称为永久代， Oracle JDK 8中将永久代移除，同时<code>增加了元数据区</code>（Metaspace）</li>
<li><code>运行时常量池</code>，这是<code>方法区的一部分</code>。如果仔细分析过反编译的类文件结构，你能看到<code>版本号</code>、<code>字段</code>、<code>方法</code>、<code>超类</code>、<code>接口</code>等各种信息，还有一项信息就是<code>常量池</code>。 Java的常量池可以存放各种常量信息，不管是编译期生成的各种字面量，还是需要在运行时决定的符号引用，所以它比一般语言的符号表存储的信息更加宽泛。</li>
<li><code>本地方法栈</code>（Native Method Stack）。它和Java虚拟机栈是非常相似的，支持对本地方法的调用，也是每个线程都会创建一个</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190409170529393.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70"></p>
<h4 id="Java对象是不是都创建在堆上的呢？"><a href="#Java对象是不是都创建在堆上的呢？" class="headerlink" title="Java对象是不是都创建在堆上的呢？"></a>Java对象是不是都创建在堆上的呢？</h4><ul>
<li>有一些观点，认为通过逃逸分析， JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择</li>
<li>目前很多书籍还是基于JDK 7以前的版本， JDK已经发生了很大变化， Intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是， Intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合对象实例都是分配在堆上。</li>
</ul>
<h4 id="什么是OOM问题，它可能在哪些内存区域发生？"><a href="#什么是OOM问题，它可能在哪些内存区域发生？" class="headerlink" title="什么是OOM问题，它可能在哪些内存区域发生？"></a>什么是OOM问题，它可能在哪些内存区域发生？</h4><ul>
<li>OOM如果通俗点儿说，就是JVM内存不够用了， javadoc中对<code>OutOfMemoryError</code>的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。在抛出OutOfMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理出空间。当然，也不是在任何情况下垃圾收集器都会被触发的，比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值， JVM可以判断出垃圾收集并不能解决这个问题，所以直接抛出OutOfMemoryError。<blockquote>
<p>从我前面分析的数据区的角度，除<code>了程序计数器，其他区域都有可能会因为可能的空间不足发OutOfMemoryError，简单总结如下</code>：</p>
</blockquote>
</li>
<li><code>堆内存不足是最常见的OOM原因之一</code>，抛出的错误信息是“java.lang.OutOfMemoryError:Java heap space”，原因可能千奇百怪，例如，可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小；或者出现JVM处理引用不及时，导致堆积起来，内存无法释放等。</li>
<li>而对于Java虚拟机栈和本地方法栈，这里要稍微复杂一点。如果我们写一段程序不断的进行递归调用，而且没有退出条件，就会导致不断地进行压栈。类似这种情况， JVM实际会抛出StackOverFlowError；当然，如果JVM试图去扩展栈空间的的时候失败，则会抛出OutOfMemoryError。</li>
<li><code>对于老版本的Oracle JDK</code>，因为永久代的大小是有限的，并且JVM对永久代垃圾回收（<code>如，常量池回收、卸载不再需要的类型</code>）非常不积极，所以当我们不断添加新类型的时候，永久代出现<code>OutOfMemoryError</code>也非常多见，尤其是在运行时存在大量动态类型生成的场合；类似Intern字符串缓存占用太多空间，也会导致<code>OOM</code>问题。对应的异常信息，会标记出来和永久代相关： “<code>java.lang.OutOfMemoryError: PermGen space</code>”。</li>
<li><code>随着元数据区的引入</code>，方法区内存已经不再那么窘迫，所以相应的OOM有所改观，出现OOM，异常信息则变成了： “<code>java.lang.OutOfMemoryError: Metaspace</code>”。</li>
<li>直接内存不足，也会导致OOM</li>
</ul>
<blockquote>
<p>我在试图分配一个100M bytes大数组的时候发生了OOME，但是GC日志显示，明明堆上还有远不止100M的空<br>间，你觉得可能问题的原因是什么？想要弄清楚这个问题，还需要什么信息呢？</p>
</blockquote>
<ul>
<li>从不同的垃圾收集器角度来看：首先，数组的分配是需要连续的内存空间的。所以对于使用年轻代和老年代来管理内存的垃圾收集器，堆大于 100M，表示的是新生代和老年代加起来总和大于100M，而新生代和老年代各自并没有大于 100M 的连续内存空间。进一步，又由于大数组一般直接进入老年代（会跳过对对象的年龄的判断），所以，是否可以认为老年代中没有连续大于 100M 的空间呢。</li>
<li>对于 G1 这种按 region 来管理内存的垃圾收集器，可能的情况是没有多个连续的 region，它们的内存总和大于 100M。当然，不管是哪种垃圾收集器以及收集算法，当内存空间不足时，都会触发 GC，只不过，可能 GC 之后，还是没有连续大于 100M 的内存空间，于是 OOM了。</li>
</ul>
<h4 id="如何监控和诊断JVM堆内和堆外内存使用？"><a href="#如何监控和诊断JVM堆内和堆外内存使用？" class="headerlink" title="如何监控和诊断JVM堆内和堆外内存使用？"></a>如何监控和诊断JVM堆内和堆外内存使用？</h4><ul>
<li>可以使用综合性的图形化工具，如JConsole、 VisualVM（注意，从Oracle JDK 9开始， VisualVM已经不再包含在JDK安装包中）等。这些工具具体使用起来相对比较直观，直接连接到Java进程，然后就可以在图形化界面里掌握内存使用情况。<blockquote>
<p>以JConsole为例，其内存页面可以显示常见的堆内存和各种堆外部分使用状态。</p>
</blockquote>
</li>
<li>也可以使用命令行工具进行运行时查询，如jstat和jmap等工具都提供了一些选项，可以查看堆、方法区等使用数据。</li>
<li>或者，也可以使用jmap等提供的命令，生成堆转储（Heap Dump）文件，然后利用jhat或Eclipse MAT等堆转储分析工具进行详细分析。</li>
<li>如果你使用的是Tomcat、 Weblogic等Java EE服务器，这些服务器同样提供了内存管理相关的功能。</li>
<li>另外，从某种程度上来说， GC日志等输出，同样包含着丰富的信息。</li>
<li><a href="https://docs.oracle.com/javase/7/docs/technotes/guides/management/jconsole.html">JConsole官方教程</a>。我这里特别推荐<a href="https://www.oracle.com/technetwork/java/javaseproducts/mission-control/java-mission-control-1998576.html">Java Mission Control（JMC）</a>，这是一个非常强大的工具，不仅仅能够使用JMX进行普通的管理、监控任务，还可以配合Java Flight Recorder（JFR）技术，以非常低的开销，收集和分析JVM底层的Profling和事件等信息。</li>
</ul>
<p><strong>堆内部是什么结构？</strong><br><img src="https://img-blog.csdnimg.cn/20190409174432758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70"><br>你可以看到，按照通常的GC年代方式划分， Java堆内分为：</p>
<p><strong>新生代</strong></p>
<ul>
<li>新生代是大部分对象创建和销毁的区域，在通常的Java应用中，绝大部分对象生命周期都是很短暂的。其内部又分为Eden区域，作为对象初始分配的区域；两个Survivor，有时候也叫from、 to区域，被用来放置从Minor GC中保留下来的对象。</li>
<li>JVM会随意选取一个Survivor区域作为“to”，然后会在GC过程中进行区域间拷贝，也就是将Eden中存活下来的对象和from区域的对象，拷贝到这个“to”区域。这种设计主要是为了防止内存的碎片化，并进一步清理无用对象。</li>
<li>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分， Hotspot JVM还有一个概念叫做（TLAB）。这是JVM为每个线程分配的一个私有缓存区域，否则，多线程同时分配内存时，为避免操作同一地址，可能需要使用加锁等机制，进而影响分配速度，TLAB仍然在堆上，它是分配在Eden区域内的。其内部结构比较直观易懂， start、 end就是起始地址， top（指针）则表示已经分配到哪里了。所以我们分配新对象， JVM就会移动top，当top和end相遇时，即表示该缓存已满， JVM会试图再从Eden里分配一块儿。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190409174715206.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70"></p>
<p><strong>老年代</strong></p>
<ul>
<li>放置长生命周期的对象，通常都是从Survivor区域拷贝过来的对象。当然，也有特殊情况，我们知道普通的对象会被分配在TLAB上；如果对象较大， JVM会试图直接分配在Eden其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间， JVM就会直接分配到老年代。</li>
</ul>
<p><strong>永久代</strong></p>
<ul>
<li><p>这部分就是早期Hotspot JVM的方法区实现方式了，储存Java类元数据、常量池、 Intern字符串缓存，在JDK 8之后就不存在永久代这块儿了。</p>
<p><strong>利用JVM参数，直接影响堆和内部区域的大小</strong></p>
</li>
<li><p>最大堆体积：<code>-Xmx value</code></p>
</li>
<li><p>初始的最小堆体积：<code>-Xms value</code></p>
</li>
<li><p>老年代和新生代的比例：<code>-XX:NewRatio=value</code>。默认情况下，这个数值是3，意味着老年代是新生代的3倍大；换句话说，新生代是堆大小的1/4。也可以不用比例的方式调整新生代的大小，直接<code>-XX:NewSize=value</code>参数，设定具体的内存大小数值。</p>
</li>
</ul>
<h4 id="Java常见的垃圾收集器有哪些？"><a href="#Java常见的垃圾收集器有哪些？" class="headerlink" title="Java常见的垃圾收集器有哪些？"></a>Java常见的垃圾收集器有哪些？</h4><ul>
<li><p><code>Serial GC</code>，它是最古老的垃圾收集器， “Serial”体现在其收集<code>工作是单线程</code>的，并且在进行垃圾收集过程中，会进入臭名昭著的<code>“Stop-The-World”</code>状态。当然，其<code>单线程设计</code>也意味着精简的GC实现，无需维护复杂的数据结构，初始化也简单，所以一直是Client模式下JVM的默认选项。</p>
</li>
<li><p>从年代的角度，通常将其老年代实现单独称作<code>Serial Old</code>，它采用了标记-整理（Mark-Compact）算法，区别于新生代的复制算法。Serial GC的对应JVM参数是：<code>-XX:+UseSerialGC</code></p>
</li>
<li><p><code>ParNew GC</code>，很明显是个<code>新生代GC</code>实现，它实际<code>是Serial GC的多线程版本</code>，最常见的应用场景是配合老年代的CMS GC工作，下面是对应参数 <code>-XX:+UseConcMarkSweepGC -XX:+UseParNewGC</code></p>
</li>
<li><p><code>CMS GC</code>，基于标记-清除（Mark-Sweep）算法 设计目标是尽量减少停顿时间，这一点对于Web等反应时间敏感的应用非常重要，一直到今天，仍然有很多系统使用CMS GC。但是， CMS采用的<code>标记-清除算法</code>，存在着<code>内存碎片化</code>问题，所以难以避免在长时间运行等情况下发生<code>full GC</code>，导致恶劣的停顿。另外，既然强调了并发（Concurrent）， CMS会<code>占用更多CPU资源</code>，并和用户线程争抢。</p>
</li>
<li><p><code>Parrallel GC</code>，在早期JDK 8等版本中，它是server模式JVM的默认GC选择,也被称作是吞吐量优先的GC。它的算法和Serial GC比较相似，尽管实现要复杂的多，其特点是<code>新生代和老年代GC都是并行进行</code>的，在常见的服务器环境中更加高效。开启选项是：<code>-XX:+UseParallelGC</code>  另外， Parallel GC引入了开发者友好的配置项，我们可以直接设置暂停时间或吞吐量等目标， JVM会自动进行适应性调整，例如下面参数：</p>
<blockquote>
<p><code>-XX:MaxGCPauseMillis=value</code>,<br>-XX:GCTimeRatio=N         //GC时间和用户时间比例 = 1 / (N+1)<br><code>查看jdk垃圾收集器</code>：java -XX:+PrintCommandLineFlags -version  </p>
</blockquote>
</li>
<li><p>G1 GC这是一种兼顾吞吐量和停顿时间的GC实现，是Oracle JDK 9以后的默认GC选项。 G1可以直观的设定停顿时间的目标，相比于CMS GC， G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</p>
</li>
<li><p>G1 GC仍然存在着年代的概念，但是其内存结构并不是简单的条带式划分，而是类似棋盘的一个个region。 Region之间是复制算法，但整体上实际可看作是标记-整理（MarkCompact）算法，可以有效地避免内存碎片，尤其是当Java堆非常大的时候， G1的优势更加明显。</p>
</li>
<li><p>G1吞吐量和停顿表现都非常不错，并且仍然在不断地完善，与此同时CMS已经在JDK 9中被标记为废弃（deprecated），所以G1 GC值得你深入掌握。</p>
</li>
</ul>
<h4 id="如何判断一个对象是否可以回收"><a href="#如何判断一个对象是否可以回收" class="headerlink" title="如何判断一个对象是否可以回收"></a>如何判断一个对象是否可以回收</h4><p>主要是两种基本算法， 引用计数和可达性分析</p>
<ul>
<li><code>引用计数算法</code>，顾名思义，就是为对象添加一个引用计数，用于记录对象被引用的情况，如果计数为0，即表示对象可回收。Java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。</li>
<li><code>Java选择的可达性分析</code>， Java的各种引用关系，在某种程度上，将可达性问题还进一步复杂化,这种类型的垃圾收集通常叫作追踪性垃圾收集。其原理简单来说，就是将对象及其引用关系看作一个图，选定活动的对象作为 <code>GC Roots</code>，然后跟踪引用链条，如果一个对象和<code>GC Roots之间不可达</code>，也就是不存在引用链条，那么即可认为是可回收对象。 JVM会把虚拟机栈和本地方法栈中正在引用的<code>对象、静态属性引用的对象和常量，作为GC Roots</code>。</li>
</ul>
<h4 id="常见的垃圾收集算法"><a href="#常见的垃圾收集算法" class="headerlink" title="常见的垃圾收集算法"></a>常见的垃圾收集算法</h4><ul>
<li><code>复制（Copying）算法</code>：将活着的对象复制到to区域，拷贝过程中将对象顺序放置，就可以避免内存碎片化。这么做的代价是，既然要进行复制，既要提前预留内存空间，有一定的浪费；另外，对于G1这种分拆成为大量regio GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，这个开销也不小，不管是内存占用或者时间开销。</li>
<li><code>标记-清除（Mark-Sweep）算法</code>，首先进行标记工作，标识出所有要回收的对象，然后进行清除。这么做除了标记、清除过程效率有限，另外就是不可避免的出现碎片化问题，这就导致其不适合特别大的堆；否则，一旦出现Full GC，暂停时间可能根本无法接受。</li>
<li><code>标记-整理（Mark-Compact）</code>，类似于标记-清除，但为避免内存碎片化，它会在清理过程中将对象移动，以确保移动后的对象占用连续的内存空间。</li>
</ul>
<h4 id="在垃圾收集的过程，对应到Eden、-Survivor、-Tenured等区域会发生什么变化呢？"><a href="#在垃圾收集的过程，对应到Eden、-Survivor、-Tenured等区域会发生什么变化呢？" class="headerlink" title="在垃圾收集的过程，对应到Eden、 Survivor、 Tenured等区域会发生什么变化呢？"></a>在垃圾收集的过程，对应到Eden、 Survivor、 Tenured等区域会发生什么变化呢？</h4><ul>
<li>这实际上取决于具体的GC方式，先来熟悉一下通常的垃圾收集流程，我画了一系列示意图，希望能有助于你理解清楚这个过程。</li>
</ul>
<p>第一， Java应用不断创建对象，通常都是分配在Eden区域，当其空间占用达到一定阈值时，触发minor GC。仍然被引用的对象（绿色方块）存活下来，被复制到JVM选择的Survivor区域，而没有被引用的对象（黄色方块）则被回收。注意，我给存活对象标记了“数字1”，这是为了表明对象的存活时间。</p>
<p><img src="https://img-blog.csdnimg.cn/20190409183348554.png"></p>
<p>第二， 经过一次<code>Minor GC</code>， Eden就会空闲下来，直到再次达到<code>Minor GC</code>触发条件，这时候，另外一个<code>Survivor</code>区域则会成为<code>to</code>区域， <code>Eden</code>区域的存活对象和<code>From</code>区域对象，都会被复制到<code>to</code>区域，并且存活的年龄计数会被加<code>1</code>。</p>
<p><img src="https://img-blog.csdnimg.cn/20190409183455640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70"></p>
<p>第三， 类似第二步的过程会发生很多次，直到有对象年龄计数达到阈值，这时候就会发生所谓的晋升（Promotion）过程，如下图所示，超过阈值的对象会被晋升到老年代。<br>这个阈值是可以通过参数指定：<code>-XX:MaxTenuringThreshold=&lt;N&gt;</code></p>
<p><img src="https://img-blog.csdnimg.cn/20190409183559189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70"></p>
<p>后面就是<code>老年代GC</code>，具体取决于选择的<code>GC</code>选项，对应不同的算法。通常我们把<code>老年代GC</code>叫作<code>Major GC，</code>将对整个<code>堆进行的清理</code>叫作<code>Full GC</code>，但是这个也没有那么绝对，因为不同的老年代GC算法其实表现差异很大，例如<code>CMS</code>， <code>“concurrent”</code>就体现在清理工作是与工作线程一起并发运行的。</p>
<p><strong>JDK又增加了两种全新的GC方式，分别是：</strong></p>
<ul>
<li><code>Epsilon GC</code>，简单说就是个<code>不做垃圾收集的GC</code>，似乎有点奇怪，有的情况下，例如在进行性能测试的时候，可能需要明确判断GC本身产生了多大的开销，这就是其典型应用场景。</li>
<li><code>ZGC</code>，这是Oracle开源出来的一个<code>超级GC</code>实现，具备令人惊讶的扩展能力，比如支持<code>T bytes级</code>别的堆大小，并且保证绝大部分情况下，<code>延迟都不会超过10 ms</code>。虽然目前还处于<code>实验阶段</code>，仅支持Linux 64位的平台，但其已经表现出的能力和潜力都非常令人期待。</li>
</ul>
<h4 id="java内存模型中的happen-before是什么？"><a href="#java内存模型中的happen-before是什么？" class="headerlink" title="java内存模型中的happen-before是什么？"></a>java内存模型中的happen-before是什么？</h4><ul>
<li>Happen-before关系，是Java内存模型中保证多线程操作可见性的机制，也是对早期语言规范中含糊的可见性概念的一个精确定义。</li>
<li>线程内执行的每个操作，都保证happen-before后面的操作，这就保证了基本的程序顺序规则，这是开发者在书写程序时的基本约定。</li>
<li>对于volatile变量，对它的写操作，保证happen-before在随后对该变量的读取操作。</li>
<li>对于一个锁的解锁操作，保证happen-before加锁操作。</li>
<li>对象构建完成，保证happen-before于fnalizer的开始动作。</li>
<li>甚至是类似线程内部操作的完成，保证happen-before其他Thread.join()的线程等。</li>
<li>这些happen-before关系是存在着传递性的，如果满足a happen-before b和b happen-before c，那么a happen-before c也成立。</li>
<li>JMM内部的实现通常是依赖于所谓的内存屏障，通过禁止某些重排序的方式，提供内存可见性保证，也就是实现了各种happen-before规则。与此同时，更多复杂度在于，需要尽量确保各种编译器、各种体系结构的处理器，都能够提供一致的行为。<blockquote>
<p><code>可从四个维度去理解JMM</code></p>
</blockquote>
</li>
<li>从JVM运行时视角来看， JVM内存可分为JVM栈、本地方法栈、 PC计数器、方法区、堆；其中前三区是线程所私有的，后两者则是所有线程共有的</li>
<li>从JVM内存功能视角来看， JVM可分为堆内存、非堆内存与其他。其中堆内存对应于上述的堆区；非堆内存对应于上述的JVM栈、本地方法栈、 PC计数器、方法区；其他则对应于直接内存</li>
<li>从线程运行视角来看， JVM可分为主内存与线程工作内存。 Java内存模型规定了所有的变量都存储在主内存中；每个线程的工作内存保存了被该线程使用到的变量，这些变量是主内存的副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量</li>
<li>从垃圾回收视角来看， JVM中的堆区=新生代+老年代。新生代主要用于存放新创建的对象与存活时长小的对象，新生代=E+S1+S2；老年代则用于存放存活时间长的对象</li>
</ul>
<h4 id="JVM优化Java代码时都做了什么"><a href="#JVM优化Java代码时都做了什么" class="headerlink" title="JVM优化Java代码时都做了什么?"></a>JVM优化Java代码时都做了什么?</h4><ul>
<li>JVM在对代码执行的优化可分为<code>运行时化</code>和<code>即时编译器优化</code>。<code>运行时优化主要是</code>解析执行和动态编译通用的一些机制,比如说锁机制(<code>如偏向锁</code>)、内存分配机制(<code>如TLAB</code>)。除此之外，还有一些专门优化器执行效率的，比如说模板解析器，内联缓存。</li>
<li>J<code>VM的即时编译器优化</code>是指将热点代码以方法为单位转换成机器码,直接运行在底层硬件之上。它采用了多种优化方式,包括静态编译器可以使用的如方法内联、逃逸分析,也􏰂包括基于程序运行<code>profle</code>的投机性优化，这个怎么理解了?比如我有一条<code>instanceof</code>指令,在编译之前的运行过程中,测试对像的类一直是同一个，那么即时编译器可以假设编译之后的执行过程中还会是这一个类，并且根据这个类直接返回<code>instanceof</code>的结果。如果出现了其他类,那么就抛弃这段编译后的机器码,并且切换回解析执行。</li>
</ul>
<h4 id="谈谈常用的分布式ID的设计方案-Snowflake是否受冬令时切换影响"><a href="#谈谈常用的分布式ID的设计方案-Snowflake是否受冬令时切换影响" class="headerlink" title="谈谈常用的分布式ID的设计方案?Snowflake是否受冬令时切换影响?"></a>谈谈常用的分布式ID的设计方案?Snowflake是否受冬令时切换影响?</h4><ul>
<li>基于数据库自增序列的实现。这种方式优缺点都非常明显，好处是简单易用,但是在扩展性和可靠性等方面存在局限性。</li>
<li>基于Twitter 早期开源的Snowflake的实现,以及相关改动方案。<br><img src="https://img-blog.csdnimg.cn/20190409221903872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70"></li>
<li>整体长度通常是64 (1 + 41 + 10+ 12 = 64)位,适合使用Java语言中的long类型来存储。</li>
<li>头部是1位的正负标识位。跟着的高位部分包含41位时间戳,通常使用<code>System.currentTimeMillis()</code></li>
<li>后面是<code>10位</code>的<code>WorkerID</code>,标准定义是5位数据中心 + 5位机器ID,组成了机器编􏱆号，以区分不同的集群节点。</li>
<li>最后的12位就是单位毫秒内可生成的序列号数目的理论极限。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程和JVM</title>
    <url>/2020/10/14/0000.%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h4 id="1-并行和并发有什么区别？"><a href="#1-并行和并发有什么区别？" class="headerlink" title="1.并行和并发有什么区别？"></a>1.并行和并发有什么区别？</h4><ul>
<li>并行是在不同实体上的多个事件，并发是在同一实体上的多个事件</li>
<li>在一台处理器上“同时”处理多个任务是并行，在多台处理器上同时处理多个任务。如hadoop分布式集群</li>
</ul>
<h4 id="2-ThreadLocal是什么？"><a href="#2-ThreadLocal是什么？" class="headerlink" title="2.ThreadLocal是什么？"></a>2.ThreadLocal是什么？</h4><ul>
<li>ThreadLocal 是一个本地线程副本变量工具类。主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰</li>
<li><code>ThreadLocal</code>内部还有一个静态内部类ThreadLocalMap，该内部类才是实现线程隔离机制的关键，get()、set()、remove()都是基于该内部类操作。ThreadLocalMap提供了一种用键值对方式存储每一个线程的变量副本的方法，key为当前ThreadLocal对象，value则是对应线程的变量副本。</li>
<li>每个<code>Thread</code>内部都有一个<code>ThreadLocal.ThreadLocalMap</code>类型的成员变量，该成员变量用来存储实际的<code>ThreadLocal</code>变量副本。</li>
<li><code>ThreadLocal</code>并不是为线程保存对象的副本，它仅仅只起到一个索引的作用。它的主要目的是为每一个线程隔离一个类的实例，这个实例的作用范围仅限于线程内部。</li>
</ul>
<h4 id="2-1-ThreadLocal为什么会内存泄漏？"><a href="#2-1-ThreadLocal为什么会内存泄漏？" class="headerlink" title="2.1 ThreadLocal为什么会内存泄漏？"></a>2.1 ThreadLocal为什么会内存泄漏？</h4><ul>
<li>每个Thread都有一个<code>ThreadLocal.ThreadLocalMap</code>的map，该map的key为<code>ThreadLocal</code>实例，它为一个弱引用,因为弱引用有利于GC回收。当ThreadLocal的key == null时，GC就会回收这部分空间，但是value却不一定能够被回收，因为他还与C当前线程存在一个强引用关系，会导致value无法回收，如果这个线程对象不会销毁那么这个强引用关系则会一直存在，就会出现内存泄漏情况。所以说只要这个线程对象能够及时被GC回收，就不会出现内存泄漏。如果碰到线程池，那就更坑了。</li>
</ul>
<h4 id="3-Lock接口拥有synchronized所不具备的哪些特性"><a href="#3-Lock接口拥有synchronized所不具备的哪些特性" class="headerlink" title="3.Lock接口拥有synchronized所不具备的哪些特性?"></a>3.Lock接口拥有synchronized所不具备的哪些特性?</h4><ul>
<li>与Synchronized不同，获取到锁的线程能够相应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放</li>
<li>超时获取锁，以及可以尝试非阻塞地获取锁(调用后可立即返回锁是否获取成功)</li>
<li>Lock是一个接口，它需要程序员自己定义了锁获取和释放的基本操作</li>
</ul>
<h4 id="4-线程和进程的区别？"><a href="#4-线程和进程的区别？" class="headerlink" title="4.线程和进程的区别？"></a>4.线程和进程的区别？</h4><ul>
<li>进程是资源分配最小单位，线程是程序执行的最小单位</li>
<li>线程是进程的一个执行单元。线程也被称为轻量级进程。</li>
<li>线程执行开销小，但是不利于资源的管理和保护。对资源的管理和保护要求高，不限制开销和效率时，使用多进程。</li>
<li>进程执行开销大，但是能够很好的进行资源管理和保护。要求效率高，频繁切换时，资源的保护管理要求不是很高时，使用多线程。</li>
</ul>
<h4 id="5-守护线程是什么？"><a href="#5-守护线程是什么？" class="headerlink" title="5.守护线程是什么？"></a>5.守护线程是什么？</h4><ul>
<li>守护线程，专门用于服务其他的线程，如果其他的线程（即用户自定义线程）都执行完毕，连main线程也执行完毕，那么jvm就会退出（即停止运行）——此时，连jvm都停止运行了，守护线程当然也就停止执行了。</li>
</ul>
<h4 id="6-创建线程有哪几种方式？"><a href="#6-创建线程有哪几种方式？" class="headerlink" title="6.创建线程有哪几种方式？"></a>6.创建线程有哪几种方式？</h4><ul>
<li>继承Thread类和实现Runnable接口，以及线程池技术</li>
<li>通过Callable接口并实现call()方法，该call()方法将作为线程执行体，并且有返回值</li>
</ul>
<h4 id="7-说一下-runnable-和-callable-有什么区别？"><a href="#7-说一下-runnable-和-callable-有什么区别？" class="headerlink" title="7.说一下 runnable 和 callable 有什么区别？"></a>7.说一下 runnable 和 callable 有什么区别？</h4><ul>
<li>相同点：两者都是接口。都可以用来创建多线程。都需要调用Thread.start()启动线程</li>
<li>不同点：实现Callable接口的任务线程能返回执行结果；而实现Runnable接口的任务线程不能返回结果。</li>
<li>Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛；</li>
<li>Callable接口支持返回执行结果，此时需要调用FutureTask.get()方法实现，此方法会阻塞主线程直到获取‘将来’结果；当不调用此方法时，主线程不会阻塞</li>
</ul>
<h4 id="8-说一下-synchronized-底层实现原理？"><a href="#8-说一下-synchronized-底层实现原理？" class="headerlink" title="8.说一下 synchronized 底层实现原理？"></a>8.说一下 synchronized 底层实现原理？</h4><ul>
<li>synchronized加在普通方法上，锁的当前对象的实例。也叫对象锁</li>
<li>synchronized加在static方法上.锁的事当前类的class对象。也就是当前类的字节码文件对象，当类加载进内存，就会产生字节码文件对象</li>
<li>同步方法块，锁是括号里面的对象。同步代码块是使用monitorenter和monitorexit指令实现的.JVM需要保证每一个monitorenter都有一个monitorexit与之相对应。任何对象都有一个monitor与之相关联，当且一个monitor被持有之后，他将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁；</li>
<li>同步方法依靠的是方法修饰符上的ACC_SYNCHRONIZED实现</li>
<li>synchronized用的锁是存在Java对象头里的.如果对象是数组类型，则虚拟机用3个字宽（Word）存储对象头，如果对象是非数组类型，则用2字宽存储对象头</li>
<li>java对象头里的Mark-Word里默认存储对象的HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等 </li>
</ul>
<h4 id="9-synchronized锁的升级与对比"><a href="#9-synchronized锁的升级与对比" class="headerlink" title="9.synchronized锁的升级与对比"></a>9.synchronized锁的升级与对比</h4><ul>
<li>jdk1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</li>
<li>锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</li>
</ul>
<h4 id="10。自旋锁"><a href="#10。自旋锁" class="headerlink" title="10。自旋锁"></a>10。自旋锁</h4><ul>
<li>自旋锁:所谓自就是让线程执行一段无意义的循环，防止不会被立即挂起。看持有锁的线程是否会很快释放锁。优点是避免线程切换带来的开销，缺点是：占用了处理器的时间。在JDK1.6中默认开启。同时自旋的默认次数为10次，可以通过参数-XX:PreBlockSpin来调整；</li>
</ul>
<h4 id="11-适应自旋锁"><a href="#11-适应自旋锁" class="headerlink" title="11.适应自旋锁"></a>11.适应自旋锁</h4><ul>
<li>适应自旋锁：所谓自适应就意味着自旋的次数不再是固定的。而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。线程如果自旋成功了，那么下次自旋的次数会更加多。反之如果自旋很少能成功，那吗在以后获取这个锁时自选次数会减少或者直接忽略掉自旋操作。</li>
</ul>
<h4 id="12-锁消除和锁粗化"><a href="#12-锁消除和锁粗化" class="headerlink" title="12.锁消除和锁粗化"></a>12.锁消除和锁粗化</h4><ul>
<li>锁消除：如果JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除。锁消除的依据是逃逸分析的数据支持。比如StringBuffer的append()方法，Vector的add()方法</li>
<li>锁粗化：就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁</li>
</ul>
<h4 id="13-synchronized的锁升级流程之偏向锁"><a href="#13-synchronized的锁升级流程之偏向锁" class="headerlink" title="13.synchronized的锁升级流程之偏向锁"></a>13.synchronized的锁升级流程之偏向锁</h4><ul>
<li>当一个线程访问同步代码块时，会在对象头和栈帧中的锁记录里存储偏向的线程ID，以后该线程进入和退出同步块时，不需要执行CAS操作来加锁和解锁，只需要简单的测试下对象头的Mark-Word是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已获取到锁</li>
<li>如果测试失败，则需要在测试下Mark-Word中偏向锁的表示是否设置为1（表示当前是偏向锁）；如果没有设置，则使用CAS竞争；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</li>
<li>偏向锁使用了一种等到竞争出现才释放锁的机制，当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁</li>
<li>偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）</li>
<li>它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否存活，如果线程处于不活动状态，则会将对象头设置成无所状态</li>
<li>如果线程仍然活着，拥有偏向锁的线程会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程</li>
</ul>
<h4 id="14-synchronized的锁升级流程之轻量级锁"><a href="#14-synchronized的锁升级流程之轻量级锁" class="headerlink" title="14.synchronized的锁升级流程之轻量级锁"></a>14.synchronized的锁升级流程之轻量级锁</h4><ul>
<li>引入轻量级锁的目的是为了减轻重量级锁使用操作系统的互斥量产生的性能消耗。当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁</li>
<li>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间,并将对象头中的Mark Word复制到锁记录中(官方称为Displaced Mark Word)</li>
<li>然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针</li>
<li>如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁</li>
<li>轻量级解锁时，会使用原子的CAS操作将Displaced-Mark-Word替换回到对象头。如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁</li>
<li>轻量级锁的加锁和释放锁都是使用CAS操作来执行的</li>
</ul>
<h4 id="14-synchronized的锁升级流程之重量级锁"><a href="#14-synchronized的锁升级流程之重量级锁" class="headerlink" title="14.synchronized的锁升级流程之重量级锁"></a>14.synchronized的锁升级流程之重量级锁</h4><ul>
<li>重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。</li>
</ul>
<h4 id="15-偏向锁-轻量锁，重量级锁的优缺点对比"><a href="#15-偏向锁-轻量锁，重量级锁的优缺点对比" class="headerlink" title="15.偏向锁,轻量锁，重量级锁的优缺点对比"></a>15.偏向锁,轻量锁，重量级锁的优缺点对比</h4><ul>
<li>偏向锁： 加锁和解锁不需要额外的消耗，和执行非同步方法只存在纳秒级的差距。缺点是如果线程间存在锁竞争，会带来额外的锁撤销的消耗。适用于只有一个线程访问同步块</li>
<li>轻量级锁：竞争的线程不会阻塞，提高了线程的响应速度。缺点是如果始终得不到锁竞争的线程，使用自旋会消耗CPU。适用于追求响应时间，同步块执行速度非常快</li>
<li>重量级锁：线程竞争不使用自旋，不会消耗CPU。缺点是线程阻塞，响应时间慢。适用追求吞吐量，同步块执行时间过长。</li>
</ul>
<h4 id="彻底搞懂synchronized-从偏向锁到重量级锁"><a href="#彻底搞懂synchronized-从偏向锁到重量级锁" class="headerlink" title="彻底搞懂synchronized(从偏向锁到重量级锁)"></a>彻底搞懂synchronized(从偏向锁到重量级锁)</h4><ul>
<li>java对象在内存中的存储结构主要有一下三个部分：对象头,实例数据,填充数据.对象头中存储的事hashCode,GC分代年龄，锁信息。</li>
<li>对象被创建出来的那一刻，就有了偏向锁的标志位，偏向锁的标志位是“01”，状态是“0”。偏向锁默认是开启的，但是创建对象时初始化状态是没生效的。</li>
<li>线程执行到临界区时，此时会利用CAS操作，将线程ID插入到Markword中，同时修改偏向锁的标志位为1。所谓临界区，就是只允许一个线程进去执行操作的区域，即同步代码块</li>
<li>这个锁会偏向于第一个获得它的线程，在接下来的执行过程中，假如该锁没有被其他线程所获取，没有其他线程来竞争该锁，那么持有偏向锁的线程将永远不需要进行同步操作。而是简单判断一下当前线程id是否与Markword当中的线程id是否一致.一致则继续执行下面代码</li>
<li>不一致，则要检查一下对象是否还是可偏向。如果还未偏向，则利用CAS操作来竞争锁，也即是第一次获取锁时的操作。</li>
<li>如果此对象已经偏向了，并且不是偏向自己，则说明存在了竞争。此时可能就要根据另外线程的情况，可能是重新偏向，也有可能是做偏向撤销，但大部分情况下就是升级成轻量级锁了。</li>
<li>由于偏向锁失效了，那么接下来就得把该锁撤销，在一个安全点停止拥有锁的线程，遍历线程栈，如果存在锁记录的话，需要修复锁记录和Markword，使其变成无锁状态。唤醒当前线程，将当前锁升级成轻量级锁。</li>
<li>锁撤销升级为轻量级锁之后，那么对象的Markword也会进行相应的的变化。线程在自己的栈桢中创建锁记录LockRecord。将锁对象的对象头中的MarkWord复制到线程的刚刚创建的锁记录中。将锁记录中的Owner指针指向锁对象。将锁对象的对象头的MarkWord替换为指向锁记录的指针。</li>
<li>轻量级锁主要有两种：自旋锁，自适应自旋锁。所谓自旋，就是指当有另外一个线程来竞争锁时，这个线程会在原地循环等待，而不是把该线程给阻塞，直到那个获得锁的线程释放锁之后，这个线程就可以马上获得锁的。</li>
<li>默认情况下，自旋的次数为10次。当线程超过了这个次数，我们就认为，继续使用自旋锁就不适合了，此时锁会再次膨胀，升级为重量级锁。</li>
<li>重量级锁是依赖对象内部的monitor锁来实现的，而monitor又依赖操作系统的MutexLock(互斥锁)来实现的，所以重量级锁也被成为互斥锁。</li>
</ul>
<h4 id="16-原子操作的实现原理"><a href="#16-原子操作的实现原理" class="headerlink" title="16.原子操作的实现原理"></a>16.原子操作的实现原理</h4><ul>
<li>原子操作意为不可被中断的一个或一系列操作</li>
<li>处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。</li>
<li>总线锁：所谓总线锁就是使用处理器提供的一个LOCK#信号，当一个处理器在总线锁输出此信号时，其它处理器就会被阻塞，该处理器将独占内存。</li>
<li>缓存锁：所谓 “缓存锁定“是指内存区域如果被锁定在缓存处理器缓存行中，并且Lock操作期间被锁定,那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK#信号，而是修改内存的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会是缓存行无效。</li>
<li>java如何实现原子操作： 使用循环CAS和锁的方式实现原子操作</li>
</ul>
<h4 id="17-CAS实现原子操作的三大问题"><a href="#17-CAS实现原子操作的三大问题" class="headerlink" title="17.CAS实现原子操作的三大问题"></a>17.CAS实现原子操作的三大问题</h4><ul>
<li>JVM中的CAS是利用处理的cmpxchg（汇编指令，比较并交换操作数）来实现的</li>
<li>ABA问题（CAS操作时需要先检查值是否变化，但是一个值是A接着被改为B 后面又修改为A，CAS操作就会认为他们没有变化。ABA的解决思路是利用版本号）</li>
<li>循环时长开销大（自旋CAS长时间不成功会增大CPU的开销）</li>
<li>只能保证一个共享变量的原子操作。解决思路把多个变量合并为一个变量操作。JDK1.5开始提供了AtomicReference保证对象引用之间的原子性，就可以把多个变量放在同一个对象里进行CAS操作</li>
</ul>
<h4 id="18-线程有哪些状态？"><a href="#18-线程有哪些状态？" class="headerlink" title="18.线程有哪些状态？"></a>18.线程有哪些状态？</h4><ul>
<li>新建(NEW)：新创建了一个线程对象。</li>
<li>可运行(RUNNABLE)：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权 。</li>
<li>运行(RUNNING)：可运行状态(runnable)的线程获得了cpu时间片（timeslice） ，执行程序代码。</li>
<li>阻塞(BLOCKED)：阻塞状态是指线程因为某种原因放弃了cpu使用权，暂时停止运行。阻塞的情况分三种：等待阻塞（wait方法）， 同步阻塞（线程在获取对象的同步锁时）， 其他阻塞（Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时）</li>
</ul>
<h4 id="19-sleep-和-wait-有什么区别？"><a href="#19-sleep-和-wait-有什么区别？" class="headerlink" title="19.sleep() 和 wait() 有什么区别？"></a>19.sleep() 和 wait() 有什么区别？</h4><ul>
<li>sleep()方法是Thread的静态方法，而wait是Object实例方法</li>
<li>wait()方法必须要在同步方法或者同步块中调用，也就是必须已经获得对象锁。而sleep()方法没有这个限制可以在任何地方种使用</li>
<li>wait()方法会释放占有的对象锁，使得该线程进入等待池中，等待下一次获取资源。而sleep()方法只是会让出CPU并不会释放掉对象锁；</li>
<li>sleep()方法在休眠时间达到后如果再次获得CPU时间片就会继续执行，而wait()方法必须等待Object.notift/Object.notifyAll通知后，才会离开等待池，并且再次获得CPU时间片才会继续执行。</li>
</ul>
<h4 id="20-notify-和-notifyAll-有什么区别？"><a href="#20-notify-和-notifyAll-有什么区别？" class="headerlink" title="20.notify()和 notifyAll()有什么区别？"></a>20.notify()和 notifyAll()有什么区别？</h4><ul>
<li>notify只会随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会；由JVM确定唤醒哪个线程，而且不是按优先级</li>
<li>notifyAll会让所有处于等待池的线程全部进入锁池去竞争获取锁的机会；</li>
</ul>
<h4 id="21-线程的-run-和-start-有什么区别？"><a href="#21-线程的-run-和-start-有什么区别？" class="headerlink" title="21.线程的 run()和 start()有什么区别？"></a>21.线程的 run()和 start()有什么区别？</h4><ul>
<li>run()是在主线程中执行方法，和调用普通方法一样；（按顺序执行，同步执行）</li>
<li>start()方法：是创建了新的线程，在新的线程中执行；（异步执行）</li>
<li>启动一个线程，当然要调用strat()</li>
</ul>
<h4 id="22-创建线程池有哪几种方式？"><a href="#22-创建线程池有哪几种方式？" class="headerlink" title="22.创建线程池有哪几种方式？"></a>22.创建线程池有哪几种方式？</h4><ul>
<li>newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务</li>
<li>newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小</li>
<li>newCachedThreadPool：创建一个可缓存的线程池。此线程池不会对线程池大小做限制。线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小</li>
<li>newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</li>
</ul>
<h4 id="22-线程池ThreadPoolExecutor的工作流程？"><a href="#22-线程池ThreadPoolExecutor的工作流程？" class="headerlink" title="22.线程池ThreadPoolExecutor的工作流程？"></a>22.线程池ThreadPoolExecutor的工作流程？</h4><ul>
<li>当提交一个新任务到线程池后，线程池首先会判断核心线程池(corePoolSize）里的线程是否都在执行任务，如果不是则创建一个新的工作线程来执行任务。</li>
<li>如果核心线程池corePoolSize的线程都被占用在执行任务，线程池判断工作队列是否已满，如果工作队列没有满：则将新提交的任务存储到工作队列中，</li>
<li>如果工作队列已满：判断线程池（maximumPoolSize）的线程是否处于工作状态，如果没有，则创建一个新的工作线程来执行任务。</li>
<li>如果线程池已满，则交给饱和策略处理这个任务</li>
</ul>
<h4 id="23-线程池都有哪些状态？"><a href="#23-线程池都有哪些状态？" class="headerlink" title="23.线程池都有哪些状态？"></a>23.线程池都有哪些状态？</h4><ul>
<li>RUNNING(运行中)：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理。线程池的初始化状态是RUNNING。</li>
<li>SHUTDOWN(关掉)：调用线程池的shutdown()接口时，线程池由RUNNING -&gt; SHUTDOWN。处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。</li>
<li>STOP(停止):调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -&gt; STOP。处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。 </li>
<li>tidying：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -&gt; TIDYING。 当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -&gt; TIDYING。</li>
<li>terminated(终止)：线程池彻底终止，就变成terminated状态。 线程池处在tidying状态时，执行完terminated()之后，就会由 tidying -&gt; terminated。</li>
</ul>
<h4 id="24-线程池中-submit-和-execute-方法有什么区别？"><a href="#24-线程池中-submit-和-execute-方法有什么区别？" class="headerlink" title="24.线程池中 submit()和 execute()方法有什么区别？"></a>24.线程池中 submit()和 execute()方法有什么区别？</h4><ul>
<li>两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中, 而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中</li>
</ul>
<h4 id="25-在java-程序中怎么保证多线程的运行安全？"><a href="#25-在java-程序中怎么保证多线程的运行安全？" class="headerlink" title="25.在java 程序中怎么保证多线程的运行安全？"></a>25.在java 程序中怎么保证多线程的运行安全？</h4><ul>
<li>线程安全在三个方面体现.如果可以保证以下三个方面，那马多线程的运行安全就得到了保证。一般是通过加锁的方式实现，分布式环境下。则要使用分布式锁</li>
<li>原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作</li>
<li>可见性：一个线程对主内存的修改可以及时地被其他线程看到</li>
<li>有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序</li>
</ul>
<h4 id="26-什么是死锁？如何避免死锁？"><a href="#26-什么是死锁？如何避免死锁？" class="headerlink" title="26.什么是死锁？如何避免死锁？"></a>26.什么是死锁？如何避免死锁？</h4><ul>
<li>线程死锁是指由于两个或者多个线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行,就是死锁</li>
<li>按顺序加锁,每个获取锁的时候加上个时限,按线程间获取锁的关系检测线程间是否发生死锁，如果发生死锁就执行一定的策略，如终断线程或回滚操作等。</li>
</ul>
<h4 id="27-说一下-atomic-的原理？"><a href="#27-说一下-atomic-的原理？" class="headerlink" title="27.说一下 atomic 的原理？"></a>27.说一下 atomic 的原理？</h4><ul>
<li>在Atomic包里一共有12个类，四种原子更新方式，分别是原子更新基本类型，原子更新数组，原子更新引用和原子更新字段。Atomic包里的类基本都是使用Unsafe实现的包装类。</li>
<li>Atomic包下的类是通过CAS操作来实现原子性的。jdk8直接使用了Unsafe的getAndAddInt方法</li>
</ul>
<h4 id="28-说一下-volatile的实现原理？"><a href="#28-说一下-volatile的实现原理？" class="headerlink" title="28.说一下 volatile的实现原理？"></a>28.说一下 volatile的实现原理？</h4><ul>
<li><code>volatile</code>修饰的变量可以禁止指令重排序和保证了内存可见性和单一操作的原子性，类似<code>i++</code>这样的复合操作的原子性保证不了</li>
<li>有<code>volatile</code>关键字修饰的共享变量进行写操作的一瞬间，底层执行汇编指令会多出一个<code>lock</code>前缀指令进行加锁。<code>lock</code>前缀指令其实就相当于一个内存屏障。在多处理器下，会将当前处理器工作内存的数据回写到主内存中，并且这个回写操作会其它线程中缓存该内存地址的数据无效。相当于会在写操作后，发出一个信号给缓存了这个数的线程，告诉它们值更新了，需要从主内存中从新获取</li>
<li>在<code>JVM</code>底层<code>volatile</code>是采用“<code>内存屏障</code>”来实现</li>
<li><code>volatile</code>经常用于两个两个场景：状态标记两、单列模式中的<code>DCL</code>。</li>
<li>当第一个操作为普通变量的读/写时，如果第二个操作是<code>volatile</code>写，则编译器不能重排序这个两个操作。</li>
<li>当第一个操作是<code>volatile</code>读时,第二个操作不管是什么都不能重排序，这个规则确保volatile读之后的操作不会排序的它之前。</li>
<li>当一个操作是volatile写时，第二个操作时volatile读时，不能重排序</li>
</ul>
<h4 id="29-volataile的内存语义及其实现？"><a href="#29-volataile的内存语义及其实现？" class="headerlink" title="29.volataile的内存语义及其实现？"></a>29.volataile的内存语义及其实现？</h4><ul>
<li>如果第一个操作为volatile读，则不管第二个操作是啥，都不能重排序。这个操作确保volatile读之后的操作不会被编译器重排序到volatile读之前；</li>
<li>当第二个操作为volatile写是，则不管第一个操作是啥，都不能重排序。这个操作确保volatile写之前的操作不会被编译器重排序到volatile写之后；</li>
<li>当第一个操作volatile写，第二操作为volatile读时，不能重排序。</li>
</ul>
<h4 id="29-说一下happens-before的理解？"><a href="#29-说一下happens-before的理解？" class="headerlink" title="29.说一下happens-before的理解？"></a>29.说一下happens-before的理解？</h4><ul>
<li>在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。</li>
<li>两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法</li>
<li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前</li>
<li>happen-before原则是JMM中非常重要的原则，它是判断数据是否存在竞争、线程是否安全的主要依据，保证了多线程环境下的可见性</li>
</ul>
<h4 id="30-说一下happens-before八种规则？"><a href="#30-说一下happens-before八种规则？" class="headerlink" title="30.说一下happens-before八种规则？"></a>30.说一下happens-before八种规则？</h4><ul>
<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；</li>
<li>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作</li>
<li>volatile变量规则：如果一个线程先去写一个volatile变量，然后一个线程去读这个变量，那么这个写操作一定是happens-before读操作的。</li>
<li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；</li>
<li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；</li>
<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</li>
<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；</li>
<li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；</li>
</ul>
<h4 id="31-什么是AQS？"><a href="#31-什么是AQS？" class="headerlink" title="31.什么是AQS？"></a>31.什么是AQS？</h4><ul>
<li>AQS抽象的队列式同步器。是实现JUC核心基础组件。</li>
<li>AQS是将每一条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node），来实现锁的分配。</li>
<li>AQS就是基于CLH队列，用volatile修饰共享变量state，线程通过CAS去改变状态符，成功则获取锁成功，失败则进入等待队列，等待被唤醒。</li>
<li>实现了AQS的锁有：自旋锁、互斥锁、读锁写锁、条件产量、信号量、栅栏都是AQS的衍生物</li>
<li>AQS提供两种同步状态的获取与释放：独占式（该方法对中断不敏感，获取同步状态失败加入到CLH同步队列中，后续对线程进行中断操作时，线程不会从同步队列中移除）和共享式（在同一时刻可以有多个线程获取同步状态）</li>
<li>总结：在AQS中维护着一个FIFO的同步队列，当线程获取同步状态失败后，则会加入到这个CLH同步队列的对尾并一直保持着自旋。在CLH同步队列中的线程在自旋时会判断其前驱节点是否为首节点，如果为首节点则不断尝试获取同步状态，获取成功则退出CLH同步队列。当线程执行完逻辑后，会释放同步状态，释放后会唤醒其后继节点。</li>
</ul>
<h4 id="32-ReentrantLock与synchronized的区别"><a href="#32-ReentrantLock与synchronized的区别" class="headerlink" title="32.ReentrantLock与synchronized的区别"></a>32.ReentrantLock与synchronized的区别</h4><ul>
<li>两者实现方式不同一个基于JVM层面，一个基于JDK源码实现</li>
<li>synchronized是隐式的获取锁和释放，ReentrantLock是显示的获取或释放锁，并且有锁超时，锁中断等功能</li>
<li>ReentrantLock提供了可轮询的锁请求。它会尝试着去获取锁，如果成功则继续，否则可以等到下次运行时处理，而synchronized则一旦进入锁请求要么成功要么阻塞，所以相比synchronized而言，ReentrantLock会不容易产生死锁些。</li>
</ul>
<h4 id="33-如何确保N个线程可以访问N个资源同时又不导致死锁"><a href="#33-如何确保N个线程可以访问N个资源同时又不导致死锁" class="headerlink" title="33.如何确保N个线程可以访问N个资源同时又不导致死锁"></a>33.如何确保N个线程可以访问N个资源同时又不导致死锁</h4><ul>
<li>使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出 现死锁了。  </li>
</ul>
<h4 id="34-yield-方法有什么用？"><a href="#34-yield-方法有什么用？" class="headerlink" title="34.yield()方法有什么用？"></a>34.yield()方法有什么用？</h4><ul>
<li>Yield方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行</li>
</ul>
<h4 id="35-CyclicBarrier和CountDownLatch的区别？"><a href="#35-CyclicBarrier和CountDownLatch的区别？" class="headerlink" title="35.CyclicBarrier和CountDownLatch的区别？"></a>35.CyclicBarrier和CountDownLatch的区别？</h4><ul>
<li>CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；是通过调用await()方法计数加1，若加1后的值不等于构造方法的值，则线程阻塞。通俗的将；让一组线程到达一个屏障时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活</li>
<li>CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行，调用countDown()方法计数减一，调用await()方法只进行阻塞，对计数没任何影响</li>
<li>CountDownLatch内部通过共享锁实现。在创建CountDownLatch实例时，需要传递一个int型的参数：count，该参数为计数器的初始值，也可以理解为该共享锁可以获取的总次数。当某个线程调用await()方法，程序首先判断count的值是否为0，如果不会0的话则会一直等待直到为0为止。当其他线程调用countDown()方法时，则执行释放共享锁状态，使count值 – 1。当在创建CountDownLatch时初始化的count参数，必须要有count线程调用countDown方法才会使计数器count等于0，锁才会释放，前面等待的线程才会继续运行。注意CountDownLatch不能回滚重置。</li>
<li>CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务</li>
<li>CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了</li>
</ul>
<h4 id="36-Semaphore有什么作用以及实现原理？"><a href="#36-Semaphore有什么作用以及实现原理？" class="headerlink" title="36.Semaphore有什么作用以及实现原理？"></a>36.Semaphore有什么作用以及实现原理？</h4><ul>
<li>Semaphore就是一个信号量，它的作用是限制某段代码块的并发数</li>
<li>Semaphore有非公平和公平模式，默认是非公平的。当Semaphore设置为1时，可以排它锁使用，同一个时刻，只能限制一个线程访问。和CountDownLatch一样的，内部都有一个Sync内部类，基于AQS实现同步状态的释放和获取。</li>
</ul>
<h4 id="37-说一说对ReentrantReadWriteLock的理解？"><a href="#37-说一说对ReentrantReadWriteLock的理解？" class="headerlink" title="37.说一说对ReentrantReadWriteLock的理解？"></a>37.说一说对ReentrantReadWriteLock的理解？</h4><ul>
<li>ReentrantReadWriteLock内部维护了一对锁，读锁和写锁。支持重入和公平以及平非公平模式。读锁是共享式的，它能够被多个线程同时获取，在没有其他写线程访问（或者写状态为0）时，读锁总会被成功地获取，而所做的也只是（线程安全的）增加读状态。如果当前线程已经获取了读锁，则增加读状态。如果当前线程在获取读锁时，写锁已被其他线程获取，则进入等待状态。</li>
<li>写锁是一个支持重进入的排它锁。如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取写锁时(还未获到)，读锁已经被获取或者该线程不是已经获取写锁的线程，则当前线程进入等待状态。</li>
<li>写锁要确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。</li>
<li>锁降级：遵循获取写锁，获取读锁在释放写锁的次序，写锁可以降级为读锁</li>
<li>锁降级中读锁的获取是否必要呢？答案是必要的。主要是为了保证数据的可见性，如果当前线程不获取读锁而是直接释放写锁，获取了写锁并修改了数据，那么当前线程无法感知线程T的数据更新</li>
</ul>
<h4 id="38-说一说Condition的理解？"><a href="#38-说一说Condition的理解？" class="headerlink" title="38 说一说Condition的理解？"></a>38 说一说Condition的理解？</h4><ul>
<li><code>Condition</code>是一个接口，与<code>Lock</code>配合可以实现的等待通知模式，类似<code>Object</code>的<code>wait</code>和<code>notify</code>。获取一个<code>Condition</code>对象需要调用Lock的<code>newCondition</code>方法或得<code>ConditionObject</code>,是AQS的一个内部类。Condition操作需要获取想关联的锁</li>
<li>一个线程获取锁后，通过调用Condition的<code>await()</code>方法，会释放锁，然后构造成节点并将节点从尾部加入等待队列,并进入等待状态。</li>
<li>当线程调用<code>signal()</code>方法后，程序首先检查当前线程是否获取了锁，然后通过<code>doSignal(Node first)</code>方法唤醒同步队列的等待时间最长的节点（首节点)。在唤醒节点之前，会将节点移动到同步队列中，被唤醒的线程，将从await()方法中的while循环中退出来，然后调用acquireQueued()方法竞争同步状态。</li>
</ul>
<h4 id="39-说一说你对exchanger的理解？"><a href="#39-说一说你对exchanger的理解？" class="headerlink" title="39.说一说你对exchanger的理解？"></a>39.说一说你对exchanger的理解？</h4><ul>
<li>Exchanger类允许在两个线程之间定义同步点。当两个线程都到达同步点时，他们交换数据结构，因此第一个线程的数据结构进入到第二个线程中，第二个线程的数据结构进入到第一个线程中</li>
<li>Exchanger算法的核心是通过一个可交换数据的slot，以及一个可以带有数据item的参与者。</li>
<li>在Exchanger中，如果一个线程已经到达了exchanger节点时，如果它的伙伴节点在该线程到达之前已经调用了exchanger方法，则它会唤醒它的伙伴然后进行数据交换，得到各自数据返回。如果它的伙伴节点还没有到达交换点，则该线程将会被挂起，等待它的伙伴节点到达被唤醒，完成数据交换。如果当前线程被中断了则抛出异常，或者等待超时了，则抛出超时异常。</li>
</ul>
<h4 id="说一说对ConcurrentHashMap的理解？"><a href="#说一说对ConcurrentHashMap的理解？" class="headerlink" title="说一说对ConcurrentHashMap的理解？"></a>说一说对ConcurrentHashMap的理解？</h4><ul>
<li>在多线程环境下，HashMap的put方法会引起死循环,是因为并发执行put方法会造成<code>Entry</code>链表形成环形数据结构，导致next指向一直不为空，就会产生死循换获取Entry。</li>
<li><code>ConcurrentHashMap</code>是一种线程安全的HashMap。相对于HashTable和Collections.synchronizedMap()，ConcurrentHashMap具有更好的性能和伸缩性。</li>
<li>JDK1.8以前采用的是分段锁机制（<code>Segment</code>+<code>HashEntry</code>）,将数据分成一段一段存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一段数据时，其它段的数据能被其它线程访问。其中Segment在实现上继承了ReentrantLock，这样就自带了锁的功能</li>
<li><code>put实现</code>：当执行put方法插入数据时，根据key的hash值，在Segment数组中找到相应的位置，如果相应位置的Segment还未初始化，则通过CAS进行赋值，接着执行Segment对象的put方法通过加锁机制插入数据</li>
<li><code>size实现</code>:因为ConcurrentHashMap是可以并发插入数据的，所以在准确计算元素时存在一定的难度,一般的思路是统计每个Segment对象中的元素个数，然后进行累加，但是这种方式计算出来的结果并不一样的准确的，因为在计算后面几个Segment的元素个数时，已经计算过的Segment同时可能有数据的插入或则删除。jdk1.8以前中是先采用不加锁的方式，连续计算元素的个数，最多计算3次，如果前后两次计算结果相同，则说明计算出来的元素个数是准确的；如果前后两次计算结果都不同，则给每个Segment进行加锁，再计算一次元素的个数；</li>
<li>1.8 中使用<code>CAS+synchronized+Node+红黑树</code>的实现方式。当链表长度达到8时，将链表转化为红黑树，当链表长度小于6时，将红黑树转化为链表。</li>
<li>详细分析：<a href="https://www.jianshu.com/p/e694f1e868ec">https://www.jianshu.com/p/e694f1e868ec</a></li>
</ul>
<h4 id="说一下CoucurrentLinkedQueue的理解？"><a href="#说一下CoucurrentLinkedQueue的理解？" class="headerlink" title="说一下CoucurrentLinkedQueue的理解？"></a>说一下CoucurrentLinkedQueue的理解？</h4><ul>
<li><code>ConcurrentLinkedQueue</code>是一个基于链接节点的无边界的线程安全队列，它采用先进先出原则对元素进行排序，插入元素放入队列尾部，出队时从队列头部返回元素，利用CAS方式实现的</li>
<li><code>CoucurrentLinkedQueue</code>的结构由头节点和尾节点组成的，都是使用<code>volatile</code>修饰的。每个节点由节点元素<code>item</code>和指向下一个节点的<code>next</code>引用组成.<br>*入队:</li>
</ul>
<h4 id="CopyOnWrite思想是什么-CopyOnWriteArrayList如何实现"><a href="#CopyOnWrite思想是什么-CopyOnWriteArrayList如何实现" class="headerlink" title="CopyOnWrite思想是什么?CopyOnWriteArrayList如何实现"></a>CopyOnWrite思想是什么?CopyOnWriteArrayList如何实现</h4><ul>
<li>CopyOnWrite大概就是“写数据的时候利用拷贝的副本来执行。我们知道ArrayList是线程不安全，会有并发问题，一般要保证线程的首先想到是加锁，或者是用ReadWriteLock读写锁的方式来控制</li>
<li>如果使用读写锁去控制，这样多个读请求可以同时执行从ArrayList里读取数据，但是读请求和写请求之间互斥，写请求和写请求也是互斥的。</li>
<li>最大的问题，其实就在于写锁和读锁的互斥。假设写操作频率很低，读操作频率很高，是写少读多的场景。那么偶尔执行一个写操作的时候，是不是会加上写锁，此时大量的读操作过来是不是就会被阻塞住，无法执行，这个就是读写锁可能遇到的最大的问题。</li>
<li>CopyOnWriteArrayList的思想就是，在写入时通过复制一个数组的副本来进行写操作，并且这个数组是volatile修饰的，写完后通过volatile变量赋值的方式，把修改好的数组副本给更新回去，立马让其他线程可见的，同时内部加入了lock锁的机制，也就是同一时间只有一个线程可以更新防止产生多个副本</li>
<li>因为读操作就是非常简单的对那个数组进行读而已，不涉及任何的锁</li>
<li>CopyOnWriteArrayList，就是用空间换时间，更新的时候基于副本更新，避免锁，然后最后用volatile变量来赋值保证可见性，更新的时候对读线程没有任何的影响！</li>
</ul>
<h4 id="CopyOnWrite-思想在Kafka源码中的运用"><a href="#CopyOnWrite-思想在Kafka源码中的运用" class="headerlink" title="CopyOnWrite 思想在Kafka源码中的运用"></a>CopyOnWrite 思想在Kafka源码中的运用</h4><ul>
<li>在Kafka的内核源码中，有这么一个场景，客户端在向Kafka写数据的时候，会把消息先写入客户端本地的内存缓冲，然后在内存缓冲里形成一个Batch之后再一次性发送到Kafka服务器上去，这样有助于提升吞吐量。</li>
</ul>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><blockquote>
<p><a href="%5Bhttps://blog.qinxuewu.club/interview-docs/#/2019/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%5D(https://blog.qinxuewu.club/interview-docs/#/2019/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM)">深入理解Java虚拟机笔记</a></p>
</blockquote>
<h4 id="JAVA内存模型与JVM内存模型的区别"><a href="#JAVA内存模型与JVM内存模型的区别" class="headerlink" title="JAVA内存模型与JVM内存模型的区别"></a>JAVA内存模型与JVM内存模型的区别</h4><ul>
<li>JAVA内存模型：Java内存模型规定所有的变量都是存在主存中，每个线程都有自己的工作内存。线程堆变量的操作都必须在工作内存进行，不能直接堆主存进行操作，并且每个线程不能访问其他线程的工作内存</li>
<li>JVM内存模型</li>
</ul>
<h4 id="jvm线上问题排查思路"><a href="#jvm线上问题排查思路" class="headerlink" title="jvm线上问题排查思路"></a>jvm线上问题排查思路</h4><ul>
<li>思路：首先找到 CPU 飚高的那个 Java 进程，因为你的服务器会有多个 JVM 进程。然后找到那个进程中的 “问题线程”，最后根据线程堆栈信息找到问题代码。最后对代码进行排查</li>
<li>通过 top命令找到CPU消耗最高的进程，并记住进程 ID。</li>
<li>再次通过 top -Hp [进程 ID]找到CPU 消耗最高的线程 ID，并记住线程 ID.</li>
<li>通过 JDK 提供的 jstack 工具dump 线程堆栈信息到指定文件中。具体命令jstack -l [进程 ID] &gt;jstack.log。</li>
<li>由于刚刚的线程ID是十进制的，而堆栈信息中的线程ID是16进制的，因此我们需要将10进制的转换成16进制的，并用这个线程 ID 在堆栈中查找。使用 printf “%x\n”[十进制数字]，可以将10进制转换成16进制。</li>
<li>通过刚刚转换的16进制数字从堆栈信息里找到对应的线程堆栈。就可以从该堆栈中看出端倪</li>
</ul>
<h4 id="说下一Java的内存模型"><a href="#说下一Java的内存模型" class="headerlink" title="说下一Java的内存模型"></a>说下一Java的内存模型</h4><ul>
<li>Java内存模型是JVM的抽象模型,就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。</li>
<li>目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。目的是保证并发编程场景中的原子性、可见性和有序性。</li>
<li>Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存,线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存.不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。</li>
</ul>
<h4 id="说一下jvm-的主要组成部分？及其作用？"><a href="#说一下jvm-的主要组成部分？及其作用？" class="headerlink" title="说一下jvm 的主要组成部分？及其作用？"></a>说一下jvm 的主要组成部分？及其作用？</h4><ul>
<li>JVM基本上由三部分组成：类加载器，执行引擎，运行时数据区</li>
<li>类加载器：在JVM启动时以及程序运行时将需要加载的class文件加载到JVM中</li>
<li>执行引擎：负责执行class文件中包含的字节码指令，相当于物理机器上的CPU</li>
<li>运行时数据区：将划分给Java程序的内存划分成几个区来模拟物理机器上的存储、记录和调度功能</li>
</ul>
<h4 id="说一下-jvm-运行时数据区？"><a href="#说一下-jvm-运行时数据区？" class="headerlink" title="说一下 jvm 运行时数据区？"></a>说一下 jvm 运行时数据区？</h4><p><img src="http://wx1.sinaimg.cn/large/006b7Nxngy1g1bbk4bc68j30g20anab3.jpg" alt="运行时数据区"></p>
<ul>
<li>线程私有的：虚拟机栈，本地方法栈，程序计数器</li>
<li>线程共享的 方法区，堆</li>
<li>程序计数器可以看作是当前线程所执行的字节码行号指示器。通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支,循环,跳转,异常处理,线程恢复等基础功能都需要这个计数器来完成</li>
<li>虚拟机栈：每个方法被执行的时候都会创建一个栈帧用于存储局部变量表，操作栈，动态链接，方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机中从入栈到出栈的过程</li>
<li>本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。</li>
<li>方法区主要用于存放已经被虚拟机加载的类信息，如常量，静态变量，即时编译器编译后的代码等。和Java堆一样不需要连续的内存，并且可以动态扩展</li>
<li>Java 堆是整个虚拟机所管理的最大内存区域，所有的对象创建都是在这个区域进行内存分配。堆内存也分为 新生代、老年代。</li>
</ul>
<h4 id="说一下堆栈的区别？"><a href="#说一下堆栈的区别？" class="headerlink" title="说一下堆栈的区别？"></a>说一下堆栈的区别？</h4><ul>
<li>栈内存:栈内存首先是一片内存区域，存储的都是方法的局部变量，凡是定义在方法中的都是局部变量（方法外的是全局变量），for循环内部定义的也是局部变量，是先加载函数才能进行局部变量的定义，所以方法先进栈，然后再定义变量，变量有自己的作用域，一旦离开作用域，变量就会被释放。栈内存的更新速度很快，因为局部变量的生命周期都很短。</li>
<li>堆内存:存储的是数组和对象（其实数组就是对象），凡是new建立的都是在堆中，堆中存放的都是实体（对象），实体用于封装数据，而且是封装多个（实体的多个属性），如果一个数据消失，这个实体也没有消失，还可以用，所以堆是不会随时释放的，但是栈不一样，栈里存放的都是单个变量，变量被释放了，那就没有了。堆里的实体虽然不会被释放，但是会被当成垃圾，Java有垃圾回收机制不定时的收取。</li>
</ul>
<h4 id="队列和栈是什么？有什么区别？"><a href="#队列和栈是什么？有什么区别？" class="headerlink" title="队列和栈是什么？有什么区别？"></a>队列和栈是什么？有什么区别？</h4><ul>
<li>队列(Queue)：是限定只能在表的一端进行插入和在另一端进行删除操作的线性表;</li>
<li>栈(Stack)：是限定只能在表的一端进行插入和删除操作的线性表。</li>
<li>队列是先进先出，栈是先进后出</li>
<li>队列：基于地址指针进行遍历，而且可以从头部或者尾部进行遍历，但不能同时遍历，无需开辟空间，因为在遍历的过程中不影响数据结构，所以遍历速度要快;</li>
<li>栈：只能从顶部取数据，也就是说最先进入栈底的，需要遍历整个栈才能取出来，而且在遍历数据的同时需要为数据开辟临时空间，保持数据在遍历前的一致性。</li>
</ul>
<h4 id="什么是双亲委派模型？"><a href="#什么是双亲委派模型？" class="headerlink" title="什么是双亲委派模型？"></a>什么是双亲委派模型？</h4><ul>
<li>如果一个类收到加载请求时，它不会先自己去尝试加载这个类，而是委派给父类加载器去加载，只有当父类加载器在自己的搜索范围找不到这个类时，才会委派给子类加载器去执行加载。</li>
<li>优点：加载的类是同一个，保证内库更安全，缺点效率低</li>
</ul>
<h4 id="说一下类加载的执行过程？"><a href="#说一下类加载的执行过程？" class="headerlink" title="说一下类加载的执行过程？"></a>说一下类加载的执行过程？</h4><ul>
<li>类的加载过程分为加载，验证，准备，解析，初始化，使用，卸载七个阶段。其中主准备，解析和初始化统称为链接阶段。其中类加载工作由ClassLoader及其子类负责。</li>
<li>加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定</li>
<li>类装载包括了加载，连接（验证、准备、解析（可选）），初始化</li>
<li>加载指的是把class字节码文件从各个来源通过类加载器装载入内存中</li>
<li>验证是为了保证加载进来的字节流符合虚拟机规范，不会造成安全错误</li>
<li>主要是为类变量（注意，不是实例变量）分配内存，并且赋予初值</li>
<li>解析是将常量池内的符号引用替换为直接引用的过程</li>
<li>初始化，这个阶段主要是对类变量初始化，是执行类构造器的过程。</li>
<li>使用阶段包括主动引用和被动引用</li>
<li>卸载，类所有的实例都已经被回收，加载该类的ClassLoader已经被回收，该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法，jvm就会在方法区垃圾回收的时候对类进行卸载</li>
</ul>
<h4 id="说一下类加载器有哪些？"><a href="#说一下类加载器有哪些？" class="headerlink" title="说一下类加载器有哪些？"></a>说一下类加载器有哪些？</h4><p><img src="http://ww1.sinaimg.cn/large/0068QeGHgy1g7am11fbowj30hv072dg0.jpg" alt="双亲委派模型.png"></p>
<ul>
<li>启动类加载器：负责加载JRE的核心类库，如jre目标下的rt.jar,charsets.jar等.</li>
<li>扩展类加载器：负责加载JRE扩展目录ext中JAR类包</li>
<li>系统类加载器：负责加载ClassPath路径下的类包</li>
<li>用户自定义加载器：负责加载用户自定义路径下的类包</li>
</ul>
<h4 id="怎么判断对象是否可以被存活？"><a href="#怎么判断对象是否可以被存活？" class="headerlink" title="怎么判断对象是否可以被存活？"></a>怎么判断对象是否可以被存活？</h4><ul>
<li>java是使用根搜索算法判断对象是否存活的</li>
<li>通过一系列的名为“GC-roots”的对象作为起点，从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象的GC-roots没有任何引用链相连时，则证明此对象是不可用的</li>
<li>可以作为GC-Roots对象有虚拟机栈中的引用对象,方法区中的类静态属性引用对象,方法区中的常量引用的对象,本地方法中JNI（即一般说的native方法）的引用的对象。</li>
</ul>
<h4 id="java-中都有哪些引用类型？"><a href="#java-中都有哪些引用类型？" class="headerlink" title="java 中都有哪些引用类型？"></a>java 中都有哪些引用类型？</h4><ul>
<li>四种：强引用，软引用，弱引用，虚引用</li>
<li>只要强引用还存在，垃圾回收期永远不会回收掉被引用的对象</li>
<li>软引用：用来描述一些还有用，但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出前，将会把这些对象列进回收范围之内并进行第二次回收，如果这此次回收还是没有足够的内存，才会抛出内存溢出</li>
<li>弱引用：用来描述非必须的对象，但是它的强度比软引用更弱一下，被弱引用关联的对象，只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，只会回收被弱引用关联的对象</li>
<li>虚引用：被称为幽灵引用或幻引用，是最弱的一种引用关系。为一个对象设置虚引用的目的就是在对象被回收时收到一个系统通知。</li>
</ul>
<h4 id="说一下-jvm-有哪些垃圾回收算法？"><a href="#说一下-jvm-有哪些垃圾回收算法？" class="headerlink" title="说一下 jvm 有哪些垃圾回收算法？"></a>说一下 jvm 有哪些垃圾回收算法？</h4><ul>
<li>标记-清除算法：算法分为标记和清除两个阶段。首先先标记所有要被回收的对象，标记完成后再统一清除被标记的对象。效率低，会产生大量不连续的内存碎片</li>
<li>复制算法：将可用内存按容量划分为大小相等的两块，每次只用其中的一块，当这一块内存用完，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉</li>
<li>标记-整理算法：标记过程仍然与标记-清楚算法一样。但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存</li>
<li>分代收集算法：根据对象的存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高，没有额外空间对它进行分配担保，就必须使用标记-清理或标记-整理算法来进行回收</li>
</ul>
<h4 id="说一下-jvm-有哪些垃圾回收器？"><a href="#说一下-jvm-有哪些垃圾回收器？" class="headerlink" title="说一下 jvm 有哪些垃圾回收器？"></a>说一下 jvm 有哪些垃圾回收器？</h4><p><img src="http://wx4.sinaimg.cn/large/0068QeGHgy1g4auzcw1bnj30dn0920tb.jpg" alt="垃圾回收器"></p>
<blockquote>
<p>Serial,ParNew,Parallel Scavenge都是新生代回收器，新生代使用复制回收算法</p>
</blockquote>
<blockquote>
<p>老年代垃圾回收器除了CMS是使用标记清除算法外(减少回收停顿时间)，其余都是使用标记整理算法。</p>
</blockquote>
<ul>
<li><code>Serial</code>收集器：一个单线程的收集器，只会使用一个CPU或一条收集线程去完成垃圾收集工作。在进行垃圾收集时必须暂停其它所有的工作线程，直接到结束。是虚拟机运行在Client模式下的默认新手代收集器，简单而高效</li>
<li><code>ParNew</code>收集器：Serial收集器的多线程版本，使用多条线程收集。是许多运行在Server模式下的虚拟机首选新生代收集器。且目前除了Serial收集器，只有它可以与CMS收集器配合工作</li>
<li><code>Parallel Scavenge</code>收集器：它是一款新生代收集器。使用复制算法收集，又是并行的多线程收集器</li>
<li><code>Serial Old</code>收集器：它是Serial收集器的老年代版本，是一个单线程收集器，使用标记-整理算法收集</li>
<li><code>Parallel Old</code>收集器：它是<code>Parallel-Scavenge</code>收集器的老年代版本，使用多线程和标记-整理算法。JDK1.6才开始提供。</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/0068QeGHgy1g7dvc1ftmtj30jz08q750.jpg" alt="CMS垃圾收集器.png"></p>
<ul>
<li><code>CMS</code>收集器：是一种以获取最短回收停顿时间的为目标的收集器。基于标记-清楚算法实现。运作过程分为四个阶段。初始标记,并发标记,重新标记,并发清除。初始标只会标记出所有GC Roots直接应用的对象,虽说会造成<code>Stop the World</code>但影响不大,因为他的速度很快。并发标记阶段会让系统线程随意创建各种新对象，在这个过程中，垃圾回收线程会尽可能的对已有的对象进行GC Roots追踪，这个过程系统会不停的工作和创建对象，这个阶段也是最耗时的，但是因为是和系统程序并发允许的，所以其实不会对系统运行造成影响。重新标记阶段会再次进入<code>Stop the World</code>,然后重新标记下在第二阶段里新创建的对象和已有对象可能失去引用变成垃圾的情况，这个速度是很快的，他其实就是对第二阶段中被系统程序运行变动过的少数对象进行标记，所以运行速度很快。并发清理阶段让系统程序随意运行，然后他来清理掉之前标记为垃圾的对象即可，这个阶段其实也是最耗时的，但他也是和系统程序并发运行，不影响系统程序执行。</li>
</ul>
<p><img src="http://ws1.sinaimg.cn/large/0068QeGHgy1g7goxrqtjhj30ia08n3zy.jpg" alt="G1垃圾收集器"></p>
<ul>
<li><code>G1</code>收集器：将整个Java堆分为多个大小相等的独立区域。虽然保留新生代和老年代，但它们不再是物理隔离，都是一部分不需要连续的集合。特点是并行与并发充分利用CPU缩短停顿时间。分代收集，空间整合不会产生内存空间碎片，可预测的停顿。有计划的避免回收整个Java堆。</li>
<li><code>XX:G1NewSizePercent</code>参数设置新生代初始占比，维持默认值即可。系统运行中JVM其实会不停的给新生代代增加更多的Region，但是新生代占比不会超过60%，可以通过<code>XX:G1MaxNewSizePercent</code></li>
<li>G1中新生代也有<code>Eden区</code>和<code>Survivor</code>概念，之前的参数<code>-XX:SurvivorRatio=8</code>就可以区分，比如100个Region,按照默认<code>8:1:1</code>那么可能80个Region就是Eden，两个<code>Survivor</code>各占10个</li>
<li>G1的垃圾回收触发机制：随着系统不停的分配内存，一旦新生代到达设定的最大大小60%,比如1200个Region,里面Eden占据1000,每个Survivor是100,而且Eden区还占满对象，这个时候就会触发新生代GC,使用之前的复制算法进行垃圾回收，进入stop the world状态</li>
</ul>
<h4 id="新生代与复制算法"><a href="#新生代与复制算法" class="headerlink" title="新生代与复制算法"></a>新生代与复制算法</h4><ul>
<li>目前大部分 JVM的GC对于新生代都采取Copying算法，因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少，但通常并不是按照1：1来划分新生代。一般将新生代划分为一块较大的 Eden空间和两个较小的Survivor空间(FromSpace, To Space)，每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将该两块空间中还存活的对象复制到另一块 Survivor 空间中。</li>
<li>这样做最大的好处是之浪费少数的内存空间，内存空间利用率可达到90%</li>
</ul>
<h4 id="老年代与标记整理算法-Mark-Compact"><a href="#老年代与标记整理算法-Mark-Compact" class="headerlink" title="老年代与标记整理算法(Mark-Compact )"></a>老年代与标记整理算法(Mark-Compact )</h4><ul>
<li>对象的内存分配主要在新生代的 Eden Space 和 Survivor Space 的 From Space(Survivor 目前存放对象的那一块)，少数情况会直接分配到老生代。</li>
<li>当新生代的 Eden Space 和 From Space 空间不足时就会发生一次 GC，进行 GC 后， Eden Space 和 From Space 区的存活对象会被挪到 To Space，然后将 Eden Space 和 From Space 进行清理</li>
<li>如果 To Space 无法足够存储某个对象，则将这个对象存储到老生代。</li>
<li>在进行 GC 后，使用的便是 Eden Space 和 To Space 了，如此反复循环</li>
<li>当对象在 Survivor 区躲过一次 GC 后，其年龄就会+1。 默认情况下年龄到达 15 的对象会被移到老生代中</li>
</ul>
<h4 id="常用的-jvm-调优的参数都有哪些？"><a href="#常用的-jvm-调优的参数都有哪些？" class="headerlink" title="常用的 jvm 调优的参数都有哪些？"></a>常用的 jvm 调优的参数都有哪些？</h4><ul>
<li>-Xms20M:表示设置JVM启动内存的最小值为20M，必须以M为单位</li>
<li>-Xmx20M:表示设置JVM启动内存的最大值为20M</li>
<li>-verbose:gc:表示输出虚拟机中GC的详细情况</li>
<li>-Xss128k:表示可以设置虚拟机栈的大小为128k</li>
<li>-Xoss128k:表示设置本地方法栈的大小为128k</li>
<li>-XX:PermSize=10M:表示JVM初始分配的永久代（方法区）的容量，必须以M为单位</li>
</ul>
<h4 id="java内存泄漏常见5种情况总结"><a href="#java内存泄漏常见5种情况总结" class="headerlink" title="java内存泄漏常见5种情况总结"></a>java内存泄漏常见5种情况总结</h4><ul>
<li>静态集合类，如HashMap、LinkedList等等引起。如果这些容器为静态的，那么它们的生命周期与程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。</li>
<li>简单而言，长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收。</li>
<li>各种连接，如数据库连接、网络连接和IO连接等，使用完后没释放，将会造成大量的对象无法被回收，从而引起内存泄漏。</li>
<li>对变量设置了不合理的作用域，一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏。另一方面，如果没有及时地把对象设置为null，很有可能导致内存泄漏的发生。</li>
<li>static关键字的使用问题：它的生命周期是很长的，如果他用来引用一下资源耗费过多的实例 (全局生存期)</li>
<li>对象内存过大：保存了多个耗用内存过大的对象，造成内存超出限制</li>
<li>如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。</li>
</ul>
<h4 id="MESI缓存一致性协议和总线锁"><a href="#MESI缓存一致性协议和总线锁" class="headerlink" title="MESI缓存一致性协议和总线锁"></a>MESI缓存一致性协议和总线锁</h4><ul>
<li>总线锁：CPU从主内存读取数据到高速缓存，会在总线对这个数据加锁，这样其它CPU没法去读或写这个数据，直到这个CPU使用完数据释放锁之后其它CPU才能读取数据</li>
<li>缓存一致性协议：多个CPU从内存读取同一个数据到各自的高速缓存，当其中某个CPU修改 了缓存里的数据，该数据会马上同步回主内存，其它CPU通过总线嗅探机制可以感知到数据的变化从而将自己的缓存里的数据失效</li>
</ul>
<h4 id="tomcat需要破坏双亲委派模型的原因"><a href="#tomcat需要破坏双亲委派模型的原因" class="headerlink" title="tomcat需要破坏双亲委派模型的原因"></a>tomcat需要破坏双亲委派模型的原因</h4><ul>
<li>tomcat中的需要支持不同web应用依赖同一个第三方类库的不同版本，jar类库需要保证相互隔离；</li>
<li>同一个第三方类库的相同版本在不同web应用可以共享</li>
<li>tomcat自身依赖的类库需要与应用依赖的类库隔离</li>
<li>jsp需要支持修改后不用重启tomcat即可生效 为了上面类加载隔离和类更新不用重启，定制开发各种的类加载器</li>
</ul>
<h4 id="JVM参数设置"><a href="#JVM参数设置" class="headerlink" title="JVM参数设置"></a>JVM参数设置</h4><p><img src="http://ww1.sinaimg.cn/large/0068QeGHgy1g7bogbbuepj30hy09gdg7.jpg" alt="JVM参数设置.png"></p>
<ul>
<li><code>-Xms</code>:Java堆内存大小</li>
<li><code>-Xmx</code>:Java堆内存最大大小</li>
<li><code>-Xmn</code>:Java堆内存中的新生代大小，扣除新生代剩下的就是老年代的内存大小了</li>
<li><code>-XX:PermSize</code>:永久代大小</li>
<li><code>-XX:MaxPermSize</code>:永久代最大大小</li>
<li><code>-Xss</code>：每个线程的栈内存大小</li>
<li><code>java -Xms512M -Xmx512M -Xmn256M -Xss1M -XX:PermSize=128M -XX:MaxPermSize=128M -jar App.jar</code></li>
</ul>
<h4 id="JVM常见配置汇总"><a href="#JVM常见配置汇总" class="headerlink" title="JVM常见配置汇总"></a>JVM常见配置汇总</h4><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//堆设置 </span></span><br><span class="line">-<span class="attr">Xms:</span>初始堆大小 </span><br><span class="line">-<span class="attr">Xmx:</span>最大堆大小 </span><br><span class="line">-<span class="attr">XX:</span>NewSize=<span class="attr">n:</span>设置年轻代大小 </span><br><span class="line">-<span class="attr">XX:</span>NewRatio=<span class="attr">n:</span>设置年轻代和年老代的比值.如:为<span class="number">3</span>,表示年轻代与年老代比值为<span class="number">1</span>:<span class="number">3</span>,年轻代占整个年轻代年老代和的<span class="number">1</span>/<span class="number">4</span> </span><br><span class="line">-<span class="attr">XX:</span>SurvivorRatio=<span class="attr">n:</span>年轻代中Eden区与两个Survivor区的比值.注意Survivor区有两个.如:<span class="number">3</span>,表示<span class="attr">Eden:</span>Survivor=<span class="number">3</span>:<span class="number">2</span>,一个Survivor区占整个年轻代的<span class="number">1</span>/<span class="number">5</span> </span><br><span class="line">-<span class="attr">XX:</span>MaxPermSize=<span class="attr">n:</span>设置持久代大小</span><br><span class="line"><span class="comment">//收集器设置 </span></span><br><span class="line">-<span class="attr">XX:</span>+<span class="attr">UseSerialGC:</span>设置串行收集器 </span><br><span class="line">-<span class="attr">XX:</span>+<span class="attr">UseParallelGC:</span>设置并行收集器 </span><br><span class="line">-<span class="attr">XX:</span>+<span class="attr">UseParalledlOldGC:</span>设置并行年老代收集器 </span><br><span class="line">-<span class="attr">XX:</span>+<span class="attr">UseConcMarkSweepGC:</span>设置并发收集器</span><br><span class="line"></span><br><span class="line"><span class="comment">//垃圾回收统计信息 </span></span><br><span class="line">-<span class="attr">XX:</span>+PrintGC </span><br><span class="line">-<span class="attr">XX:</span>+PrintGCDetails </span><br><span class="line">-<span class="attr">XX:</span>+PrintGCTimeStamps </span><br><span class="line">-<span class="attr">Xloggc:</span>filename</span><br><span class="line">-<span class="attr">XX:</span>+DisableExplicitGC来禁用JVM对显示GC的响应</span><br><span class="line"><span class="comment">//并行收集器设置 </span></span><br><span class="line">-<span class="attr">XX:</span>ParallelGCThreads=<span class="attr">n:</span>设置并行收集器收集时使用的CPU数.并行收集<span class="comment">//线程数. </span></span><br><span class="line">-<span class="attr">XX:</span>MaxGCPauseMillis=<span class="attr">n:</span>设置并行收集最大暂停时间 </span><br><span class="line">-<span class="attr">XX:</span>GCTimeRatio=<span class="attr">n:</span>设置垃圾回收时间占程序运行时间的百分比.公式为<span class="number">1</span>/(<span class="number">1</span>+n)</span><br><span class="line"><span class="comment">//并发收集器设置 </span></span><br><span class="line">-<span class="attr">XX:</span>+<span class="attr">CMSIncrementalMode:</span>设置为增量模式.适用于单CPU情况. </span><br><span class="line">-<span class="attr">XX:</span>CMSInitiatingOccupancyFaction  设置CMS收集器老年代占用多少比例的时候触发CMS垃圾回收，JDK <span class="number">1.6</span>里面默认的值是<span class="number">92</span>%。</span><br><span class="line">-<span class="attr">XX:</span>ParallelGCThreads=<span class="attr">n:</span>设置并发收集器年轻代收集方式为并行收集时,使用的CPU数.并行收集线程数.</span><br><span class="line">-<span class="attr">XX:</span>+UseCMSCompactAtFullCollection  在Full GC之后要再次进行“Stop the World”，停止工作线程，然后进行碎片整理，就是把存活对象挪到一起，空出来大片连续内存空间，避免内存碎片。</span><br><span class="line">-<span class="attr">XX:</span>CMSFullGCsBeforeCompaction  意思是执行多少次Full GC之后再执行一次内存碎片整理的工作，默认是<span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// JVM参数参考模板,根据系统情况设置不同参数即可</span></span><br><span class="line">-Xms4096M -Xmx4096M -Xmn3072M -Xss1M  </span><br><span class="line">-<span class="attr">XX:</span>MetaspaceSize=<span class="number">256</span>M </span><br><span class="line">-<span class="attr">XX:</span>MaxMetaspaceSize=<span class="number">256</span>M </span><br><span class="line">-<span class="attr">XX:</span>+UseParNewGC </span><br><span class="line">-<span class="attr">XX:</span>+UseConcMarkSweepGC </span><br><span class="line">-<span class="attr">XX:</span>CMSInitiatingOccupancyFraction=<span class="number">92</span> </span><br><span class="line">-<span class="attr">XX:</span>+UseCMSCompactAtFullCollection </span><br><span class="line">-<span class="attr">XX:</span>CMSFullGCsBeforeCompaction=<span class="number">0</span> </span><br><span class="line">-<span class="attr">XX:</span>+CMSParallelInitialMarkEnabled </span><br><span class="line">-<span class="attr">XX:</span>+CMSScavengeBeforeRemark </span><br><span class="line">-<span class="attr">XX:</span>+DisableExplicitGC </span><br><span class="line">-<span class="attr">XX:</span>+PrintGCDetails </span><br><span class="line">-<span class="attr">Xloggc:</span>gc.log </span><br><span class="line">-<span class="attr">XX:</span>+HeapDumpOnOutOfMemoryError  </span><br><span class="line">-<span class="attr">XX:</span>HeapDumpPath=<span class="regexp">/usr/</span>local<span class="regexp">/app/</span>oom</span><br></pre></td></tr></table></figure>


<h4 id="GC的详细执行流程"><a href="#GC的详细执行流程" class="headerlink" title="GC的详细执行流程"></a>GC的详细执行流程</h4><p><img src="http://ws3.sinaimg.cn/large/0068QeGHgy1g7cahzc4cxj30ij0gp417.jpg" alt="GC执行流程"></p>
<ul>
<li>开始执行GC，首先检查老年代可用空间是否大于新生代全部对象</li>
<li>如果大于则执行Minor GC。否则检查<code>-XX:HandlePromotionFaulure</code>参数是否开启，</li>
<li>如果开启上述参数，则判断老年代可用空间收费大于历次Minor GC过后进入老年代的对象平均大小</li>
<li>如果大于 则放心执行Minor GC</li>
<li>如果小于则执行Full GC,然后执行Minor GC</li>
<li>如果Full GC,然后执行Minor GC过后 内存还是不够则抛出OOM</li>
</ul>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><blockquote>
<p>编写线程A，A线程中循环执行一个任务，外部线程可以中断A线程</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">volatile</span>  <span class="keyword">boolean</span> falg=<span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">doTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doTask..........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  Exception </span>&#123;</span><br><span class="line">        Thread a=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!falg)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程被终止。。。。&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    doTask();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        a.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    falg=<span class="keyword">false</span>;</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果保证A,B,C三个线程顺序执行打印</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">       Thread a=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;aaaaaaaaa&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       Thread b=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;bbbbbbbbbbbbbb&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       Thread c=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;cccccccccccc&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       a.start();</span><br><span class="line">       a.join();</span><br><span class="line">       b.start();</span><br><span class="line">       b.join();</span><br><span class="line">       c.start();</span><br><span class="line">       c.join();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JVM</title>
    <url>/2020/10/14/0000.%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/</url>
    <content><![CDATA[<h2 id="1-运行时数据区域"><a href="#1-运行时数据区域" class="headerlink" title="1. 运行时数据区域"></a>1. 运行时数据区域</h2><ul>
<li>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途,以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。</li>
</ul>
<p><img src="http://wx1.sinaimg.cn/large/006b7Nxngy1g1bbk4bc68j30g20anab3.jpg" alt="运行时数据区域"></p>
<ul>
<li>线程私有的：虚拟机栈，本地方法栈，程序计数器</li>
<li>线程共享的 方法区，堆</li>
</ul>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><ul>
<li>程序计数器是一块较小的内存空间,它的作用可以看作是当前线程所执行的字节码行号指示器，在虚拟机的概念模型里，字节码解释器工作时 就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支,循环,跳转,异常处理,线程恢复等基础功能都需要这个计数器来完成。（如果正在执行的是本地方法则计数器为空）。</li>
</ul>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><ul>
<li>虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会创建一个栈帧用于存储局部变量表，操作栈，动态链接，方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机中从入栈到出栈的过程。</li>
</ul>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。</p>
<h3 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h3><ul>
<li><code>Java</code> 堆是整个虚拟机所管理的最大内存区域，所有的对象创建都是在这个区域进行内存分配。</li>
<li>这块区域也是垃圾回收器重点管理的区域，由于大多数垃圾回收器都采用<code>分代回收算法</code>，所有堆内存也分为 <code>新生代</code>、<code>老年代</code>，可以方便垃圾的准确回收。</li>
</ul>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><ul>
<li>方法区主要用于存放已经被虚拟机加载的类信息，如<code>常量，静态变量</code>，即时编译器编译后的代码等。和Java堆一样不需要连续的内存，并且可以动态扩展。</li>
<li>对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。</li>
</ul>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><ul>
<li>运行时常量池是方法区的一部分。class文件除了有类的版本，字段，方法，接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，会在类加载后放入这个区域。</li>
</ul>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><ul>
<li>直接内存并不是虚拟机运行时数据区域的一部分。</li>
<li>在 JDK 1.4 中新加入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。</li>
</ul>
<h2 id="2-Minor-GC和Full-GC"><a href="#2-Minor-GC和Full-GC" class="headerlink" title="2. Minor GC和Full GC"></a>2. Minor GC和Full GC</h2><ul>
<li>Minor GC：指发生在新生代的垃圾收集动作，因为 Java 对象大多都具<br>备朝生夕灭的特性，所以<code> Minor GC</code> 非常频繁，一般回收速度也比较快。</li>
<li>Major GC或Full GC：指发生在老年代的 GC，出现了 Major GC，经常<br>会伴随至少一次的 Minor GC（但非绝对的，在 ParallelScavenge 收集器的收集策略里<br>就有直接进行 <code>Major GC</code> 的策略选择过程） 。<code>MajorGC</code> 的速度一般会比 Minor GC 慢 10<br>倍以上。</li>
</ul>
<h3 id="Minor-GC触发机制"><a href="#Minor-GC触发机制" class="headerlink" title="Minor GC触发机制"></a>Minor GC触发机制</h3><p>当年轻代满时就会触发Minor GC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC</p>
<h3 id="Full-GC触发机制："><a href="#Full-GC触发机制：" class="headerlink" title="Full GC触发机制："></a>Full GC触发机制：</h3><ul>
<li>当年老代满时会引发Full GC，Full GC将会同时回收年轻代、年老代，</li>
<li>当永久代满时也会引发Full GC，会导致Class、Method元信息的卸载</li>
</ul>
<h2 id="3-Java中的四种引用"><a href="#3-Java中的四种引用" class="headerlink" title="3. Java中的四种引用"></a>3. Java中的四种引用</h2><p>强引用,软引用,弱引用,虚引用</p>
<h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>就是指在程序代码中普遍存在的，类似Object obj=new Object()这类的引用，只要强引用还存在，垃圾回收期永远不会回收掉被引用的对象</p>
<h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>用来描述一些还有用，但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出前，将会把这些对象列进回收范围之内并进行第二次回收，如果这此次回收还是没有足够的内存，才会抛出内存溢出。</p>
<h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>用来描述非必须的对象，但是它的强度比软引用更弱一下，被弱引用关联的对象，只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，只会回收被弱引用关联的对象</p>
<h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>被称为幽灵引用或幻引用，是最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其它生存时间构成影响，也无法通过虚引用来取得一个实列。为一个对象设置虚引用的目的就是在对象被回收时收到一个系统通知。</p>
<h2 id="4-垃圾收集算法"><a href="#4-垃圾收集算法" class="headerlink" title="4. 垃圾收集算法"></a>4. 垃圾收集算法</h2><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><ul>
<li>一个单线程的收集器，只会使用一个CPU或一条收集线程去完成垃圾收集工作。在进行垃圾收集时必须暂停其它所有的工作线程，直接到结束。(Stop The Word)这项工作是虚拟机在后台自动发起和完成的。</li>
<li>JDK1.3之前是新生代收集的唯一选择。</li>
<li>它依然是虚拟机运行在Client模式下的默认新手代收集器，简单而高效。</li>
</ul>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>Serial收集器的多线程版本，使用多条线程收集。其余的和Serial一样，是许多运行在Server模式下的虚拟机首选新生代收集器。且目前除了Serial收集器，只有它可以与CMS收集器配合工作</p>
<h3 id="3-Parallel-Scavenge收集器"><a href="#3-Parallel-Scavenge收集器" class="headerlink" title="3.Parallel Scavenge收集器"></a>3.Parallel Scavenge收集器</h3><ul>
<li>它是一款新生代收集器。使用复制算法收集，又是并行的多线程收集器</li>
<li>特点是达到一个可控制的吞吐量，也被称为“吞吐量优先”收集器。</li>
</ul>
<h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><ul>
<li>它是Serial收集器的老年代版本，是一个单线程收集器，使用标记-整理算法收集。</li>
<li>主要意义是给Client模式下虚拟机使用。如果是Server模式，则有两种用途，一是在JDK1.5之前与Parallel Scavenge收集器搭配使用。二是作为CMS收集器的后背预案</li>
</ul>
<h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>它是Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法。JDK1.6才开始提供。</p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><ul>
<li>是一种以获取最短回收停顿时间的为目标的收集器。基于标记-清楚算法实现。</li>
<li>运作过程分为四个阶段。初始标记,并发标记,重新标记,并发清除。</li>
<li>初始标记和并发标记仍然需要”Stop The Word”.初始标记只是记录下GC Roots能直接关联到对象，速度快。并发标记就是进行GC Roots Tracing过程。重新标记修正并发标记期间因程序继续运作导致标记产生变动的一部分对象的标记记录。整个过程耗时最长是并发标记和并发清除过程。</li>
<li>优点是并发收集，低停顿。缺点是：对CPU资源非常敏感，无法处理浮动垃圾。收集结束时会产生大量空间碎片</li>
</ul>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><ul>
<li>当前收集器技术最前沿成果之一。将整个Java堆分为多个大小相等的独立区域。虽然保留新生代和老年代，但它们不再是物理隔离，都是一部分不需要连续的集合。</li>
<li>特点是并行与并发充分利用CPU缩短停顿时间。分代收集，空间整合不会产生内存空间碎片，可预测的停顿。有计划的避免回收整个Java堆。</li>
<li>运行大致分为:初始标记,并发标记,最终标记,筛选回收。</li>
</ul>
<h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><ul>
<li><p>算法分为标记和清除两个阶段。首先先标记所有要被回收的对象，标记完成后再统一清除被标记的对象。</p>
<p><strong>主要缺点有两个，</strong> </p>
</li>
<li><p>一是效率问题，标记和清除的过程效率都不高。二是空间问题，标记清除后会产生大量不连续的内存碎片，空间碎片太多,可能会导致，当程序在以后的运行过程中需要分配较大的对象时无法找到足够的连续内存，而不得不提前出发另一次垃圾收集动作</p>
</li>
</ul>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><ul>
<li>为了解决效率问题，一种复制收集的算法出现了。它将可用内存按容量划分为大小相等的两块，每次只用其中的一块。当这一块内存用完，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对其中一块进行内存回收，内存分配时也就不用内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半未免太高了一点。</li>
</ul>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><ul>
<li>复制手机算法在对象存活率较高的时要执行多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要额外的空间进行分配担保，以应对被使用的内存中对象都100%存货的极端情况，所以在老年代一般不能直接选用这种算法。根据老年代的特点，有人提出了另一种 标记-整理的算法，标记过程仍然与 标记-清楚算法一样。但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存</li>
</ul>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><ul>
<li>根据对象的存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高，没有额外空间对它进行分配担保，就必须使用标记-清理或标记-整理算法来进行回收</li>
</ul>
<h2 id="5-内存分配与回收策略"><a href="#5-内存分配与回收策略" class="headerlink" title="5. 内存分配与回收策略"></a>5. 内存分配与回收策略</h2><ul>
<li>对象的内存分配，往大方向讲，就是在堆上分配，对象主要分配在新生代的Eden区上，如果启动本地线程分配缓冲，将按线程的优先级在TLAB上分配。少数情况也可能分配在老年代中，分配的规则并不是百分之白固定，其细节取决于当前使用的是哪一种垃圾回收期组合，还有虚拟机中于内存相关的参数设置。</li>
</ul>
<h3 id="对象优先在Eden区分配"><a href="#对象优先在Eden区分配" class="headerlink" title="对象优先在Eden区分配"></a>对象优先在Eden区分配</h3><p>对象通常在新生代的Eden区进行分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC，与Minor GC对应的是Major GC、Full GC。</p>
<ul>
<li>Minor GC:指发生在新生代的垃圾收集动作，非常频繁，速度较快。</li>
<li>Major GC:指发生在老年代的GC，出现Major GC，经常会伴随一次Minor GC，同时Minor GC也会引起Major GC，一般在GC日志中统称为GC，不频繁。</li>
<li>Full GC:指发生在老年代和新生代的GC，速度很慢，需要Stop The World。</li>
</ul>
<h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><ul>
<li>需要大量连续内存空间的Java对象称为大对象，大对象的出现会导致提前触发垃圾收集以获取更大的连续的空间来进行大对象的分配。虚拟机提供了-XX:PretenureSizeThreadshold参数来设置大对象的阈值，超过阈值的对象直接分配到老年代。</li>
</ul>
<h3 id="长期存活的对象进入老年代"><a href="#长期存活的对象进入老年代" class="headerlink" title="长期存活的对象进入老年代"></a>长期存活的对象进入老年代</h3><ul>
<li>每个对象有一个对象年龄计数器，与前面的对象的存储布局中的GC分代年龄对应。对象出生在Eden区、经过一次Minor GC后仍然存活，并能够被Survivor容纳，设置年龄为1，对象在Survivor区每次经过一次Minor GC，年龄就加1，当年龄达到一定程度（默认15），就晋升到老年代，虚拟机提供了-XX:MaxTenuringThreshold来进行设置。</li>
</ul>
<h3 id="动态对象年龄判断"><a href="#动态对象年龄判断" class="headerlink" title="动态对象年龄判断"></a>动态对象年龄判断</h3><ul>
<li>对象的年龄到达了MaxTenuringThreshold可以进入老年代，同时，如果在survivor区中相同年龄所有对象大小的总和大于survivor区的一半，年龄大于等于该年龄的对象就可以直接进入老年代。无需等到MaxTenuringThreshold中要求的年龄。</li>
</ul>
<p>具体代码如下：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AllocationTest</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *     -Xms20M -Xmx20M -Xmn10M </span></span><br><span class="line"><span class="comment">        -XX:SurvivorRatio=8 </span></span><br><span class="line"><span class="comment">        -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment">        -XX:+UseSerialGC</span></span><br><span class="line"><span class="comment">        -XX:MaxTenuringThreshold=15</span></span><br><span class="line"><span class="comment">        -XX:+PrintTenuringDistribution</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testTenuringThreshold2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB / <span class="number">4</span>];</span><br><span class="line">        allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB / <span class="number">4</span>];</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">        allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">        allocation4 = null;</span><br><span class="line">        allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        testPretenureSizeThreshold2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><ul>
<li>发生Minor GC时，虚拟机会检查老年代连续的空闲区域是否大于新生代所有对象的总和，若成立，则说明Minor GC是安全的，否则，虚拟机需要查看HandlePromotionFailure的值，看是否运行担保失败，若允许，则虚拟机继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，若大于，将尝试进行一次Minor GC；若小于或者HandlePromotionFailure设置不运行冒险，那么此时将改成一次Full GC，以上是JDK Update 24之前的策略，之后的策略改变了，只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC。</li>
<li>冒险是指经过一次Minor GC后有大量对象存活，而新生代的survivor区很小，放不下这些大量存活的对象，所以需要老年代进行分配担保，把survivor区无法容纳的对象直接进入老年代。</li>
</ul>
<h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><ul>
<li>很多人任务方法区是没有垃圾回收的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而在方法去进行垃圾收集的性价比一般比较低，在堆中，由其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%~96%的空间，而永久代的垃圾收集效率远低于此。</li>
<li>永久代的垃圾主要回收两部分内容：废弃常量和无用的类。</li>
<li>回收废弃常量于回收<code>Java堆</code>中的对象非常相似。以常量池中字面量的回收为列，假如一个字符串“<code>abc</code>“已经进入常量池中，但是当前系统没有任何一个String对象叫做”<code>abc</code>“的，换句话就是没有任何Sting对象引用常量池中的”abc”,也没有其它地方引用了这个字面变量，如果这时候发生内存回收，而且必要的话，这个“<code>abc</code>“常量就会被系统请出常量池，常量池中的其它类，接口，方法，字段的符号引用也与此类似。</li>
</ul>
<p><img src="http://wx1.sinaimg.cn/large/006b7Nxngy1g1bblyvtcpj30mx04x415.jpg"></p>
<h3 id="Java中对象访问是如何进行的"><a href="#Java中对象访问是如何进行的" class="headerlink" title="Java中对象访问是如何进行的"></a>Java中对象访问是如何进行的</h3><ul>
<li><p>对象访问在Java中无处不在，即时是最简单的访问也会涉及到Java栈，Java堆，方法区这三个最重要的内存区域之间的关系。</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span> obj=<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>假设这段代码出现在方法体中， 那吗“<code>Object obj</code>”这部分的语义将会反应到<code>Java栈</code>的本地变量中，作为一个<code>reference</code>类型数据出现。而“<code>new Object()</code>”这部分的语义将会反应到<code>Java堆</code>中,形成一块存储了Object类型所有实例数据值的结构化内存，根据具体类型以及虚拟机实现的对象内存布局的不同，这块内存的长度是不固定的。</p>
</li>
<li><p>另外，在Java堆中还必须包含能查找到此对象类型数据（如对象类型，父亲，实现的接口，方法等）的地址消息，这些类型数据则存储在方法区中。</p>
</li>
</ul>
<h3 id="怎样判断对象是否存活"><a href="#怎样判断对象是否存活" class="headerlink" title="怎样判断对象是否存活"></a>怎样判断对象是否存活</h3><ul>
<li>是否使用引用计数法？很多判断对象存活的算法是这样的，给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1，当引用失效时，计数器减1；</li>
<li>任何时刻计数器都为0的对象就是不可能再被使用的。客观的来说，引用计数法的实现简单，判定效率也很高，在大部分情况下是一个不错的算法，也有一些著名的案例，列如微软的COM技术，但是，在Java语言中没有选用引用技术发来管理内存，其中最主要的原因是因为它很难解决对象之间的互循环引用问题。</li>
</ul>
<blockquote>
<p>摘抄自&lt;&lt;深入理解Java虚拟机&gt;&gt;一书中的原话</p>
</blockquote>
<ul>
<li>根搜索算法：Java是使用根搜索算法判断对象是否存活的。</li>
<li>这个算法的思路就是通过一系列的名为“GC roots”的对象作为起点，从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象的GC roots没有任何引用链相连时，则证明此对象是不可用的。如下图所示，对象object5,object6,object7虽然相互关联，但是他们的GC roots是不可达到的，所以它们将会被判定是可回收的对象。</li>
</ul>
<p><img src="http://wx1.sinaimg.cn/large/006b7Nxngy1g1bbmje0uuj30fu0c2tay.jpg"></p>
<h3 id="作为GC-roots的几种对象"><a href="#作为GC-roots的几种对象" class="headerlink" title="作为GC roots的几种对象"></a>作为GC roots的几种对象</h3><ul>
<li>虚拟机栈(栈中的本地变量表)中的引用对象。</li>
<li>方法区中的类静态属性引用对象。</li>
<li>方法区中的常量引用的对象。</li>
<li>本地方法中JNI（即一般说的native方法）的引用的对象。</li>
</ul>
<h2 id="6-虚拟机类加载机制"><a href="#6-虚拟机类加载机制" class="headerlink" title="6. 虚拟机类加载机制"></a>6. 虚拟机类加载机制</h2><h3 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h3><ul>
<li><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)7个阶段。其中准备、验证、解析3个部分统称为连接（Linking）<br><img src="http://wx1.sinaimg.cn/large/006b7Nxngy1g1bbnlpc6bj30hf06774b.jpg"></p>
</li>
<li><p>加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。</p>
</li>
</ul>
<h3 id="何时开始类加载的第一个阶段"><a href="#何时开始类加载的第一个阶段" class="headerlink" title="何时开始类加载的第一个阶段"></a>何时开始类加载的第一个阶段</h3><ul>
<li>java虚拟机规范中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。但是对于初始阶段，虚拟机规范则是严格规定了有且只有5种情况必须立即对类进行初始化（而加载，验证，准备自然需要再次之前开始）</li>
</ul>
<ol>
<li>遇到<code>new,getstatic,pustatic</code>或<code>invokestatic</code>这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见Java代码场景是：使用new关键字实例化对象，读取或设置一个类的静态字段（被final修饰，已在编译器把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。</li>
<li>对类进行反射调用时，如果类没有进行过初始化，则需要先触发其初始化。</li>
<li>当初始化一个类时，如果发现父类还没有初始化，则需要先触发父类初始化。</li>
<li>当虚拟机启动时，用户指定一个执行的主类，虚拟机会先初始化这个主类。</li>
<li>当使用jdk1.7动态语言支持时,如果一个实例最后解析结果REF_getStatic,REF_putStatic,REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li>
</ol>
<h3 id="什么是被动引用"><a href="#什么是被动引用" class="headerlink" title="什么是被动引用"></a>什么是被动引用</h3><p>一个类进行主动引用时会执行初始化。所有引用类的方式多不会触发初始化称为被动引用。</p>
<ul>
<li>通过子类调用父类的静态字段，不会导致子类初始化，只会触发父类的初始化。</li>
<li>通过数组定义的引用类，不会触发此类的初始化。</li>
<li>常量在编译阶段会存入调用类的常量池中，因此不会触发定义常量的类初始化。</li>
</ul>
<h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><h4 id="1-加载"><a href="#1-加载" class="headerlink" title="1.加载"></a>1.加载</h4><p>在加载阶段（可以参考java.lang.ClassLoader的loadClass()方法），虚拟机需要完成以下3件事情：</p>
<ul>
<li>通过一个类的全限定名来获取定义此类的二进制字节流（并没有指明要从一个Class文件中获取，可以从其他渠道，譬如：网络、动态生成、数据库等）；</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口；</li>
</ul>
<p>加载阶段和连接阶段（Linking）的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。</p>
<h4 id="2-验证"><a href="#2-验证" class="headerlink" title="2.验证"></a>2.验证</h4><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 </p>
<p> <strong>验证阶段大致会完成4个阶段的检验动作：</strong> </p>
<ol>
<li>文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以魔术0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li>
<li>元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。</li>
<li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的</li>
<li>符号引用验证：确保解析动作能正确执行。</li>
</ol>
<p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<h4 id="3-准备"><a href="#3-准备" class="headerlink" title="3.准备"></a>3.准备</h4><ul>
<li>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为：</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="keyword">value</span>=<span class="number">123</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>那变量value在准备阶段过后的初始值为0而不是123.因为这时候尚未开始执行任何java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器()方法之中，所以把value赋值为123的动作将在初始化阶段才会执行。 </li>
<li>至于“特殊情况”是指：public static final int value=123，即当类字段的字段属性是ConstantValue时，会在准备阶段初始化为指定的值，所以标注为final之后，value的值在准备阶段初始化为123而非0.</li>
</ul>
<h4 id="4-解析"><a href="#4-解析" class="headerlink" title="4.解析"></a>4.解析</h4><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</p>
<h4 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5.初始化"></a>5.初始化</h4><ul>
<li>如果一个类被主动引用，就会触发类的初始化。</li>
<li>在java中，直接引用的情况有，通过new关键字实例化对象、读取或设置类的静态变量、调用类的静态方法。通过反射方式执行以上三种行为。初始化子类的时候，会触发父类的初始化。作为程序入口直接运行时（也就是直接调用main方法）。除了以上四种情况，其他使用类的方式叫做被动引用，而被动引用不会触发类的初始化<h4 id="6-使用"><a href="#6-使用" class="headerlink" title="6.使用"></a>6.使用</h4></li>
<li>类的使用包括主动引用和被动引用</li>
<li>被动引用：引用父类的静态字段，只会引起父类的初始化，而不会引起子类的初始化。定义类数组，不会引起类的初始化。引用类的常量，不会引起类的初始化。<h4 id="7-卸载"><a href="#7-卸载" class="headerlink" title="7.卸载"></a>7.卸载</h4></li>
<li>满足下面的情况，类就会被卸载：该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。加载该类的ClassLoader已经被回收。该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
<li>如果以上三个条件全部满足，jvm就会在方法区垃圾回收的时候对类进行卸载，类的卸载过程其实就是在方法区中清空类信息，java类的整个生命周期就结束了。</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>对象基本上都是在jvm的堆区中创建，在创建对象之前，会触发类加载（加载、连接、初始化），当类初始化完成后，根据类信息在堆区中实例化类对象，初始化非静态变量、非静态代码以及默认构造方法，当对象使用完之后会在合适的时候被jvm垃圾收集器回收。</li>
<li>对象的生命周期只是类的生命周期中使用阶段的主动引用的一种情况（即实例化类对象）。而类的整个生命周期则要比对象的生命周期长的多。</li>
</ul>
<h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><ul>
<li>jvm（java虚拟机）中的几个比较重要的内存区域，这几个区域在java类的生命周期中扮演着比较重要的角色：</li>
</ul>
<ol>
<li>方法区：在java的虚拟机中有一块专门用来存放已经加载的类信息、常量、静态变量以及方法代码的内存区域，叫做方法区。</li>
<li>常量池：常量池是方法区的一部分，主要用来存放常量和类中的符号引用等信息。</li>
<li>堆区：用于存放类的对象实例。</li>
<li>栈区：也叫java虚拟机栈，是由一个一个的栈帧组成的后进先出的栈式结构，栈桢中存放方法运行时产生的局部变量、方法出口等信息。当调用一个方法时，虚拟机栈中就会创建一个栈帧存放这些数据，当方法调用完成时，栈帧消失，如果方法中调用了其他方法，则继续在栈顶创建新的栈桢。</li>
</ol>
<ul>
<li><p>当我们编写一个java的源文件后，经过编译会生成一个后缀名为class的文件，这种文件叫做字节码文件，只有这种字节码文件才能够在java虚拟机中运行，java类的生命周期就是指一个class文件从加载到卸载的全过程</p>
</li>
<li><p>一个java类的完整的生命周期会经历加载、连接、初始化、使用、和卸载五个阶段，当然也有在加载或者连接之后没有被初始化就直接被使用的情况</p>
</li>
</ul>
<p><img src="http://wx1.sinaimg.cn/large/006b7Nxngy1g1bboaruavj30830el0sy.jpg"></p>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ul>
<li>通过一个类的全限定名来获取描述此类的二进制字节流,这个动作放到java虚拟机外部去实现。以便让应用程序自己决定如何去获取所需要的类。实现各动作的代码模块称为“类加载器”。</li>
<li>比较两个类是否相等，只有这两个类是由同一个类加载器加载的前提下才有意义，否则即使这两个；诶是来源同一个class文件，但类加载器不同，他们也不相等。<h4 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h4>这个类加载器负责放在<JAVA_HOME>\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库。用户无法直接使用。</li>
</ul>
<h4 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h4><p>这个类加载器由sun.misc.Launcher$AppClassLoader实现。它负责<JAVA_HOME>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库。用户可以直接使用。</p>
<h4 id="应用程序类加载器"><a href="#应用程序类加载器" class="headerlink" title="应用程序类加载器"></a>应用程序类加载器</h4><p>这个类由sun.misc.Launcher$AppClassLoader实现。是ClassLoader中getSystemClassLoader()方法的返回值。它负责用户路径（ClassPath）所指定的类库。用户可以直接使用。如果用户没有自己定义类加载器，默认使用这个</p>
<h4 id="自定义加载器"><a href="#自定义加载器" class="headerlink" title="自定义加载器"></a>自定义加载器</h4><p>用户自己定义的类加载器。</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存在在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的Bootstrap ClassLoader进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。</li>
<li>相反，如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个java.lang.Object的同名类并放在ClassPath中，那系统中将会出现多个不同的Object类，程序将混乱。因此，如果开发者尝试编写一个与rt.jar类库中重名的Java类，可以正常编译，但是永远无法被加载运行。</li>
</ul>
<h2 id="7-happens-before原则"><a href="#7-happens-before原则" class="headerlink" title="7. happens-before原则"></a>7. happens-before原则</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>我们无法就所有场景来规定某个线程修改的变量何时对其他线程可见，但是我们可以指定某些规则，这规则就是happens-before，从JDK 5 开始，JMM就使用happens-before的概念来阐述多线程之间的内存可见性。</li>
<li>在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。<br>happens-before原则非常重要，它是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们解决在并发环境下两操作之间是否可能存在冲突的所有问题。下面我们就一个简单的例子稍微了解下happens-before ；</li>
</ul>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">i</span> = <span class="number">1</span><span class="comment">;       //线程A执行</span></span><br><span class="line"><span class="attr">j</span> = i <span class="comment">;      //线程B执行</span></span><br></pre></td></tr></table></figure>
<p>j 是否等于1呢？假定线程A的操作（i = 1）happens-before线程B的操作（j = i）,那么可以确定线程B执行后j = 1 一定成立，如果他们不存在happens-before原则，那么j = 1 不一定成立。这就是happens-before原则的威力。</p>
<h3 id="原则定义"><a href="#原则定义" class="headerlink" title="原则定义"></a>原则定义</h3><ul>
<li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。 </li>
<li>两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。</li>
</ul>
<h3 id="规则如下"><a href="#规则如下" class="headerlink" title="规则如下"></a>规则如下</h3><h4 id="程序次序规则"><a href="#程序次序规则" class="headerlink" title="程序次序规则"></a>程序次序规则</h4><p>一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；</p>
<h4 id="锁定规则"><a href="#锁定规则" class="headerlink" title="锁定规则"></a>锁定规则</h4><p>一个unLock操作先行发生于后面对同一个锁额lock操作；</p>
<h4 id="volatile变量规则"><a href="#volatile变量规则" class="headerlink" title="volatile变量规则"></a>volatile变量规则</h4><p>对一个变量的写操作先行发生于后面对这个变量的读操作；</p>
<h4 id="传递规则"><a href="#传递规则" class="headerlink" title="传递规则"></a>传递规则</h4><p>如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；</p>
<h4 id="线程启动规则"><a href="#线程启动规则" class="headerlink" title="线程启动规则"></a>线程启动规则</h4><p>Thread对象的start()方法先行发生于此线程的每个一个动作；</p>
<h4 id="程中断规则"><a href="#程中断规则" class="headerlink" title="程中断规则"></a>程中断规则</h4><p>对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</p>
<h4 id="线程终结规则"><a href="#线程终结规则" class="headerlink" title="线程终结规则"></a>线程终结规则</h4><p>线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；</p>
<h4 id="对象终结规则"><a href="#对象终结规则" class="headerlink" title="对象终结规则"></a>对象终结规则</h4><p>一个对象的初始化完成先行发生于他的finalize()方法的开始；</p>
<h2 id="8-对象"><a href="#8-对象" class="headerlink" title="8. 对象"></a>8. 对象</h2><h3 id="Java中创建对象的5种方式"><a href="#Java中创建对象的5种方式" class="headerlink" title="Java中创建对象的5种方式"></a>Java中创建对象的5种方式</h3><p>使用new关键字 → 调用了构造函数</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">Employee emp1 = <span class="keyword">new</span> <span class="type">Employee</span>();</span><br></pre></td></tr></table></figure>

<p>使用Class类的newInstance方法→ 调用了构造函数</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--使用Class类的newInstance方法创建对象。这个newInstance方法调用无参的构造函数创建对象。--&gt;</span></span><br><span class="line"></span><br><span class="line">Employee emp2 = (Employee) Class.forName(&quot;org.programming.mitra.exercises.Employee&quot;).newInstance();</span><br></pre></td></tr></table></figure>

<p>使用Constructor类的newInstance方法 → 调用了构造函数</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--和Class类的newInstance方法很像， java.lang.reflect.Constructor类里也有一个newInstance方法可以创建对象--&gt;</span></span><br><span class="line"></span><br><span class="line">Constructor<span class="tag">&lt;<span class="name">Employee</span>&gt;</span> constructor = Employee.class.getConstructor();</span><br><span class="line">Employee emp3 = constructor.newInstance();</span><br></pre></td></tr></table></figure>

<p>使用clone方法→ 没有调用构造函数</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--无论何时我们调用一个对象的clone方法，jvm就会创建一个新的对象，将前面对象的内容全部拷贝进去。用clone方法创建对象并不会调用任何构造函数。--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--要使用clone方法，我们需要先实现Cloneable接口并实现其定义的clone方法--&gt;</span></span><br><span class="line">Employee emp4 = (Employee) emp3.clone();</span><br></pre></td></tr></table></figure>
<p>使用反序列化→ 没有调用构造函数</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">ObjectInputStream <span class="keyword">in</span> = <span class="keyword">new</span> <span class="type">ObjectInputStream</span>(<span class="keyword">new</span> <span class="type">FileInputStream</span>(<span class="string">&quot;data.obj&quot;</span>));</span><br><span class="line">Employee emp5 = (Employee) <span class="keyword">in</span>.readObject();</span><br></pre></td></tr></table></figure>

<p><img src="http://wx1.sinaimg.cn/large/006b7Nxngy1g1bboaruavj30830el0sy.jpg" alt="对象的创建"></p>
<h3 id="Java-对象生命周期"><a href="#Java-对象生命周期" class="headerlink" title="Java 对象生命周期"></a>Java 对象生命周期</h3><p> 对象的整个生命周期大致可以分为7个阶段：</p>
<h4 id="创建阶段（Creation）"><a href="#创建阶段（Creation）" class="headerlink" title="创建阶段（Creation）"></a>创建阶段（Creation）</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">在创建阶段系统通过下面的几个步骤来完成对象的创建过程</span><br><span class="line"><span class="number">1</span>，为对象分配存储空间</span><br><span class="line"><span class="number">2</span>，开始构造对象</span><br><span class="line"><span class="number">3</span>，从超类到子类对static成员进行初始化</span><br><span class="line"><span class="number">4</span>，超类成员变量按顺序初始化，递归调用超类的构造方法</span><br><span class="line"><span class="number">5</span>，子类成员变量按顺序初始化，子类构造方法调用</span><br><span class="line"></span><br><span class="line">一旦对象被创建，并被分派给某些变量赋值，这个对象的状态就切换到了应用阶段</span><br></pre></td></tr></table></figure>
<h4 id="应用阶段-In-Use"><a href="#应用阶段-In-Use" class="headerlink" title="应用阶段(In Use)"></a>应用阶段(In Use)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对象至少被一个强引用持有着</span><br></pre></td></tr></table></figure>
<h4 id="不可视阶段（Invisible）"><a href="#不可视阶段（Invisible）" class="headerlink" title="不可视阶段（Invisible）"></a>不可视阶段（Invisible）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当一个对象处于不可见阶段时，说明程序本身不再持有该对象的任何强引用，虽然该这些引用仍然是存在着的。</span><br><span class="line">简单说就是程序的执行已经超出了该对象的作用域了。</span><br></pre></td></tr></table></figure>

<h4 id="不可到达阶段（Unreachable）"><a href="#不可到达阶段（Unreachable）" class="headerlink" title="不可到达阶段（Unreachable）"></a>不可到达阶段（Unreachable）</h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">对象处于不可达阶段是指该对象不再被任何强引用所持有</span><br><span class="line"></span><br><span class="line">与“不可见阶段”相比，“不可见阶段”是指程序不再持有该对象的任何强引用，这种情况下，该对象仍可能被JVM等系统下的某些已装载的静态变量或线程或JNI等强引用持有着，这些特殊的强引用被称为”<span class="built_in">GC</span> root”。存在着这些<span class="built_in">GC</span> root会导致对象的内存泄露情况，无法被回收。</span><br></pre></td></tr></table></figure>

<h4 id="可收集阶段（Collected）"><a href="#可收集阶段（Collected）" class="headerlink" title="可收集阶段（Collected）"></a>可收集阶段（Collected）</h4><figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line">当垃圾回收器发现该对象已经处于“不可达阶段”并且垃圾回收器已经对该对象的内存空间重新分配做好准备时，则对象进入了“收集阶段”。</span><br><span class="line">如果该对象已经重写了<span class="function"><span class="title">finalize</span>()方法，则会去执行该方法的终端操作。</span></span><br></pre></td></tr></table></figure>
<h4 id="终结阶段（Finalized）"><a href="#终结阶段（Finalized）" class="headerlink" title="终结阶段（Finalized）"></a>终结阶段（Finalized）</h4><figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line">当对象执行完<span class="function"><span class="title">finalize</span>()方法后仍然处于不可达状态时，则该对象进入终结阶段。在该阶段是等待垃圾回收器对该对象空间进行回收。</span></span><br></pre></td></tr></table></figure>
<h4 id="对象空间重新分配阶段"><a href="#对象空间重新分配阶段" class="headerlink" title="对象空间重新分配阶段"></a>对象空间重新分配阶段</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">垃圾回收器对该对象的所占用的内存空间进行回收或者再分配了，则该对象彻底消失了，称之为“对象空间重新分配阶段”。</span><br></pre></td></tr></table></figure>
<h3 id="对象内存分配"><a href="#对象内存分配" class="headerlink" title="对象内存分配"></a>对象内存分配</h3><p>类加载检查通过后，虚拟机将为新生对象分配内存，对象所需内存大小在类加载完成后可以完全确定，对象内存分配任务就是把一块确定大小的内存从堆中划分出来。</p>
<h4 id="指针碰撞法"><a href="#指针碰撞法" class="headerlink" title="指针碰撞法"></a>指针碰撞法</h4><ul>
<li>如果堆中内存是绝对规整的。用过的内存放一边，空闲的放一边，中间放着一个指针作为分界点的指示器，那所分配内存就是把指针向空闲一边移动一段与对象大小相等的距离，即为“指针碰撞”<h4 id="空闲列表法"><a href="#空闲列表法" class="headerlink" title="空闲列表法"></a>空闲列表法</h4></li>
<li>如果堆中内存不规整，已使用内存和未使用内存相互交错，虚拟机就必须一个列表，记录哪些内存块可用，在分配时从列表中找到一块足够大空间划分给对象，并更新列表上记录，即为“空闲列表”<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4></li>
<li>选择何种分配方式，由堆是否规整决定，而堆是否规整由采用的垃圾收集器是否有压缩整理功能决定。</li>
<li>使用Serial，ParNew等带Compactg过程的收集器时，系统采用指针碰撞法</li>
<li>使用CMS这种基于Mark-Sweep算法的收集器时，系统采用空闲列表法<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3></li>
<li>Java程序需要通过栈上的references数据来操作堆上的具体对象。因为referencesz只是指向对象的一个引用，并没有定义这个引用通过何种方式去方位堆中对象的具体位置。所以对象访问方式取决于虚拟机实现而定的。</li>
<li>目前主流的访问方式有使用句柄和直接指针两种。<h4 id="句柄定位"><a href="#句柄定位" class="headerlink" title="句柄定位"></a>句柄定位</h4>使用句柄访问时，Java堆中会划分出一块内存来作为句柄池，references中存储的就是对象的句柄地址。句柄中包含对象实列数据与类型数据各组的具体地址信息  references-&gt;句柄池-&gt;java堆</li>
</ul>
<p><img src="http://wx1.sinaimg.cn/large/006b7Nxngy1g1bbpgjsioj30ih0900uu.jpg"></p>
<h4 id="直接指针定位"><a href="#直接指针定位" class="headerlink" title="直接指针定位"></a>直接指针定位</h4><p>如果是直接指针访问，Java堆的布局就必须考虑如何放置访问类型数据相关。</p>
<p><img src="http://wx1.sinaimg.cn/large/006b7Nxngy1g1bbpxha4lj30kf09bwgj.jpg"></p>
<h4 id="各自优点"><a href="#各自优点" class="headerlink" title="各自优点"></a>各自优点</h4><ul>
<li>句柄访问最大好处就是references中存储的是稳定的句柄地址，在对象移动(垃圾收集时移动对象是普遍行为)时只会改变句柄中的实列数据指针，references本身不需要修改。</li>
<li>直接指针访问的最大好处是速度快，节省了一次定位的实时间开销。</li>
</ul>
<h2 id="9-常量池总结"><a href="#9-常量池总结" class="headerlink" title="9. 常量池总结"></a>9. 常量池总结</h2><h3 id="全局字符串池"><a href="#全局字符串池" class="headerlink" title="全局字符串池"></a>全局字符串池</h3><p>string pool也有叫做string literal pool</p>
<ul>
<li>全局字符串池里的内容是在类加载完成，经过验证，准备阶段之后在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到string pool中（记住：string pool中存的是引用值而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放的。）。</li>
<li>在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个哈希表，里面存的是驻留字符串(也就是我们常说的用双引号括起来的)的引用（而不是驻留字符串实例本身），也就是说在堆中的某些字符串实例被这个StringTable引用之后就等同被赋予了”驻留字符串”的身份。这个StringTable在每个HotSpot VM的实例只有一份，被所有的类共享。</li>
</ul>
<h3 id="class文件常量池"><a href="#class文件常量池" class="headerlink" title="class文件常量池"></a>class文件常量池</h3><p>class constant pool</p>
<ul>
<li>我们都知道，class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)，用于存放编译器生成的各种字面量(Literal)和符号引用(Symbolic References)。 </li>
<li>字面量就是我们所说的常量概念，如文本字符串、被声明为final的常量值等。</li>
<li>符号引用是一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可（它与直接引用区分一下，直接引用一般是指向方法区的本地指针，相对偏移量或是一个能间接定位到目标的句柄）。一般包括下面三类常量。类和接口的全限定名，字段的名称和描述符，方法的名称和描述符。</li>
</ul>
<p>常量池的每一项常量都是一个表，一共有如下表所示的11种各不相同的表结构数据，这每个表开始的第一位都是一个字节的标志位（取值1-12），代表当前这个常量属于哪种常量类型。 </p>
<p><img src="http://wx1.sinaimg.cn/large/006b7Nxngy1g1bbqe1waij30mp099go2.jpg"></p>
<h3 id="运行时常量池（runtime-constant-pool）"><a href="#运行时常量池（runtime-constant-pool）" class="headerlink" title="运行时常量池（runtime constant pool）"></a>运行时常量池（runtime constant pool）</h3><p>当java文件被编译成class文件之后，也就是会生成我上面所说的class常量池，那么运行时常量池又是什么时候产生的呢？</p>
<ul>
<li>jvm在执行某个类的时候，必须经过加载、连接、初始化，而连接又包括验证、准备、解析三个阶段。而当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，由此可知，运行时常量池也是每个类都有一个。在上面我也说了，class常量池中存的是字面量和符号引用，也就是说他们存的并不是对象的实例，而是对象的符号引用值。而经过解析（resolve）之后，也就是把符号引用替换为直接引用，解析的过程会去查询全局字符串池，也就是我们上面所说的StringTable，以保证运行时常量池所引用的字符串与全局字符串池中所引用的是一致的。</li>
</ul>
<p>举个实例来说明一下:</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span> []args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">String</span> str1 = <span class="string">&quot;abc&quot;</span>; </span><br><span class="line">		<span class="keyword">String</span> str2 = <span class="keyword">new</span> <span class="keyword">String</span>(<span class="string">&quot;def&quot;</span>); </span><br><span class="line">		<span class="keyword">String</span> str3 = <span class="string">&quot;abc&quot;</span>; </span><br><span class="line">		<span class="keyword">String</span> str4 = str2.intern(); </span><br><span class="line">		<span class="keyword">String</span> str5 = <span class="string">&quot;def&quot;</span>; </span><br><span class="line">		System.out.<span class="built_in">println</span>(str1 == str3);<span class="comment">//true </span></span><br><span class="line">		System.out.<span class="built_in">println</span>(str2 == str4);<span class="comment">//false </span></span><br><span class="line">		System.out.<span class="built_in">println</span>(str4 == str5);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>回到上面的那个程序，现在就很容易解释整个程序的内存分配过程了，首先，在堆中会有一个”abc”实例，全局StringTable中存放着”abc”的一个引用值</li>
<li>然后在运行第二句的时候会生成两个实例，一个是”def”的实例对象，并且StringTable中存储一个”def”的引用值，还有一个是new出来的一个”def”的实例对象 与上面那个是不同的实例</li>
<li>当在解析str3的时候查找StringTable，里面有”abc”的全局驻留字符串引用，所以str3的引用地址与之前的那个已存在的相同</li>
<li>str4是在运行的时候调用intern()函数，返回StringTable中”def”的引用值，如果没有就将str2的引用值添加进去，在这里，StringTable中已经有了”def”的引用值了，所以返回上面在new str2的时候添加到StringTable中的 “def”引用值</li>
<li>上面程序的首先经过编译之后，在该类的class常量池中存放一些符号引用，然后类加载之后，将class常量池中存放的符号引用转存到运行时常量池中，然后经过验证，准备阶段之后，在堆中生成驻留字符串的实例对象（也就是上例中str1所指向的”abc”实例对象），然后将这个对象的引用存到全局String Pool中，也就是StringTable中，最后在解析阶段，要把运行时常量池中的符号引用替换成直接引用，那么就直接查询StringTable，保证StringTable里的引用值与运行时常量池中的引用值一致，大概整个过程就是这样了。</li>
</ul>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li>1.全局常量池在每个VM中只有一份，存放的是字符串常量的引用值。</li>
<li>2.class常量池是在编译的时候每个class都有的，在编译阶段，存放的是常量的符号引用。</li>
<li>3.运行时常量池是在类加载完成之后，将每个class常量池中的符号引用值转存到运行时常量池中，也就是说，每个class都有一个运行时常量池，类在解析之后，将符号引用替换成直接引用，与全局常量池中的引用值保持一致。</li>
</ul>
<h3 id="class文件常量池和运行时常量池"><a href="#class文件常量池和运行时常量池" class="headerlink" title="class文件常量池和运行时常量池"></a>class文件常量池和运行时常量池</h3><p>最近一直被方法区里面存着什么东西困扰着？</p>
<pre><code> 1.方法区里存class文件信息和class文件常量池是个什么关系。

 2.class文件常量池和运行时常量池是什么关系。        </code></pre>
<p>方法区存着类的信息，常量和静态变量，即类被编译后的数据。这个说法其实是没问题的，只是太笼统了。更加详细一点的说法是方法区里存放着类的版本，字段，方法，接口和常量池。常量池里存储着字面量和符号引用。</p>
<p>符号引用包括：1.类的全限定名，2.字段名和属性，3.方法名和属性。</p>
<p><img src="http://wx1.sinaimg.cn/large/006b7Nxngy1g1bbqzm910j30jh0bnjry.jpg"><br><img src="http://wx1.sinaimg.cn/large/006b7Nxngy1g1bbrhy9jzj30k90b8abh.jpg"></p>
<p> 可以看到在方法区里的class文件信息包括：魔数，版本号，常量池，类，父类和接口数组，字段，方法等信息，其实类里面又包括字段和方法的信息。</p>
<p><img src="http://wx1.sinaimg.cn/large/006b7Nxngy1g1bbrzbkpdj30o90jzt9j.jpg"></p>
<p><img src="http://wx1.sinaimg.cn/large/006b7Nxngy1g1bbsjfbubj30nz0e30ui.jpg" alt="输入图片说明"></p>
<h3 id="class文件常量池和运行时常量池的关系以及区别"><a href="#class文件常量池和运行时常量池的关系以及区别" class="headerlink" title="class文件常量池和运行时常量池的关系以及区别"></a>class文件常量池和运行时常量池的关系以及区别</h3><ul>
<li><p>class文件常量池存储的是当class文件被java虚拟机加载进来后存放在方法区的一些字面量和符号引用，字面量包括字符串，基本类型的常量。</p>
</li>
<li><p>运行时常量池是当class文件被加载完成后，java虚拟机会将class文件常量池里的内容转移到运行时常量池里，在class文件常量池的符号引用有一部分是会被转变为直接引用的，比如说类的静态方法或私有方法，实例构造方法，父类方法，这是因为这些方法不能被重写其他版本，所以能在加载的时候就可以将符号引用转变为直接引用，而其他的一些方法是在这个方法被第一次调用的时候才会将符号引用转变为直接引用的。</p>
<p><strong>总结：</strong> </p>
</li>
<li><p>方法区里存储着class文件的信息和运行时常量池,class文件的信息包括类信息和class文件常量池。</p>
</li>
<li><p>运行时常量池里的内容除了是class文件常量池里的内容外，还将class文件常量池里的符号引用转变为直接引用，而且运行时常量池里的内容是能动态添加的。例如调用String的intern方法就能将string的值添加到String常量池中，这里String常量池是包含在运行时常量池里的，但在jdk1.8后，将String常量池放到了堆中。</p>
</li>
</ul>
<h2 id="10-类文件结构"><a href="#10-类文件结构" class="headerlink" title="10. 类文件结构"></a>10. 类文件结构</h2><h3 id="1-class类文件结构"><a href="#1-class类文件结构" class="headerlink" title="1.class类文件结构"></a>1.class类文件结构</h3><ul>
<li>class 文件结构是一组以8位字节为基础单位的二进制流。存储的内容几乎全部是程序运行的必要数据，无空隙。</li>
<li>如果需要占用8位字节以上空间的数据，则按照高位在前的方式分割成若干个8位字节进行存储。</li>
<li>class文件结构采用一种类似C语言体系的伪结构体系，这种伪结构只有无符号数和表两种数据类型。</li>
</ul>
<h4 id="魔数与Class文件的版本"><a href="#魔数与Class文件的版本" class="headerlink" title="魔数与Class文件的版本"></a>魔数与Class文件的版本</h4><ul>
<li>class文件的头4个字节称为魔数，唯一作用是确定这个文件是否为一个能被虚拟机接受的文件。</li>
<li>魔数值可以自由选择,只要未被广泛使用同事不会引起混淆。</li>
<li>紧接着魔数的4个字节是class文件版本号，第5和第6个字节是次版本你好，7和8个字节是class文件版本号(java版本号从45开始。jdk7是51.0)</li>
</ul>
<h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><ul>
<li>主次版本号之后的是常量池，常量池可以理解为class文件中的资源仓库。</li>
<li>class文件结构中只有常量的容量技术是从1开始</li>
<li>常量池主要存放两大类常量：字面量(如文本字符串，finald常量)和符号引用(类和接口的全限定名，字段的名称和描述符，方法的名称和描述符)。</li>
<li>虚拟机运行时,需从常量池获取对应的符号引用，再在类创建时或运行将诶系会，翻译到哪具体的内存地址中。</li>
</ul>
<h4 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h4><p>常量池之后的两个字节代表访问标志，用于识别class是类还是接口，是否为public类型或abstract类型等等。</p>
<h4 id="类索引-父类缩影与接口索引集合"><a href="#类索引-父类缩影与接口索引集合" class="headerlink" title="类索引,父类缩影与接口索引集合"></a>类索引,父类缩影与接口索引集合</h4><ul>
<li>这三项按顺序排列在访问标志之后,class文件中由这三项来确定整个类的继承关系。</li>
<li>类索引用于确定类的全限定名，父类索引用于确定类的父类权限定名。接口索引集合描述类实现了哪些接口</li>
</ul>
<h4 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h4><p>用于描述接口或类中声明的变量。字段包裹类级别的变量和实列变量。不包括方法内部声明的局部变量。</p>
<h4 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h4><p>方法表结构依次包括访问标志,名称索引,描述索引,属性集合.</p>
<h2 id="11-虚拟机字节码执行引擎"><a href="#11-虚拟机字节码执行引擎" class="headerlink" title="11. 虚拟机字节码执行引擎"></a>11. 虚拟机字节码执行引擎</h2><p>执行引擎是Java虚拟机最核心的组成部分之一。</p>
<h3 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h3><ul>
<li>栈帧用于虚拟机进行方法调用和方法执行的数据结构。</li>
<li>栈帧存储了方法的局部变量表,操作数据栈,动态链接和返回地址等信息。每一个方法从调用开始至执行完成过程,都是在虚拟机中入栈到出栈的过程。</li>
<li>栈帧需要分配多少内存，不受程序运行时期变量数据影响，取决虚拟机的具体实现。</li>
</ul>
<h4 id="1-局部变量表"><a href="#1-局部变量表" class="headerlink" title="1.局部变量表"></a>1.局部变量表</h4><ul>
<li>一组变量值存储空间,存放方法参数和方法内部的局部变量, 类编译为class文件时就在方法的code属性max_locals中确定了方法局部变量表的最大容量。</li>
<li>一变量槽”Slot“为最小单位,虚拟机没指明solt的占用内存大小,一般每个solt都可以存放一个boolean,bye,char,short,int,float,reference或returnAddress类的数据(32位或更小物理内存存放)。</li>
<li>它是建立在线程的堆栈上。是线程私有的数据,所以是线程安全的。</li>
<li>虚拟机通过索引的方式使用局部变量表。执行方法时,通过局部变量表完成参数值到参数变量列表的过程。如果执行实列方法(非static),变量表中第0位索引的slot默认用户传递方法的引用。</li>
</ul>
<h4 id="2-操作数栈"><a href="#2-操作数栈" class="headerlink" title="2.操作数栈"></a>2.操作数栈</h4><ul>
<li>它是一个后入先出的栈。同局部变量表一样，最大深度在编译时写入到code属性的max_stacks中。</li>
<li>操作数栈的每一个元素可以是任意的Java数据类型。32位的数据类所占的栈容量为1,64位栈容量2(long,double)</li>
<li>一个方方法刚开始执行时,操作数栈时空的。在方法执行过程中,通过各种字节码指令往操作数栈写入和提取内容,也就是出栈/入栈操作.</li>
</ul>
<h4 id="3-动态链接"><a href="#3-动态链接" class="headerlink" title="3.动态链接"></a>3.动态链接</h4><ul>
<li>每个栈帧都包含一个指向运行时常量池中该栈所属方法的引用，持有这个引用是为了支持方法调用过程中的动态链接</li>
</ul>
<h4 id="4-方法返回地址"><a href="#4-方法返回地址" class="headerlink" title="4.方法返回地址"></a>4.方法返回地址</h4><ul>
<li>一个方法执行后，只有通过正常完成出口和异常完成出口两种方式退出。</li>
<li>正常完成出口：当执行引擎遇到一个方法返回的字节码指令</li>
<li>异常完成出口：方法执行过程中遇到异常且方法中未处理此异常,就会导致方法退出。</li>
<li>方法正常退出时,调用者的程序计数器的值可以作为返回地址。</li>
<li>方法退出的过程等于就是把当前栈帧出栈。</li>
</ul>
<h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><ul>
<li>方法调用不等于方法执行,方法调用阶段唯一任务就是确定被调用方法的版本。</li>
<li>一切方法调用在Class文件里存储都只是符号引用,而不是方法在实际运行时内存布中的入口地址(直接引用）。</li>
</ul>
<h4 id="1-解析"><a href="#1-解析" class="headerlink" title="1.解析"></a>1.解析</h4><ul>
<li>所有方法调用重点目标方法在Class文件里都是一个常量池的符号引用,解析阶段会将一部分符号引用转化为直接引用。</li>
<li>“编译器可知,运行期间不可变”这类方法的调用称为解析.(静态方法和私有方法)</li>
<li>只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本.(比如静态方法,私有方法,实列构造器,父类方法)它们在类加载时候会把符号引用解析为该方法的直接引用。</li>
</ul>
<h4 id="2-静态分派"><a href="#2-静态分派" class="headerlink" title="2.静态分派"></a>2.静态分派</h4><p>在重载时时通过参数的静态类型而不是实际类型作为判定依据的。并且静态类型是编译可知的。<br>静态分派的典型应用就是方法重载</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">//左边是静态类型 右边是实际类型</span></span><br><span class="line">Human man=<span class="keyword">new</span> <span class="type">Man</span>();</span><br><span class="line">Huamn woman=<span class="keyword">new</span> <span class="type">Woman</span>();</span><br></pre></td></tr></table></figure>
<h4 id="3-动态分派"><a href="#3-动态分派" class="headerlink" title="3.动态分派"></a>3.动态分派</h4><p>方法的重写就是动态分派的体现。</p>
<h2 id="12-高效并发"><a href="#12-高效并发" class="headerlink" title="12. 高效并发"></a>12. 高效并发</h2><h3 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h3><ul>
<li>JAVA内模型规定所有的变量都存储在主内存中，每个线程都有自己的工作内存，线程的工作内存中保存的是当前线程使用到的变量值的副本（主内村拷贝过来的）。</li>
<li>线程对变量的所有操作都必须在工作内存中进行，不能直接与主内存进行读写交.线程间相互的传值需要通过主内存完成。</li>
</ul>
<h3 id="内存间的交互"><a href="#内存间的交互" class="headerlink" title="内存间的交互"></a>内存间的交互</h3><p>JAVA内存模型定义了以下8种操作来完成内存交互工作：</p>
<ul>
<li><p><code>lock</code>(锁定)：作用于主内存的变量。把一个变量标识为一条线程独占的状态。</p>
</li>
<li><p><code>unlock</code>(解锁)：作用于主内存的变量.把一个处于锁定状态的变量释放出来。</p>
</li>
<li><p><code>read</code>(读取):作用于主内存的变量。把一个变量值从主内存传输到线程的工作内存中，以便随后的<code>load</code>动作使用。</p>
</li>
<li><p><code>load</code>(载入):作用于工作内存的变量，它把read操作从主内存中得到的值放入工作内存的变量副本中。</p>
</li>
<li><p><code>use</code>(使用)：作用与工作内存的变量.它把工作内存中一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时就会执行这个操作。</p>
</li>
<li><p><code>assign</code>(赋值）:作用于工作内存的变量，它把一个从执行引擎收到的赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</p>
</li>
<li><p><code>store</code>(存储)：作用于工作内存的变量，它把工作内存中的一个变量的值传送到主内存中，以便随后的wirte操作使用。</p>
</li>
<li><p><code>wirte</code>（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量值放入主内存中。</p>
<p><strong>上述操作虚拟机实现时保证每一种操作都是原子性的。且比如满足如下规则</strong></p>
</li>
<li><p>不 _允许一个变量从主内存读取但工作内存不接受，或者工作内存发起回写了但主内存不接受的情况出现</p>
</li>
<li><p>变量在工作内存中改变之后必须把该变化同步回主内存</p>
</li>
<li><p>一个新的变量必须在主内存中诞生。不允许工作内存直接使用未初始化的变量。</p>
</li>
<li><p>一个变量同一个时刻只能一条线程进行lock操作，但是lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。</p>
</li>
<li><p>如果一个变量执行lock操作,那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作。</p>
</li>
<li><p>如果一个变量事先没有被lock操作锁定，那将不允许执行unlock操作，也不允许去unlock一个被其它线程锁定住的变量</p>
</li>
<li><p>对一个变量执行unlock操作之前,必须先把此变量同步回主内存中 </p>
</li>
</ul>
<h3 id="对于volatile型变量的特殊规则"><a href="#对于volatile型变量的特殊规则" class="headerlink" title="对于volatile型变量的特殊规则"></a>对于volatile型变量的特殊规则</h3><ul>
<li>volatile是虚拟机提供的最轻量级同步机制。它具备两种特性：保证被修饰的变量对所有线程可见（即可见性）和禁止指令重排序。</li>
<li>volatile只能保证可见性，不能保证操作运算的原子性。</li>
<li>运算结果并不依赖变量的当前值时和不需要与其他的状态变量共同参与不变约束时适合使用volatile</li>
</ul>
<h3 id="对于long和double型变量的特殊规则"><a href="#对于long和double型变量的特殊规则" class="headerlink" title="对于long和double型变量的特殊规则"></a>对于long和double型变量的特殊规则</h3><ul>
<li>对于64位的数据类型long和double,在内存模型中有一条相对宽松的规定：允许虚拟机将没有被volatile修饰的64位数据类型分为两次32位的操作来新型。</li>
<li>允许虚拟机实现选择可以不保证64位数据类型的<code>load</code>,<code>storm</code>,<code>read</code>,<code>write</code>这个四个操作的原子性（ong和double的非原子性协定）</li>
<li>JAVA内存模型虽然允许虚拟机不把<code>long</code>和<code>double</code>变量的读写实现成原子操作，但允许虚拟机选择把这些操作实现为具有原子性的操作。目前各种平台下的虚拟机几乎都选择吧64位数据类型读写操作作为原子操作对待。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL实战45讲</title>
    <url>/2020/10/14/0000.MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="一条SQL查询语句是如何执行的"><a href="#一条SQL查询语句是如何执行的" class="headerlink" title="一条SQL查询语句是如何执行的"></a>一条SQL查询语句是如何执行的</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from T where ID=10；</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20190410210326412.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70" alt="MySQL的逻辑架构图"></p>
<blockquote>
<p>大体来说，MySQL可以分为<code>Server</code>层和<code>存储引擎</code>层两部分</p>
</blockquote>
<ul>
<li><code>Server</code>层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</li>
<li><code>存储引擎层</code>负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认存储引擎。</li>
<li>不同的存储引擎共用一个Server层，也就是从连接器到执行器的部分</li>
<li></li>
<li>*连接器**</li>
<li>第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在<code>show processlist</code>命令中看到它。客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数<code>wait_timeout</code>控制的，默认值是<code>8</code>小时。数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</li>
</ul>
<p><strong>查询缓存</strong></p>
<ul>
<li>连接建立完成后，你就可以执行select语句了。执行逻辑就会来到第二步：查询缓存。</li>
<li>MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端。</li>
<li>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。<blockquote>
<p>大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。</p>
</blockquote>
</li>
</ul>
<p><strong>分析器</strong></p>
<ul>
<li>如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL需要知道你要做什么，因此需要对SQL语句做解析。分析器先会做<code>“词法分析”</code>,词法分析完后就要做<code>“语法分析”</code>。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒</li>
</ul>
<p><strong>优化器</strong></p>
<ul>
<li>经过了分析器，MySQL就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。</li>
<li>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。<blockquote>
<p>比如你执行下面这样的语句，这个语句是执行两个表的join：<br><code>mysql&gt; select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;</code><br>既可以先从表t1里面取出c=10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。<br>也可以先从表t2里面取出d=20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否等于10。<br>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。</p>
</blockquote>
</li>
</ul>
<p><strong>执行器</strong></p>
<ul>
<li><p>MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。</p>
</li>
<li><p>开始执行的时候，要先判断一下你对这个表T有没有执行查询的权限，如果没有，就会返回没有权限的错误</p>
</li>
<li><p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</p>
<blockquote>
<p><code>mysql&gt; select * from T where ID=10;</code><br>比如我们这个例子中的表T中，ID字段没有索引，那么执行器的执行流程是这样的：<br>调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中；<br>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。<br>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</p>
</blockquote>
</li>
<li><p>至此，这个整个语句就执行完成了。一条查询语句的执行过程一般是经过连接器、分析器、优化器、执行器等功能模块，最后到达存储引擎。</p>
</li>
</ul>
<h3 id="一条SQL更新语句是如何执行的"><a href="#一条SQL更新语句是如何执行的" class="headerlink" title="一条SQL更新语句是如何执行的"></a>一条SQL更新语句是如何执行的</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> T <span class="keyword">set</span> c=c+<span class="number">1</span> <span class="keyword">where</span> <span class="keyword">ID</span>=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>与查询流程不一样的是，更新流程还涉及两个重要的日志模块 <code>redo log</code>（重做日志）和 <code>binlog</code>（归档日志）</li>
<li>每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高。为了解决这个问题，MySQL的设计者WAL技术，WAL的全称是Write-Ahead Logging，它的关键点就是<code>先写日志</code>，<code>再写磁盘</code></li>
<li>当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log里面，并更新内存，这个时候更新就算完成了。</li>
<li>同时，<code>InnoDB</code>引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。但是<code>InnoDB</code>的<code>redo log</code>是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB,总共就可以记录4GB的操作。从头开始写，写到末尾就又回到开头循环写。</li>
<li>在进行<code>redo log</code>写入时，有两个重要参数的write pos(当前记录的位置),<code>checkpoint</code>是当前要擦除的位置<br><img src="https://img-blog.csdnimg.cn/20190410230340406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70"></li>
<li>一边写一边后移，写到第3号文件末尾后就回到0号文件开头,checkpoint也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。write pos和checkpoint之间还空着的部分，可以用来记录新的操作。</li>
<li>如果<code>write pos</code>追上<code>checkpoin</code>，表示<code>redo log</code>满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把checkpoint推进一下。</li>
<li>有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe(崩溃安全()。</li>
<li>redo log是InnoDB引擎特有的日志，而Server层也有自己的日志，称为binlog（归档日志）</li>
<li>最开始MySQL里并没有<code>InnoDB引擎</code>。MySQL自带的引擎是MyISAM，但是MyISAM没有crash-safe的能力，binlog日志只能用于归档。而InnoDB是另一个公司以插件形式引入MySQL的，既然只依靠binlog是没有crash-safe能力的，所以InnoDB使用另外一套日志系统——也就是redo log来实现crash-safe能力。</li>
</ul>
<blockquote>
<p><code>redo log是InnoDB引擎特有的</code>；binlog是MySQL的Server层实现的，所有引擎都可以使用。<br><code>redo log是物理日志</code>，记录的是“在某个数据页上做了什么修改”；<code>binlog是逻辑日志</code>，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1 ”。<br>r<code>edo log是循环写的</code>，<code>空间固定</code>会用完；<code>binlog是可以追加写入的</code>。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</p>
</blockquote>
<p><strong>执行器和InnoDB引擎在执行这个简单的update语句时的内部流程:</strong></p>
<ul>
<li>执行器先找引擎取ID=2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li>
<li>执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li>
<li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。</li>
<li>执行器生成这个操作的binlog，并把binlog写入磁盘。</li>
<li>执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。</li>
<li>redo log的写入拆成了两个步骤：prepare和commit，这就是<code>&quot;两阶段提交&quot;</code>。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2019041023325625.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70"></p>
<blockquote>
<p><code>1 prepare阶段 2 写binlog 3 commit</code> , 当在<code>2之前崩溃时</code>,重启恢复：后发现没有commit，回滚。备份恢复：没有binlog 。<br><code>当在3之前崩溃</code>,重启恢复：虽没有commit，但满足prepare和binlog完整，所以重启后会自动commit。备份：有binlog. 一致</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>Redo log不是记录数据页“更新之后的状态”，而是记录这个页 “做了什么改动”。</li>
<li>Binlog有两种模式，statement 格式的话是记sql语句， row格式会记录行的内容，记两条，更新前和更新后都有。</li>
</ul>
<h3 id="事务隔离：为什么你改了我还看不见"><a href="#事务隔离：为什么你改了我还看不见" class="headerlink" title="事务隔离：为什么你改了我还看不见"></a>事务隔离：为什么你改了我还看不见</h3><ul>
<li><p>事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在MySQL中，事务支持是在引擎层实现的。MySQL默认的<code>MyISAM</code>引擎就不支持事务，这也是<code>MyISAM</code>被<code>InnoDB</code>取代的重要原因之一。</p>
</li>
<li><p>事务的特性：<code>ACID</code>即原子性、一致性、隔离性、持久性。多个事务同时执行的时候，就可能出现<code>脏读</code>，<code>不可重复读</code>，<code>幻读</code>，为了解决这些问题，就有了“<code>隔离级别</code>”的概念。但是隔离得越严实，效率就会越低</p>
</li>
<li><p>SQL标准的事务隔离级别包括：<code>读未提交</code>（read uncommitted）、<code>读提交</code>（read committed）、<code>可重复读</code>（repeatable read）和<code>串行化</code>（serializable ）</p>
<blockquote>
<p>读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。<br>读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。<br>可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。未提交的更改对其他事务是不可见的<br>串行化:对应一个记录会加读写锁，出现冲突的时候，后访问的事务必须等前一个事务执行完成才能继续执行</p>
</blockquote>
</li>
<li><p>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“<code>可重复读</code>”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在<code>“读提交”</code>隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的。<code>“读未提交”</code>隔离级别下直接返回记录上的最新值，没有视图概念。<code>串行化</code>”隔离级别下直接用加锁的方式来避免并行访问</p>
</li>
<li><p>查看数据库的实物隔离级别：<code>show variables like &#39;%isolation%&#39;;</code></p>
</li>
<li><p>事务隔离的实现：在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。</p>
</li>
</ul>
<p>假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录。不同时刻启动的事务会有不同的read-view，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（<code>MVCC</code>）<br><img src="https://img-blog.csdnimg.cn/20190411130916709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70"></p>
<ul>
<li>回滚日志总不能一直保留吧，什么时候删除呢？答案是，在不需要的时候才删除。系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的read-view的时候。</li>
<li>为什么尽量不要使用长事务。长事务意味着系统里面会存在很老的事务视图，在这个事务提交之前，回滚记录都要保留，这会导致大量占用存储空间。除此之外，长事务还占用锁资源，可能会拖垮库。</li>
<li>事务启动方式：一、显式启动事务语句，<code>begin</code>或者<code>start transaction</code>,提交<code>commit</code>，回滚<code>rollback</code>；二、<code>set autocommit=0</code>，该命令会把这个线程的自动提交关掉。这样只要执行一个select语句，事务就启动，并不会自动提交，直到主动执行<code>commit</code>或<code>rollback</code>或断开连接。</li>
<li>建议使用方法一，如果考虑多一次交互问题，可以使用<code>commit work and chain</code>语法。在<code>autocommit=1</code>的情况下用<code>begin</code>显式启动事务，如果执行<code>commit</code>则提交事务。如果执行<code>commit work and chain</code>则提交事务并自动启动下一个事务</li>
</ul>
<h3 id="深入浅出索引（上）"><a href="#深入浅出索引（上）" class="headerlink" title="深入浅出索引（上）"></a>深入浅出索引（上）</h3><p><strong>索引的常见模型</strong></p>
<ul>
<li>索引的出现是为了提高查询效率，常见的三种索引模型分别是<code>哈希表</code>、<code>有序数组</code>和<code>搜索树</code></li>
<li><code>哈希表</code>：一种以<code>key-value</code> 存储数据的结构，哈希的思路是把值放在数组里，用一个哈希函数把<code>key</code>换算成一个确定的位置，然后把<code>value</code>放在数组的这个位置。哈希冲突的处理办法是使用<code>链表</code>。哈希表适用只有<code>等值查询</code>的场景</li>
<li><code>有序数组</code>：按顺序存储。查询用二分法就可以快速查询，时间复杂度是：O(log(N))。查询效率高，更新效率低（涉及到移位）。在等值查询和范围查询场景中的性能就都非常优秀。有序数组索引只适用于静态存储引擎。</li>
<li>二叉搜索树：每个节点的左儿子小于父节点，右儿子大于父节点。查询时间复杂度O(log(N))，更新时间复杂度O(log(N))。数据库存储大多不适用二叉树，因为树高过高，会适用N叉树</li>
</ul>
<p><strong>InnoDB 的索引模型</strong></p>
<ul>
<li><code>InnoDB</code>使用了<code>B+树</code>索引模型，所以数据都是存储在B+树中的。每一个索引在<code>InnoDB</code>里面对应一棵B+树。</li>
<li>索引类型分为<code>主键索引</code>和<code>非主键索引</code>。主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也被称为<code>聚簇索引</code>。非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为<code>二级索引</code></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190411164702315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70" alt="InnoDB的索引组织结构"></p>
<p><strong>主键索引和普通索引的查询有什么区别？</strong></p>
<ul>
<li>如果语句是<code>select * from T where ID=500</code>，即主键查询方式，则只需要搜索ID这棵B+树；</li>
<li>如果语句是<code>select * from T where k=5</code>，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为<code>回表</code>。</li>
<li>基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询</li>
</ul>
<p><strong>索引维护</strong></p>
<ul>
<li><code>B+树</code>为了维护索引有序性，在插入新值的时候需要做必要的维护。涉及到数据的移动和数据页的增加和删减</li>
<li>一个数据页满了，按照B+Tree算法，新增加一个数据页，叫做<code>页分裂</code>，会导致性能下降。空间利用率降低大概50%。当相邻的两个数据页利用率很低的时候会做<code>数据页合并</code>，合并的过程是分裂过程的<code>逆过程</code>。</li>
</ul>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul>
<li>索引可能因为删除，或者页分裂等原因，导致数据页有空洞，重建索引的过程会创建一个新的索引，把数据按顺序插入，这样页面的利用率最高，也就是索引更紧凑、更省空间。<blockquote>
<p><code>alter table T drop index k</code>;     alter table T add index(k);<br>要重建主键索引<br><code>alter table T drop primary key</code>;      <code>alter table T add primary key(id)</code>;<br>重建索引k的做法是合理的，可以达到省空间的目的。但是，重建主键的过程不合理。不论是删除主键还是创建主键，都会将整个表重建。所以连着执行这两个语句的话，第一个语句就白做了。<br>可以用这个语句代替 ： alter table T engine=InnoDB</p>
</blockquote>
</li>
</ul>
<h3 id="深入浅出索引（下）"><a href="#深入浅出索引（下）" class="headerlink" title="深入浅出索引（下）"></a>深入浅出索引（下）</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table T (</span><br><span class="line">ID int primary key,</span><br><span class="line">k int NOT NULL DEFAULT 0, </span><br><span class="line">s varchar(16) NOT NULL DEFAULT &#x27;&#x27;,</span><br><span class="line">index k(k))</span><br><span class="line">engine=InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> T <span class="keyword">values</span>(<span class="number">100</span>,<span class="number">1</span>, <span class="string">&#x27;aa&#x27;</span>),(<span class="number">200</span>,<span class="number">2</span>,<span class="string">&#x27;bb&#x27;</span>),(<span class="number">300</span>,<span class="number">3</span>,<span class="string">&#x27;cc&#x27;</span>),(<span class="number">500</span>,<span class="number">5</span>,<span class="string">&#x27;ee&#x27;</span>),(<span class="number">600</span>,<span class="number">6</span>,<span class="string">&#x27;ff&#x27;</span>),(<span class="number">700</span>,<span class="number">7</span>,<span class="string">&#x27;gg&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20190411193509228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70" alt="InnoDB的索引组织结构"><br>如果我执行 <code>select * from T where k between 3 and 5</code>，需要执行几次树的搜索操作，会扫描多少行？</p>
<p><strong>SQL查询语句的执行流程：</strong></p>
<ul>
<li>在k索引树上找到k=3的记录，取得 ID = 300；</li>
<li>再到ID索引树查到ID=300对应的R3；</li>
<li>在k索引树取下一个值k=5，取得ID=500；</li>
<li>再回到ID索引树查到ID=500对应的R4；</li>
<li>在k索引树取下一个值k=6，不满足条件，循环结束。</li>
<li>在这个过程中，回到主键索引树搜索的过程，我们称为回表。可以看到，这个查询过程读了k索引树的3条记录，回表了两次。在这个例子中，由于查询结果所需要的数据只在主键索引上有，所以不得不回表。</li>
</ul>
<p><strong>优化方式</strong></p>
<ul>
<li>sql语句修改为<code>select ID from T where k between 3 and 5</code>，这时只需要查ID的值，而ID的值已经在k索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引k已经“覆盖了”我们的查询需求，我们称为<code>覆盖索引</code>。</li>
<li>由于<code>覆盖索引</code>可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</li>
</ul>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><ul>
<li><code>覆盖索引</code>：如果查询条件使用的是普通索引（或是联合索引的最左原则字段），查询结果是联合索引的字段或是主键，不用回表操作，直接返回结果，减少IO磁盘读写读取正行数据</li>
<li><code>最左前缀</code>：联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符</li>
<li><code>联合索引</code>：根据创建联合索引的顺序，以最左原则进行where检索，比如（age，name）以age=1 或 age= 1 and name=‘张三’可以使用索引，单以name=‘张三’ 不会使用索引，考虑到存储空间的问题，还请根据业务需求，将查找频繁的数据进行靠左创建索引。</li>
<li>索引下推：<code>like &#39;hello%’and age &gt;10</code> 检索，MySQL5.6版本之前，会对匹配的数据进行回表查询。5.6版本后，会先过滤掉age&lt;10的数据，再进行回表查询，减少回表率，提升检索速度</li>
</ul>
<h3 id="讲全局锁和表锁：给表加个字段怎么有这么多阻碍"><a href="#讲全局锁和表锁：给表加个字段怎么有这么多阻碍" class="headerlink" title="讲全局锁和表锁：给表加个字段怎么有这么多阻碍"></a>讲全局锁和表锁：给表加个字段怎么有这么多阻碍</h3><blockquote>
<p>根据加锁的范围，MySQL里面的锁大致可以分成全局锁、表级锁和行锁三类</p>
</blockquote>
<p><strong>全局锁</strong></p>
<ul>
<li>对整个数据库实例加锁。MySQL提供加全局读锁的方法：<code>Flush tables with read lock(FTWRL)</code>。这个命令可以使整个库处于只读状态。使用该命令之后，数据更新语句、数据定义语句和更新类事务的提交语句等操作都会被阻塞。使用场景：<code>全库逻辑备份</code>。</li>
<li>风险是如果在主库备份，在备份期间不能更新，业务停摆。如果在从库备份，备份期间不能执行主库同步的binlog，导致主从延迟。官方自带的逻辑备份工具<code>mysqldump</code>，当mysqldump使用参数<code>--single-transaction</code>的时候，会启动一个事务，确保拿到一致性视图。而由于<code>MVCC</code>的支持，这个过程中数据是可以正常更新的。</li>
<li>一致性读是好，但是前提是引擎要支持这个隔离级别。如果要全库只读，为什么不使用<code>set global readonly=true</code>的方式？在有些系统中，<code>readonly</code>的值会被用来做其他逻辑，比如判断主备库。所以修改global变量的方式影响太大。</li>
<li>在异常处理机制上有差异。如果执行<code>FTWRL</code>命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为<code>readonly</code>之后，如果客户端发生异常，则数据库就会一直保持<code>readonly</code>状态，这样会导致整个库长时间处于不可写状态，风险较高。</li>
</ul>
<p><strong>表级锁</strong></p>
<ul>
<li><p>MySQL里面表级锁有两种，一种是表锁，一种是元数据所(meta data lock,MDL)。表锁的语法是:l<code>ock tables ... read/write</code></p>
</li>
<li><p>可以用<code>unlock tables</code>主动释放锁，也可以在客户端断开的时候自动释放。<code>lock tables</code>语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</p>
</li>
<li><p>对于<code>InnoDB</code>这种支持<code>行锁</code>的引擎，一般不使用<code>lock tables</code>命令来控制并发，毕竟锁住整个表的影响面还是太大。</p>
</li>
<li><p>另一类表级的锁是<code>MDL</code>（metadata lock)。<code>MDL不需要显式使用</code>，在访问一个表的时候会被<code>自动加上</code>。MDL的作用是，<code>保证读写的正确性</code>。当对一个表做增删改查操作的时候，加<code>MDL读锁</code>；当要对表做结构变更操作的时候，加<code>MDL写锁</code>。<code>读锁之间不互斥</code>，因此你可以有多个线程同时对一张表增删改查。<code>读写锁之间、写锁之间是互斥的</code>，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</p>
</li>
<li><p><code>MDL</code> 会直到事务提交才会释放，在做表结构变更的时候，一定要小心不要导致锁住线上查询和更新。</p>
<p><strong>如何安全地给表加字段</strong></p>
</li>
<li><p>给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据。首先我们要解决长事务，事务不提交，就会一直占着MDL锁。在MySQL的<code>information_schema</code> 库的 <code>innodb_trx</code> 表中，你可以查到当前执行中的事务。如果你要做<code>DDL</code>变更的表刚好有<code>长事务</code>在执行，要考虑先暂停DDL，或者<code>kill</code>掉这个长事务。</p>
</li>
<li><p>如果你要变更的表是一个<code>热点表</code>，虽然数据量不大，但是上面的请求很频繁，这时候kill可能未必管用，因为新的请求马上就来了。比较理想的机制是，在<code>alter table</code>语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到<code>MDL写锁</code>最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者DBA再通过重试命令重复这个过程。</p>
</li>
</ul>
<h3 id="讲行锁功过：怎么减少行锁对性能的影响"><a href="#讲行锁功过：怎么减少行锁对性能的影响" class="headerlink" title="讲行锁功过：怎么减少行锁对性能的影响"></a>讲行锁功过：怎么减少行锁对性能的影响</h3><ul>
<li>MySQL的<code>行锁</code>是在引擎层由各个<code>引擎自己实现</code>的。但并不是所有的引擎都支持行锁，比<code>如MyISAM引擎就不支持行锁</code>。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。<code>InnoDB是支持行锁</code>的，这也是<code>MyISAM</code>被<code>InnoDB</code>替代的重要原因之一。</li>
<li><code>两阶段锁协议</code>：在<code>InnoDB</code>事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</li>
<li><code>死锁</code>：当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190412161554856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70"></p>
<ul>
<li><code>事务A</code>在等待<code>事务B</code>释放id=2的行锁，而<code>事务B在等待事务A</code>释放id=1的行锁。 事务A和事务B在互相等待对方的资源释放，就是进入了<code>死锁状态</code></li>
</ul>
<p><strong>出现死锁以后，有两种策略：</strong></p>
<ul>
<li>一种策略是，<code>直接进入等待，直到超时</code>。这个超时时间可以通过参数<code>innodb_lock_wait_timeout</code>来设置。在InnoDB中，默认值是<code>50s</code></li>
<li>另一种策略是，<code>发起死锁检测</code>，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数<code>innodb_deadlock_detect设置为on</code>，表示开启这个逻辑。默认值本身就是on</li>
<li>正常情况下选择第二种策略，但是它也是有额外负担的，如果瞬间有大量线程请求会消耗消耗大量的CPU资源，但是每秒却执行不了几个事务，因为每次都要检测。</li>
</ul>
<p><strong>怎么解决由这种热点行更新导致的性能问题?</strong></p>
<ul>
<li>问题的症结在于，死锁检测要耗费大量的CPU资源</li>
<li>如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。 一般不建议采用</li>
<li>控制并发度，对应相同行的更新，在进入引擎之前排队。这样在InnoDB内部就不会有大量的死锁检测工作了。</li>
<li>将热更新的行数据拆分成逻辑上的多行来减少锁冲突，但是业务复杂度可能会大大提高。</li>
<li><code>innodb行级锁是通过锁索引记录实现的，如果更新的列没建索引是会锁住整个表的。</code> </li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>如果你要删除一个表里面的前10000行数据，有以下三种方法可以做到：</p>
<ul>
<li>第一种，直接执行     <code>delete from T limit 10000;</code>   </li>
<li>第二种，在一个连接中循环执行20次 <code>delete from T limit 500;</code></li>
<li>第三种，在20个连接中同时执行    <code>delete from T limit 500</code></li>
</ul>
<p><strong>三种方案分析</strong></p>
<ul>
<li>方案一，事务相对较长，则占用锁的时间较长，会导致其他客户端等待资源时间较长。</li>
<li>方案二，串行化执行，将相对长的事务分成多次相对短的事务，则每次事务占用锁的时间相对较短，其他客户端在等待相应资源的时间也较短。这样的操作，同时也意味着将资源分片使用（每次执行使用不同片段的资源），可以提高并发性。</li>
<li>方案三，人为自己制造锁竞争，加剧并发量。</li>
</ul>
<h3 id="事务到底是隔离的还是不隔离的"><a href="#事务到底是隔离的还是不隔离的" class="headerlink" title="事务到底是隔离的还是不隔离的"></a>事务到底是隔离的还是不隔离的</h3><ul>
<li><code>innodb</code>支持<code>RC(读提交)</code>和<code>RR(可重复读)</code>隔离级别实现是用的一致性视图(consistent read view)</li>
<li>.事务在启动时会拍一个快照,这个快照是基于整个库的。基于整个库的意思就是说一个事务内,整个库的修改对于该事务都是不可见的(对于快照读的情况)。如果在事务内<code>select t</code>表,另外的事务执行了<code>DDL t</code>表,根据发生时间,<code>要吗锁住要嘛报错</code></li>
</ul>
<p><strong>事务是如何实现的MVCC呢?</strong></p>
<ul>
<li>每个事务都有一个事务ID,叫做<code>transaction id</code>(严格递增)</li>
<li>事务在启动时,找到已提交的最大事务ID记为up_limit_id。</li>
<li>事务在更新一条语句时,比如id=1改为了id=2.会把id=1和该行之前的<code>row trx_id</code>写到<code>undo log</code>里。并且在数据页上把id的值改为2,并且把修改这条语句的<code>transaction id</code>记在该行行头。</li>
<li>再定一个规矩,一个事务要查看一条数据时,必须先用该事务的<code>up_limit_id</code>与该行的<code>transaction id</code>做比对</li>
<li>如果<code>up_limit_id&gt;=transaction id</code>,那么可以看.如果<code>up_limit_id&lt;transaction id</code>,则只能去<code>undo log</code>里去取。去undo log查找数据的时候,也需要做比对,必须<code>up_limit_id&gt;transaction id</code>,才返回数据</li>
</ul>
<p><strong>什么是当前读,</strong></p>
<ul>
<li>由于当前读都是先读后写,只能读当前的值,所以认为当前读.会更新事务内的up_limit_id为该事务的transaction id</li>
</ul>
<p><strong>为什么<code>RR</code>能实现可重复读而<code>RC</code>不能,分两种情况</strong></p>
<ul>
<li>快照读的情况下,rr(可重复读)不能更新事务内的up_limit_id,而<code>rc(读提交)</code>每次会把<code>up_limit_id</code>更新为快照读之前最新已提交事务的<code>transaction id</code>,则<code>rc(读提交)</code>不能可重复读</li>
<li>当前读的情况下,<code>rr(可重复读)</code>是利用<code>record lock+gap lock</code>来实现的,而<code>rc(读提交)</code>没有gap,所以rc不能可重复读 </li>
</ul>
<h3 id="MySQL为什么有时候会选错索引"><a href="#MySQL为什么有时候会选错索引" class="headerlink" title="MySQL为什么有时候会选错索引"></a>MySQL为什么有时候会选错索引</h3><ul>
<li>在MySQL中一张表其实是可以支持多个索引的。但是，你写SQL语句的时候，并没有主动指定使用哪个索引。也就是说，使用哪个索引是由MySQL来确定的。所以有时候由于MySQL选错了索引，而导致执行速度变得很慢</li>
</ul>
<p>测试代码 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`a`</span> (<span class="string">`a`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`b`</span> (<span class="string">`b`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>；</span><br></pre></td></tr></table></figure>
<p>然后，我们往表t中插入10万行记录，取值按整数递增，即：(1,1,1)，(2,2,2)，(3,3,3) 直到(100000,100000,100000)。</p>
<p>分析一条SQL语句：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from t where a between 10000 and 20000;</span><br></pre></td></tr></table></figure>
<p>正常情况下，a上有索引，肯定是要使用索引a的。</p>
<p><img src="https://img-blog.csdnimg.cn/20190414141306715.png" alt="explain命令"><br>但是特许情况下如果同时有两个以下下操作执行：</p>
<ul>
<li>如果一个A请求首先开启了事物，随后，B请求把数据都删除后，又插入了10万行数据。</li>
<li>这时候， B操作的查询语句<code>select * from t where a between 10000 and 20000</code>就不会再选择索引a了，会执行全表扫描，执行时间会比之前慢很多。<code>为什么会出现这样情况？</code>因为选择索引是优化器的工作，而优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。</li>
<li>MySQL在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据统计信息来估算记录数。这个统计信息就是索引的“<code>区分度</code>”。一个索引上不同的值越多，这个索引的区分度就越好。而一个索引上不同的值的个数，我们称之为<code>“基数”</code>（cardinality）。也就是说，这个基数越大，索引的区分度越好。</li>
<li>可以使用<code>show index table</code>方法，看到一个索引的基数</li>
<li>MySQL是怎样得到索引的基数的呢？MySQL通过采样统计的方法得到基数</li>
<li>如果使用索引a，每次从索引a上拿到一个值，都要回到主键索引上查出整行数据，这个代价优化器也要算进去的。而如果选择扫描10万行，是直接在主键索引上扫描的，没有额外的代价。优化器会估算这两个选择的代价，从结果看来，优化器认为直接扫描主键索引更快。当然，从执行时间看来，这个选择并不是最优的。</li>
<li><code>analyze table t</code> 命令可以用来重新统计索引信息</li>
<li>采用<code>force index</code>强行选择一个索引。如果force index指定的索引在候选索引列表中，就直接选择这个索引，不再评估其他索引的执行代价。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190414141504344.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> long_query_time=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> a <span class="keyword">between</span> <span class="number">10000</span> <span class="keyword">and</span> <span class="number">20000</span>; <span class="comment">/*Q1*/</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">force</span> <span class="keyword">index</span>(a) <span class="keyword">where</span> a <span class="keyword">between</span> <span class="number">10000</span> <span class="keyword">and</span> <span class="number">20000</span>;<span class="comment">/*Q2*/</span></span><br><span class="line"></span><br><span class="line">第一句，是将慢查询日志的阈值设置为0，表示这个线程接下来的语句都会被记录入慢查询日志中；</span><br><span class="line">第二句，Q1是session B原来的查询；</span><br><span class="line">第三句，Q2是加了force index(a)来和session B原来的查询语句执行情况对比。</span><br></pre></td></tr></table></figure>
<ul>
<li>delete 语句删掉了所有的数据，然后再通过call idata()插入了10万行数据，看上去是覆盖了原来的10万行。</li>
<li>但是，session A开启了事务并没有提交，所以之前插入的10万行数据是不能删除的。这样，之前的数据每一行数据都有两个版本，旧版本是delete之前的数据，新版本是标记为deleted的数据。这样，索引a上的数据其实就有两份</li>
</ul>
<h3 id="怎么给字符串字段加索引"><a href="#怎么给字符串字段加索引" class="headerlink" title="怎么给字符串字段加索引"></a>怎么给字符串字段加索引</h3><ul>
<li>假设，你现在维护一个支持邮箱登录的系统，用户表是这么定义的：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table SUser(</span><br><span class="line">ID bigint unsigned primary key,</span><br><span class="line">email varchar(64), </span><br><span class="line">... </span><br><span class="line">)engine=innodb; </span><br></pre></td></tr></table></figure>
<p>由于要使用邮箱登录，所以业务代码中一定会出现类似于这样的语句：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; select f1, f2 from SUser where email=&#x27;xxx&#x27;;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果email这个字段上没有索引，那么这个语句就只能做全表扫描。同时，MySQL是支持前缀索引的，也就是说，你可以定义字符串的一部分作为索引。默认地，如果你创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。</li>
</ul>
<p>比如，这两个在email字段上创建索引的语句：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter table SUser add index index1(email);</span><br><span class="line">或</span><br><span class="line">mysql&gt; alter table SUser add index index2(email(6));</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/201904142351118.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70" alt="inddex1索引结构"><br><img src="https://img-blog.csdnimg.cn/20190414235147183.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70" alt="index2索引结构"></p>
<ul>
<li>第一个语句创建的index1索引里面，包含了每个记录的整个字符串；</li>
<li>第二个语句创建的index2索引里面，对于每个记录都是只取前6个字节。由于email(6)这个索引结构中每个邮箱字段都只取前6个字节,所以占用的空间会更小，这就是使用前缀索引的优势。但是 可能会增加额外的记录扫描次数。</li>
</ul>
<p><strong>使用的是index1的执行流程</strong></p>
<ul>
<li>从<code>index1</code>索引树找到满足索引值是’<a href="mailto:&#x7a;&#104;&#x61;&#x6e;&#x67;&#115;&#115;&#120;&#121;&#x7a;&#x40;&#x78;&#x78;&#120;&#46;&#99;&#111;&#109;">&#x7a;&#104;&#x61;&#x6e;&#x67;&#115;&#115;&#120;&#121;&#x7a;&#x40;&#x78;&#x78;&#120;&#46;&#99;&#111;&#109;</a>’的这条记录，取得ID2的值；</li>
<li>到主键上查到主键值是ID2的行，判断email的值是正确的，将这行记录加入结果集；</li>
<li>取index1索引树上刚刚查到的位置的下一条记录，发现已经不满足email=’zhangssxyz@xxx.com’的条件了，循环结束</li>
<li>这个过程中，只需要回主键索引取一次数据，所以系统认为只扫描了一行。</li>
</ul>
<p><strong>使用的是index2的执行流程</strong></p>
<ul>
<li>从<code>index2</code>索引树找到满足索引值是’zhangs’的记录，找到的第一个是ID1；</li>
<li>到主键上查到主键值是ID1的行，判断出email的值不是’<a href="mailto:&#x7a;&#104;&#x61;&#110;&#x67;&#x73;&#115;&#120;&#121;&#122;&#64;&#x78;&#120;&#x78;&#x2e;&#x63;&#111;&#109;">&#x7a;&#104;&#x61;&#110;&#x67;&#x73;&#115;&#120;&#121;&#122;&#64;&#x78;&#120;&#x78;&#x2e;&#x63;&#111;&#109;</a>’，这行记录丢弃；</li>
<li>取index2上刚刚查到的位置的下一条记录，发现仍然是’zhangs’，取出ID2，再到ID索引上取整行然后判断，这次值对了，将这行记录加入结果集；</li>
<li>重复上一步，直到在idxe2上取到的值不是’zhangs’时，循环结束。</li>
<li>在这个过程中，要回主键索引取4次数据，也就是扫描了4行。</li>
<li>但是  对于这个查询语句来说，如果你定义的<code>index2</code>不是email(6)而是email(7），也就是说取email字段的前7个字节来构建索引的话，即满足前缀’zhangss’的记录只有一个，也能够直接查到ID2，只扫描一行就结束了。</li>
<li>也就是说<code>使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本</code>。</li>
</ul>
<p><strong>前缀索引对覆盖索引的影响</strong></p>
<ul>
<li>使用前缀索引可能会增加扫描行数，这会影响到性能。其实，前缀索引的影响不止如此</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查询1 </span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,email <span class="keyword">from</span> SUser <span class="keyword">where</span> email=<span class="string">&#x27;zhangssxyz@xxx.com&#x27;</span>;</span><br><span class="line"><span class="comment"># 查询2</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span>,email <span class="keyword">from</span> SUser <span class="keyword">where</span> email=<span class="string">&#x27;zhangssxyz@xxx.com&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果使用index1（即email整个字符串的索引结构）的话，可以利用覆盖索引，从index1查到结果后直接就返回了，不需要回到ID索引再去查一次。而如果使用index2（即email(6)索引结构）的话，就不得不回到ID索引再去判断email字段的值。</li>
<li>即使你将index2的定义修改为email(18)的前缀索引，这时候虽然index2已经包含了所有的信息，但InnoDB还是要回到id索引再查一下，因为系统并不确定前缀索引的定义是否截断了完整信息。</li>
<li>使用前缀索引就用不上覆盖索引对查询性能的优化了</li>
</ul>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>对于类似于邮箱这样的字段来说，使用前缀索引的效果可能还不错。但是，遇到前缀的区分度不够好的情况时。比如，我们国家的身份证号，一共18位，其中前6位是地址码，所以同一个县的人的身份证号前6位一般会是相同的。</p>
<p>假设你维护的数据库是一个市的公民信息系统，这时候如果对身份证号做长度为6的前缀索引的话，这个索引的区分度就非常低了。可能你需要创建长度为12以上的前缀索引，才能够满足区分度要求。但是，<code>索引选取的越长，占用的磁盘空间就越大，相同的数据页能放下的索引值就越少，搜索的效率也就会越低</code>。</p>
<p>那么，如果我们能够确定业务需求里面只有按照身份证进行等值查询的需求，还有没有别的处理方法呢？这种方法，既可以占用更小的空间，也能达到相同的查询效率。</p>
<p>第一种方式是使用<code>倒序存储</code>。如果你存储身份证号的时候把它倒过来存，每次查询的时候，你可以这么写：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; select field_list from t where id_card = reverse(&#x27;input_id_card_string&#x27;);</span><br></pre></td></tr></table></figure>
<p>由于身份证号的最后6位没有地址码这样的重复逻辑，所以最后这6位很可能就提供了足够的区分度。</p>
<p>第二种方式是<code>使用hash字段</code>。你可以在表上再创建一个整数字段，来保存身份证的校验码，同时在这个字段上创建索引。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter table t add id_card_crc int unsigned, add index(id_card_crc);</span><br></pre></td></tr></table></figure>
<p>然后每次插入新记录的时候，都同时用crc32()这个函数得到校验码填到这个新字段。由于校验码可能存在冲突，也就是说两个不同的身份证号通过crc32()函数得到的结果可能是相同的，所以你的查询语句where部分要判断id_card的值是否精确相同。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; select field_list from t where id_card_crc=crc32(&#x27;input_id_card_string&#x27;) and id_card=&#x27;input_id_card_string&#x27;</span><br></pre></td></tr></table></figure>
<p>这样，索引的长度变成了4个字节，比原来小了很多。</p>
<p><strong>使用倒序存储和使用hash字段这两种方法的异同点</strong></p>
<ul>
<li>首先，它们的相同点是，都不支持范围查询。</li>
<li><code>从占用的额外空间来看</code>，倒序存储方式在主键索引上，不会消耗额外的存储空间，而hash字段方法需要增加一个字段</li>
<li><code>在CPU消耗方面</code>，倒序方式每次写和读的时候，都需要额外调用一次reverse函数，而hash字段的方式需要额外调用一次crc32()函数</li>
<li><code>从查询效率上看</code>，使用hash字段方式的查询性能相对更稳定一些。因为crc32算出来的值虽然有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行数接近1。而倒序存储方式毕竟还是用的前缀索引的方式，也就是说还是会增加扫描行数。</li>
</ul>
<p><strong>字符串字段创建索引的场景你可以使用的方式有：</strong></p>
<ul>
<li>直接创建完整索引，这样可能比较占用空间；</li>
<li>创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引；</li>
<li>倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题；</li>
<li>创建hash字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描。</li>
</ul>
<p><strong>利用学号作为登录名索引设计问题？</strong></p>
<blockquote>
<p>如果你在维护一个学校的学生信息数据库，学生登录名的统一格式是”学号@gmail.com”, 而学号的规则是：十五位的数字，其中前三位是所在城市编号、第四到第六位是学校编号、第七位到第十位是入学年份、最后五位是顺序编号。<br>系统登录的时候都需要学生输入登录名和密码，验证正确后才能继续使用系统。就只考虑登录验证这个行为的话，你会怎么设计这个登录名的索引呢？</p>
</blockquote>
<p><strong><code>设计思路：</code></strong></p>
<ul>
<li>由于这个学号的规则，无论是正向还是反向的前缀索引，重复度都比较高。因为维护的只是一个学校的，因此前面6位（其中，前三位是所在城市编号、第四到第六位是学校编号）其实是固定的，邮箱后缀都是@gamil.com，因此可以只存入学年份加顺序编号，它们的长度是9位。</li>
<li>而其实在此基础上，可以用数字类型来存这9位数字。比如201100001，这样只需要占4个字节。其实这个就是一种hash，只是它用了最简单的转换规则：字符串转数字的规则，而刚好我们设定的这个背景，可以保证这个转换后结果的唯一性。</li>
</ul>
<h3 id="为什么我的MySQL会“抖”一下"><a href="#为什么我的MySQL会“抖”一下" class="headerlink" title="为什么我的MySQL会“抖”一下"></a>为什么我的MySQL会“抖”一下</h3><ul>
<li>一条SQL语句，正常执行的时候特别快，但是有时也不知道怎么回事，它就会变得特别慢，并且这样的场景很难复现，它不只随机，而且持续时间还很短。看上去，这就像是数据库“抖”了一下</li>
<li>在MySQL里，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高。为了解决这个问题，MySQL的设计者使用了<code>WAL技术</code>，WAL的全称是Write-Ahead Logging，它的关键点就是<code>先写日志，再写磁盘</code>。</li>
<li>利用WAL技术，数据库将随机写转换成了顺序写，大大提升了数据库的性能。但是，由此也带来了内存脏页的问题。脏页会被后台线程自动flush，也会由于数据页淘汰而触发flush，而刷脏页的过程由于会占用资源，可能会让你的更新和查询语句的响应时间长一些</li>
<li>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。</li>
<li>平时执行很快的更新操作，其实就是在写内存和日志，而MySQL偶尔“抖”一下的那个瞬间，可能就是在刷脏页（<code>flush</code>）。</li>
</ul>
<p><strong>什么情况会引发数据库的flush过程呢？</strong></p>
<ul>
<li><code>InnoDB</code>在处理更新语句的时候，只做了写日志这一个磁盘操作。这个日志叫作redo log（重做日志）。在更新内存写完<code>redo log</code>后，就返回给客户端，本次更新成功。</li>
<li><code>InnoDB</code>的<code>redo log</code>(重做日志)写满了。这时候系统会停止所有更新操作，把<code>checkpoint(检查点)</code>往前推进，<code>redo log</code>留出空间可以继续写</li>
<li>第二种场景是：对应的就是系统内存不足。当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到磁盘。</li>
<li>第三种场景就是<code>MySQL</code>认为系统<code>“空闲”</code>的时候。也要见缝插针地找时间，只要有机会就刷一点<code>“脏页”</code></li>
<li>第四种场景就是<code>MySQL正常关闭的情况</code>。这时候，MySQL会把内存的脏页都flush到磁盘上，这样下次MySQL启动的时候，就可以直接从磁盘上读数据，启动速度会很快。</li>
</ul>
<p><strong>分析一下上面四种场景对性能的影响</strong></p>
<ul>
<li><code>第一种是“redo log写满了，要flush脏页”</code>，这种情况是InnoDB要尽量避免的。因为出现这种情况的时候，整个系统就不能再接受更新了，所有的更新都必须堵住。如果你从监控上看，这时候更新数会跌为0。</li>
<li><code>第二种是“内存不够用了，要先将脏页写到磁盘”</code>，这种情况其实是常态。InnoDB用缓冲池（buffer pool）管理内存，缓冲池中的内存页有三种状态：第一种是，还没有使用的；第二种是，使用了并且是干净页；第三种是，使用了并且是脏页。InnoDB的策略是尽量使用内存，因此对于一个长时间运行的库来说，未被使用的页面很少。</li>
<li>而当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页。这时候只能把最久不使用的数据页从内存中淘汰掉：如果要淘汰的是一个干净页，就直接释放出来复用；但如果是脏页呢，就必须将脏页先刷到磁盘，变成干净页后才能复用。</li>
<li>所以，刷脏页虽然是常态，但是出现以下这两种情况，都是会明显影响性能的：一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长；日志写满，更新全部堵住，写性能跌为0，这种情况对敏感业务来说，是不能接受的。</li>
</ul>
<p><strong>InnoDB刷脏页的控制策略</strong></p>
<ul>
<li>首先，你要正确地告诉<code>InnoDB</code>所在主机的<code>IO能力</code>，这样<code>InnoDB</code>才能知道需要全力刷脏页的时候，可以刷多快。这就要用到<code>innodb_io_capacity</code>这个参数了，它会告诉<code>InnoDB</code>你的磁盘能力。这个值我建议你设置成<code>磁盘的IOPS</code>。</li>
<li>假设有这样一个场景：<code>MySQL的写入速度很慢，TPS很低</code>，但是数据库主机的<code>IO压力并不大</code>。主机磁盘用的是SSD，但是<code>innodb_io_capacity</code>的值设置的是<code>300</code>。于是，InnoDB认为这个系统的能力就这么差，所以刷脏页刷得特别慢，甚至比脏页生成的速度还慢，这样就造成了脏页累积，影响了查询和更新性能。</li>
<li><code>InnoDB</code>的刷盘速度就是要参考这两个因素：一个是<code>脏页比例</code>，一个是<code>redo log写盘速度</code>。</li>
<li>参数<code>innodb_max_dirty_pages_pct</code>是<code>脏页比例上限</code>，默认值是<code>75%</code>。InnoDB会根据当前的脏页比例（假设为M），算出一个范围在0到100之间的数字。<code>InnoDB</code>每次写入的日志<code>都有一个序号</code>，当前写入的序号跟<code>checkpoint</code>对应的序号之间的差值。我们假设为N。InnoDB会根据这个N算出一个范围在0到100之间的数字，这个计算公式可以记为F2(N)。F2(N)算法比较复杂，你只要知道N越大，算出来的值越大就好了。</li>
<li>然后，根据上述算得的F1(M)和F2(N)两个值，取其中较大的值记为R，之后引擎就可以按照<code>innodb_io_capacity</code>定义的能力乘以<code>R%</code>来控制刷脏页的速度。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2019041513510966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70"></p>
<ul>
<li>InnoDB会在后台刷脏页，而刷脏页的过程是要将内存页写入磁盘。所以，无论是你的查询语句在需要内存的时候可能要求淘汰一个脏页，还是由于刷脏页的逻辑会占用IO资源并可能影响到了你的更新语句，都可能是造成你从业务端感知到MySQL“抖”了一下的原因。</li>
<li>要尽量避免这种情况，你就要合理地设置<code>innodb_io_capacity的值</code>，并且平时要多关注脏页比例，不要让它经常接近<code>75%</code>。</li>
</ul>
<blockquote>
<p>脏页比例是通过Innodb_buffer_pool_pages_dirty/Innodb_buffer_pool_pages_total得到的</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select VARIABLE_VALUE into @a from global_status where VARIABLE_NAME = &#x27;Innodb_buffer_pool_pages_dirty&#x27;;</span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> @b <span class="keyword">from</span> global_status <span class="keyword">where</span> VARIABLE_NAME = <span class="string">&#x27;Innodb_buffer_pool_pages_total&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> @a/@b;</span><br></pre></td></tr></table></figure>
<ul>
<li>一旦一个查询请求需要在执行过程中先flush掉一个脏页时，这个查询就可能要比平时慢了。而MySQL中的一个机制，可能让你的查询会更慢：在准备刷一个脏页的时候，如果这个数据页旁边的数据页刚好是脏页，就会把这个“邻居”也带着一起刷掉；而且这个把“邻居”拖下水的逻辑还可以继续蔓延，也就是对于每个邻居数据页，如果跟它相邻的数据页也还是脏页的话，也会被放到一起刷。</li>
<li>在InnoDB中，<code>innodb_flush_neighbors</code> 参数就是用来控制这个行为的，<code>值为1</code>的时候会有上述的<code>“连坐”机制</code>，<code>值为0时</code>表示不找邻居，自己刷自己的。</li>
<li>找<code>“邻居”</code>这个优化在<code>机械硬盘时代是很有意义</code>的，可以<code>减少很多随机IO</code>。机械硬盘的随机<code>IOPS</code>一般只有几百，相同的逻辑操作减少随机IO就意味着系统性能的大幅度提升。</li>
<li>而如果使用的是<code>SSD这类IOPS比较高的设备</code>的话，我就建议你把<code>innodb_flush_neighbors</code>的值设置成0。因为这时候<code>IOPS</code>往往不是瓶颈，而<code>“只刷自己”</code>，就能更快地执行完必要的刷脏页操作，减少SQL语句响应时间。</li>
<li>在MySQL 8.0中<code>，innodb_flush_neighbors参数的默认值已经是0</code>了。</li>
</ul>
<h3 id="为什么表数据删掉一半，表文件大小不变"><a href="#为什么表数据删掉一半，表文件大小不变" class="headerlink" title="为什么表数据删掉一半，表文件大小不变"></a>为什么表数据删掉一半，表文件大小不变</h3><ul>
<li>一个InnoDB表包含两部分，即：表结构定义和数据。在MySQL 8.0版本以前，表结构是存在以.frm为后缀的文件里。</li>
<li>表数据既可以存在共享表空间里，也可以是单独的文件。这个行为是由参数<code>innodb_file_per_table</code>控制的，设置为<code>OFF</code>表示的是，表的数据放在<code>系统共享表空间</code>，也就是跟数据字典放在一起；设置为<code>ON</code>表示的是，每个InnoDB表数据存储在一个以 <code>.ibd</code>为后缀的文件中。从<code>MySQL 5.6.6</code>版本开始，它的<code>默认值就是ON</code>了</li>
<li>建议你不论使用MySQL的哪个版本，都将这个值设置为ON。因为，一个表单独存储为一个文件更容易管理，而且在你不需要这个表的时候，通过<code>drop table</code>命令，系统就会直接删除这个文件。而如果是放在共享表空间中，即使表删掉了，空间也是不会回收的。</li>
<li>我们在删除整个表的时候，可以使用drop table命令回收表空间。但是，我们遇到的更多的删除数据的场景是删除某些行，表中的数据被删除了，但是表空间却没有被回收。</li>
</ul>
<p><strong>数据删除流程</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190416104535458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70" alt="InnoDB中一个索引的示意图"></p>
<ul>
<li>假设，我们要删掉R4这个记录，InnoDB引擎只会把R4这个记录标记为删除。如果之后要再插入一个ID在300和600之间的记录时，可能会复用这个位置。但是，磁盘文件的大小并不会缩小。</li>
<li>InnoDB的数据是按页存储的，那么如果我们删掉了一个数据页上的所有记录，整个数据页就可以被复用了。</li>
<li>但是，数据页的复用跟记录的复用是不同的。记录的复用，只限于符合范围条件的数据，比如R4这条记录被删除后，如果插入一个ID是400的行，可以直接复用这个空间。但如果插入的是一个ID是800的行，就不能复用这个位置了。</li>
<li>而当整个页从B+树里面摘掉以后，可以复用到任何位置。如果相邻的两个数据页利用率都很小，系统就会把这两个页上的数据合到其中一个页上，另外一个数据页就被标记为可复用。</li>
<li>所以如果我们用delete命令把整个表的数据删除，结果就是，所有的数据页都会被标记为可复用。但是磁盘上，文件不会变小。也就是说，通过delete命令是不能回收表空间的。这些可以复用，而没有被使用的空间，看起来就像是<code>“空洞”</code>。</li>
<li>实际上，不止是删除数据会造成空洞，插入数据也会。如果数据是按照索引递增顺序插入的，那么索引是紧凑的。但如果数据是随机插入的，就可能造成索引的数据页分裂。另外，更新索引上的值，可以理解为删除一个旧的值，再插入一个新值。不难理解，这也是会造成空洞的。</li>
</ul>
<p><strong>重建表</strong></p>
<ul>
<li>重建表就是新建一个与表A结构相同的表B，然后按照主键ID递增的顺序，把数据一行一行地从表A里读出来再插入到表B中。由于表B是新建的表，所以表A主键索引上的空洞，在表B中就都不存在了。</li>
<li>可以使用<code>alter table A engine=InnoDB</code>命令来重建表。MySQL 5.5之后会自动完成转存数据、交换表名、删除旧表的操作。</li>
<li>重建表的过程中，如果中途有新的数据要写入，就会造成数据丢失。所以在整个<code>DDL</code>过程中，表A中不能有更新。也就是说，这个DDL不是<code>Online</code>的。在MySQL 5.6版本开始引入的<code>Online DDL</code>，对这个操作流程做了优化。</li>
<li>对于很大的表来说，这个操作是很消耗IO和CPU资源的。想要比较安全的操作的话，推荐使用<code>GitHub</code>开源的<a href="https://github.com/github/gh-ost">gh-ost</a>来做。</li>
</ul>
<p><strong>MySQL执行DDL()原理</strong></p>
<ul>
<li><code>DML</code>：它们是SELECT、UPDATE、INSERT、DELETE，就象它的名字一样，这4条命令是用来对数据库里的数据进行操作的语言</li>
<li><code>DDL</code>：DDL比DML要多，主要的命令有CREATE、ALTER、DROP等，DDL主要是用在定义或改变表(TABLE)的结构，数据类型，表之间的链接和约束等初始化工作上，他们大多在建立表时使用</li>
<li><code>DCL</code>：是数据库控制功能。是用来设置或更改数据库用户或角色权限的语句</li>
<li>MySQL各版本，对于DDL的处理方式是不同的，主要有三种：</li>
<li><code>Copy Table</code>方式：这是InnoDB最早支持的方式。通过临时表拷贝的方式实现的。新建一个带有新结构的临时表，将原表数据全部拷贝到临时表，然后Rename，完成创建操作。这个方式过程中，<code>原表是可读的，不可写</code>。但是<code>会消耗一倍的存储空间</code>。</li>
<li><code>Inplace</code>方式：这是原生MySQL 5.5，以及<code>innodb_plugin</code>中提供的方式。所谓Inplace，也就是在<code>原表上直接进行，不会拷贝临时表</code>。相对于Copy Table方式，这比较高效率。<code>原表同样可读的，但是不可写</code>。</li>
<li><code>Online方式</code>：MySQL 5.6以上版本中提供的方式，无论是Copy Table方式，还是Inplace方式，<code>原表只能允许读取，不可写</code>。对应用有较大的限制，因此MySQL最新版本中，InnoDB支持了所谓的<code>Online方式DDL</code>。与以上两种方式相比，<code>online方式支持DDL时不仅可以读，还可以写</code></li>
</ul>
<h3 id="count-语句到底是怎样实现的"><a href="#count-语句到底是怎样实现的" class="headerlink" title="count(*)语句到底是怎样实现的"></a>count(*)语句到底是怎样实现的</h3><ul>
<li>在不同的MySQL引擎中，count(*)有不同的实现方式。</li>
<li><code>MyISAM引擎</code>把一个表的总行数存在了磁盘上，因此执行<code>count(*)</code>的时候会直接返回这个数，效率很高。这里讨论的是没有过滤条件的count(*)，如果加了where 条件的话，MyISAM表也是不能返回得这么快的。</li>
<li><code>InnoDB引擎</code>就麻烦了，它执行count(*)的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</li>
</ul>
<p><strong>为什么InnoDB不跟MyISAM一样，也把数字存起来呢？</strong></p>
<ul>
<li>这是因为即使是在同一个时刻的多个查询，由于<code>多版本并发控制</code>（MVCC）的原因，InnoDB表“应该返回多少行”也是不确定的。</li>
<li>这和InnoDB的事务设计有关系，<code>可重复读是它默认的隔离级别</code>，在代码上就是通过多版本并发控制，也就是MVCC来实现的。每一行记录都要判断自己是否对这个会话可见，因此对于count(*)请求来说，InnoDB只好把数据一行一行地读出依次判断，可见的行才能够用于计算“基于这个查询”的表的总行数。</li>
<li><code>InnoDB是索引组织表</code>，<code>主键索引树的叶子节点是数据</code>，而<code>普通索引树的叶子节点是主键值</code>。所以，普通索引树比主键索引树小很多。对于count(*)这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的。因此，MySQL优化器会找到最小的那棵树来遍历。在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。</li>
<li>MyISAM表虽然count(<em>)很快，但是不支持事务；show table status命令虽然返回很快，但是不准确；InnoDB表直接count(</em>)会遍历全表，虽然结果准确，但会导致性能问题。</li>
</ul>
<h3 id="不同的count用法"><a href="#不同的count用法" class="headerlink" title="不同的count用法"></a>不同的count用法</h3><p><code>select count(?) from t</code>这样的查询语句里面，<code>count(*)、count(主键id)、count(字段)和count(1)</code>等不同用法的性能，有哪些差别。</p>
<ul>
<li>count()是一个聚合函数，对于返回的结果集，一行行地判断，如果count函数的参数不是NULL，累计值就加1，否则不加。最后返回累计值。</li>
<li>所以，count(*)、count(主键id)和count(1) 都表示返回满足条件的结果集的总行数；而count(字段），则表示返回满足条件的数据行里面，参数“字段”不为NULL的总个数。</li>
<li><code>对于count(主键id)来说</code>，InnoDB引擎会遍历整张表，把每一行的id值都取出来，返回给server层。server层拿到id后，判断是不可能为空的，就按行累加。</li>
<li><code>对于count(1)来说</code>，InnoDB引擎遍历整张表，但不取值。server层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。</li>
<li><code>对于count(字段)来说</code>：如果这个“字段”是定义为not null的话，一行行地从记录里面读出这个字段，判断不能为null，按行累加；如果这个“字段”定义允许为null，那么执行的时候，判断到有可能是null，还要把值取出来再判断一下，不是null才累加。</li>
<li>count(<em>)是例外：并不会把全部字段取出来，而是专门做了优化，不取值。count(</em>)肯定不是null，按行累加。</li>
<li>所以结论是：按照效率排序的话，count(字段)&lt;count(主键id)&lt;count(1)≈count(<em>)，所以我建议你，尽量使用count(</em>)。</li>
</ul>
<h3 id="order-by是怎么工作的"><a href="#order-by是怎么工作的" class="headerlink" title="order by是怎么工作的"></a>order by是怎么工作的</h3><p>首先创建一个测试表  <code>t_city</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t_city`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`city`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`addr`</span> <span class="built_in">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`city`</span> (<span class="string">`city`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>
<p>使用存储过程 添加10W条测试数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata2()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="built_in">int</span>;</span><br><span class="line">  <span class="keyword">set</span> i=<span class="number">1</span>;</span><br><span class="line">  while(i&lt;=10000)do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t_city <span class="keyword">values</span>(i,<span class="string">&#x27;广州&#x27;</span>, i,i,i);</span><br><span class="line">    <span class="keyword">set</span> i=i+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> idata2();</span><br></pre></td></tr></table></figure>
<p>比如有如下sql语句，为避免全表扫描，已经在city字段加上索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> city,<span class="keyword">name</span>,age <span class="keyword">from</span> t_city <span class="keyword">where</span> city=<span class="string">&#x27;广州&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">limit</span> <span class="number">1000</span>;</span><br></pre></td></tr></table></figure>
<p>这个语句看上去逻辑很清晰， 那吗数据库内部到底是怎样执行的了？</p>
<p>首先先用<code>explain</code>看看执行计划</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> city,<span class="keyword">name</span>,age <span class="keyword">from</span> t_city <span class="keyword">where</span> city=<span class="string">&#x27;广州&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">limit</span> <span class="number">1000</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20190416172638203.png"><br><strong>先看下个执行计划各参数的含义：</strong></p>
<ul>
<li><code>select_type</code>：显 示查询中每个select子句的类型</li>
<li><code>table</code>： 显示这一行的数据是关于哪张表的，有时不是真实的表名字</li>
<li><code>type</code>：在表中找到所需行的方式，又称“访问类型”。常用的类型有： ALL, index,  range, ref, eq_ref, const, system, NULL（从左到右，性能从差到好）</li>
<li><code>possible_keys</code>：指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用</li>
<li><code>Key</code>：key列显示MySQL实际决定使用的键（索引）</li>
<li><code>key_len</code>：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度，key_len显示的值为索引字段的最大可能长度，并非实际使用长度，不损失精确性的情况下，长度越短越好 </li>
<li><code>ref</code>：表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</li>
<li><code>rows</code>： 表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数</li>
<li><code>Extra</code>：该列包含MySQL解决查询的详细信息。Extra这个字段中的<code>“Using filesort”表示的就是需要排序</code>，MySQL会给每个线程分配一块内存用于排序，称为<code>sort_buffer</code>。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190416174643103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70" alt="全字段排序"></p>
<ul>
<li>按name排序”这个动作，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和参数<code>sort_buffer_size</code>。</li>
<li><code>sort_buffer_size</code>就是MySQL为排序开辟的内存（<code>sort_buffer</code>）的大小。如果要排序的数据量小于sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。</li>
</ul>
<blockquote>
<p>确定一个排序语句是否使用了临时文件</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 打开optimizer_trace，只对本线程有效 */</span></span><br><span class="line"><span class="keyword">SET</span> optimizer_trace=<span class="string">&#x27;enabled=on&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* @a保存Innodb_rows_read的初始值 */</span></span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> @a <span class="keyword">from</span>  performance_schema.session_status <span class="keyword">where</span> variable_name = <span class="string">&#x27;Innodb_rows_read&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 执行语句 */</span></span><br><span class="line"><span class="keyword">select</span> city, <span class="keyword">name</span>,age <span class="keyword">from</span> t <span class="keyword">where</span> city=<span class="string">&#x27;杭州&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">limit</span> <span class="number">1000</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查看 OPTIMIZER_TRACE 输出 */</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`information_schema`</span>.<span class="string">`OPTIMIZER_TRACE`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* @b保存Innodb_rows_read的当前值 */</span></span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> @b <span class="keyword">from</span> performance_schema.session_status <span class="keyword">where</span> variable_name = <span class="string">&#x27;Innodb_rows_read&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计算Innodb_rows_read差值 */</span></span><br><span class="line"><span class="keyword">select</span> @b-@a;</span><br></pre></td></tr></table></figure>
<p>这个方法是通过查看 OPTIMIZER_TRACE 的结果来确认的，你可以从 number_of_tmp_files中看到是否使用了临时文件。</p>
<p><img src="https://img-blog.csdnimg.cn/2019041617592518.png"></p>
<ul>
<li><code>number_of_tmp_files</code>表示的是，排序过程中使用的临时文件数。内存放不下时，就需要使用外部排序，外部排序一般使用归并排序算法。，MySQL将需要排序的数据分成12份，每一份单独排序后存在这些临时文件中。然后把这12个有序文件再合并成一个有序的大文件。</li>
<li>如果<code>sort_buffer_size</code>超过了需要排序的数据量的大小，<code>number_of_tmp_files</code>就是0，表示排序可以直接在内存中完成。否则就需要放在临时文件中排序。</li>
<li><code>sort_buffer_size</code>越小，需要分成的份数越多，<code>number_of_tmp_files</code>的值就越大。</li>
<li><code>sort_mode</code> 里面的<code>packed_additional_fields</code>的意思是，排序过程对字符串做了<code>“紧凑”</code>处理。即使name字段的定义是varchar(16)，在排序过程中还是要按照实际长度来分配空间的。</li>
<li>同时，最后一个查询语句select @b-@a 的返回结果是4000，表示整个执行过程只扫描了4000行。</li>
<li>这里需要注意的是，为了避免对结论造成干扰，我把internal_tmp_disk_storage_engine设置成MyISAM。否则，select @b-@a的结果会大于4000</li>
<li>在上面这个算法过程里面，只对原表的数据读了一遍，剩下的操作都是在sort_buffer和临时文件中执行的。但这个算法有一个问题，就是如果查询要返回的字段很多的话，那么sort_buffer里面要放的字段数太多，这样内存里能够同时放下的行数很少，要分成很多个临时文件，排序的性能会很差。</li>
</ul>
<p><strong>如果MySQL认为排序的单行长度太大会怎么做呢？</strong></p>
<ul>
<li><code>max_length_for_sort_data</code>，是MySQL中专门控制用于排序的行数据的长度的一个参数。它的意思是，如果单行的长度超过这个值，MySQL就认为单行太大，要换一个算法。</li>
</ul>
<h3 id="如何正确地显示随机消息"><a href="#如何正确地显示随机消息" class="headerlink" title="如何正确地显示随机消息"></a>如何正确地显示随机消息</h3><p>从一个单词表中随机选出三个单词</p>
<p>创建测试表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`words`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`word`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>
<p>添加测试数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata3()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="built_in">int</span>;</span><br><span class="line">  <span class="keyword">set</span> i=<span class="number">0</span>;</span><br><span class="line">  while i&lt;10000 do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> words(word) <span class="keyword">values</span>(<span class="keyword">concat</span>(<span class="built_in">char</span>(<span class="number">97</span>+(i <span class="keyword">div</span> <span class="number">1000</span>)), <span class="built_in">char</span>(<span class="number">97</span>+(i % <span class="number">1000</span> <span class="keyword">div</span> <span class="number">100</span>)), <span class="built_in">char</span>(<span class="number">97</span>+(i % <span class="number">100</span> <span class="keyword">div</span> <span class="number">10</span>)), <span class="built_in">char</span>(<span class="number">97</span>+(i % <span class="number">10</span>))));</span><br><span class="line">    <span class="keyword">set</span> i=i+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> idata3();</span><br></pre></td></tr></table></figure>
<p><strong>首先，会想到用order by rand()来实现这个逻辑</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> word <span class="keyword">from</span> words <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">rand</span>() <span class="keyword">limit</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20190416182846114.png"></p>
<ul>
<li>Extra字段显示<code>Using temporary</code>，表示的是需要使用临时表；<code>Using filesort</code>，表示的是需要执行排序操作。因此这个Extra的意思就是，需要临时表，并且需要在临时表上排序</li>
<li>order by rand()使用了内存临时表，内存临时表排序的时候使用了rowid排序方法。</li>
<li>tmp_table_size这个配置限制了内存临时表的大小，默认值是16M。如果临时表大小超过了tmp_table_size，那么内存临时表就会转成磁盘临时表。</li>
<li>磁盘临时表使用的引擎默认是InnoDB，是由参数internal_tmp_disk_storage_engine控制的。当使用磁盘临时表的时候，对应的就是一个没有显式索引的InnoDB表的排序过程。</li>
</ul>
<h3 id="幻读是什么，幻读有什么问题"><a href="#幻读是什么，幻读有什么问题" class="headerlink" title="幻读是什么，幻读有什么问题"></a>幻读是什么，幻读有什么问题</h3><ul>
<li>幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。</li>
<li>在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现。</li>
</ul>
<p><strong>创建测试数据</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;t&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;c&#96; int(11) DEFAULT NULL,</span><br><span class="line">  &#96;d&#96; int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  KEY &#96;c&#96; (&#96;c&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB;</span><br><span class="line"></span><br><span class="line">insert into t values(0,0,0),(5,5,5),</span><br><span class="line">(10,10,10),(15,15,15),(20,20,20),(25,25,25);</span><br></pre></td></tr></table></figure>
<p><strong>下面的语句序列，是怎么加锁的，加的锁又是什么时候释放的呢？</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> d=<span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>这个语句会命中d=5的这一行，对应的主键id=5，因此在select 语句执行完成后，id=5这一行会加一个写锁，而且由于两阶段锁协议，这个写锁会在执行commit语句的时候释放。</li>
<li>由于字段d上没有索引，因此这条查询语句会做全表扫描。那么，其他被扫描到的，但是不满足条件的5行记录上，会不会被加锁呢？</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190418165218311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70"></p>
<ul>
<li>可以看到，session A里执行了三次查询，分别是Q1、Q2和Q3。它们的SQL语句相同，都是select * from t where d=5 for update。这个语句的意思你应该很清楚了，查所有d=5的行，而且使用的是当前读，并且加上写锁</li>
</ul>
<p><strong>图中SQL执行流程</strong></p>
<ul>
<li>Q1只返回id=5这一行；</li>
<li>在T2时刻，session B把id=0这一行的d值改成了5，因此T3时刻Q2查出来的是id=0和id=5这两行；</li>
<li>在T4时刻，session C又插入一行（1,1,5），因此T5时刻Q3查出来的是id=0、id=1和id=5的这三行。</li>
<li>其中，Q3读到id=1这一行的现象，被称为<code>“幻读”</code>。</li>
<li>在<code>可重复读</code>(InnoDB的默认)隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，<code>幻读在“当前读”下才会出现。</code></li>
<li>上面session B的修改结果，被session A之后的select语句用“当前读”看到，不能称为幻读。幻读仅专指“新插入的行”</li>
</ul>
<p>从事务可见性规则来分析的话，上面这三条SQL语句的返回结果都没有问题。因为这三个查询都是加了for update，都是当前读。而当前读的规则，就是要能读到所有已经提交的记录的最新值。并且，session B和sessionC的两条语句，执行后就会提交，所以Q2和Q3就是应该看到这两个事务的操作效果，而且也看到了，这跟事务的可见性规则并不矛盾。但是，这是不是真的没问题呢？</p>
<p><strong>幻读有什么问题？</strong></p>
<ul>
<li>首先是语义上的。session A在T1时刻就声明了，“我要把所有d=5的行锁住，不准别的事务进行读写操作”。而实际上，这个语义被破坏了。</li>
</ul>
<p><strong>其次，是数据一致性的问题。</strong></p>
<ul>
<li>我们知道，锁的设计是为了保证数据的一致性。而这个一致性，不止是数据库内部数据状态在此刻的一致性，还包含了数据和日志在逻辑上的一致性</li>
<li>为了说明这个问题，我给session A在T1时刻再加一个更新语句，即：update t set d=100 where d=5。<br><img src="https://img-blog.csdnimg.cn/20190418171046246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70"></li>
<li>*上面的执行流程**</li>
<li>经过T1时刻，id=5这一行变成 (5,5,100)，当然这个结果最终是在T6时刻正式提交的;</li>
<li>经过T2时刻，id=0这一行变成(0,5,5);</li>
<li>经过T4时刻，表里面多了一行(1,5,5);</li>
</ul>
<p>这样看，这些数据也没啥问题，但是我们再来看看这时候binlog里面的内容。</p>
<ul>
<li>T2时刻，session B事务提交，写入了两条语句；</li>
<li>T4时刻，session C事务提交，写入了两条语句；</li>
<li>T6时刻，session A事务提交，写入了update t set d=100 where d=5 这条语句。</li>
</ul>
<p>放到一起的话，就是这样的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d=<span class="number">5</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">0</span>; <span class="comment">/*(0,0,5)*/</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> c=<span class="number">5</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">0</span>; <span class="comment">/*(0,5,5)*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>); <span class="comment">/*(1,1,5)*/</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> c=<span class="number">5</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>; <span class="comment">/*(1,5,5)*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d=<span class="number">100</span> <span class="keyword">where</span> d=<span class="number">5</span>;<span class="comment">/*所有d=5的行，d改成100*/</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个语句序列，不论是拿到备库去执行，还是以后用binlog来克隆一个库，这三行的结果，都变成了 (0,5,100)、(1,5,100)和(5,5,100)。也就是说，id=0和id=1这两行，发生了数据不一致。这个问题很严重，是不行的。</p>
</blockquote>
<p><strong>如何解决幻读？</strong></p>
<ul>
<li>产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB只好引入新的锁，也就是间隙锁(Gap Lock)。</li>
<li>间隙锁，锁的就是两个值之间的空隙。比如文章开头的表t，初始化插入了6个记录，这就产生了7个间隙。</li>
<li>这样，当你执行 select * from t where d=5 for update的时候，就不止是给数据库中已有的6个记录加上了行锁，还同时加了7个间隙锁。这样就确保了无法再插入新的记录。</li>
<li>也就是说这时候，在一行行扫描的过程中，不仅将给行加上了行锁，还给行两边的空隙，也加上了间隙锁。</li>
<li>间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作。间隙锁之间都不存在冲突关系。</li>
<li>间隙锁和next-key lock的引入，帮我们解决了幻读的问题，但同时也带来了一些“困扰”</li>
</ul>
<blockquote>
<p>比如现在有这样一个场景 业务逻辑这样的：任意锁住一行，如果这一行不存在的话就插入，如果存在这一行就更新它的数据，代码如下：</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span>=N <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果行不存在*/</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(N,N,N);</span><br><span class="line"><span class="comment">/*如果行存在*/</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d=N <span class="keyword">set</span> <span class="keyword">id</span>=N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可能你会说，这个不是<code>insert ... on duplicate key update</code> 就能解决吗？但其实在有多个唯一键的时候,这个方法是不能满足要求的。这个逻辑一旦有并发，就会碰到死锁。你一定也觉得奇怪，这个逻辑每次操作前用for update锁起来，已经是最严格的模式了，怎么还会有死锁呢？</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20190418172853342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70" alt="间隙锁导致的死锁"><br>你看到了，其实都不需要用到后面的update语句，就已经形成死锁了。我们按语句执行顺序来分析一下：</p>
<ul>
<li>session A 执行select … for update语句，由于id=9这一行并不存在，因此会加上间隙锁(5,10);</li>
<li>session B 执行select … for update语句，同样会加上间隙锁(5,10)，间隙锁之间不会冲突，因此这个语句可以执行成功；</li>
<li>session B 试图插入一行(9,9,9)，被session A的间隙锁挡住了，只好进入等待；</li>
<li>session A试图插入一行(9,9,9)，被session B的间隙锁挡住了。</li>
<li>至此，两个session进入互相等待状态，形成死锁。当然，InnoDB的死锁检测马上就发现了这对死锁关系，让session A的insert语句报错返回了。</li>
</ul>
<blockquote>
<p><code>间隙锁是在可重复读隔离级别下才会生效的</code>。所以，你如果把隔离级别设置为读提交的话，就没有间隙锁了。但同时，你要解决可能出现的数据和日志不一致问题，需要把<code>binlog</code>格式设置为row。这，也是现在不少公司使用的配置组合。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2020/10/14/0000.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="内核态和用户态"><a href="#内核态和用户态" class="headerlink" title="内核态和用户态"></a>内核态和用户态</h2><p>内核态：运行内核程序，可以执行特权指令</p>
<p>用户态：运行用户程序，只能运行非特权指令</p>
<h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><p>进程：是程序的一次执行，是系统进行资源分配的最小单位，有自己独立的地址空间，包含至少一个线程</p>
<p>线程：是执行CPU调度的最小单位，同一个进程中的线程可以共享进程中的资源</p>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>协程是一个特殊的函数，这个函数可以在某个地方挂起，也可以在挂起处外继续运行。所以说，协程与进程、线程相比并不是一个维度的概念。</p>
<p>协程由程序所控制，在用户态执行，不被操作系统内核所管理。这样带来的好处是性能大幅度的提升，因为不会像线程切换那样消耗资源。</p>
<p>一个进程可以包含多个线程，一个线程也可以包含多个协程。</p>
<p>如果是多核CPU，多个进程或一个进程内的多个线程是可以并行运行的，但是一个线程内协程却绝对是串行的，无论CPU有多少个核。</p>
<p>当一个协程运行时，其它协程必须挂起。</p>
<h2 id="进程、线程、协程的对比"><a href="#进程、线程、协程的对比" class="headerlink" title="进程、线程、协程的对比"></a>进程、线程、协程的对比</h2><ul>
<li>协程既不是进程也不是线程，协程仅仅是一个特殊的函数，协程它进程和进程不是一个维度的。</li>
<li>一个进程可以包含多个线程，一个线程可以包含多个协程。</li>
<li>一个线程内的多个协程虽然可以切换，但是多个协程是串行执行的，只能在一个线程内运行，没法利用CPU多核能力。</li>
<li>协程与进程一样，切换是存在上下文切换问题的。</li>
</ul>
<blockquote>
<p>进程的切换者是操作系统</p>
<p>线程的切换者是操作系统</p>
<p>协程的切换这是用户（编程者或应用程序）</p>
</blockquote>
<h2 id="进程线程的几种状态以及转换"><a href="#进程线程的几种状态以及转换" class="headerlink" title="进程线程的几种状态以及转换"></a>进程线程的几种状态以及转换</h2><p>新建 、运行、死亡、阻塞、等待、限时等待</p>
<h2 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h2><ol>
<li>管道(PIPE)：管道是一种半双工的通信方式，数据只能单向流动，并且只能在具有亲缘关系的进程间使用（亲缘关系一般指：父子进程关系）</li>
<li>命名管道(FIFO)：命名管道也是一种半双工的通信方式，但是允许无亲缘关系进程间的通讯</li>
<li>信号(Signal)：一个进程向另一个进程发送信号，通知 接收线程某个事件已经发生。主要作为不同进程或者同一进程不同线程之间的同步手段</li>
<li>信号量(Semaphore)：信号量是一个计数器，可以控制多个进程对共享资源的访问。通常作为一种锁机制，防止一个进程访问共享资源时，另一个进程也访问该资源</li>
<li>消息队列(MessageQueue)：消息队列是消息的链表，存放在内核中。一个消息队列由标识符（队列ID）来标识。消息队列克服了 信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点</li>
<li>共享内存(Shared Memry)：两个或多个进程共享一个给定的内存区域。每个进程访问内存的时候有一个虚拟内存地址和物理内存地址的映射，一般两个进程的虚拟内存地址可以是一样的，但映射的物理地址内存一般是不一样的。共享内存就是让他们的物理内存地址也是一样的，这样的话两个进程就可以访问相同的物理内存了，借助这块物理内存就可以实现通信了</li>
</ol>
<blockquote>
<p>特点：</p>
<ul>
<li>共享内存是最快的一种，因为进程是直接对内存进行存取的</li>
<li>因为多个进程同时操作，所以需要进行同步</li>
<li>信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问</li>
</ul>
</blockquote>
<ol>
<li><p>套接字(Socket)：可以用于本机内的进程通信，也可以用于不同机器间的进程通信。</p>
</li>
<li><ol>
<li><ol>
<li>本机访问数据库：Linux 底层套接字<ol start="2">
<li>远程访问数据库：TCP 套接字</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><strong>区别：</strong></p>
<ol>
<li>管道：速度慢，容量有限，只有父子进程能通讯</li>
<li>FIFO：速度慢，任何进程间都能通讯</li>
<li>消息队列：容量受系统限制，且要注意第一次读的时候，要考虑上一次有没有读完数据的问题</li>
<li>信号量：只能用来进行同步，不能用来传递复杂消息</li>
<li>共享内存：容量容易控制，速度快，但要保持同步</li>
</ol>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>提供系统性的服务，比如：垃圾回收线程、JIT线程</p>
<h2 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h2><p><strong>概念：</strong>父进程创建一个子进程，子进程退出后，父进程没有调用 <strong>wait</strong> 或 <strong>waitpid</strong> 获取子进程的<strong>状态信息</strong>，那么子进程的<strong>状态描述符</strong>仍然保存在系统中</p>
<p><strong>危害：</strong>不调用 wait 或者 waitpid，保留的信息不会被释放，进程号会被一直占用，但是系统的进程号是有限的，如果有大量的僵尸进程，系统会因为没有进程号而无法创建新的进程</p>
<h2 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h2><p><strong>概念：</strong>父进程退出，而它的子进程仍然在执行，那么子进程就会成为孤儿进程</p>
<p><strong>无危害：</strong>孤儿进程被 init 进程（进程号为1）所收养，并由 init 进程对它们完成状态收集工作</p>
<h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><ul>
<li>先来先服务：按照进程到达的先后顺序进行服务</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1200640/1586009730593-9f07911d-853a-4762-af3f-23248d3d87f6.png" alt="image.png"></p>
<ul>
<li>短作业优先：要求服务时间最短的进程先得到服务</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1200640/1586009834930-b97983d4-b149-48bc-8eb2-64424ff8e27a.png" alt="image.png"></p>
<ul>
<li>高响应比优先：每次调度时先计算各个进程响应比，响应比高的进程优先得到服务</li>
</ul>
<blockquote>
<p>响应比=（等待时间+要求服务时间）/要求服务时间</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1200640/1586010004686-c5ae2b98-91cd-45a5-be2b-2ccccfc2dd85.png" alt="image.png"></p>
<ul>
<li>时间片轮转：按照进程到达就绪队列的顺序，轮流让各个进程执行一个时间片。若进程未在一个时间片内执行完，则剥夺处理机，将进程放入就绪队列的队尾重新排队。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1200640/1586010210447-ce5c646f-358c-43d3-b3de-417e92c93f23.png" alt="image.png"></p>
<ul>
<li>优先级调度算法：调度时选择优先级最高的进程</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1200640/1586010562142-4f368109-f23d-4865-8a9e-0f7afb10334d.png" alt="image.png"></p>
<ul>
<li>多级反馈队列算法</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1200640/1586010596676-76b660ae-8b76-4d47-86a5-860075b0c7a4.png" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1200640/1586010046562-73847f6e-e2a4-47b3-9656-b4c54f3cbdb5.png" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1200640/1586010615274-122c43a9-c69e-489e-b9d7-feecabbb4944.png" alt="image.png"></p>
<p><a href="https://www.yuque.com/office/yuque/0/2020/pdf/1200640/1586011092123-79578b24-8928-4bf8-8b11-3728ae463f5d.pdf?from=https://www.yuque.com/qianyi-cjurz/gihu7p/zvl8gg">2.2_4_调度算法：先来先服务、最短作业优先、最高响应比优先.pdf</a></p>
<p><a href="https://www.yuque.com/office/yuque/0/2020/pdf/1200640/1586011142686-87b26097-3749-4b49-ab13-e54e567f1c41.pdf?from=https://www.yuque.com/qianyi-cjurz/gihu7p/zvl8gg">2.2_5_调度算法：时间片轮转、优先级、多级反馈队列.pdf</a></p>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><blockquote>
<ul>
<li>时间局部性：如果访问了程序的某条指令或者数据，那么在未来一段时间内，这条指令或者数据有可能被再次访问（程序中有大量的循环）</li>
<li>空间局部性：如果程序访问了某个存储单元，那么在未来一段时间内，附近的存储单元也有可能被访问（因为很多数据和指令在内存中是顺序存放的）</li>
</ul>
</blockquote>
<ul>
<li>在程序装入内存时，将未来一段时间内会用到的部分装入内存，暂时用不到的留在外存</li>
<li>在程序执行过程中，若需要的信息不再内存中，就把所需的信息从外存调入内存</li>
<li>若内存空间不够，就将内存中暂时不用的信息换出到外存</li>
</ul>
<p>在用户看来，似乎是一个比实际内存大得多的内存，就叫虚拟内存</p>
<h2 id="缓存的置换方式"><a href="#缓存的置换方式" class="headerlink" title="缓存的置换方式"></a>缓存的置换方式</h2><p>最佳置换（OPT）：每次选择淘汰的页面将是以后永远或者最长时间内不再被访问的页面</p>
<p>先进先出（FIFO）：每次选择淘汰的页面是最早进入内存的页面</p>
<p>最近最久未使用（LRU）：每次淘汰的页面是最近最久未使用的页面</p>
<h2 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h2><p>多个进程，都拥有其它进程需要的资源，又需要别人拥有的资源，但自己不释放资源，同时又申请其它资源，形成了循环等待链，这就是死锁</p>
<h2 id="死锁发生的条件"><a href="#死锁发生的条件" class="headerlink" title="死锁发生的条件"></a>死锁发生的条件</h2><ul>
<li>互斥条件：对互斥资源的抢夺才会导致死锁</li>
<li>请求和保持条件：进程保持着某些资源不释放，同时申请其它资源</li>
<li>不剥夺条件：进程保持的资源只能主动释放，不能强行剥夺</li>
<li>循环等待条件：存在着某种资源的循环等待链</li>
</ul>
<h2 id="死锁的预防、避免和解决"><a href="#死锁的预防、避免和解决" class="headerlink" title="死锁的预防、避免和解决"></a>死锁的预防、避免和解决</h2><ul>
<li><p>死锁的预防：设置某些限制条件，死锁的四个发生条件中，破坏其中之一即可</p>
</li>
<li><p>死锁的避免：在资源的动态分配过程中，用某种方法防止系统进入某种不安全状态（例如：银行家算法）</p>
</li>
<li><p>死锁的解决：</p>
</li>
<li><ul>
<li>资源剥夺法：挂起某些死锁进程并抢夺它的资源，以便让其它进程继续推进<ul>
<li>撤销进程法：强制撤销部分或者全部死锁进程，并剥夺它们的资源</li>
<li>进程回退法：让进程主动释放某些资源，回退到避免死锁的地步</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Linux中的五种IO模型"><a href="#Linux中的五种IO模型" class="headerlink" title="Linux中的五种IO模型"></a>Linux中的五种IO模型</h2><p>BIO</p>
<p>NIO</p>
<p>多路复用IO</p>
<p>信号量</p>
<p>AIO</p>
<p>Linux中的</p>
<h2 id="LInux-中CPU占用率过高该用什么指令进行查看"><a href="#LInux-中CPU占用率过高该用什么指令进行查看" class="headerlink" title="LInux 中CPU占用率过高该用什么指令进行查看"></a>LInux 中CPU占用率过高该用什么指令进行查看</h2><p>top</p>
<h2 id="如何杀死进程"><a href="#如何杀死进程" class="headerlink" title="如何杀死进程"></a>如何杀死进程</h2><p>kill</p>
<p>killall</p>
<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h2><ol>
<li>并发</li>
</ol>
<ul>
<li><ul>
<li>并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。</li>
<li>并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。</li>
<li>操作系统通过引入进程和线程，使得程序能够并发运行。</li>
</ul>
</li>
</ul>
<ol>
<li>共享</li>
</ol>
<ul>
<li><ul>
<li>共享是指系统中的资源可以被多个并发进程共同使用。</li>
<li>有两种共享方式：互斥共享和同时共享。</li>
<li>互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。</li>
</ul>
</li>
</ul>
<ol>
<li>虚拟</li>
</ol>
<ul>
<li><ul>
<li>虚拟技术把一个物理实体转换为多个逻辑实体。</li>
<li>主要有两种虚拟技术：时分复用技术和空分复用技术。</li>
<li>多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</li>
<li><strong>虚拟内存使用了空分复用技术，它**</strong>将物理内存抽象为地址空间**<strong>，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存**</strong>中。**</li>
</ul>
</li>
</ul>
<ol>
<li>异步</li>
</ol>
<ul>
<li><ul>
<li>异步指进程不是一次性执行完毕</li>
</ul>
</li>
</ul>
<h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><ol>
<li>进程管理</li>
</ol>
<ul>
<li><ul>
<li>进程控制、进程同步、进程通信、死锁处理、处理机调度等。</li>
</ul>
</li>
</ul>
<ol>
<li>内存管理</li>
</ol>
<ul>
<li><ul>
<li>内存分配、地址映射、内存保护与共享、虚拟内存等。</li>
</ul>
</li>
</ul>
<ol>
<li>文件管理</li>
</ol>
<ul>
<li><ul>
<li>文件存储空间的管理、目录管理、文件读写管理和保护等。</li>
</ul>
</li>
</ul>
<ol>
<li>设备管理</li>
</ol>
<ul>
<li><ul>
<li>完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。</li>
<li>主要包括缓冲管理、设备分配、设备处理、虛拟设备等。</li>
</ul>
</li>
</ul>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><ul>
<li><p>如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成</p>
</li>
<li><p>凡是与资源有关的操作（存储分配、I/O、管理文件等），都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成</p>
</li>
<li><p>用户程序执行陷入指令（trap指令）发起系统请求，将CPU使用权主动交给操作系统内核，即CPU状态会从用户态进入内核态</p>
</li>
<li><p>操作系统处理完系统调用的请求后，又会把CPU使用权还给用户程序，即CPU状态会从内核态回到用户态</p>
</li>
<li><p>目的：用户程序不能直接执行对系统影响非常大的操作，保证系统的稳定性和安全性，防止用户程序随意更改或访问重要的系统资源，影响其他进程的运行</p>
</li>
<li><p>PS：从用户态到内核态，不仅状态需要切换，而且所用的堆栈也可能需要从用户堆栈切换为系统堆栈（系统堆栈也属于该进程）</p>
</li>
<li><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1599652312538-4fc8bac8-3c3a-44b5-90b0-c8b954c72099.png" alt="image.png"></p>
</li>
<li><p>系统调用可以分为如下几类：</p>
</li>
<li><ul>
<li>设备管理：完成设备的请求和释放，以及设备启动等功能</li>
<li>文件管理：完成文件的读、写、创建及删除等功能</li>
<li>进程控制：完成进程的撞见、撤销、阻塞及唤醒等功能</li>
<li>进程通信：完成进程之间的消息传递或信号传递等功能</li>
<li>内存管理：完成内存的分配、回收以及获取作业占用内存大小及初始地址等功能</li>
</ul>
</li>
<li><p>Linux 的系统调用主要有以下这些：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Task</th>
<th>Commands</th>
</tr>
</thead>
<tbody><tr>
<td>进程控制</td>
<td>fork(); exit(); wait();</td>
</tr>
<tr>
<td>进程通信</td>
<td>pipe(); shmget(); mmap();</td>
</tr>
<tr>
<td>文件操作</td>
<td>open(); read(); write();</td>
</tr>
<tr>
<td>设备操作</td>
<td>ioctl(); read(); write();</td>
</tr>
<tr>
<td>信息维护</td>
<td>getpid(); alarm(); sleep();</td>
</tr>
<tr>
<td>安全</td>
<td>chmod(); umask(); chown();</td>
</tr>
</tbody></table>
<h2 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1599632380372-38516e83-b1a9-4e9e-bdd0-dec85fe803ee.png" alt="image.png"></p>
<ol>
<li><strong>中断(也称外中断)</strong></li>
</ol>
<ul>
<li><ul>
<li>由 CPU 执行指令以外的事件引起,即与处理器运行的程序无关</li>
<li>I/O 中断:表示设备输入/输出处理已经完成，希望处理器能够发送下一个输入/输出请求,同时让完成输入/输出的程序继续运行</li>
<li>时钟中断:表示一个固定的时间片已到,让处理器处理定时运行的任务</li>
</ul>
</li>
</ul>
<ol>
<li><strong>异常(也称内中断)</strong></li>
</ol>
<ul>
<li><ul>
<li>由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等</li>
</ul>
</li>
<li><p>硬中断/软中断</p>
</li>
<li><ul>
<li>Linux 将中断处理过程分成了两个阶段，也就是上半部和下半部</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>上半部用来快速处理中断，它在中断禁止模式下运行，主要处理跟硬件紧密相关的或时间敏感的工作</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>网卡接收到数据包后，会通过硬件中断的方式，通知内核有新的数据到了。这时，内核就应该调用中断处理程序来响应它</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>下半部用来延迟处理上半部未完成的工作，通常以内核线程的方式运行</li>
<li>网卡接收到数据包后，会通过硬件中断的方式，通知内核有新的数据到了。这时，内核就应该调用中断处理程序来响应它</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>上半部:把网卡的数据读到内存中，然后更新一下硬件寄存器的状态（表示数据已经读好了），最后再发送一个软中断信号，通知下半部做进一步的处理</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li><ul>
<li>上半部直接处理硬件请求，也就是我们常说的硬中断，特点是快速执行</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>下半部:下半部被软中断信号唤醒后，需要从内存中找到网络数据，再按照网络协议栈，对数据进行逐层解析和处理，直到把它送给应用程序</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li><ul>
<li>下半部则是由内核触发，也就是我们常说的软中断，特点是延迟执行</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>硬中断：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>硬中断是由硬件产生的，比如，像磁盘，网卡，键盘，时钟等。每个设备或设备集都有它自己的IRQ（中断请求）</li>
<li>当中断产生的时候，CPU会中断当前正在运行的任务，来处理中断。在有多核心的系统上，一个中断通常只能中断一颗CPU</li>
<li>硬中断可以直接中断CPU。它会引起内核中相关的代码被触发。对于那些需要花费一些时间去处理的进程</li>
<li>对于时钟中断，内核调度代码会将当前正在运行的进程挂起，从而让其他的进程来运行。它的存在是为了让调度代码（或称为调度器）可以调度多任务。</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>软中断：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>软中断是利用硬件中断的概念，用软件方式进行模拟，实现宏观上的异步执行效果。很多情况下，软中断和”信号”有些类似，同时，软中断又是和硬中断相对应的，”硬中断是外部设备对CPU的中断”，”软中断通常是硬中断服务程序对内核的中断”，”信号则是由内核（或其他进程）对某个进程的中断”</li>
<li>软中断是实现系统API函数调用的手段</li>
<li>通常，软中断是一些对I/O的请求。这些请求会调用内核中可以调度I/O发生的程序。</li>
<li>软中断仅与内核相联系。而内核主要负责对需要运行的任何其他的进程进行调度</li>
<li>软中断并不会直接中断CPU。也只有当前正在运行的代码（或进程）才会产生软中断。这种中断是一种需要内核为正在运行的进程去做一些事情（通常为I/O）的请求。有一个特殊的软中断是Yield调用，它的作用是请求内核调度器去查看是否有一些其他的进程可以运行。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="中断处理的流程"><a href="#中断处理的流程" class="headerlink" title="中断处理的流程"></a>中断处理的流程</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1599633797251-4db4b86b-e2f1-47d2-820a-8354145a1cf4.png" alt="image.png"></p>
<ul>
<li>1<del>3步在CPU进入中断周期后，由硬件自动完成，4</del>9步由中断服务程序完成</li>
<li>恢复现场指在中断返回前，必须将寄存器的内容恢复到中断处理前的状态，由中断服务程序完成</li>
</ul>
<ol>
<li>关中断</li>
</ol>
<ul>
<li><ul>
<li>CPU关闭响应更高级中断源的中断请求,否则现场保存不完整</li>
</ul>
</li>
</ul>
<ol>
<li>保存断点</li>
</ol>
<ul>
<li><ul>
<li>将原来程序的程序计数器PC保存起来</li>
</ul>
</li>
</ul>
<ol>
<li>引出中断服务程序</li>
</ol>
<ul>
<li><ul>
<li>取出中断服务程序的入口地址，送去程序技术去PC中</li>
</ul>
</li>
</ul>
<ol>
<li>保存线程和屏蔽字</li>
</ol>
<ul>
<li><ul>
<li>进入中断程序后，首先保存现场信息：程序状态字寄存器PSWR和某些通用寄存器内容</li>
</ul>
</li>
</ul>
<ol>
<li>开中断</li>
</ol>
<ul>
<li><ul>
<li>允许更高级别中断请求得到响应</li>
</ul>
</li>
</ul>
<ol>
<li>执行中断服务程序</li>
</ol>
<ul>
<li><ul>
<li>中断请求的目的就是执行中断服务程序</li>
</ul>
</li>
</ul>
<ol>
<li>关中断</li>
</ol>
<ul>
<li><ul>
<li>保证在恢复线程和屏蔽字时不被中断</li>
</ul>
</li>
</ul>
<ol>
<li>恢复现场和屏蔽字</li>
</ol>
<ul>
<li><ul>
<li>将现场和屏蔽字恢复到原来的状态</li>
</ul>
</li>
</ul>
<ol>
<li>开中断、中断返回</li>
</ol>
<ul>
<li><ul>
<li>中断服务程序的最后一条指令通常是中断返回指令，时期返回原程序断点处，以便继续执行原程序</li>
</ul>
</li>
</ul>
<h2 id="用户态-内核态"><a href="#用户态-内核态" class="headerlink" title="用户态/内核态"></a>用户态/内核态</h2><ul>
<li><p>操作系统为什么分为用户态和内核态：</p>
</li>
<li><ul>
<li>在CPU的所有指令中，有一些指令是非常危险的，如果错用，将导致整个系统崩溃，比如：清内存、设置时钟等</li>
<li>CPU将指令分为特权指令和非特权指令，特权指令只能由内核态运行</li>
</ul>
</li>
<li><p>从用户空间到内核空间有两种触发手段</p>
</li>
<li><ul>
<li>用户空间的应用程序，通过<strong>系统调用</strong>，进入内核空间</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>这个时候用户空间的进程要传递很多变量、参数的值给内核，内核态运行的时候也要保存用户进程的一些寄存器值、变量等</li>
<li>所谓的“进程上下文”，可以看作是用户进程传递给内核的这些参数以及内核要保存的那一整套的变量和寄存器值和当时的环境等</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>硬件通过触发信号，导致内核调用<strong>中断</strong>处理程序，进入内核空间</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>这个过程中，硬件的一些变量和参数也要传递给内核，内核通过这些参数进行中断处理</li>
<li>所谓的“中断上下文”，其实也可以看作就是硬件传递过来的这些参数和内核需要保存的一些其他环境（主要是当前被打断执行的进程环境）</li>
</ul>
</li>
</ul>
</li>
<li><p>用户态和内核态的关系：</p>
</li>
<li><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1598182666276-405e7713-ed1d-457b-a7bb-30e93af83ba8.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image.png"></li>
</ul>
</li>
</ul>
<h1 id="二、进程管理"><a href="#二、进程管理" class="headerlink" title="二、进程管理"></a>二、进程管理</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><ul>
<li><p><strong>进程是资源分配的基本单位</strong></p>
</li>
<li><p>进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。</p>
</li>
<li><p>进程的上下文包含的内容：</p>
</li>
<li><ul>
<li>内存中的程序代码和数据、寄存器内容、程序计数器、环境变量、打开文件的描述符集合</li>
</ul>
</li>
<li><p>程序段+相关数据段+PCB构成了进程实体</p>
</li>
<li><p><strong>进程的创建（创建原语）：</strong></p>
</li>
<li><ul>
<li>申请一个空白的PCB，每个进程有唯一的进程标识号</li>
<li>为进程分配资源，为新进程的程序和数据以及用户栈分配必要的内存空间</li>
<li>初始化PCB，包括初始化标志信息、初始化处理器状态信息和初始化处理器控制信息，已经设置进程的优先级等</li>
<li>最后把该进程转入就绪态，插入就绪队列，等待被调度</li>
</ul>
</li>
<li><p><strong>进程的终止（撤销原语）：</strong></p>
</li>
<li><ul>
<li>根据被终止进程的标识符，检索PCB，从中读出该进程的状态</li>
<li>若被终止的进程处于执行状态，立即终止该进程的执行，将处理器资源分配给其他进程</li>
<li>若该进程有子进程，则将所有子进程终止</li>
<li>将该进程所拥有的全部资源，归还给父进程，或归还给操作系统</li>
<li>将该PCB从队列（链表）中删除</li>
</ul>
</li>
<li><p><strong>进程的阻塞和唤醒</strong></p>
</li>
<li><ul>
<li>正在执行的进程，由于请求系统资源失败、等待某种操作等，无新工作可做，则系统自动执行阻塞原语（Block），使自己由运行态变为阻塞态</li>
<li>进程的阻塞是进程自身的主动行为，只有处于运行态的进程才能转为阻塞态</li>
<li>当阻塞进程期待的事件发生后，如I/O操作完成，由有关进程（如，释放该I/O设备的进程，或提供数据的进程）调用唤醒原语（Wakeup），将该进程唤醒</li>
<li><strong>阻塞原语：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>找到要被阻塞进程的标识号对应的PCB</li>
<li>如果该进程为运行态，则保护其现场，将其状态转为阻塞态，停止运行</li>
<li>将该PCB插入相应事件的等待队列，将处理器资源调度给其他就绪进程</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>唤醒原语</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>在该事件的等待队列中找到相应进程的PCB</li>
<li>将其从等待队列中移出，并置为就绪态</li>
<li>将该PCB插入就绪队列，等待调度程序调度</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>进程切换</strong></p>
</li>
<li><ul>
<li>进程切换指处理器从一个进程运行转到另一个进程上，进程的运行环境产生了实质的变化，过程如下</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>保存处理器上下文，包括程序计数器和其他寄存器</li>
<li>保存PCB信息</li>
<li>把进程的PCB移入相应的队列，如就绪队列、在某个事件阻塞队列</li>
<li>选择另一个进程执行，并更新其PCB</li>
<li>更新内存管理的数据结构</li>
<li>恢复处理器上下文</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>进程切换与处理器模式切换不同</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>进程切换：</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>当前运行进程改变了，则当前进程的环境信息也需要改变</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>处理器模式切换：</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>模式切换时，处理器可能还在同一进程中运行</li>
<li>如果进程因中断或异常进入内核态运行，执行完后又回到用户态刚被中断的程序运行</li>
<li>这种情况，操作系统只需要恢复进程进入内核时所保存的CPU现场，无须改变当前进程的环境信息</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>调度和切换的区别：</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>调度：调度决定资源分配给哪个进程的行为，是一种决策行为</li>
<li>切换：切换指实际分配的行为，是执行行为</li>
<li>一般来说，先有资源的调度，然后才有进程的切换</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>进程控制块（PCB）</strong></p>
</li>
<li><ul>
<li>PCB是进程实体的一部分，是进程存在的唯一标志</li>
<li>操作系统通过PCB表管理和控制进程</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>操作系统调度某进程时，会从其PCB中查出其现行状态及优先级，根据PCB中保存的处理器状态信息，设置该进程恢复运行的现场，并根据其PCB中的程序和数据的内存起始地址，找到程序和数据</li>
<li>进程运行时，当需要和合作的进程实现同步、通信或访问文件时，也需要访问PCB</li>
<li>进程由于某种原因而暂停运行时，又需要将其断点的处理器环境保存在PCB中</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>PCB内容：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1599662589459-7e940eb5-67e2-427d-995f-2af27e689057.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image.png"></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>程序段</strong></p>
</li>
<li><ul>
<li>被进程调度程度调度到CPU执行的程序代码段，程序可被多个进程共享，即多个进程可以运行同一个程序</li>
</ul>
</li>
<li><p>数据段</p>
</li>
<li><ul>
<li>一个进程的数据段，可以实原始数据，也可以是程序执行的中间或最终结果</li>
</ul>
</li>
</ul>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul>
<li>线程是基本的CPU执行单元，也是程序执行流的最小单元，系统独立调度和分派的基本单位</li>
<li>线程由线程ID、程序计数器、寄存器集合和堆栈组成</li>
<li>进程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但是可与同属于一个进程的其他线程共享所拥有的全部资源</li>
<li>一个线程可以创建和撤销另一个线程</li>
<li>一个进程中可以有多个线程，它们共享进程资源</li>
<li>引入线程后，进程的内涵发生了改变，进程只作为除CPU外的系统资源的分配单元，而线程则作为处理器的分配单元</li>
<li>引入进程的目的是为了更好的使多程序并发执行，提高资源利用率和系统吞吐量；引入线程的目的是为了减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能</li>
<li>QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件</li>
</ul>
<h2 id="进程和线程的区别-1"><a href="#进程和线程的区别-1" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><ul>
<li><p><strong>拥有资源</strong></p>
</li>
<li><ul>
<li>进程是资源分配的基本单位，但是线程不拥有资源（除了一点必不可少的资源），线程可以访问隶属进程的系统资源</li>
<li>如果线程也拥有资源，则切换线程就需要较大的时空开销，线程的概念就没有意义了</li>
</ul>
</li>
<li><p>调度</p>
</li>
<li><ul>
<li>传统操作系统中拥有资源和独立调度的基本单位都是进程</li>
<li>引入线程后，线程是独立调度的基本单位，进程是拥有资源的基本单位</li>
<li>在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</li>
</ul>
</li>
<li><p><strong>系统开销</strong></p>
</li>
<li><ul>
<li>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。</li>
<li>类似地，在进行<strong>进程切换时</strong>，涉及当前<strong>执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置（即，Context）</strong>，而<strong>线程切换时</strong>只需<strong>保存和设置少量寄存器内容</strong>，开销很小</li>
<li>同一个进程内的多个线程共享进程的地址空间，因此这些线程间同步与通信非常容易，甚至无须操作系统的干预</li>
</ul>
</li>
<li><p>并发性：</p>
</li>
<li><ul>
<li>引入线程后，不仅进程间可以并发执行，而且多个线程之间也可以并发执行，提高了并发性和吞吐量</li>
</ul>
</li>
<li><p><strong>通信方面</strong></p>
</li>
<li><ul>
<li>进程间通信需要进程同步和互斥手段的辅助，以保证数据的一致性，而线程间通信可以直接读/写进程数据段（如全局变量）来进行通信</li>
</ul>
</li>
</ul>
<h2 id="协程-1"><a href="#协程-1" class="headerlink" title="协程"></a>协程</h2><ul>
<li><p>协程，是一种基于线程之上，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，自主开辟的异步任务，具有对内核来说不可见的特性</p>
</li>
<li><p>正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程</p>
</li>
<li><p><strong>协程的目的</strong></p>
</li>
<li><ul>
<li>当出现长时间的I/O操作时，通过让出目前的协程调度，执行下一个任务的方式，<strong>减少ContextSwitch上的开销</strong></li>
<li>传统的是，每个请求占用一个线程完成完整的业务逻辑（包括事务），所以系统的吞吐能力取决于每个线程的操作耗时</li>
<li>如果遇到很耗时的I/O行为，则整个系统的吞吐立刻下降，同时，较多的线程会带来很多的上下文切换的开销</li>
<li>由于协程的暂停完全由程序控制，发生在用户态上；而线程的阻塞状态是由操作系统内核来进行切换，发生在内核态上。因此，协程的开销远远小于线程的开销，也就没有了ContextSwitch上的开销</li>
</ul>
</li>
<li><p><strong>协程的特点</strong></p>
</li>
</ul>
<ol>
<li><ol>
<li><strong>线程的切换由操作系统负责调度，协程由用户自己进行调度，因此减少了上下文切换，提高了**</strong>效率。**</li>
<li><strong>线程的默认Stack大小是1M，而协程更轻量，接近1K。因此可以在相同的内存中开启更多的**</strong>协程。**</li>
<li>由于在同一个线程上，因此可以避免竞争关系而使用锁。</li>
<li>适用于被阻塞的，且需要大量并发的场景。但不适用于大量计算的多线程，遇到此种情况，更好用线程解决。</li>
</ol>
</li>
</ol>
<ul>
<li><p><strong>协程的原理</strong></p>
</li>
<li><ul>
<li>当出现IO阻塞的时候，由协程的调度器进行调度，通过将数据流立刻yield掉（主动让出），并且记录当前栈上的数据</li>
<li>阻塞完后立刻再通过线程恢复栈，并把阻塞的结果放到这个线程上去跑，这样看上去好像跟写同步代码没有任何差别</li>
<li>这整个流程可以称为coroutine，而跑在由coroutine负责调度的线程称为Fiber。比如Golang里的 go关键字其实就是负责开启一个Fiber，让func逻辑跑在上面</li>
</ul>
</li>
</ul>
<h2 id="协程和线程的区别"><a href="#协程和线程的区别" class="headerlink" title="协程和线程的区别"></a>协程和线程的区别</h2><table>
<thead>
<tr>
<th>比较项</th>
<th>线程</th>
<th>协程</th>
</tr>
</thead>
<tbody><tr>
<td>占用资源</td>
<td>初始单位为1MB,固定不可变</td>
<td>初始一般为 2KB，可随需要而增大</td>
</tr>
<tr>
<td>调度所属</td>
<td>由 OS 的内核完成</td>
<td>由用户完成</td>
</tr>
<tr>
<td>切换开销</td>
<td>涉及模式切换(从用户态切换到内核态)、16个寄存器、PC、SP…等寄存器的刷新等</td>
<td>只有三个寄存器的值修改 - PC / SP / DX.</td>
</tr>
<tr>
<td>性能问题</td>
<td>资源占用太高，频繁创建销毁会带来严重的性能问题</td>
<td>资源占用小,不会带来严重的性能问题</td>
</tr>
<tr>
<td>数据同步</td>
<td>需要用锁等机制确保数据的一直性和可见性</td>
<td>不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</td>
</tr>
</tbody></table>
<h2 id="进程状态的切换"><a href="#进程状态的切换" class="headerlink" title="进程状态的切换"></a>进程状态的切换</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1599655539465-7c6412b9-cf1c-41eb-98c2-631439893c16.png" alt="image.png"></p>
<ul>
<li>就绪状态（ready）：进程获取了除处理器以外的一切所需资源，等待被调度，多个处于就绪状态的进程拍成就绪队列</li>
<li>运行状态（running）：进程正在处理器上运行</li>
<li>阻塞状态（waiting）：等待某资源为可用</li>
<li>创建态（created）：进程正在被创建，尚未转到就绪态</li>
<li>结束态（terminated）：进程正从系统消失，可能是进程正常结束或其他原因中断退出运行</li>
</ul>
<p>应该注意以下内容：</p>
<ul>
<li>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li>
<li>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</li>
</ul>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><h3 id="调度与切换"><a href="#调度与切换" class="headerlink" title="调度与切换"></a>调度与切换</h3><ul>
<li><p>调度：从就绪队列中按照一定的算法选择一个进程并将处理器分配给它运行，以实现进程并发执行</p>
</li>
<li><p>处理器的三级调度</p>
</li>
<li><ul>
<li>低级调度（进程调度）</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>最基本的调度，按照某种算法从就绪队列中选取一个进程，并将处理器分配给它</li>
<li>进程调度的频率很高，一般几十毫秒一次</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>中级调度（内存调度）</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>作用：提高内存利用率和系统吞吐量</li>
<li>将暂时不能运行的进程调至外存等待，此时的该进程称为挂起态</li>
<li>当其具备运行条件且内存有空闲时，由中级调度将外存上的就绪进程重新调入内存，并修改其状态为就绪态，挂在就绪队列上等待</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>高级调度（作业调度）</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>按一定的规则从外存上处于后备状态的作业中挑选一个或多个作业，给它们分配内存、输入输出设备必要的资源，并建立相应的进程</li>
<li>多道批处理系统中大多配有作业调度，而其他系统中通常不需要配置作业调度，作业调度执行频率低，通常几分钟一次</li>
</ul>
</li>
</ul>
</li>
<li><p>进程切换</p>
</li>
<li><ul>
<li>进程切换在调度完成后立刻发生</li>
<li>操作系统内核将原进程的现场信息推入当前进程的内核堆栈来保存它们，并更新堆栈指针</li>
<li>内核完成从新进程的内核栈中装入新进程的现场信息、更新当前运行进程空间指针、重设PC寄存器等工作</li>
<li>开始运行新的进程</li>
</ul>
</li>
<li><p>不能马上进行调度与切换的情况：</p>
</li>
<li><ul>
<li>处理中断的过程中：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>中断过程复杂，实现上很难做到进程切换，而中断处理是系统的一部分，逻辑上不属于某一个进程，不应被剥夺处理器资源</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>进程在操作系统内核程序临界区中：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>进入临界区后，需要独占式访问共享数据，解锁前不应切换到其他进程运行</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>需要完全屏蔽中断的原子操作过程中：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>加锁、解锁、中断现场保护、恢复等原子操作，中断都要屏蔽，更不应该进行进程调度和切换</li>
</ul>
</li>
</ul>
</li>
<li><p>进程调度方式</p>
</li>
<li><ul>
<li>非剥夺调度方式（非抢占方式）：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>一旦把CPU分配给一个进程，该进程会保持CPU直到终止或转换到等待态</li>
<li>优点：系统开销小，适合批处理系统</li>
<li>缺点：不能用于分时系统和实时系统</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>剥夺调度方式（抢占方式）：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>当进程正在CPU上执行时，若某个更重要/紧迫的进程需要使用CPU，则立即暂停正在执行的进程，将处理机分配给这个更为重要/紧迫的进程</li>
</ul>
</li>
</ul>
</li>
<li><p>调度的基本准则</p>
</li>
<li><ul>
<li>CPU利用率：尽可能使CPU利用率最高</li>
<li>系统吞吐量：单位时间内CPU完成作业的数量</li>
<li>周转时间：从作业提交到作业完成所经历的时间</li>
<li>等待时间：进程处于等待CPU状态的时间之和</li>
<li>响应时间：从用户提交到系统首次产生响应所用的时间</li>
</ul>
</li>
</ul>
<h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><h4 id="1-批处理系统"><a href="#1-批处理系统" class="headerlink" title="1. 批处理系统"></a>1. 批处理系统</h4><ul>
<li>批处理系统在很老的计算机时使用，没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）</li>
</ul>
<p><strong>1.1 先来先服务 first-come first-serverd（FCFS）</strong></p>
<ul>
<li>非抢占式的调度算法，按照请求的顺序进行调度</li>
<li><strong>有利于长作业，但不利于短作业</strong>，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长</li>
</ul>
<p><strong>1.2 短作业优先 shortest job first（SJF）</strong></p>
<ul>
<li>非抢占式的调度算法，按估计运行时间最短的顺序进行调度</li>
<li><strong>长作业有可能会饿死</strong>，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度</li>
</ul>
<p><strong>1.3 高响应比优先</strong> </p>
<ul>
<li>高响应比优先调度算法是FCFS和SJF的综合平衡，每次进行作业调度时，先计算后备作业队列中每个作业的响应比，从中选出响应比最高的作业投入运行</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1599725265351-ac1b4730-41f4-45af-ab73-a8e3bf6ae880.png" alt="image.png"></li>
<li>要求服务时间短，响应比高，有利于短作业</li>
<li>等待时间长，响应比高，不会出现长作业饿死的情况</li>
</ul>
<h4 id="2-交互式系统"><a href="#2-交互式系统" class="headerlink" title="2. 交互式系统"></a>2. 交互式系统</h4><ul>
<li>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</li>
</ul>
<p><strong>2.1 时间片轮转</strong></p>
<ul>
<li><p>将所有就绪进程按先到先来原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片</p>
</li>
<li><p>当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程</p>
</li>
<li><p>时间片轮转算法的效率和时间片的大小有很大关系：</p>
</li>
<li><ul>
<li>因为进程切换都要保存进程的信息并且载入新进程的信息，<strong>如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间</strong>。</li>
<li>而<strong>如果时间片过长，那么实时性就不能得到保证</strong></li>
</ul>
</li>
<li><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1597059036482-eecf0326-76a1-49dc-9528-a46128edc7dd.png" alt="image.png"></p>
</li>
</ul>
<p><strong>2.2 优先级调度</strong></p>
<ul>
<li>为每个进程分配一个优先级，按优先级进行调度</li>
<li>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级</li>
</ul>
<p><strong>2.3 多级反馈队列</strong></p>
<ul>
<li>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次</li>
<li>多级队列是为这种需要连续执行多个时间片的进程考虑，<strong>设置了多个队列，每个队列时间片大小都不同</strong>，例如 1,2,4,8,..。<strong>进程在第一个队列没执行完，就会被移到下一个队列</strong>。这种方式下，之前的进程只需要交换 7 次</li>
<li><strong>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列中的进程</strong></li>
<li>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1597059054815-90d0949c-b2e6-4976-812f-d707922f2f8e.png" alt="image.png"></p>
<h4 id="3-实时系统"><a href="#3-实时系统" class="headerlink" title="3. 实时系统"></a>3. 实时系统</h4><p>实时系统要求一个请求在一个确定时间内得到响应。</p>
<p>分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><ul>
<li><p><strong>进程间通信(IPC，InterProcess Communication)的目的</strong></p>
</li>
<li><ul>
<li><strong>数据传输：</strong>一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几兆字节之间</li>
<li><strong>共享数据：</strong>多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到</li>
<li><strong>通知事件：</strong>一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）</li>
<li><strong>资源共享：</strong>多个进程之间共享同样的资源。为了作到这一点，需要内核提供锁和同步机制</li>
<li><strong>进程控制：</strong>有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变</li>
</ul>
</li>
<li><p>IPC方式包括：管道、系统IPC（信号量、消息队列、共享内存）和套接字（socket）</p>
</li>
</ul>
<h3 id="管道-pipe"><a href="#管道-pipe" class="headerlink" title="管道(pipe)"></a>管道(pipe)</h3><ul>
<li><p><strong>管道的特点：</strong></p>
</li>
<li><ul>
<li><strong>管道是半双工</strong>，数据只能向一个方向流动；双方需要互相通信时，需要建立起两个管道</li>
<li>只能用于具有亲缘关系的进程（<strong>父子进程或者兄弟进程</strong>）之间</li>
<li>管道对于两端通信的进程来说就只是一种<strong>文件</strong>，一种<strong>不属于文件系统仅存在内存中的“伪文件”</strong></li>
<li>管道的通信方式为：写端每次都将数据写入管道缓冲区的 <strong>末尾</strong> ，而读端每次都从管道缓冲区的 <strong>头部</strong> 读出数据</li>
<li>当一个管道建立时，它会创建两个文件描述符：fd[0]为读而打开，fd[1]为写而打开，要关闭管道只需将这两个文件描述符关闭即可。如下图：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1598175402011-cbc30792-6045-4701-b33c-2222787f89e6.png" alt="image.png"></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>管道的实质</strong></p>
</li>
<li><ul>
<li>管道的实质是一个<strong>内核缓冲区</strong>，进程以先进先出的方式从缓冲区存取数据：管道一端的进程顺序地将进程数据写入缓冲区，另一端的进程则顺序地读取数据</li>
<li>该缓冲区可以看做一个循环队列，读和写的位置都是自动增加的，一个数据只能被读一次，读出以后再缓冲区都不复存在了</li>
<li>当缓冲区读空或者写满时，有一定的规则控制相应的读进程或写进程是否进入等待队列，当空的缓冲区有新数据写入或慢的缓冲区有数据读出时，就唤醒等待队列中的进程继续读写</li>
</ul>
</li>
</ul>
<h3 id="信号-signals"><a href="#信号-signals" class="headerlink" title="信号(signals)"></a>信号(signals)</h3><ul>
<li><p><strong>信号的特点：</strong></p>
</li>
<li><ul>
<li>Unix系统中使用的最古老的进程间通信的方法之一，操作系统通过信号来通知进程系统中发生了某种预先规定好的事件（一组事件中的一个），它也是用户进程之间通信和同步的一种原始机制</li>
<li>一个键盘中断或者一个错误条件（比如进程试图访问它的虚拟内存中不存在的位置等）都有可能产生一个信号</li>
<li>信号可以在任何时候发给某一进程，而无需知道该进程的状态、</li>
<li>对信号的任何处理，包括终止进程，都必须由接收到信号的进程真正执行时才能处理，所以信号处理可能需要延迟一段时间</li>
<li>如果该进程当前并未处于执行状态，则内核保存该信号，直到该进程回复执行并传递给它为止</li>
</ul>
</li>
<li><p><strong>信号的来源：</strong></p>
</li>
<li><ul>
<li><strong>信号是软件层次上对中断机制的一种模拟，是一种异步通信方式（所以信号不是中断，**</strong>信号处理程序在用户态下运行的, 中断程序在核心态下运行的**<strong>）</strong></li>
<li><strong>信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发生了哪些系统事件</strong></li>
<li>信号事件主要有两个来源：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>硬件来源：用户按键输入 <code>Ctrl+C</code> 退出、硬件异常如无效的存储访问等</li>
<li>软件终止：终止进程信号、其他进程调用 <code>kill</code> 函数、软件异常产生信号</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>信号生命周期和处理流程</strong></p>
</li>
</ul>
<ol>
<li><ol>
<li><strong>信号被某个进程产生</strong>，并设置此信号传递的对象（一般为<strong>对应进程的pid</strong>），然后<strong>传递给操作系统</strong></li>
<li>操作系统根据接收进程的设置（是否阻塞）而选择性的发送给接收者，如果接收者阻塞该信号（且该信号是可以阻塞的），操作系统将暂时保留该信号，而不传递，直到该进程解除了对此信号的阻塞（如果对应进程已经退出，则丢弃此信号），<strong>如果对应进程没有阻塞，操作系统将传递此信号</strong></li>
<li><strong>目的进程接收到此信号后</strong>，将根据当前进程对此信号设置的预处理方式，<strong>暂时终止当前代码的执行，**</strong>保护上下文<strong>（主要包括临时寄存器数据，当前程序位置以及当前CPU的状态）、</strong>转而执行中断服务程序**<strong>，执行完成后在回复到中断的位置</strong>。当然，对于抢占式内核，在中断返回时还将引发新的调度</li>
</ol>
</li>
</ol>
<h3 id="消息队列-message"><a href="#消息队列-message" class="headerlink" title="消息队列(message)"></a>消息队列(message)</h3><ul>
<li><p>消息队列的特点：</p>
</li>
<li><ul>
<li>消息队列是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识</li>
<li>消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区受限等特点</li>
<li>消息队列允许一个或多个进程向它写入与读取消息</li>
<li>管道和消息队列的通信数据都是先进先出的原则</li>
<li>与管道相比，管道发送的数据没有类型；消息队列有类型，读端可以根据数据类型读取特定的数据</li>
</ul>
</li>
</ul>
<h3 id="共享内存-share-memory"><a href="#共享内存-share-memory" class="headerlink" title="共享内存(share memory)"></a>共享内存(share memory)</h3><ul>
<li>使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的</li>
<li>为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率</li>
<li>信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问</li>
</ul>
<h3 id="信号量-semaphore"><a href="#信号量-semaphore" class="headerlink" title="信号量(semaphore)"></a>信号量(semaphore)</h3><ul>
<li><p><strong>信号量</strong></p>
</li>
<li><ul>
<li>信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于<strong>进程间同步</strong></li>
</ul>
</li>
<li><p><strong>信号量与普通整型变量的区别：</strong></p>
</li>
<li><ul>
<li>信号量是非负整型变量，除了初始化之外，它只能通过两个标准原子操作：wait(semap) , signal(semap) ; 来进行访问</li>
<li>操作也被成为PV原语，而普通整型变量则可以在任何语句块中被访问</li>
</ul>
</li>
</ul>
<h3 id="套接字-socket"><a href="#套接字-socket" class="headerlink" title="套接字(socket)"></a>套接字(socket)</h3><ul>
<li>适合<strong>同一主机的不同进程间</strong>和<strong>不同主机的进程间</strong>进行全双工网络通信</li>
</ul>
<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="1-临界区"><a href="#1-临界区" class="headerlink" title="1. 临界区"></a>1. 临界区</h3><ul>
<li>对临界资源进行访问的那段代码称为临界区。</li>
<li>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</li>
<li>// entry section</li>
<li>// critical section;</li>
<li>// exit section</li>
</ul>
<h3 id="2-同步与互斥"><a href="#2-同步与互斥" class="headerlink" title="2. 同步与互斥"></a>2. 同步与互斥</h3><ul>
<li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li>
<li>互斥：多个进程在同一时刻只有一个进程能进入临界区。</li>
</ul>
<h3 id="3-信号量"><a href="#3-信号量" class="headerlink" title="3. 信号量"></a>3. 信号量</h3><ul>
<li><p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p>
</li>
<li><ul>
<li><strong>down</strong> : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li>
<li><strong>up</strong> ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</li>
</ul>
</li>
<li><p><strong>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断</strong>。</p>
</li>
<li><p>如果信号量的取值只能为 0 或者 1，那么就成为了 <strong>互斥量（Mutex）</strong> ，0 表示临界区已经加锁，1 表示临界区解锁。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>使用信号量实现生产者-消费者问题</strong></p>
<p>问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。</p>
<p>因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。</p>
<p>为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。</p>
<p>注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。</p>
<figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">#define N 100</span><br><span class="line">typedef int semaphore;</span><br><span class="line">semaphore mutex = 1;</span><br><span class="line">semaphore empty = N;</span><br><span class="line">semaphore full = 0;</span><br><span class="line">void producer() &#123;</span><br><span class="line">    <span class="meta">while</span>(TRUE) &#123;</span><br><span class="line">        int item = produce_item();</span><br><span class="line">        <span class="meta">do</span><span class="meta">wn(</span><span class="variable">&amp;empty</span>);</span><br><span class="line">        <span class="meta">do</span><span class="meta">wn(</span><span class="variable">&amp;mutex</span>);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        up(<span class="variable">&amp;mutex</span>);</span><br><span class="line">        up(<span class="variable">&amp;full</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void consumer() &#123;</span><br><span class="line">    <span class="meta">while</span>(TRUE) &#123;</span><br><span class="line">        <span class="meta">do</span><span class="meta">wn(</span><span class="variable">&amp;full</span>);</span><br><span class="line">        <span class="meta">do</span><span class="meta">wn(</span><span class="variable">&amp;mutex</span>);</span><br><span class="line">        int item = remove_item();</span><br><span class="line">        consume_item(item);</span><br><span class="line">        up(<span class="variable">&amp;mutex</span>);</span><br><span class="line">        up(<span class="variable">&amp;empty</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-管程"><a href="#4-管程" class="headerlink" title="4. 管程"></a>4. 管程</h3><ul>
<li>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</li>
<li>c 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。</li>
</ul>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">monitor ProducerConsumer</span><br><span class="line">    integer i;</span><br><span class="line">    condition c;</span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">()</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">remove</span><span class="params">()</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span> monitor;</span><br></pre></td></tr></table></figure>

<ul>
<li>管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。</li>
<li>管程引入了 <strong>条件变量</strong> 以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</li>
<li><strong>使用管程实现生产者-消费者问题</strong></li>
</ul>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 管程</span></span><br><span class="line">monitor ProducerConsumer</span><br><span class="line">    condition full, <span class="keyword">empty</span>;</span><br><span class="line">    integer count := <span class="number">0</span>;</span><br><span class="line">    condition c;</span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">(item: integer)</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> count = N <span class="keyword">then</span> wait(full);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        count := count + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">1</span> <span class="keyword">then</span> signal(<span class="keyword">empty</span>);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">remove</span>:</span> integer;</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">0</span> <span class="keyword">then</span> wait(<span class="keyword">empty</span>);</span><br><span class="line">        <span class="keyword">remove</span> = remove_item;</span><br><span class="line">        count := count - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = N -<span class="number">1</span> <span class="keyword">then</span> signal(full);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span> monitor;</span><br><span class="line"><span class="comment">// 生产者客户端</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">producer</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="title">true</span> <span class="title">do</span></span></span><br><span class="line"><span class="function">    <span class="title">begin</span></span></span><br><span class="line"><span class="function">        <span class="title">item</span> = <span class="title">produce_item</span>;</span></span><br><span class="line">        ProducerConsumer.insert(item);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">// 消费者客户端</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">consumer</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="title">true</span> <span class="title">do</span></span></span><br><span class="line"><span class="function">    <span class="title">begin</span></span></span><br><span class="line"><span class="function">        <span class="title">item</span> = <span class="title">ProducerConsumer</span>.<span class="title">remove</span>;</span></span><br><span class="line">        consume_item(item);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>

<h1 id="三、死锁"><a href="#三、死锁" class="headerlink" title="三、死锁"></a>三、死锁</h1><h3 id="1、死锁、饥饿、死循环的区别"><a href="#1、死锁、饥饿、死循环的区别" class="headerlink" title="1、死锁、饥饿、死循环的区别"></a>1、死锁、饥饿、死循环的区别</h3><ul>
<li><p>死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。至少有两个进程或以上同时发生死锁。</p>
</li>
<li><p>饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。比如：在短进程优先（SPF）算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生进程饥饿。可能只有一个进程发生饥饿。发生饥饿的进程既可能是阻塞态（如长期得不到I/O设备），也可能是就绪态（长期得不到处理机）</p>
</li>
<li><p>死循环：某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug导致的，有时是程序员故意设计的。死循环的进程可以上处理机运行（可以是运行态）。</p>
</li>
<li><p>总结：死锁和饥饿是管理者（操作系统）的问题，死循环是被管理者的问题。</p>
</li>
</ul>
<h3 id="2、死锁产生的必要条件"><a href="#2、死锁产生的必要条件" class="headerlink" title="2、死锁产生的必要条件"></a>2、死锁产生的必要条件</h3><p>产生死锁必须同时满足以下四个条件，只要其中一个不成立，死锁就不会发生。</p>
<ul>
<li>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁（如哲学家的筷子、打印机设备）。</li>
<li>不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</li>
<li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。（有了一个，还想要另一个，但是自己原来那个不放手。）</li>
<li>循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</li>
</ul>
<p>注意！发生死锁的时候一定又循环等待，但是发生循环等待时未必死锁（循环等待是死锁的必要不充分条件）。</p>
<p>如果同类资源数大于1，则即使有循环等待，也未必发生死锁。</p>
<p>如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件。</p>
<h3 id="3、什么时候会发生死锁"><a href="#3、什么时候会发生死锁" class="headerlink" title="3、什么时候会发生死锁"></a>3、什么时候会发生死锁</h3><p>1、对系统资源的竞争。各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁。</p>
<p>2、进程推进顺序非法。请求和释放资源的顺序不当，同样也会导致死锁。例如，并发执行进程P1、P2分别申请并占有了资源R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又申请R1，两者会因为申请的资源被对方占有而阻塞，从而发生死锁。</p>
<p>3、信号量的使用不当也会造成死锁。如生产者-消费者问题中，如果实现互斥的P操作在实现同步的P操作之前，就有可能导致死锁。（可以把互斥信号量、同步信号量也看做是一种抽象的系统资源）</p>
<p>总之，对不可剥夺资源的不合理分配，就可能导致死锁。第三点要记住。</p>
<h3 id="4、死锁的处理——预防死锁"><a href="#4、死锁的处理——预防死锁" class="headerlink" title="4、死锁的处理——预防死锁"></a>4、死锁的处理——预防死锁</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/png/218528/1575718340782-6dca5998-47bd-490f-bab3-2417f36e8825.png?x-oss-process=image/resize,w_1500" alt="image.png"></p>
<h4 id="4-1-破坏互斥条件"><a href="#4-1-破坏互斥条件" class="headerlink" title="4.1 破坏互斥条件"></a>4.1 破坏互斥条件</h4><p>如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如：SPOOLing技术。操作系统可以采用SPOOLing技术把独占设备在逻辑上改造成共享设备。比如，用SPOOLing技术将打印机改造为共享设备，在各进程看来，自己对打印机资源的使用请求立即就被接收处理了，不需要再阻塞等待。</p>
<p>缺点：并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，很多时候都无法破坏互斥情况。</p>
<h4 id="4-2-破坏不剥夺条件"><a href="#4-2-破坏不剥夺条件" class="headerlink" title="4.2 破坏不剥夺条件"></a>4.2 破坏不剥夺条件</h4><p>1、不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</p>
<p>2、破坏不剥夺条件：</p>
<p>方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。</p>
<p>方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级。（比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用）</p>
<p>3、缺点：</p>
<ul>
<li>实现起来比较复杂</li>
<li>释放已获得的资源可能造成前一段工作的失效。因此这种方法一般只适用于保存和恢复状态的资源，如CPU。</li>
<li>反复地申请和释放资源会增加系统开销，降低系统吞吐量。</li>
<li>若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果一直发生这样的情况，就会导致进程饥饿。</li>
</ul>
<h4 id="4-3-破坏请求和保持条件"><a href="#4-3-破坏请求和保持条件" class="headerlink" title="4.3 破坏请求和保持条件"></a>4.3 破坏请求和保持条件</h4><p>1、请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</p>
<p>2、可采用静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了。</p>
<p>3、缺点：</p>
<ul>
<li>有些资源可能只需要用很短的时间，因此如果进程的整个运行过程都一直保持着所有资源，就会造成严重的资源浪费，资源利用率极低。另外，该策略也有可能导致某些进程饥饿。</li>
</ul>
<p>例子： A进程需要a资源，B进程需要b资源，C进程需要AB两个资源，那么当A进程和B进程源源不断地加入时，根本轮不到C进程。</p>
<h4 id="4-4-破坏循环等待条件"><a href="#4-4-破坏循环等待条件" class="headerlink" title="4.4 破坏循环等待条件"></a>4.4 破坏循环等待条件</h4><p>1、循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</p>
<p>2、可采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序去请求资源，同类资源（即编号相同的资源）一次申请完。</p>
<p>3、原理分析：一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/218528/1575722481617-3d969ddf-1025-4b09-8522-71e5f3b6b16d.png" alt="image.png"></p>
<p>4、缺点：</p>
<ul>
<li>不方便增加新的设备，因为可能需要重新分配所有的编号</li>
<li>进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费（有可能大号的资源是要先使用的，小号资源晚使用，可是由于编号递增规则，只能先申请小号资源）</li>
<li>必须按规定次序申请资源，用户编程麻烦（在不同机器上，编号可能不一样，用户可能要重新编写代码）</li>
</ul>
<h3 id="5、死锁的处理——避免死锁"><a href="#5、死锁的处理——避免死锁" class="headerlink" title="5、死锁的处理——避免死锁"></a>5、死锁的处理——避免死锁</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/png/218528/1575722844700-df890c05-54b7-4217-898b-4cce009af1db.png?x-oss-process=image/resize,w_1500" alt="image.png"></p>
<h4 id="5-1-安全序列、不安全状态、死锁的联系"><a href="#5-1-安全序列、不安全状态、死锁的联系" class="headerlink" title="5.1 安全序列、不安全状态、死锁的联系"></a>5.1 安全序列、不安全状态、死锁的联系</h4><p>1、所谓安全序列，就是指如果系统按照这种序列分配子牙u你，则每个进程都顺利完成。只要能找出一个安全序列，系统就是安全状态。当然，安全序列可能有多个。</p>
<p>2、如果分配了资源之后，系统中找不到任何一个安全序列，系统就进入了不安全状态。这就意味着之后可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态。</p>
<p>3、如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就可能发生死锁（处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态）</p>
<p>4、可以在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。这也是“银行家算法”的核心思想。</p>
<h4 id="5-2-银行家算法"><a href="#5-2-银行家算法" class="headerlink" title="5.2 银行家算法"></a>5.2 银行家算法</h4><p><img src="https://cdn.nlark.com/yuque/0/2019/png/218528/1575723680965-560e06d5-2688-40b9-bede-4f3822bf6237.png?x-oss-process=image/resize,w_1500" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/218528/1575725368390-6e09854f-9422-4228-b3d3-36cb7473d161.png?x-oss-process=image/resize,w_1500" alt="image.png"></p>
<p>银行家算法总结：</p>
<p>用Available向量表示系统当前的可用资源数。</p>
<p>试分配：</p>
<p>在某一时刻，进程提出资源申请，系统首先检查申请的资源数是否超过进程的最大需求量。</p>
<p>不超过，则检查是否超过当前可用的资源数。</p>
<p>如果都不超过，则试着分配给该进程。</p>
<p>然后用安全性算法检查此次分配是否会导致系统进入不安全状态。</p>
<p>安全性算法简单理解：系统当前剩余的资源数超过了某个进程的Need向量，就把该进程加入安全序列，并将Allocation添加到Available，不断循环此过程，看最终能否让所有进程都加入安全序列，如果可以，此次分配时安全的，系统开始分配。</p>
<p>注意：处于安全状态一定不会死锁，死锁一定处于不安全状态，处于不安全状态不一定会死锁。</p>
<h3 id="6、死锁的处理——检测和解除"><a href="#6、死锁的处理——检测和解除" class="headerlink" title="6、死锁的处理——检测和解除"></a>6、死锁的处理——检测和解除</h3><h4 id="6-1-数据结构"><a href="#6-1-数据结构" class="headerlink" title="6.1 数据结构"></a>6.1 数据结构</h4><p>1、用种数据结构来保存资源的请求和分配信息。数据结构定义如下：</p>
<ul>
<li><p>两种结点：</p>
</li>
<li><ul>
<li>进程结点：对应一个进程<ul>
<li>资源结点：对应一类资源，一类资源可能有多个</li>
</ul>
</li>
</ul>
</li>
<li><p>两种边：</p>
</li>
<li><ul>
<li>进程结点-&gt;资源结点：表示进程想申请几个资源（每条边代表一个）<ul>
<li>资源结点-&gt;进程结点：表示进程想申请几个资源（每条边代表一个）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/218528/1575734720016-bc4c28fa-fae9-478a-aed9-816b1286e6f3.png" alt="image.png"></p>
<p>（矩形中的小圆代表资源的数量）</p>
<p>2、提供一种算法，利用上述信息来检测系统是否已进入死锁状态。算法描述如下：</p>
<p>如果系统中剩余的可用资源满足进程的需求，则进程将顺利自行下去，然后将资源归还系统，然后激活正在等待资源的进程，并顺利执行下去，一直这样下去，如果最终能消除所有边，就称这个图是可完全简化的，此时一定没有发生死锁（相当于找一个安全序列）。如果最终不能消除所有边，那么此时就是发生了死锁。最终连着边的那些进程就是处于死锁状态的进程。</p>
<p>算法简单理解：把没有处于阻塞态的进程的边都去掉，循环此过程。</p>
<h4 id="6-2-死锁的解除"><a href="#6-2-死锁的解除" class="headerlink" title="6.2 死锁的解除"></a>6.2 死锁的解除</h4><p>1、一旦检测出死锁的发生，就应该立即解除死锁。</p>
<p>2、并不是系统中所有进程都是死锁状态，用死锁检测算法简化资源分配图后，还连着边的那些进程就是死锁进程。</p>
<p>3、解除死锁的主要方法有：</p>
<ul>
<li>资源剥夺法：挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</li>
<li>撤销进程法（终止进程法）：强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的有点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束，一旦被终止可谓功亏一篑，以后还得从头再来。</li>
<li>进程回退法：让一个或多个死锁进程回退到足以避免死锁的地步。这就是要求系统要记录进程的历史信息，设置还原点。</li>
</ul>
<p>问题：决定对谁动手？</p>
<ul>
<li>进程优先级</li>
<li>已执行了多长时间</li>
<li>还要多久完成</li>
<li>进程已经使用了多少资源（资源分配多的优先）</li>
<li>进程是交互式的还是批处理式的（批处理优先）</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/218528/1575734667024-d54814af-cee6-49d8-8a26-4798efd42280.png?x-oss-process=image/resize,w_746"></p>
<h1 id="四、内存管理"><a href="#四、内存管理" class="headerlink" title="四、内存管理"></a>四、内存管理</h1><h2 id="虚拟内存-1"><a href="#虚拟内存-1" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><ul>
<li><strong>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存</strong>。</li>
<li>为了更好的管理内存，<strong>操作系统将内存抽象成地址空间。**</strong>每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中**。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</li>
<li>从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个<strong>程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能</strong>。<strong>例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序</strong>。</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1597062741056-0b5eeebc-b334-4929-9319-359a8cf9e7cc.png" alt="image.png"></li>
</ul>
<h2 id="分页与分段"><a href="#分页与分段" class="headerlink" title="分页与分段"></a>分页与分段</h2><ul>
<li><strong>分页</strong>管理方式是从计算机的角度考虑设计的，以<strong>提高内存的利用率</strong>，提升计算机的性能, 且分页通过硬件机制实现，对用户完全透明</li>
<li><strong>分段</strong>管理方式的提出则是考虑了用户和程序员，以<strong>满足方便编程、信息保护和共享、动态增长及动态链接</strong>等多方面的需要</li>
</ul>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><ul>
<li><p><strong>内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表</strong>。</p>
</li>
<li><p>一个虚拟地址分成两个部分，一部分存储页号，一部分存储偏移量。</p>
</li>
<li><p>页表：</p>
</li>
<li><ul>
<li>为了便于在内存中找到进程的每个页面所对应的物理块，<strong>系统为每个进程建立一张页表</strong>，记录页面在内存中对应的物理块号，页表一般存放在内存中。在配置了页表后，进程执行时，通过查找该表，即可找到每页在内存中的物理块号。可见，页表的作用是实现从页号到物理块号的地址映射</li>
<li>下图的页表存放着 16 个页，这 16 个页需要用 4 个bit来进行索引定位。</li>
</ul>
</li>
<li><p>例如对于虚拟地址（0010 000000000100），前 4 位是当在虚拟地址对应的存储页号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。那么映射后，这个页（地址空间）对应的页框（物理内存地址）的地址为 （110 000000000100）。</p>
</li>
<li><p><strong>相当于前缀做一个Mapping，前缀决定虚拟地址属于哪个块，后缀决定这个虚拟地址在块中的相对位置</strong></p>
</li>
<li><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1266758/1597064732122-fa391785-bc91-450c-a6db-3284d9ee19ea.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
</li>
</ul>
<h2 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h2><ul>
<li><p>分段式管理方式按照用户进程中的自然段划分逻辑空间</p>
</li>
<li><ul>
<li>例如，用户进程由主程序、两个子程序、栈和一段数据组成，于是可以把这个用户进程划分为5个段，每段从0 开始编址，并分配一段连续的地址空间</li>
<li>段内要求连续，段间不要求连续，因此整个作业的地址空间是二维的，其<strong>逻辑地址</strong>由<strong>段号S</strong>与<strong>段内偏移量W</strong>两部分组成</li>
</ul>
</li>
<li><p>页式系统中，逻辑地址的页号和页内偏移量对用户是透明的，段式系统中，段号和段内偏移量必须由用户显示提供，，在髙级程序设计语言中，这个工作由编译程序完成</p>
</li>
<li><p>段表</p>
</li>
<li><ul>
<li>每个进程都有一张逻辑空间与内存空间映射的段表，其中每一个段表项对应进程的一个段，段表项记录该段在内存中的起始地址和段的长度</li>
<li>在配置了段表后，执行中的进程可通过查找段表，找到每个段所对应的内存区</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1598085231446-c4b4cce0-09de-4296-85a2-7a2021e9f923.png" alt="image.png"></li>
</ul>
</li>
<li><p>段的共享和保护</p>
</li>
<li><ul>
<li>共享：通过两个作业的段表中相应表项指向被共享的段的同一个物理副本来实现的</li>
<li>保护：存取控制保护、地址越界保护</li>
</ul>
</li>
</ul>
<h2 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h2><ul>
<li>分页能有效地提高内存利用率，分段能反映程序的逻辑结构并有利于段的共享，将这两种存储管理方法结合起来，就形成了段页式存储管理方式</li>
<li>程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1598086260778-9d62781d-6da7-4186-af92-ecf9e30b8b47.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image.png"></li>
</ul>
<h2 id="分页与分段的比较"><a href="#分页与分段的比较" class="headerlink" title="分页与分段的比较"></a>分页与分段的比较</h2><ul>
<li>对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段</li>
<li>地址空间的维度：分页是一维地址空间，分段是二维的</li>
<li>大小是否可以改变：页的大小不可变，段的大小可以动态改变</li>
<li>出现的原因：<strong>分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护</strong></li>
</ul>
<h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><ul>
<li>在程序运行过程中，<strong>如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中</strong>。<strong>此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间</strong>。</li>
<li>页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。</li>
<li><strong>页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）</strong></li>
</ul>
<ol>
<li><strong>最佳（OPT, Optimal replacement algorithm）</strong></li>
</ol>
<ul>
<li><ul>
<li>所<strong>选择的被换出的页面在未来最长时间内不再被访问</strong>，通常可以保证获得最低的缺页率。</li>
<li>是一种<strong>理论上的算法</strong>，因为无法知道一个页面多长时间不再被访问。</li>
<li>举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：</li>
<li>7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1</li>
<li>开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。</li>
</ul>
</li>
</ul>
<ol>
<li><strong>最近最久未使用（LRU, Least Recently Used）</strong></li>
</ol>
<ul>
<li><ul>
<li><strong>虽然无法知道未来要使用的页面情况，但是可以知道过去使用页面的情况</strong>。LRU 将最近最久未使用的页面换出。</li>
<li><strong>为了实现 LRU，需要在内存中维护一个所有页面的链**</strong>表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。**</li>
<li><strong>因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。</strong></li>
<li>4，7，0，7，1，0，1，2，1，2，6</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1597061862423-62868c5b-e196-486b-9104-ffc39a540f9f.png" alt="image.png"></li>
</ul>
</li>
</ul>
<ol>
<li><strong>最近未使用（NRU, Not Recently Used）</strong></li>
</ol>
<ul>
<li><ul>
<li>每个页面都有两个状态位：R 与 M，<strong>当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1</strong>。其中 R 位会定时被清零。可以将页面分成以下四类：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>R=0，M=0</li>
<li>R=0，M=1</li>
<li>R=1，M=0</li>
<li>R=1，M=1</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。</li>
<li><strong>NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）</strong>。</li>
</ul>
</li>
</ul>
<ol>
<li><strong>先进先出（FIFO, First In First Out）</strong></li>
</ol>
<ul>
<li><ul>
<li>选择换出的页面是最先进入的页面。</li>
<li><strong>该算法会将那些经常被访问的页面换出，导致缺页率升高</strong>。</li>
</ul>
</li>
</ul>
<ol>
<li><strong>第二次机会算法</strong></li>
</ol>
<ul>
<li><ul>
<li><strong>FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：</strong></li>
<li><strong>当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。</strong></li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1597061941454-03800959-859a-4877-abfd-27c39e401945.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image.png"></li>
</ul>
</li>
</ul>
<ol>
<li><strong>时钟（Clock）</strong></li>
</ol>
<ul>
<li><ul>
<li>第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1597062565754-826091ad-7dc4-4c83-943d-343b7bd7bdac.png" alt="image.png"></li>
</ul>
</li>
</ul>
<h1 id="五、设备管理"><a href="#五、设备管理" class="headerlink" title="五、设备管理"></a>五、设备管理</h1><h2 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h2><ul>
<li>盘面（Platter）：一个磁盘有多个盘面；</li>
<li>磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；</li>
<li>扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小；</li>
<li>磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；</li>
<li>制动手臂（Actuator arm）：用于在磁道之间移动磁头；</li>
<li>主轴（Spindle）：使整个盘面转动。</li>
<li><img src="https://camo.githubusercontent.com/42c8be3472d81b72762c2a88b29fa61b4bdf2409/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30313466626334642d643837332d346131322d623136302d3836376464616564393830372e6a7067?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></li>
</ul>
<h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><ul>
<li><p>读写一个磁盘块的时间的影响因素有：</p>
</li>
<li><ul>
<li>旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）</li>
<li>寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）</li>
<li>实际的数据传输时间</li>
</ul>
</li>
<li><p>其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p>
</li>
</ul>
<ol>
<li>先来先服务（FCFS, First Come First Served）</li>
</ol>
<ul>
<li><ul>
<li>按照磁盘请求的顺序进行调度。</li>
<li>优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。</li>
</ul>
</li>
</ul>
<ol>
<li>最短寻道时间优先（SSTF, Shortest Seek Time First）</li>
</ol>
<ul>
<li><ul>
<li>优先调度与当前磁头所在磁道距离最近的磁道。</li>
<li>虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是<strong>出现饥饿现象</strong>。<strong>具体来说，两端的磁道请求更容易出现饥饿现象。</strong></li>
<li><img src="https://camo.githubusercontent.com/513755459b87116ae3a03bb9c4c6a0b161e7d0ed/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34653234383565342d333462642d343936372d396630322d3063303933623739376161612e706e67" alt="image"></li>
</ul>
</li>
</ul>
<ol>
<li>电梯算法（SCAN）</li>
</ol>
<ul>
<li><ul>
<li>电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</li>
<li>电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。</li>
<li>因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。</li>
<li><img src="https://camo.githubusercontent.com/8187903788bbfb90978169f20fa4fd41e094bf22/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32373163653038662d633132342d343735662d623439302d6265343466656463366432652e706e67" alt="image"></li>
</ul>
</li>
<li><p><a href="#LbxNj">一</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2020/10/14/0000.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="OSI七层体系结构（从上到下）"><a href="#OSI七层体系结构（从上到下）" class="headerlink" title="OSI七层体系结构（从上到下）"></a>OSI七层体系结构（从上到下）</h2><ul>
<li>应用层（数据）：确定<strong>进程之间通信的性质</strong>，以满足用户需要以及<strong>提供网络</strong>与<strong>用户应用</strong></li>
<li>表示层（数据）：主要解决用户信息的<strong>语法表示</strong>问题，例如：加密、解密</li>
<li>会话层（数据）：建立和维护应用之间<strong>通信的机制</strong>，例如：服务器验证用户登录</li>
<li>传输层（数据段）：进程和进程之间，可靠传输、错误检测、流量控制（TCP、UDP）</li>
<li>网络层（数据包）：主机和主机之间，提供逻辑地址（IP）、选路</li>
<li>数据链路层（帧）：将上层数据封装成<strong>帧</strong>，用MAC地址访问媒介，错误检测与修正</li>
<li>物理层（比特流）：设备之间<strong>比特流</strong>的传输</li>
</ul>
<h2 id="各层的数据交换设备"><a href="#各层的数据交换设备" class="headerlink" title="各层的数据交换设备"></a>各层的数据交换设备</h2><ul>
<li>网关：应用层、传输层</li>
<li>路由器：网络层</li>
<li>交换机：数据链路层、网络层</li>
<li>网桥：数据链路层</li>
<li>集线器、中继器：物理层</li>
</ul>
<h2 id="IP地址与物理地址的区别"><a href="#IP地址与物理地址的区别" class="headerlink" title="IP地址与物理地址的区别"></a>IP地址与物理地址的区别</h2><p>物理地址：数据链路层和物理层使用的地址</p>
<p>IP地址：网络层和以上各层使用的地址，逻辑地址</p>
<p>ARP协议：用于IP地址和MAC地址的对应</p>
<h2 id="ping-的原理"><a href="#ping-的原理" class="headerlink" title="ping 的原理"></a>ping 的原理</h2><p>使用 ICMP 协议</p>
<h2 id="Traceroute"><a href="#Traceroute" class="headerlink" title="Traceroute"></a>Traceroute</h2><p>使用 ICMP 协议</p>
<p>给目的主机发送一个 <strong>TTL=1</strong>的 <strong>UDP 数据包</strong>，经过的第一个路由器收到这个数据包后，将 TTL-1，TTL变为0后，路由器将这个包丢掉，同时发送一个主机不可达的ICMP数据报给主机；</p>
<p>主机收到后再发一个TTL=2的UDP数据包给目的主机，然后第二个路由器给主机发送ICMP报文；</p>
<p>如此往复直到达到目的主机。</p>
<h2 id="TCP是什么"><a href="#TCP是什么" class="headerlink" title="TCP是什么"></a>TCP是什么</h2><p>TCP是传输控制协议，是一种面向连接的、可靠的、基于<strong>字节流</strong>的传输层通信协议。</p>
<h2 id="TCP特点"><a href="#TCP特点" class="headerlink" title="TCP特点"></a>TCP特点</h2><p>面向连接的</p>
<p>点对点，每一个 TCP 连接只能有两个端点</p>
<p>可靠交付。通过 TCP 连接传送的数据，无差错、不丢失、不重复，并且按序到达</p>
<p>全双工通信</p>
<p>面向字节流</p>
<h2 id="TCP对应的应用层协议"><a href="#TCP对应的应用层协议" class="headerlink" title="TCP对应的应用层协议"></a>TCP对应的应用层协议</h2><p>FTP</p>
<p>HTTP</p>
<h2 id="TCP三次握手过程"><a href="#TCP三次握手过程" class="headerlink" title="TCP三次握手过程"></a>TCP三次握手过程</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1200640/1585819858709-9cb88c52-1abd-40fe-8617-f0fa8631c860.png?x-oss-process=image/resize,w_1500" alt="image"></p>
<h2 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h2><ol>
<li>初始化双方序列号的初始值</li>
<li>若服务器发送确认数据包和同步数据包，而客户端却迟迟不确认，服务端会一直等待，会浪费服务器的资源，容易受到 DOS/DDOS攻击</li>
<li>若第二次握手数据丢失，服务器认为已经连接，而客户端认为并没有连接。服务器发送数据，C不会接收。C会继续进行握手操作，这会浪费S的连接资源（SYN Flood）</li>
</ol>
<h2 id="SYN-Flood"><a href="#SYN-Flood" class="headerlink" title="SYN Flood"></a>SYN Flood</h2><p>服务端发送确认数据包后，客户端迟迟不回应，服务端会一直等待客户端回应，浪费资源，影响正常服务</p>
<p><strong>解决</strong></p>
<p>1、缩短 SYN半连接的超时时间</p>
<p>2、SYN Cookie 技术：SYN 队列满后，服务器回发SYN Cookie，若为正常连接，客户端会回发 SYN Cookie，建立正常连接</p>
<h2 id="建立连接后，客户端出现故障怎么办"><a href="#建立连接后，客户端出现故障怎么办" class="headerlink" title="建立连接后，客户端出现故障怎么办"></a>建立连接后，客户端出现故障怎么办</h2><p>服务端会一直向客户端发送保活探测报文，到达一定次数后仍未得到响应就断开连接</p>
<h2 id="TCP四次挥手过程"><a href="#TCP四次挥手过程" class="headerlink" title="TCP四次挥手过程"></a>TCP四次挥手过程</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1200640/1585819858671-82faa363-7411-4d14-8a99-1fb57ccd2e7c.png" alt="image"></p>
<h2 id="为什么要有四次挥手"><a href="#为什么要有四次挥手" class="headerlink" title="为什么要有四次挥手"></a>为什么要有四次挥手</h2><p>TCP是全双工模式，客户端断开连接，不能向服务器发送数据，但服务器还能向客户端发送数据。服务器可能还有数据要发送给客户端，所以第二第三此挥手不能放一块。</p>
<h2 id="Last-ack"><a href="#Last-ack" class="headerlink" title="Last_ack"></a>Last_ack</h2><p>等待对方的ack报文</p>
<h2 id="为什么等-2MSL"><a href="#为什么等-2MSL" class="headerlink" title="为什么等 2MSL"></a>为什么等 2MSL</h2><ul>
<li>C的第四次挥手可能会丢失；服务器会不断地发送FIN报文。所以C不能直接关闭，而是要等待S收到ACK。C进入TIMEWAIT状态后，等待2MSL，如果接收到了S的FIN报文，就会重新发送ACK包。</li>
<li></li>
<li></li>
<li>释放的端口可能会重连服务器刚断开的端口，新的TCP连接报文和旧TCP报文可能会产生冲突。所以要等2MSL，等待网络中旧的TCP报文全部挂掉</li>
</ul>
<h2 id="服务器出现大量-CLOSE-WAIT状态"><a href="#服务器出现大量-CLOSE-WAIT状态" class="headerlink" title="服务器出现大量 CLOSE_WAIT状态"></a>服务器出现大量 CLOSE_WAIT状态</h2><p>对方关闭socket连接，我方忙于读或写，没有即使释放连接</p>
<p>检查释放资源的代码</p>
<h2 id="UDP是什么"><a href="#UDP是什么" class="headerlink" title="UDP是什么"></a>UDP是什么</h2><p>面向非连接的协议，不与对方建立连接，直接把数据包发过去</p>
<h2 id="UDP特点"><a href="#UDP特点" class="headerlink" title="UDP特点"></a>UDP特点</h2><p>面向无连接</p>
<p>支持一对一、一对多、多对一、多对多</p>
<p>不保证可靠交付，尽最大努力交付</p>
<p>面向<strong>报文</strong></p>
<p>没有拥塞控制</p>
<p>首部开销8字节</p>
<h2 id="UDP对应的应用层协议"><a href="#UDP对应的应用层协议" class="headerlink" title="UDP对应的应用层协议"></a>UDP对应的应用层协议</h2><p>DNS：域名解析服务，将域名地址解析为IP</p>
<h2 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h2><table>
<thead>
<tr>
<th>类型</th>
<th>是否面向连接</th>
<th>可靠性</th>
<th>传输形式</th>
<th>效率</th>
<th>所需资源</th>
<th>应用场景</th>
<th>首部字节</th>
</tr>
</thead>
<tbody><tr>
<td>TCP</td>
<td>是</td>
<td>可靠</td>
<td>字节流</td>
<td>慢</td>
<td>多</td>
<td>通信数据可靠</td>
<td>20-60</td>
</tr>
<tr>
<td>UDP</td>
<td>否</td>
<td>不可靠</td>
<td>数据报文段</td>
<td>快</td>
<td>少</td>
<td>通信速度( 视频)</td>
<td>8</td>
</tr>
</tbody></table>
<h2 id="TCP的拆包、粘包概念、原因、解决方法"><a href="#TCP的拆包、粘包概念、原因、解决方法" class="headerlink" title="TCP的拆包、粘包概念、原因、解决方法"></a>TCP的拆包、粘包概念、原因、解决方法</h2><ul>
<li>UDP时面向报文的，首部有两个字节指示UDP数据报文的长度，因此能够在应用层将不同的数据报问分开，避免了拆包和粘包</li>
<li>TCP是面向字节流的，①虽然应用层和TCP传输层的交互是大小不等的数据块，但TCP把这些数据块看成无结构的字节流，没有边界，②首部没有表示数据长度的字段，所以会出现拆包和粘包现象</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1200640/1586012924750-1f474292-da29-47a7-a820-7180c4d95b40.png" alt="image.png"></p>
<p>粘包、拆包的原因</p>
<ol>
<li>要发送的数据大于 TCP <strong>发送缓冲区</strong>剩余空间大小，将会发生拆包</li>
<li>要发送的数据大于<strong>最大报文长度</strong>，TCP 在传输前会对其进行拆包</li>
<li>要发送的数据小于<strong>TCP 发送缓冲区的大小</strong>，TCP 将多次写入缓冲区的数据一次发送出去，发生粘包</li>
<li><strong>接收端</strong>的应用层没有及时读取<strong>缓冲区</strong>中的数据，发生粘包</li>
</ol>
<p>粘包、拆包的解决</p>
<ol>
<li>发送端给每个数据包添加<strong>包首部</strong>，首部中应该包含数据包的<strong>长度字段</strong>，这样接收端在接收到数据后，通过读取包首部的长度字段，就可以知道每个数据包的实际长度了</li>
<li>发送端将每个数据包封装为<strong>固定长度</strong>（不够可以用0填充），这样接收端从接收缓冲区中读取固定长度的数据就可以把数据包拆分开来</li>
<li>在数据包之间<strong>设置边界</strong>，比如添加<strong>特殊符号</strong>，这样接收端通过边界就可以将不同的数据包拆分开来</li>
</ol>
<h2 id="TCP的可靠传输、流量控制、拥塞控制"><a href="#TCP的可靠传输、流量控制、拥塞控制" class="headerlink" title="TCP的可靠传输、流量控制、拥塞控制"></a>TCP的可靠传输、流量控制、拥塞控制</h2><p>作者：又戈月空</p>
<p>链接：<a href="https://www.nowcoder.com/discuss/402118">https://www.nowcoder.com/discuss/402118</a></p>
<p>来源：牛客网</p>
<p>TCP流量控制，简单来说就是让数据传输端传输的速率不要太快，让数据接收端来得及接收，利用滑动窗口机制可以很方便的在TCP连接上实现对数据传输端的流量控制。TCP的窗口单位是字节，不是报文段，数据传输端的发送窗口不能超过接收端给出的接收窗口的数值，流量控制的机制是控制丢包率，主要目的：让数据传输端了解数据接收端当前的接收能力，可灵活调整传输速率。</p>
<p>滑动窗口：TCP采用大小可变的滑动窗口进行流量控制，窗口大小的单位是字节。数据传输窗口在连接建立时由双方商定。但在通信的过程中，数据接收端可根据自己的资源情况，随时动态地调整对方的传输窗口大小。</p>
<p>滑动窗口引进原由：把窗口理解为缓冲区（但是有些窗口和缓冲区又不太一样）。如果没有这些“窗口”，那么TCP每发送一段数据后都必须等到数据接收端确认后才能发送下一段数据，这样做的话TCP传输的效率实在是太低了。解决的办法就是在发送端等待确认的时候继续发送数据，假设发送到第X个数据段是收到数据接收端的确认信息，如果X在可接受的范围内那么这样做也是可接受的。</p>
<p>滑动窗口：</p>
<p>A、数据接收端窗口 X</p>
<p>接收端缓冲区大小。接收端将此窗口值放在 TCP 报文的首部中的窗口字段，传送给发送端。</p>
<p>B、拥塞窗口 Y</p>
<p>发送端缓冲区大小</p>
<p>C、数据传输窗口 Z</p>
<p>发送窗口的上限值 = Min [X, Y]</p>
<p>① 当 X &lt; Y 时，是接收端的接收能力限制数据传输窗口的最大值。</p>
<p>② 当 Y &lt; X 时，则是网络的拥塞限制数据传输窗口的最大值。</p>
<p>(零窗口：发送方停止发送数据，只能发送探测数据包)</p>
<h1 id="0-中继设备"><a href="#0-中继设备" class="headerlink" title="0.中继设备"></a>0.中继设备</h1><p>* <strong>物理层</strong>中继系统：<strong>转发器</strong>(repeater)。</p>
<p>* <strong>数据链路层</strong>中继系统：<strong>网桥</strong>(bridge)。</p>
<p>* <strong>网络层</strong>中继系统：<strong>路由器</strong>(router)，路由器连接了多个网络，所以至少有2个以上IP地址。</p>
<p>* <strong>网络层以上</strong>的中继系统：**网关(**gateway)。</p>
<p><strong>0.1 各层数据</strong></p>
<p><strong>数据包(packet)：</strong>应用层；</p>
<p><strong>段(segment)：</strong>传输层;</p>
<p><strong>IP数据报(datagram)：</strong>网络层，也有人称IP数据包</p>
<p><strong>数据帧(frame)：</strong>数据链路层；</p>
<h1 id="1-物理层："><a href="#1-物理层：" class="headerlink" title="1.物理层："></a>1.物理层：</h1><p>   无</p>
<h1 id="2-数据链路层："><a href="#2-数据链路层：" class="headerlink" title="2.数据链路层："></a>2.数据链路层：</h1><h2 id="2-1-使用的主要是点对点信道和广播信道两种"><a href="#2-1-使用的主要是点对点信道和广播信道两种" class="headerlink" title="2.1 使用的主要是点对点信道和广播信道两种"></a>2.1 使用的主要是点对点信道和广播信道两种</h2><h2 id="2-2-传输的协议数据单元是帧"><a href="#2-2-传输的协议数据单元是帧" class="headerlink" title="2.2 传输的协议数据单元是帧"></a>2.2 传输的协议数据单元是帧</h2><h2 id="2-3-三个基本问题是：封装成帧，透明传输和差错检测"><a href="#2-3-三个基本问题是：封装成帧，透明传输和差错检测" class="headerlink" title="2.3 三个基本问题是：封装成帧，透明传输和差错检测"></a>2.3 三个基本问题是：封装成帧，透明传输和差错检测</h2><p>​     <strong>封装成帧：</strong>在一段数据的前后分别添加首部和尾部，这样就构成了一个帧。接收端在收到物理层上交的比特流后，就能<strong>根据首部和尾部的标记，从比特流中识别帧的开始和结束</strong>。MTU（Maximum Transfer Unit）：帧数据部分长度上限，<strong>链路层MTU是1500字节</strong></p>
<p>​       <img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201015143240.png" alt="image"></p>
<p>   <strong>透明传输：</strong>当数据部分是非ASCII码的文本文件时(如class文件)，如果数据中的某个字节的二进制代码恰好是帧尾部控制字符，那么就会把帧的后面部分丢弃，这种情况就不是透明传输。</p>
<p>​     <strong>解决：</strong>字节填充法——<strong>发送端的数据链路层**</strong>在数据<strong>中出现控制字符”SOH”或”EOT”的前面插入一个转义字符”ESC”。而在</strong>接收端的数据链路层**在将数据送往网络层之前删除这个插入的转义字符。当然如果转义字符”ESC”也出现在数据当中，那么解决的方法仍然是在转义字符的前面插入一个转义字符，所以，当接收到连续的两个转义字符的时候，就去删除其中前面的一个。 </p>
<p>​             <img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201015143258.png" alt="image.png"></p>
<p>   <strong>差错检测：</strong>数据链路层广泛使用了循环冗余检验（CRC）的检错技术，在IP数据报后添加2字节的帧检验序列FCS。</p>
<p>​     CRC的基本思想就是将传输的数据当作一个位数很长的数，将这个数除以另外的一个数，得到的余数作为校验数据附加到原数据后面。</p>
<p>​     在数据链路层若仅仅使用CRC差错检验技术，则只能做到对帧的无差错接收，不会检查ip数据报是不是正确的（只能保证数据链路层传输数据时不发生错误）。</p>
<h2 id="2-4-PPP协议（Point-to-Point-Protocol，属于数据链路层的点对点信道）："><a href="#2-4-PPP协议（Point-to-Point-Protocol，属于数据链路层的点对点信道）：" class="headerlink" title="2.4 PPP协议（Point-to-Point Protocol，属于数据链路层的点对点信道）："></a>2.4 PPP协议（Point-to-Point Protocol，属于数据链路层的点对点信道）：</h2><p>用户计算机和ISP(运营商)进行通信时所使用的数据链路层协议，数据链路层三个基本问题它都支持</p>
<p>​     <strong>PPP协议有三个组成部分：</strong></p>
<p>​       （1）数据链路层协议：IP数据报封装到串行链路的方法</p>
<p>​       （2）链路控制协议LCP（Link Control Protocol）：用来建立并维护<strong>数据链路连接</strong>，身份验证(运行商使用)</p>
<p>​       （3）网络控制协议NCP：支持不同的网络层协议，如IP</p>
<p>​         <img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201015143411.png" alt="image"></p>
<p>​     <strong>PPP协议帧格式：</strong>数据链路层的三个基本问题是：封装成帧，透明传输和差错检测都支持</p>
<p>​       <img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1586510356478-29ca549d-195c-4ebd-a4c4-6d6c86822219.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<h2 id="2-5-CSMA-CD（Carrier-Sense-Multiple-Access-Collision-Detect，属于数据链路层的广播信道）：载波监听多路访问-冲突检测方法"><a href="#2-5-CSMA-CD（Carrier-Sense-Multiple-Access-Collision-Detect，属于数据链路层的广播信道）：载波监听多路访问-冲突检测方法" class="headerlink" title="2.5 CSMA/CD（Carrier Sense Multiple Access/Collision Detect，属于数据链路层的广播信道）：载波监听多路访问/冲突检测方法"></a>2.5 CSMA/CD（Carrier Sense Multiple Access/Collision Detect，属于数据链路层的广播信道）：载波监听多路访问/冲突检测方法</h2><p>​       特点是：发送前先监听，边发送边监听，一旦发现总线上出现了碰撞，就立即停止发送。然后按照退避算法等待一段随机时间后再次发送，推迟的平均时间随着重传次数而增大，退避时间的单位是一个争用期的时间长度(信号的双程传播所需要的时间)</p>
<p>​       <img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1586510356525-89b6dc95-a628-43c6-bc62-37da855c12a1.png" alt="image"></p>
<h2 id="2-6-交换机"><a href="#2-6-交换机" class="headerlink" title="2.6 交换机"></a>2.6 交换机</h2><ul>
<li><p>交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 <strong>MAC 地址到接口的映射</strong></p>
</li>
<li><p>工作原理：</p>
</li>
<li><ul>
<li>交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中</li>
<li>为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧</li>
<li>主机 C 和主机 D 会丢弃该帧，主机 B 回应该帧向主机 A 发送数据包时，交换机查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 2 的映射</li>
</ul>
</li>
</ul>
<h1 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3.网络层"></a>3.网络层</h1><h2 id="3-1-网络层的设计思路"><a href="#3-1-网络层的设计思路" class="headerlink" title="3.1 网络层的设计思路"></a>3.1 网络层的设计思路</h2><ul>
<li>网络层向上只提供简单灵活的、<strong>无连接的</strong>、尽<strong>最大努力交付</strong>的数据报服务</li>
<li>网络在发送分组时<strong>不需要先建立连接</strong>。每一个分组（即 IP 数据报）独立发送，与其前后的分组无关（不进行编号）</li>
<li>网络层不提供服务质量的承诺。即所传送的分组<strong>可能出错、丢失、重复和失序</strong>（不按序到达终点），当然也不保证分组传送的时限。</li>
<li>优点：路由器可以做的简单便宜，<strong>网络造价降低</strong>。可靠的进程通信由主机的运输层负责(包括差错处理、流量控制等)</li>
</ul>
<h2 id="3-2-数据在互联网中的传送"><a href="#3-2-数据在互联网中的传送" class="headerlink" title="3.2 数据在互联网中的传送"></a>3.2 数据在互联网中的传送</h2><p>​     <img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201015143349.png" alt="image"></p>
<p>​     1.<strong>应用层</strong>要发送的数据在<strong>传输层</strong>被分成段1,2,3并编号</p>
<p>​     2.<strong>网络层</strong>将数据段增加<strong>发送端IP地址</strong>和<strong>接收端IP地址</strong>封装成包(IP数据报)</p>
<p>​     3.<strong>数据链路层</strong>将数据报增加<strong>发送端MAC地址</strong>和<strong>路由器MAC地址</strong></p>
<p>​     4.<strong>物理层</strong>将数据帧转化成比特流发送</p>
<p>​     5.<strong>交换机</strong>工作在<strong>数据链路层</strong>，读取比特流，</p>
<p>​         5.1 如果接收端IP地址和发送端IP是同一个网络下(根据IP地址和子网掩码确定)，则根据<strong>ARP协议</strong>找到<strong>接收端MAC地址</strong></p>
<p>​         5.2 如果不是同一个网络下，则根据<strong>ARP协议</strong>找到网络中一个<strong>路由器MAC地址</strong>，交给路由器进行路由选择</p>
<p>​     6.<strong>路由器工作在网络层</strong>，发送的数据帧中<strong>接收端的MAC是FF</strong>，即<strong>广播</strong>，所有路由器都可以接收该请求</p>
<p>​     7.确定接收端MAC地址后，接收主机逐层解析数据，传输层只有数据段</p>
<p>​     8+.<strong>路由选择</strong>的时候只用<strong>下三层协议</strong></p>
<h2 id="3-3-IP协议（-TCP-IP-体系中两个最主要的协议之一）"><a href="#3-3-IP协议（-TCP-IP-体系中两个最主要的协议之一）" class="headerlink" title="3.3 IP协议（ TCP/IP 体系中两个最主要的协议之一）"></a>3.3 IP协议（ TCP/IP 体系中两个最主要的协议之一）</h2><ul>
<li><p><strong>IP 数据报的格式</strong></p>
</li>
<li><ul>
<li>IP协议主要内容围绕在IP数据包格式中</li>
<li>一个 IP 数据报由<strong>首部</strong>和<strong>数据</strong>两部分组成</li>
<li><strong>首部</strong>的前一部分是固定长度，共 <strong>20 字节</strong>，是所有 IP 数据报必须具有的</li>
<li>在首部的<strong>固定部分后面</strong>是一些<strong>可选字段</strong>，其长度是可变的</li>
<li>链路层一个数据帧最大长度是<strong>1500字节</strong>，除去<strong>固定部分20字节</strong>，<strong>网络层分片后</strong>最多有<strong>1480字节</strong>用来<strong>传输数据，</strong>即每1480字节数据就要分片</li>
</ul>
</li>
</ul>
<p>​         <img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201015143454.png" alt="image"></p>
<ul>
<li>IP数据报首部格式</li>
</ul>
<p>​       <img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1586510356694-e3c4d3c8-6347-42d8-9d7b-681c9601c548.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<p>​       <strong>版本：</strong>占 4 个比特，指 IP 协议的版本，目前的 IP 协议版本号为 4 (即 IPv4)</p>
<p>​       <strong>首部长度：</strong>占 4 个比特，可表示的最大数值，15 个单位(一个单位为 4 字节)，因此 IP 的首部长度的最大值是 60 字节</p>
<p>​       <strong>区分服务：</strong>占 8 个比特，只有在使用区分服务时，这个字段才起作用，在一般的情况下都不使用这个字段</p>
<p>​       <strong>总长度：</strong>占 16 个比特，首部和数据之和的长度，单位为字节，因此数据报的最大长度2^16=65535=64K字节。<strong>分片后</strong>总长度必须不超过最大传送单元 MTU</p>
<p>​       <strong>标识：</strong>占 16 个比特，一个计数器，记录数据报分片后的标识。每产生一个数据报，计数器就+1，并赋值给标识字段。等到重组数据报时就是将相同标识符的数据报重组成一个数据报</p>
<p>​       <strong>标志：</strong>占 3 个比特，目前只有前两位有意义，最低位MF (More Fragment)=1表示后面还有分片，MF=0表示最后一个分片，中间位DF (Don’t Fragment=0时才允许分片</p>
<p>​       <strong>片偏移：</strong>当前片在原分组中的相对位置</p>
<p>​       <strong>生存时间：</strong>占8个比特，TTL (Time To Live)，数据报在网络中可通过的路由器数的最大值</p>
<p>​       <strong>协议：</strong>占8个比特，此数据报携带的数据使用何种协议，以便目的主机的 IP 层将数据部分上交给哪个处理过程</p>
<p>​           <img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1586510356731-cffb3a6f-2a16-4f44-87ca-7fdaa05000d0.png" alt="image"></p>
<p>​       <strong>首部检验和：</strong>占16比特，检验数据报的首部，不检验数据部分</p>
<p>​       <strong>源地址/目的地址：</strong>占32比特，即，对应IP地址32位</p>
<p>​       <strong>可变部分：</strong>可以占1-40字节，实际上很少使用，占0字节</p>
<h2 id="3-4-IP-协议配套使用的还有三个协议，其中ARP属于网络层偏下层，ICMP和IGMP属于网络层偏上层，会封装成IP数据报发送"><a href="#3-4-IP-协议配套使用的还有三个协议，其中ARP属于网络层偏下层，ICMP和IGMP属于网络层偏上层，会封装成IP数据报发送" class="headerlink" title="3.4 IP 协议配套使用的还有三个协议，其中ARP属于网络层偏下层，ICMP和IGMP属于网络层偏上层，会封装成IP数据报发送"></a>3.4 IP 协议配套使用的还有三个协议，其中ARP属于网络层偏下层，ICMP和IGMP属于网络层偏上层，会封装成IP数据报发送</h2><p>​       <strong><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1586510356769-2726549c-5e6c-4983-a37e-9d5d0b27627b.png" alt="image"></strong></p>
<h2 id="3-5-ARP地址解析协议-Address-Resolution-Protocol-："><a href="#3-5-ARP地址解析协议-Address-Resolution-Protocol-：" class="headerlink" title="3.5 ARP地址解析协议(Address Resolution Protocol)："></a>3.5 ARP地址解析协议(Address Resolution Protocol)：</h2><p>​     3.5.1 解决同一个局域网上的主机或路由器的 IP 地址和MAC地址的映射问题，命令：arp -a，网络层的底层协议</p>
<p>​     3.5.2 不管网络层使用的是什么协议，在实际网络的<strong>链路上传送数据帧时</strong>，最终还是<strong>必须使用硬件地址</strong></p>
<p>​     3.5.3 <strong>每一个主机</strong>都设有一个 <strong>ARP 高速缓存</strong>(ARP cache)，里面有所在的<strong>局域网</strong>上的各主机和路由器的 <strong>IP 地址</strong>到<strong>硬件地址</strong>的<strong>映射表</strong></p>
<p>​     3.5.4 当主机 A 欲向本局域网上的某个主机 B 发送 IP 数据报时，就先在其 <strong>ARP 高速缓存</strong>中查看有无主机 B 的 IP 地址。如有，就可查出其对应的硬件地址，再将此硬件地址写入 MAC 帧，然后通过局域网将该 MAC 帧发往此硬件地址</p>
<p>3.5.5 ARP攻击：ARP缓存表会过期，所以监听者可以通过ARP协议获取要监听的主机的MAC地址，并且告诉其他主机自己的MAC就是被监听的主机的MAC</p>
<h2 id="3-6-ICMP网际控制报文协议-Internet-Control-Message-Protocol-："><a href="#3-6-ICMP网际控制报文协议-Internet-Control-Message-Protocol-：" class="headerlink" title="3.6 ICMP网际控制报文协议(Internet Control Message Protocol)："></a>3.6 ICMP网际控制报文协议(Internet Control Message Protocol)：</h2><p>​     3.6.1 IP 协议缺少一个<strong>辅助机制</strong>，即主机的管理和<strong>查询机制</strong>。在某些情况下，源主机需要确定另一个主机或者路由器是否是活跃的，对于不活跃的主机，就没有必要再向它发送数据报了</p>
<p>​     3.6.2 ICMP 协议有自己的一套报文格式，且<strong>ICMP 报文是放在 IP 数据报中的数据区域发送的</strong></p>
<p>​     3.6.3 <strong>Ping</strong>的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</p>
<p>​     3.6.4 <strong>Traceroute</strong>是用来查看所经过的每一跳路由，可以具体判断时延变大或者丢包的点</p>
<p>​         * 源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；</p>
<p>​       * 源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。</p>
<p>​       * 不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为<strong>数据报封装的是无法交付的 UDP</strong>，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。</p>
<p>​         * 之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</p>
<p>​       <img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1586510356807-d144ec80-ac25-437c-ad8f-d7cab7f1da96.png" alt="image"></p>
<p>​     3.6.4 <strong>ICMP的报文格式</strong></p>
<p>​       <img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1586510356840-4ea83f26-ccfd-481f-86e2-3af9552ed4ce.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<p>​       <strong>类型：</strong>占8个比特，标识ICMP报文的类型，从类型值来看ICMP报文可以分为两大类。第一类是取值为1~127的差错报文，第2类是取值128以上的信息报文</p>
<p>​       <strong>代码：</strong>占8个比特 ，标识对应ICMP报文的代码。它与类型字段一起共同标识了ICMP报文的详细类型</p>
<p>​       <strong>校验和：</strong>这是对<strong>包括ICMP报文数据部分</strong>在内的整个ICMP数据报的校验和，以检验报文在传输过程中是否出现了差错（其计算方法与IP数据报头中的校验和计算方法是一样的）</p>
<p>​     3.6.5 ICMP报文的分类</p>
<p>​       ICMP分为两类，一类是<strong>ICMP查询报文</strong>，另一类是<strong>ICMP差错报文</strong></p>
<p>​       <img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1586510356891-b7b3e05d-ecca-45c0-ac3f-3183f096fa87.png" alt="image"></p>
<h2 id="3-7-IGMP网际组管理协议-Internet-Group-Management-Protocol-："><a href="#3-7-IGMP网际组管理协议-Internet-Group-Management-Protocol-：" class="headerlink" title="3.7 IGMP网际组管理协议(Internet Group Management Protocol)："></a>3.7 IGMP网际组管理协议(Internet Group Management Protocol)：</h2><p>​     IGMP协议是让连接在本局域网上的多播路由器知道本局域网上是否有主机（严格来讲是主机上的某个进程）参加或者退出了某个多播组，下面会详细介绍</p>
<h2 id="3-8-IP地址的编码方式"><a href="#3-8-IP地址的编码方式" class="headerlink" title="3.8 IP地址的编码方式"></a>3.8 IP地址的编码方式</h2><p>​     3.8.1 IP 地址的编址方式经历了三个历史阶段：分类，子网划分，无分类，每次改进解决的问题之一都是路由表太大</p>
<p>​       <strong>分类</strong>：二级IP地址——IP 地址 ::= {<strong>&lt; 网络号 &gt;</strong>, &lt; 主机号 &gt;}</p>
<p>​         <img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1586510356928-e0998ee2-cd2f-48c9-906a-39dc548120e3.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<p>​       <strong>子网划分：</strong>IP地址 ::= {&lt;网络号&gt;, <strong>&lt;子网号&gt;</strong>, &lt;主机号&gt;}    </p>
<p>​         * 划分子网纯属一个单位内部的事情。单位对外仍然表现为没有划分子网的网络。</p>
<p>​         * 划分子网只是把 IP 地址的<strong>主机号 host-id 这部分进行再划分</strong>，而不改变 IP 地址原来的网络号 net-id。</p>
<p>​         <img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1586510356997-aaa13338-551c-442a-bf33-ce189ed3e6e6.png" alt="image"></p>
<p>​       <strong>无分类：</strong>无分类域间路由选择 <strong>CIDR</strong> (Classless Inter-Domain Routing)——IP地址 ::= {&lt;网络前缀&gt;, &lt;主机号&gt;}</p>
<p>​         * 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号对 IP 地址进行编码，<strong>网络前缀的长度可以根据需要变化</strong></p>
<p>​         * CIDR使用各种长度的“网络前缀”(network-prefix)来代替分类地址中的网络号和子网号。</p>
<p>​         * IP 地址从三级编址（使用子网掩码）又回到了两级编址</p>
<p>​         * 128.14.32.0/20 表示的地址块共有 2^12 个地址（因为斜线后面的 20 是网络前缀的位数，所以这个地址的主机号是 12 位）</p>
<p>​         * 这个地址块的起始地址是 128.14.32.0</p>
<h2 id="3-9-路由聚合-构成超网"><a href="#3-9-路由聚合-构成超网" class="headerlink" title="3.9 路由聚合/构成超网"></a>3.9 路由聚合/构成超网</h2><p>​     * 一个 CIDR 地址块可以表示很多地址，这种地址的聚合常称为路由聚合，它使得路由表中的一个项目可以表示很多个原来传统分类地址的路由</p>
<p>​     * 路由聚合也称为构成超网(supernetting)</p>
<p>​     * 前缀长度不超过 23 位的 CIDR 地址块都包含了多个 C 类地址(C类地址前缀长度是24位)</p>
<p>​     * 这些 C 类地址合起来就构成了超网</p>
<h2 id="3-10-最长前缀匹配"><a href="#3-10-最长前缀匹配" class="headerlink" title="3.10 最长前缀匹配"></a>3.10 最长前缀匹配</h2><p>​     * 使用 CIDR 时，路由表中的每个项目由“<strong>网络前缀</strong>”和“<strong>下一跳地址</strong>”组成。在查找路由表时可能会得到不止一个匹配结果</p>
<p>​     * 应当从<strong>匹配结果</strong>中选择具有<strong>最长网络前缀的路由</strong>：最长前缀匹配</p>
<p>​     * <strong>网络前缀越长</strong>，其<strong>地址块就越小</strong>，因而路由就<strong>越具体</strong></p>
<h2 id="3-11-二叉树加速查找路由表"><a href="#3-11-二叉树加速查找路由表" class="headerlink" title="3.11 二叉树加速查找路由表"></a>3.11 二叉树加速查找路由表</h2><p>​     * 比如路由表存储有5个前缀 0100,0101,011,10110,10111</p>
<p>​     * 对应的二叉树为：</p>
<p>​       <img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1586510357044-540b6cb1-d8e0-4bb9-8f7b-92c52ae23766.png" alt="image"></p>
<h2 id="3-12-路由器结构"><a href="#3-12-路由器结构" class="headerlink" title="3.12 路由器结构"></a>3.12 路由器结构</h2><p>​       * 路由器从功能上可以划分为：路由选择和分组转发</p>
<p>​       * 路由器结构</p>
<p>​         <img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1586510357122-654fa069-8a21-4605-83ff-9f3c96f6a622.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<h2 id="3-13-路由器分组转发流程"><a href="#3-13-路由器分组转发流程" class="headerlink" title="3.13 路由器分组转发流程"></a>3.13 路由器分组转发流程</h2><p>​       (1)从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N</p>
<p>​       (2)若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付</p>
<p>​       (3)若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器</p>
<p>​       (4)若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器</p>
<p>​       (5)若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器</p>
<p>​       (6)报告转发分组出错</p>
<h2 id="3-14-路由选择协议"><a href="#3-14-路由选择协议" class="headerlink" title="3.14 路由选择协议"></a>3.14 路由选择协议</h2><p>​       * <strong>基本概念：</strong></p>
<p>​         <strong>静态路由：</strong>简单开销小，不能适应网络状态变化</p>
<p>​         <strong>动态路由：</strong>复杂开销大，能适应网络状态变化</p>
<p>​       *<strong>** **自治系统</strong> AS(Autonomous System)：一个网络单元，包含多个路由器，内部可以使用多种路由协议，但是对外使用一致的路由选择策略</p>
<p>​       *<strong>** **内部网关协议 IGP</strong> (Interior Gateway Protocol)：一个自治系统内部使用的路由选择协议，如 <strong>RIP协议</strong>和<strong>OSPF 协议</strong>。</p>
<p>​       *<strong>** **外部网关协议EGP</strong> (External Gateway Protocol)：源站和目的站处在不同的自治系统中，使用的协议，如<strong>BGP</strong></p>
<p>​         注：历史原因，这里的可以认为网关和路由器是同义词(其实网关的概念更大，连接两个不同的网络即网关)</p>
<h2 id="3-15-内部网关协议——RIP协议-Routing-Information-Protocol"><a href="#3-15-内部网关协议——RIP协议-Routing-Information-Protocol" class="headerlink" title="3.15 内部网关协议——RIP协议(Routing Information Protocol)"></a>3.15 内部网关协议——RIP协议(Routing Information Protocol)</h2><p>​       * 属于<strong>动态路由协议</strong></p>
<p>​       * RIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。</p>
<p>​       * <strong>要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录</strong></p>
<p>​       * 封装成UDP数据报然后再封装成IP数据报发送</p>
<p>​       * <strong>距离向量算法：</strong></p>
<p>​         (1) 对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；</p>
<p>​         (2) 对修改后的 RIP 报文中的每一个项目，进行以下步骤：</p>
<p>​         (3) 若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；</p>
<p>​         (4) 否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；</p>
<p>​         (4.1) 否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；</p>
<p>​         (4.2) 否则什么也不做。</p>
<p>​         (5) 若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。</p>
<p>​       * <strong>RIP协议的优缺点：</strong></p>
<p>​         * RIP 协议实现简单，开销小。</p>
<p>​         * 但是 RIP 能使用的<strong>最大距离为 15</strong>，限制了网络的规模。并且当<strong>网络出现故障的消息传送到所有路由器的时间较慢</strong>。交换的路由信息是路由器中的完整路由表，因而随着<strong>网络规模的扩大</strong>，<strong>开销也就增加</strong></p>
<h2 id="3-16-内部网关协议——OSPF-Open-Shortest-Path-First"><a href="#3-16-内部网关协议——OSPF-Open-Shortest-Path-First" class="headerlink" title="3.16 内部网关协议——OSPF(Open Shortest Path First)"></a>3.16 内部网关协议——OSPF(Open Shortest Path First)</h2><p>​       * 也属于<strong>动态路由协议</strong></p>
<p>​       * 为了克服 RIP 的缺点而开发出来的，网络规模可以较大且开销较小，没有故障消息传得慢问题。</p>
<p>​       * 向本自治系统中的所有路由器发送信息，这种方法是洪泛法</p>
<p>​       * 发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示</p>
<p>​       * 只有当链路状态发生变化时，路由器才会发送信息</p>
<p>​       * 所有路由器都具有全网的拓扑结构图，并且是一致的</p>
<p>​       * 和RIP协议不同，直接封装成IP数据报发送</p>
<h2 id="3-17-外部网关协议——BGP"><a href="#3-17-外部网关协议——BGP" class="headerlink" title="3.17 外部网关协议——BGP"></a>3.17 外部网关协议——BGP</h2><p>​       * 也属于<strong>动态路由协议</strong></p>
<p>​       * 若源站和目的站处在不同的自治系统中，当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中</p>
<p>​       * AS 之间的路由选择很困难，主要是由于</p>
<p>​         * 互联网规模很大，各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量</p>
<p>​         * AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过</p>
<p>​       * BGP 只能寻找一条比较好的路由，而不是最佳路由</p>
<p>​       * BGP报文封装成TCP报文然后封装成IP数据报进行发送</p>
<p>​       * 每个 <strong>AS</strong> 都必须配置一个<strong>路由器作为BGP 发言人</strong>，通过在两个相邻 BGP 发言人之间建立 <strong>TCP 连接</strong>来交换路由信息，如图</p>
<p>​         <img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1586510357176-d463d586-4fa1-4dc8-90d6-e71922fccb8d.png" alt="image"></p>
<h2 id="3-18-网际组管理协议-IGMP和多播路由选择协议"><a href="#3-18-网际组管理协议-IGMP和多播路由选择协议" class="headerlink" title="3.18 网际组管理协议 IGMP和多播路由选择协议"></a>3.18 网际组管理协议 IGMP和多播路由选择协议</h2><p>​       * 多播可明显地减少网络中资源的消耗，如果单播的话会单播很多次很浪费</p>
<p>​       * 在局域网上进行硬件多播</p>
<p>​       * 为了使路由器知道多播组成员的信息，需要利用<strong>网际组管理协议 IGMP</strong>(Internet Group Management Protocol)</p>
<p>​       * 连接在局域网上的多播路由器还必须和因特网上的其他多播路由器协同工作，以便把<strong>多播数据报用最小代价传送给所有的组成员</strong>。这就需要使用<strong>多播路由选择协议</strong>。</p>
<p>​       * <strong>IGMP 协议</strong>是让连接在<strong>本地局域网上的多播路由器</strong>知道本局域网上是否有主机（严格讲，是<strong>主机上的某个进程</strong>）<strong>参加或退出了某个多播组</strong></p>
<p>​       * IGMP协议封装成IP数据报发送</p>
<h2 id="3-19-VPN-Virtual-Private-Network，虚拟专用网络"><a href="#3-19-VPN-Virtual-Private-Network，虚拟专用网络" class="headerlink" title="3.19 VPN(Virtual Private Network，虚拟专用网络)"></a>3.19 VPN(Virtual Private Network，虚拟专用网络)</h2><p>​       * 应对IP地址紧缺的解决方案之一，对内使用本地地址(如，192.169.0.1)，对外使用全球地址。</p>
<p>​       * 平时所说的是远程接入VPN(remote access VPN)，类似学校用来下载文献的VPN</p>
<p>​       * 如图，场所A的本地地址10.1.0.1向场所B的本地地址10.2.0.3通信的过程</p>
<p>​         <img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1586510357217-82e3b8e9-4843-4924-8a4a-bb6d1c29b43e.png" alt="image"></p>
<h2 id="3-20-NAT-Network-Address-Translation，网络地址转换"><a href="#3-20-NAT-Network-Address-Translation，网络地址转换" class="headerlink" title="3.20 NAT(Network Address Translation，网络地址转换)"></a>3.20 NAT(Network Address Translation，网络地址转换)</h2><p>​       专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将<strong>本地 IP 转换为全球 IP</strong></p>
<h1 id="4-运输层"><a href="#4-运输层" class="headerlink" title="4.运输层"></a>4.运输层</h1><h2 id="4-1-运输层协议概述"><a href="#4-1-运输层协议概述" class="headerlink" title="4.1 运输层协议概述"></a>4.1 运输层协议概述</h2><h3 id="4-1-1-进程之间的通信"><a href="#4-1-1-进程之间的通信" class="headerlink" title="4.1.1 进程之间的通信"></a>4.1.1 进程之间的通信</h3><p>​       * 运输层向它上面的应用层提供通信服务，它属于<strong>面向通信部分的最高层</strong>，同时也是<strong>用户功能中的最低层</strong></p>
<p>​       * 两个<strong>主机通信</strong>实际上就是两个主机中的<strong>应用进程通信</strong></p>
<p>​       * <strong>应用进程之间的通信</strong>又称为<strong>端到端的通信</strong>，运输层向高层用户屏蔽了下面网络核心的细节（如网络拓扑、所采用的路由选择协议等），它使应用进程看见的就是好像在两个运输层实体之间有一条端到端的逻辑通信信道</p>
<p>​       * 运输层的一个很重要的功能就是<strong>复用</strong>和<strong>分用</strong>。应用层<strong>不同进程的报文</strong>通过<strong>不同的端口</strong>向下交到运输层，再往下就<strong>共用网络层</strong>提供的服务</p>
<p>​       * 运输层协议和网络层协议的主要区别：</p>
<p>​         <img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1586510357269-5f562fc3-7620-43d9-9295-62d7c6784596.png" alt="image"></p>
<h3 id="4-1-2-运输层的两个主要协议"><a href="#4-1-2-运输层的两个主要协议" class="headerlink" title="4.1.2 运输层的两个主要协议"></a>4.1.2 运输层的两个主要协议</h3><p>​       (1) <strong>用户数据报协议 UDP(User Datagram Protocol)</strong></p>
<p>​         * UDP 传送的<strong>数据单位</strong>协议是 <strong>UDP 报文</strong>或<strong>用户数据报</strong></p>
<p>​         * 这种<strong>逻辑通信信道</strong>是一条<strong>不可靠信道</strong></p>
<p>​       (2) <strong>传输控制协议 TCP(Transmission Control Protocol)</strong></p>
<p>​         * TCP 传送的<strong>数据单位</strong>协议是 <strong>TCP 报文段(segment)</strong></p>
<p>​         * 尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种<strong>逻辑通信信道</strong>就相当于一条<strong>全双工的可靠信道</strong></p>
<p>​         * 命令netstat -n</p>
<h3 id="4-1-3-运输层的端口"><a href="#4-1-3-运输层的端口" class="headerlink" title="4.1.3 运输层的端口"></a>4.1.3 运输层的端口</h3><p>​       * 端口用一个 16 位端口号进行标志(TCP报文中的16位端口号)</p>
<p>​       * 端口号只具有本地意义</p>
<p>​       * 软件端口与硬件端口</p>
<p>​           * 在协议栈层间的抽象的协议端口是软件端口</p>
<p>​           * 路由器或交换机上的端口是硬件端口</p>
<p>​       * 三类端口</p>
<p>​         * 熟知端口，数值一般为 0~1023(2^10)</p>
<p>​         * 登记端口号，数值为1024~49151(48*2^10)，为没有熟知端口号的应用程序使用的。这个范围的端口号必须在 IANA 登记，以防止重复</p>
<p>​         * 客户端口号或短暂端口号，数值为49152~65535(2^16)，留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用</p>
<h2 id="4-2-用户数据报协议-UDP"><a href="#4-2-用户数据报协议-UDP" class="headerlink" title="4.2 用户数据报协议 UDP"></a>4.2 用户数据报协议 UDP</h2><h3 id="4-2-1-UDP-概述"><a href="#4-2-1-UDP-概述" class="headerlink" title="4.2.1 UDP 概述"></a>4.2.1 UDP 概述</h3><p>​       <strong>用户数据报协议 UDP(User Datagram Protocol):**在 IP 的数据报服务之上增加了很少一点的功能，即</strong>端口功能<strong>和</strong>差错检测功能**</p>
<p>​       *** 无连接的<strong>，</strong>尽最大可能交付<strong>，</strong>没有拥塞控制**</p>
<p>​       *** 面向报文(**对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部)</p>
<p>​       * 支持<strong>一对一</strong>、<strong>一对多</strong>、<strong>多对一</strong>和<strong>多对多</strong>的交互通信</p>
<p>​       * UDP 的首部开销小，只有 8 个字节</p>
<p>​       * 一个数据包就能完成通信</p>
<p>​       * (王者荣耀就是用的UDP)</p>
<h3 id="4-2-2-UDP-的首部格式"><a href="#4-2-2-UDP-的首部格式" class="headerlink" title="4.2.2 UDP 的首部格式"></a>4.2.2 UDP 的首部格式</h3><p>​       计算检验和时，<strong>临时</strong>把”**伪首部”**和 UDP 用户数据报连接在一起。伪首部仅仅是为了计算检验和。</p>
<p>​       <img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1586510357300-29d2f2c7-7ab1-4068-a1f7-bf407653c233.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<h2 id="4-3-传输控制协议-TCP-概述"><a href="#4-3-传输控制协议-TCP-概述" class="headerlink" title="4.3 传输控制协议 TCP 概述"></a>4.3 传输控制协议 TCP 概述</h2><p>​     * TCP(Transmission Control Protocol)是<strong>面向连接</strong>的，每一条 TCP 连接只能有两个端点</p>
<p>​     * 提供<strong>可靠交付</strong>，有<strong>流量控制</strong>，<strong>拥塞控制</strong></p>
<p>​     * 提供<strong>全双工通信</strong>，<strong>面向字节流</strong>(把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块)</p>
<p>​     * 每一条 TCP 连接只能是点对点的(一对一)，<strong>不提供广播或多播服务</strong></p>
<h3 id="4-3-1-TCP面向流示意图"><a href="#4-3-1-TCP面向流示意图" class="headerlink" title="4.3.1 TCP面向流示意图"></a>4.3.1 TCP面向流示意图</h3><p>​       <strong><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1586510357354-2cb3000b-3b36-41aa-a81a-63a7cd82805c.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></strong></p>
<p>​       <strong>注意：</strong></p>
<p>​         * TCP 对应用进程一次把多长的报文发送到TCP 的缓存中是不关心的</p>
<p>​         * TCP 根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节</p>
<p>​         * TCP 可以把太长的数据块划分短一些再传送。TCP 也可等待积累有足够多的字节后再构成报文段发送出去</p>
<h3 id="4-3-2-TCP连接"><a href="#4-3-2-TCP连接" class="headerlink" title="4.3.2 TCP连接"></a>4.3.2 TCP连接</h3><p>​       * TCP 连接的端点叫做套接字(socket)：套接字 socket = (IP地址: 端口号)</p>
<p>​       * 每一条 TCP 连接唯一地被通信两端的两个端点（即两个套接字）所确定</p>
<h3 id="4-3-3-TCP-报文段的首部格式"><a href="#4-3-3-TCP-报文段的首部格式" class="headerlink" title="4.3.3 TCP 报文段的首部格式"></a>4.3.3 TCP 报文段的首部格式</h3><p>​       <img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1586510357408-b509aaaf-ff39-4096-a9b0-116751b46010.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<p>​       <strong>源端口/目的端口：</strong>端口是运输层与应用层的服务接口，运输层的复用和分用功能都要通过端口才能实现</p>
<p>​       <strong>序号：**</strong>用于对发送端字节流进行编号，本TCP报文数据部分首字节在整个文件中的序号**</p>
<p>​         * 例如序号为 301，表示TCP数据部分第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</p>
<p>​       <strong>确认号 ack：**</strong>期望收到的下一个报文段的序号**</p>
<p>* 例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</p>
<p>​         * (<strong>序号</strong>是<strong>本TCP报文</strong>数据部分的首字节序号，<strong>确认号</strong>是成功接收<strong>别人TCP报文</strong>，并期待接收的下一个TCP报文中数据部分的首字节的序号)</p>
<p>* 因为不能控制TCP报文到达的顺序，所以使用序号+确认号实现将TCP报文恢复成文件时的有序</p>
<p>​       <strong>数据偏移：</strong>指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度</p>
<p>​       <strong>优先发送</strong> <strong>URG：</strong>(urgent) 设置后发送端优先发送，而不是在缓存中排队</p>
<p>​       <strong>确认 ACK：</strong>(Acknowledge) 当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</p>
<p>​         * ack指确认号，ACK指一个比特的标志位</p>
<p>​       <strong>优先读取 PSH：</strong>设置后接收端优先读取，而不是在缓存中排队</p>
<p>​       <strong>重置</strong> <strong>RST：</strong>(reset) 设置意味着TCP会话出现严重错误，必须释放和重新连接</p>
<p>​       <strong>同步 SYN：</strong>在连接建立时用来同步序号。<strong>当 SYN=1,ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中SYN=1,ACK=1</strong></p>
<p>​       <strong>终止 FIN：</strong>用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</p>
<p>​       <strong>窗口 ：</strong>窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的</p>
<p>​       <strong>校验和：</strong>检验范围包括首部和数据，和UDP类似，需要在TCP报文段前加上12字节的临时伪首部</p>
<p>​       <strong>紧急指针：</strong>本报文段中紧急数据在数据部分中结束的位置(URG=1时才有效)，数据部分中紧急数据放在前面</p>
<p>​       <strong>选项：</strong>例如MSS(Maximum Segment Size)，告诉TCP对象我的缓存能存数据字段的字节数最大值</p>
<p>​         * TCP三次握手时可以互相确定对象的窗口大小和MSS大小</p>
<h3 id="4-3-4-各层的数据报的最大负载"><a href="#4-3-4-各层的数据报的最大负载" class="headerlink" title="4.3.4 各层的数据报的最大负载"></a>4.3.4 各层的数据报的最大负载</h3><p>​       运输层TCP：TCP数据报用16比特表示数据部分长度，最大长度2^16=65535=64K字节，首部长度20字节，所以TCP报文最大负载65515</p>
<p>​       网络层：IP数据报也用16比特表示数据部分长度，首部长度也是20字节，所以TCP报文段最大负载为65515-20=65495字节</p>
<h3 id="4-3-5-可靠传输的工作原理"><a href="#4-3-5-可靠传输的工作原理" class="headerlink" title="4.3.5 可靠传输的工作原理"></a>4.3.5 可靠传输的工作原理</h3><p>​       * TCP 连接的每一端设有窗口——发送窗口/接收窗口，窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小</p>
<p>​       * <strong>TCP 的可靠传输机制用字节的序号进行控制。TCP 所有的确认都是基于序号而不是基于报文段</strong></p>
<p>​       * TCP 两端的四个窗口经常处于动态变化之中</p>
<p>​       * TCP连接的往返时间 RTT 也不是固定不变的，所以重传时间需要使用合适的算法确定</p>
<p>​       * <strong>停止等待协议</strong></p>
<p>​         * 这种可靠传输协议常称为自动重传请求ARQ(Automatic Repeat reQuest)</p>
<p>​         * 如果接收端接收到重复的M1则使用重传的M1</p>
<p>​         * 如果发送端已经接受到接收端的确认M1，即使后面再次接收到确认M1也不管</p>
<p>​         <img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1586510357452-e66e9f24-9702-44ca-9e09-ff20467705ed.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<p>​       * <strong>连续 ARQ 协议</strong></p>
<p>​         * ARQ协议的缺点是信道利用率太低，连续ARQ协议中发送端可以连续发送分组，不必每发送一个就等待确认</p>
<p>​         * 下图窗口内的所有数据都一个连续发送出去，并且会根据收到的确认信号滑动窗口</p>
<p>​         * 如果发送端接收到分组3的确认信号则发送窗口左边可以划到分组4，不需要接收分组1,2的确认信号</p>
<p>​         * 如果分组3丢失了，分组4,5成功接收了，发送端仍然需要重传分组3,4,5</p>
<p>​           <img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1586510357513-558dd4ae-3c61-48d4-8b9a-f9730c00775e.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<h3 id="4-3-6-可靠通信的具体实现"><a href="#4-3-6-可靠通信的具体实现" class="headerlink" title="4.3.6 可靠通信的具体实现"></a>4.3.6 可靠通信的具体实现</h3><p>​       <img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1586510357552-c816e1a5-9d98-410d-94da-fb5d1f1d974f.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<p>​       <img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1586510357588-b3d2924b-d417-4c24-a5f6-656a0ee20269.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<p>​       <img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1586510357641-a1d8d748-6d8d-4c53-8aa8-8c6045814110.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<p>​       <img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1586510357706-2329bc6f-de70-43ee-99a8-5fe1eebc6007.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<h3 id="4-3-7-超时重传时间的选择"><a href="#4-3-7-超时重传时间的选择" class="headerlink" title="4.3.7 超时重传时间的选择"></a>4.3.7 超时重传时间的选择</h3><p>​       * TCP 每发送一个报文段，就对这个报文段设置一次计时器。只要计时器设置的重传时间到但还没有收到确认，就要重传这一报文段</p>
<p>​       * 一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：</p>
<p>​         <img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1586510357746-f84fde79-9caf-4ada-8121-b2e6f0dfe5bd.png" alt="image">  其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响</p>
<h3 id="4-3-8-TCP的流量控制"><a href="#4-3-8-TCP的流量控制" class="headerlink" title="4.3.8 TCP的流量控制"></a>4.3.8 TCP的流量控制</h3><p>​       * <strong>流量控制是为了控制发送方发送速率，保证接收方来得及接收</strong></p>
<p>​       * 利用滑动窗口实现流量控制</p>
<p>​       * <strong>接收方发送的确认报文中窗口字段可以用来控制发送方窗口大小</strong>，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据</p>
<h3 id="4-3-9-TCP-的拥塞控制"><a href="#4-3-9-TCP-的拥塞控制" class="headerlink" title="4.3.9 TCP 的拥塞控制"></a>4.3.9 TCP 的拥塞控制</h3><p>​       * <strong>流量控制是接收端，拥塞控制是发送端</strong></p>
<p>​       * 拥塞控制的作用：</p>
<p>​         <img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1586510357797-6eb020c8-1c2c-4036-b61b-01fc0a307429.png" alt="image"></p>
<p>​       * <strong>TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复</strong></p>
<p>​       * 发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量</p>
<p>​       * 拥塞窗口与发送方窗口的区别：实际窗口大小=min(拥塞窗口，发送窗口)，即实际窗口大小可能小于拥塞窗口</p>
<p>​       * 为了便于讨论，做如下假设：</p>
<p>​         * 接收方有足够大的接收缓存，因此不会发生流量控制</p>
<p>​         * 虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段</p>
<h3 id="4-3-10-拥塞控制——慢开始与拥塞避免"><a href="#4-3-10-拥塞控制——慢开始与拥塞避免" class="headerlink" title="4.3.10 拥塞控制——慢开始与拥塞避免"></a>4.3.10 拥塞控制——慢开始与拥塞避免</h3><p>​       * 拥塞窗口(cwnd)从1开始，没有达到ssthresh前指数增长，达到ssthresh后线性增长</p>
<p>​       * 一旦发生拥塞，ssthreash设置为拥塞时拥塞窗口大小/2，并且窗口回到1，重新慢开始</p>
<p>​         <img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1586510357838-ffc17b4e-4ace-46c2-9955-f8b0e9f9d082.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<h3 id="4-3-11-拥塞控制——快重传"><a href="#4-3-11-拥塞控制——快重传" class="headerlink" title="4.3.11 拥塞控制——快重传"></a>4.3.11 拥塞控制——快重传</h3><p>​       * <strong>快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认，这样做可以让发送方及早知道有报文段没有到达接收方（对比的是超时重传）</strong></p>
<p>​       * 例如已经接收到 M1 和 M2，此时收到 M4，应当发送M2的确认</p>
<p>​       * 发送方只要连续收到三个重复确认就应当立即重传对方尚未收到的报文段，例如收到M1,M2,然后收到M4,M5,M6</p>
<p>​         <img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1586510357879-0666e2dc-1cda-412b-98a0-0c6f800c2741.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<h3 id="4-3-12-拥塞控制——快恢复"><a href="#4-3-12-拥塞控制——快恢复" class="headerlink" title="4.3.12 拥塞控制——快恢复"></a>4.3.12 拥塞控制——快恢复</h3><p>​       * <strong>执行时机：</strong>当发送端收到连续<strong>三个重复的确认</strong>时(<strong>快重传</strong>)</p>
<p>​       * <strong>执行操作：</strong>执行“乘法减小”算法，把慢开始门限 ssthresh 减半，并且拥塞窗口不设置为1而是从减半后的ssthresh开始线性增加</p>
<p>​         <img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1586510357923-a6662776-6a34-4f07-9297-0ae0d0b252f2.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<h3 id="4-3-13-TCP-的运输连接管理"><a href="#4-3-13-TCP-的运输连接管理" class="headerlink" title="4.3.13 TCP 的运输连接管理"></a>4.3.13 TCP 的运输连接管理</h3><p>​       * 运输连接就有三个阶段，即：<strong>连接建立</strong>、<strong>数据传送</strong>和<strong>连接释放</strong></p>
<p>​       * 连接建立过程中要解决以下三个问题：</p>
<p>​         * 要使每一方能够确知对方的存在。</p>
<p>​         * 要允许双方协商一些参数（如最大报文段长度，最大窗口大小，服务质量等）。</p>
<p>​         * 能够对运输实体资源（如缓存大小，连接表中的项目等）进行分配。</p>
<p>​       * <strong>TCP连接建立的三次握手</strong></p>
<p>​         假设 A 为客户端，B 为服务器端。</p>
<p>​         (1) 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求，处于LISTEN状态</p>
<p>​         (2) A 向 B 发送连接请求报文，SYN=1，ACK=0，A随机选择初始的序号 x，然后客户端处于SYN-SENT状态</p>
<p>​         (3) B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时随机选择初始的序号 y，然后服务端处于SYN-RCVD状态</p>
<p>​         (4) A 收到 B 的连接确认报文后，向 B 发出确认，确认号为 y+1，序号为 x+1，然后客户端处于ESTABLISHED状态（没有SYN=1）</p>
<p>​         (5) B 收到 A 的确认后，连接建立</p>
<p>​         (6+) 三次握手的时候可能还会交换窗口大小和缓存大小</p>
<p>​         <img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1586510357957-ef15ff88-14b8-44fd-8792-5ecec5803697.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<p>​       * <strong>三次握手的原因</strong></p>
<p>​         * 第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接</p>
<p>​         * 客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接</p>
<p>​         * 三次握手后，可以保证两端发送正常和接收正常</p>
<p>​       * <strong>TCP 的连接释放的四次挥手</strong></p>
<p>​         (1) A发送连接释放请求FIN=1，seq=u(并不重要)</p>
<p>​         (2) B收到后发送确定信号，ACK=1,seq=v，ack=u+1，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</p>
<p>​         (3) 当 B 不再需要连接时，发送连接释放报文，FIN=1</p>
<p>​         (4) A 收到后发出确认，进入 TIME-WAIT 状态，等待 2*MSL(最大报文存活时间)后释放连接（客户端<strong>主动关闭连接的，才有 TIME_WAIT 状态</strong>）</p>
<p>​         (5) B 收到 A 的确认后释放连接</p>
<p>​         <img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1586510358006-e0aa6605-811e-4654-a8be-2d2818f56736.png" alt="image"></p>
<p>​         <img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1586510358055-e5844377-80c9-45de-8e04-75f23f6e0840.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<p>​       * <strong>四次挥手的原因</strong></p>
<p>​         *** 客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文**</p>
<p>​         <strong>* TIME-WAIT状态等待2*MSL原因：</strong></p>
<p>​           *** 确保最后一个确认报文能够到达。**<strong>如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生</strong></p>
<p>​           * <strong>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文</strong></p>
<h3 id="4-3-14-TCP-的有限状态机"><a href="#4-3-14-TCP-的有限状态机" class="headerlink" title="4.3.14 TCP 的有限状态机"></a>4.3.14 TCP 的有限状态机</h3><p>​         粗实线箭头表示对客户进程的正常变迁。</p>
<p>​         粗虚线箭头表示对服务器进程的正常变迁。</p>
<p>​         细线箭头表示异常变迁</p>
<p>​           <img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1586510358093-f57b879e-bb3b-4a3d-a848-c4805195e36c.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<h2 id="4-4-TCP面试题"><a href="#4-4-TCP面试题" class="headerlink" title="4.4 TCP面试题"></a>4.4 TCP面试题</h2><h3 id="三次握手时可以携带数据吗？"><a href="#三次握手时可以携带数据吗？" class="headerlink" title="三次握手时可以携带数据吗？"></a>三次握手时可以携带数据吗？</h3><ul>
<li><p>第三次握手是可以携带数据的，前两次握手是不可以携带数据的</p>
</li>
<li><ul>
<li>RFC793文档里带有SYN标志的过程包是不可以携带数据的，也就是说三次握手的前两次是不可以携带数据的</li>
<li>第一次握手如果可以携带数据：可能会有人每次都在第一次握手中的SYN报文中放入大量数据。而且频繁重复发SYN报文</li>
<li>第三次握手时客户端知道服务端可以正常处理请求，所以可以携带数据了（此时服务端不知道自己的请求是否可以到达客户端）</li>
</ul>
</li>
</ul>
<h3 id="为什么是三次握手？不是两次、四次？"><a href="#为什么是三次握手？不是两次、四次？" class="headerlink" title="为什么是三次握手？不是两次、四次？"></a>为什么是三次握手？不是两次、四次？</h3><ul>
<li><p>三次握手才可以防止历史连接的初始化，防止建立无用连接导致资源浪费（主要原因）</p>
</li>
<li><ul>
<li><strong>三次握手的首要原因是为了防止旧的重复连接初始化造成混乱</strong></li>
<li>客户端连续发送多次 SYN 建立连接的报文，在网络拥堵等情况下：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>一个「旧 SVN 报文」比「最新的 SYN 」 报文早到达了服务端</li>
<li>那么此时服务端就会回一个 <code>SYN + ACK</code> 报文给客户端</li>
<li>客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送 <code>RST</code> 报文给服务端，表示中止这一次连接</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>如果是两次握手连接，就不能判断当前连接是否是历史连接，三次握手则可以在客户端（发送方）准备发送第三次报文时，客户端因有足够的上下文来判断当前连接是否是历史连接</strong></li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1596430509677-cd04876d-16ec-471e-98fa-4b2c22ad80a6.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image.png"></li>
</ul>
</li>
<li><p>三次握手才可以同步双方的初始序列号</p>
</li>
<li><ul>
<li>TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>接收方可以去除重复的数据</li>
<li>接收方可以根据数据包的序列号按序接收</li>
<li>可以标识发送出去的数据包中， 哪些是已经被对方收到的</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>四次握手其实也能够可靠的同步双方的初始化序号，但由于<strong>第二步和第三步可以优化成一步</strong>，所以就成了「三次握手」</li>
<li>而<strong>两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收</strong></li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1596430709061-87f2ad0a-97a6-4d45-9251-5706a78d4b0a.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image.png"></li>
</ul>
</li>
</ul>
<h3 id="既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？"><a href="#既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？" class="headerlink" title="既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？"></a>既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？</h3><ul>
<li><p>两种分割方式：</p>
</li>
<li><ul>
<li><code>MTU</code>：一个网络包的最大长度，以太网中一般为1500字节</li>
<li><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度</li>
</ul>
</li>
<li><p>如果在 TCP 的整个报文（头部 + 数据）交给 IP 层进行分片，效率可能会很差？</p>
</li>
<li><ul>
<li>IP层会将超过一个MTU大小的数据进行分片</li>
<li>IP数据包被分片发送后，由目标主机的IP层重新组装，再交给上一层TCP传输层</li>
<li>正常是没问题的，但是<strong>如果一个IP分片丢失，整个IP报文的所有分片都得重传</strong></li>
<li>而且<strong>IP层没有超时重传机制</strong>，对于接收方来说，当发现TCP报文某分片丢失时，不会响应ACK给发送方，发送方在TCP超时后再重发「整个 TCP 报文（头部 + 数据）」</li>
<li>所以发生分片丢失时，效率低下</li>
</ul>
</li>
<li><p>所以在建立TCP连接时通常要协商双方的MSS值</p>
</li>
<li><ul>
<li><strong>TCP层发送数据时，发现数据超过MSS，就会在TCP层对其分片，这样IP层就不会大于MTU，自然不用IP层进行分片了</strong></li>
<li>如果<strong>TCP分片丢失后，进行重发时也是以MSS为单位的</strong>，不用重传所有分片，大大增加了重传效率</li>
</ul>
</li>
</ul>
<h3 id="为什么挥手需要四次？"><a href="#为什么挥手需要四次？" class="headerlink" title="为什么挥手需要四次？"></a>为什么挥手需要四次？</h3><ul>
<li>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，<strong>仅仅表示客户端不再发送数据了但是还能接收数据</strong></li>
<li>服务器收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，而<strong>服务端可能还有数据需要处理和发送</strong>，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接，所以服务端的 <code>ACK</code> 和 <code>FIN</code> 一般都会分开发送，从而比三次握手导致多了一次</li>
</ul>
<h3 id="为什么需要-TIME-WAIT-状态，且超过2MSL？"><a href="#为什么需要-TIME-WAIT-状态，且超过2MSL？" class="headerlink" title="为什么需要 TIME_WAIT 状态，且超过2MSL？"></a>为什么需要 TIME_WAIT 状态，且超过2MSL？</h3><ul>
<li><p>主动发起关闭连接的一方，才会有 TIME-WAIT 状态</p>
</li>
<li><p>TIME-WAIT 作用：<strong>等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭</strong></p>
</li>
<li><p>原因：</p>
</li>
<li><ul>
<li>\1. 防止关闭后又建立的新连接接收到旧连接的数据包</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>假设TIME_WAIT等待过短，那么被复用的端口可能会建立新的TCP连接</li>
<li>此时旧的连接在四次握手前可能有一个旧的数据包刚刚到达（图中SEQ=301）</li>
<li><strong>这样新的连接就会处理旧的服务端数据包，产生数据错乱等严重问题</strong></li>
<li>经过 <code>2MSL</code> 这个时间，<strong>足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的</strong></li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1596433592256-38862c6d-718c-46c2-896e-386b7ad9cbb5.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image.png"></li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>2.<strong>等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>如果服务端发送了FIN后，没有接收到客户端的ACK报文，则会超时重传再次发送FIN</li>
<li>所以需要客户端等待2MSL，确保服务端接收到了ACK报文</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h3><ul>
<li><p>TCP 有一个机制是保活机制</p>
</li>
<li><ul>
<li>在定义的时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用</li>
<li>每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少</li>
<li>如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序</li>
</ul>
</li>
</ul>
<h1 id="5-应用层"><a href="#5-应用层" class="headerlink" title="5.应用层"></a>5.应用层</h1><h2 id="5-1-域名系统-DNS-Domain-Name-System"><a href="#5-1-域名系统-DNS-Domain-Name-System" class="headerlink" title="5.1 域名系统 DNS (Domain Name System)"></a>5.1 域名系统 DNS (Domain Name System)</h2><p>​     * DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据</p>
<p>​     * <strong>因特网的域名结构</strong></p>
<p>​       * 域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名</p>
<p>​         <img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1586510358147-bee25ef5-962b-48d3-bd61-008218609fbb.png" alt="image"></p>
<h2 id="5-2-文件传送协议-FTP-File-Transfer-Protocol"><a href="#5-2-文件传送协议-FTP-File-Transfer-Protocol" class="headerlink" title="5.2 文件传送协议 FTP (File Transfer Protocol)"></a>5.2 文件传送协议 FTP (File Transfer Protocol)</h2><p>​     * FTP 屏蔽了各计算机系统的细节，因而适合于在异构网络中任意计算机之间传送文件</p>
<p>​     * 一个 FTP 服务器进程可同时为多个客户进程提供服务。FTP 的服务器进程由两大部分组成：一个主进程，负责接受新的请求；另外有若干个从属进程，负责处理单个请求</p>
<p>​     * <strong>FTP 的基本工作原理</strong></p>
<p>​       * FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件</p>
<p>​       * <strong>控制连接：</strong>服务器打开端口 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器应答</p>
<p>​       * <strong>数据连接：</strong>用来传送一个文件数据。</p>
<p>​     * 根据数据连接是否是服务器端主动建立，FTP 有<strong>主动</strong>和<strong>被动两种模式</strong>：</p>
<p>​      * <strong>主动模式(**</strong>PORT****)**：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端端口号随机，但是必须大于1024，即，服务器端20端口</p>
<p>主动连接客户端指定的随机端口</p>
<p>​      * <strong>被动模式(**</strong>PASV****)**：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端随机选择大于1024的端口号。</p>
<p>​      * 主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。</p>
<h2 id="5-3-超文本传送协议-HTTP"><a href="#5-3-超文本传送协议-HTTP" class="headerlink" title="5.3 超文本传送协议 HTTP"></a>5.3 超文本传送协议 HTTP</h2><ul>
<li><p>HTTP 1.0 协议是<strong>无状态</strong>的(stateless)</p>
</li>
<li><ul>
<li>协议对客户端没有状态存储，对事物处理没有“记忆”能力，比如访问一个网站需要反复进行登录操作</li>
<li>可以使用Cookie解决无状态问题</li>
</ul>
</li>
<li><p>HTTP 1.0 协议是<strong>无连接</strong>的</p>
</li>
<li><ul>
<li><strong>HTTP/1.1之前，由于无状态特点，每次请求需要通过TCP三次握手四次挥手，和服务器重新建立连接</strong></li>
<li>比如某个客户机在短时间多次请求同一个资源，服务器并不能区别是否已经响应过用户的请求，所以每次需要重新响应请求，需要耗费不必要的时间和流量</li>
<li>HTTP 1.1 持久连接（HTTP keep-alive）可以解决无连接问题，只要任意一端没有明确提出断开连接，则保持TCP连接状态，在请求首部字段中的Connection: keep-alive即为表明使用了持久连接</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>版本</th>
<th>产生时间</th>
<th>内容</th>
<th>发展现状</th>
</tr>
</thead>
<tbody><tr>
<td>HTTP/0.9</td>
<td>1991年</td>
<td>不涉及数据包传输，规定客户端和服务器之间通信格式，只能GET请求</td>
<td>没有作为正式的标准</td>
</tr>
<tr>
<td>HTTP/1.0</td>
<td>1996年</td>
<td>传输内容格式不限制，增加PUT、PATCH、HEAD、 OPTIONS、DELETE命令</td>
<td>正式作为标准</td>
</tr>
<tr>
<td>HTTP/1.1</td>
<td>1997年</td>
<td>持久连接(长连接)、节约带宽、HOST域、管道机制、分块传输编码</td>
<td>2015年前使用最广泛</td>
</tr>
<tr>
<td>HTTP/2</td>
<td>2015年</td>
<td>多路复用、服务器推送、头信息压缩、二进制协议等</td>
<td>逐渐覆盖市场</td>
</tr>
</tbody></table>
<h2 id="5-4-HTTP-有两类报文："><a href="#5-4-HTTP-有两类报文：" class="headerlink" title="5.4 HTTP 有两类报文："></a>5.4 HTTP 有两类报文：</h2><p>​     * <strong>请求报文</strong>——从客户向服务器发送请求报文。</p>
<p>​     * <strong>响应报文</strong>——从服务器到客户的回答。</p>
<p>​     * <strong>请求报文结构：</strong></p>
<p>​       * 方法：GET,POST,OPTION,PUT,DELETE</p>
<p>​       * URL：请求资源的URL</p>
<p>​       * 版本：HTTP的版本</p>
<p>​       <img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1586510358195-593c6911-3204-4bc3-8816-64ffe84cd66a.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<p>​     * <strong>响应报文结构：</strong></p>
<p>​       * 版本：HTTP的版本</p>
<p>​       * 状态码：</p>
<p>​         * 1xx：表示请求收到了或正在进行处理</p>
<p>​         * 2xx：成功</p>
<p>​         * 3xx：重定向   </p>
<p>​         * 4xx：请求中有语法错误</p>
<p>​         * 5xx：服务器出错</p>
<p>​       <img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1586510358232-3c120c8c-9726-4af5-93de-c16a18cca955.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<h2 id="5-5-HTTP-1-1-协议"><a href="#5-5-HTTP-1-1-协议" class="headerlink" title="5.5 HTTP/1.1 协议"></a>5.5 HTTP/1.1 协议</h2><ul>
<li><p>HTTP1.1最大的特点：使用<strong>持久化连接</strong></p>
</li>
<li><ul>
<li>服务器在发送响应后仍保持连接一段时间，使同一个客户（浏览器）和该服务器可以继续在这条连接上传送后续的 HTTP 请求报文和响应报文</li>
</ul>
</li>
<li><p>HTTP 1.1提出了管线化(pipelining)理论，客户端可以同时发出多个HTTP请求，而不用一个个等待响应后再请求</p>
</li>
<li><ul>
<li>但是大部门浏览器都默认关闭该特性，所以使用HTTP 1.1协议的应用，都有可能开多个TCP连接</li>
</ul>
</li>
</ul>
<h2 id="5-6-HTTP-2-0-协议"><a href="#5-6-HTTP-2-0-协议" class="headerlink" title="5.6 HTTP/2.0 协议"></a>5.6 HTTP/2.0 协议</h2><ul>
<li><p>HTTP 2.0最重要的特性：支持<strong>多路复用</strong>(Multiplexing)</p>
</li>
<li><ul>
<li><strong>实现了管线化，可以不等待响应，直接发送下一个请求</strong></li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1596454844234-db42726b-f63b-49c6-9b8e-31655c203cb2.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image.png"></li>
</ul>
</li>
<li><p>HTTP 2.0性能增强核心在于：二进制分帧层</p>
</li>
<li><ul>
<li>HTTP 2.0 在应用层和传输层(TCP or UDP)之间增加一个二进制分帧层</li>
<li>在二进制分帧层中， HTTP/2 会将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码</li>
<li>HTTP1.x 的首部信息会被封装到 HEADER frame，而相应的 Request Body 则封装到 DATA frame里面</li>
<li>HTTP/2 通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流</li>
<li><strong>过去由于慢启动+不同资源使用不同连接，导致性能优化的关键在于低延迟而不是高带宽</strong></li>
<li><strong>HTTP 2.0让所有数据流共用同一个连接，可以有效地使用TCP连接，让高带宽也服务于HTTP的性能提升</strong></li>
</ul>
</li>
<li><p>HTTP 2.0 二进制帧和HTTP 1.X格式对比</p>
</li>
<li><ul>
<li>length定义了整个frame的开始到结束</li>
<li>type定义frame的类型（一共10种）</li>
<li>flags用bit位定义一些重要的参数</li>
<li>stream id用作流控制</li>
<li>payload就是request的正文</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1596456722108-59065606-b0ac-40ea-b4dc-49ddd366cc3c.png" alt="image.png"></li>
</ul>
</li>
<li><p>HTTP 2.0 二进制帧和HTTP1.X语义的关系</p>
</li>
<li><ul>
<li>HTTP 2.0没有改变HTTP1.X的语义，只是把原来http1.x的header和body部分用frame重新封装了一层而已</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1596456000551-005768b0-e67b-4f7a-8b34-41ccd89287da.png" alt="image.png"></li>
</ul>
</li>
</ul>
<h2 id="5-7-浏览器输入URL发生了什么"><a href="#5-7-浏览器输入URL发生了什么" class="headerlink" title="5.7 浏览器输入URL发生了什么"></a>5.7 浏览器输入URL发生了什么</h2><ol>
<li>浏览器分析URL是否合法</li>
<li>游览器检查是否有缓存（游览器缓存-系统缓存-路由器缓存），如果有，直接显示。如果没有，跳到第三步</li>
<li>浏览器向 DNS 请求解析 <a href="http://www.tsinghua.edu.cn/">www.tsinghua.edu.cn</a> 的 IP 地址</li>
<li>域名系统 DNS 解析出清华大学服务器的 IP 地址</li>
<li>浏览器向服务器发起tcp链接，与浏览器经历tcp三次握手</li>
<li>握手成功后，游览器向服务器发送http请求，请求数据包，浏览器发出取文件命令：GET /yhn/index.html</li>
<li>服务器给出响应，把文件 index.html 发给浏览器</li>
<li>浏览器收到http响应</li>
<li>TCP 连接释放</li>
<li>浏览器显示“清华大学院系设置”文件 index.htm 中的所有文本</li>
</ol>
<h2 id="5-8-数字签名"><a href="#5-8-数字签名" class="headerlink" title="5.8 数字签名"></a>5.8 数字签名</h2><ul>
<li><p>数字签名是一种用于验证消息的真实性和完整性的技术，验证内容是否被篡改，确定内容是谁生成的</p>
</li>
<li><p>数字签名步骤：</p>
</li>
<li><ul>
<li>使用哈希算法（MD5,SHA-1）创建原文本的摘要（digest）</li>
<li>使用发送者的<strong>私钥对摘要进行加密</strong></li>
<li>将加密后的摘要附加到原消息后，发送给接收者</li>
<li>接收者在原消息上也以同样的方法创建第二个摘要，如果两个摘要相同则认为消息没有被篡改</li>
</ul>
</li>
<li><p>生成签名</p>
</li>
<li><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1596460205990-9014f4e9-5972-4407-88c4-364fb5b8efba.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image.png"></li>
</ul>
</li>
<li><p>验证签名</p>
</li>
<li><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1596460228809-76b81d8a-e8da-467a-b7d4-4cc38c87ae5a.png" alt="image.png"></li>
</ul>
</li>
<li><p><strong>细节：对摘要进行加密使用的是发送方的私钥，而私钥是自己才有的，这就是唯一性的证明</strong></p>
</li>
<li><p>数字签名是常规的非对称加密的逆应用，在数字签名中，使用私钥加密，使用公钥解密</p>
</li>
<li><p>数字签名的特点是只有自己才可以签名（使用私钥），但是大家都可以验证签名</p>
</li>
</ul>
<h2 id="5-9-数字证书"><a href="#5-9-数字证书" class="headerlink" title="5.9 数字证书"></a>5.9 数字证书</h2><ul>
<li><p>为了保证公钥的安全传输，不被中间人攻击，使用数字证书</p>
</li>
<li><p><strong>服务器申请数字证书步骤：</strong></p>
</li>
<li><ul>
<li>服务器向权威机构（Certificate Authority，简称 CA）申请一个证书</li>
<li>CA把<strong>服务器的公钥</strong>、服务器信息、CA自己的信息等作为原始数据</li>
<li>CA用哈希算法对原始数据计算哈希值，用<strong>CA自己的私钥加密原始数据</strong>，得到数字签名</li>
<li>CA把数字签名附加在原始数据后，得到数字证书</li>
</ul>
</li>
<li><p><strong>客户端验证证书：</strong></p>
</li>
<li><ul>
<li>客户端接收到服务器的数字证书</li>
<li>客户端有该CA的公钥（公钥内置在浏览器或者操作系统中，默认相信公钥没有被中间人攻击到）解密数字证书中的数字签名，得到原始哈希值</li>
<li>客户端用哈希算法对数字证书的原始数据计算哈希值</li>
<li>如果哈希值相同，说明数字证书没有修改，这样就可以<strong>得到服务器的公钥</strong></li>
</ul>
</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="5-10-HTTPS工作原理"><a href="#5-10-HTTPS工作原理" class="headerlink" title="5.10 HTTPS工作原理"></a>5.10 HTTPS工作原理</h2><ul>
<li>HTTPS是身披SSL外壳的HTTP</li>
<li>一般在建立安全连接时使用非对称加密（RSA），建立完成后使用对称加密（因为非对称加密计算量大）（不能使用对称加密建立安全连接）</li>
</ul>
<h3 id="5-10-1-HTTPS工作步骤"><a href="#5-10-1-HTTPS工作步骤" class="headerlink" title="5.10.1 HTTPS工作步骤"></a>5.10.1 HTTPS工作步骤</h3><ol>
<li>client向server发送请求<a href="https://baidu.com,然后连接到server的443端口,发送的信息主要是**随机值1**和客户端支持哪些加密算法./">https://baidu.com，然后连接到server的443端口，发送的信息主要是**随机值1**和客户端支持哪些加密算法。</a></li>
<li>server接收到信息之后给予client响应握手信息，包括<strong>随机值2</strong>和匹配好的协商加密算法，这个加密算法一定是client发送给server加密算法的子集。</li>
<li>随即server给client发送第二个响应报文是数字证书（数字证书主要包含的是服务器的公钥）</li>
<li>客户端使用内置的CA公钥解析证书，这部分工作是由客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果证书没有问题，那么就生成一个<strong>随机值（预主密钥）</strong>。</li>
<li>客户端认证证书通过之后，接下来是通过<strong>随机值1、随机值2和预主**</strong>密钥**组装会话密钥。然后通过证书的公钥加密会话密钥。</li>
<li>传送加密信息，这部分传送的是用证书加密后的会话秘钥，目的就是让服务端使用密钥解密得到随机值1、随机值2和预主密钥。</li>
<li>服务端解密得到随机值1、随机值2和预主密钥，然后组装会话密钥，跟客户端会话密钥相同<strong>（可以开始对称加密了）</strong></li>
<li>客户端通过会话密钥加密一条消息发送给服务端，主要验证服务端是否正常接受客户端加密的消息。</li>
<li>同样服务端也会通过会话密钥加密一条消息回传给客户端，如果客户端能够正常接受的话表明SSL层连接建立完成了。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1596444965714-c13f6def-cc63-40d4-9ad1-6ada8d5b79bb.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image.png"></p>
<h2 id="5-11-HTTP面试题"><a href="#5-11-HTTP面试题" class="headerlink" title="5.11 HTTP面试题"></a>5.11 HTTP面试题</h2><h3 id="HTTP不同请求类型的区别"><a href="#HTTP不同请求类型的区别" class="headerlink" title="HTTP不同请求类型的区别"></a>HTTP不同请求类型的区别</h3><ul>
<li><p>GET请求</p>
</li>
<li><ul>
<li>从服务器取回数据。只是取回数据，一般不会产生其他影响</li>
<li><strong>一般来说GET请求是幂等的</strong></li>
</ul>
</li>
<li><p>POST请求</p>
</li>
<li><ul>
<li>创建一个实体，通常用POST请求来上传文件或者表单</li>
<li><strong>一般来说不是幂等的</strong>，可能会修改服务器上的资源</li>
<li>GET产生一个TCP数据包，POST产生两个TCP数据包</li>
<li>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）</li>
<li>对于POST请求，浏览器<strong>先发送header**</strong>，服务器响应100 continue<strong>，</strong>浏览器再发送data，服务器响应200**（返回数据）</li>
</ul>
</li>
<li><p>PUT请求</p>
</li>
<li><ul>
<li>用来更新一个已有的实体。通过把已经存在的资源的ID和新的实体用PUT请求上传到服务器来更新资源</li>
<li><strong>一般来说是幂等的</strong>，但是更新资源可能是取消订单这种操作，这种就不是幂等的，这是REST API的挑战</li>
</ul>
</li>
<li><p>DELETE请求</p>
</li>
<li><ul>
<li>从服务器上删除资源。需要把要删除的资源的ID上传给服务器</li>
</ul>
</li>
<li><p>TRACE请求</p>
</li>
<li><ul>
<li>提供一种方法来测试当一个请求发生的时候，服务器通过网络收到的内容。所以它会返回你发送的内容</li>
</ul>
</li>
<li><p>HEAD请求</p>
</li>
<li><ul>
<li>HEAD请求和GET请求资源类似，但仅仅返回相应的头部，没有具体的响应体。它也不会对服务器造成其他影响</li>
</ul>
</li>
<li><p>OPTIONS请求</p>
</li>
<li><ul>
<li>OPTIONS允许客户端请求一个服务所支持的请求方法</li>
<li>它所对应的响应头是Allow，它非常简洁地列出了支持的方法</li>
<li>服务端成功处理了OPTIONS请求后，响应的内容：Allow: HEAD,GET,PUT,DELETE,OPTIONS</li>
</ul>
</li>
<li><p>CONNECT请求</p>
</li>
<li><ul>
<li>主要用来建立一个对资源的网络连接。一旦建立连接后，会响应一个200状态码和一条”Connectioin Established”的消息</li>
</ul>
</li>
</ul>
<h3 id="常见的HTTP状态码"><a href="#常见的HTTP状态码" class="headerlink" title="常见的HTTP状态码"></a>常见的HTTP状态码</h3><ul>
<li><a href="https://www.cnblogs.com/xflonga/p/9368993.html">更全面的HTTP状态码</a></li>
<li>200(“OK”)：请求被正常处理</li>
<li>204(“No Content”)：请求被受理但没有资源可以返回（例如PUT、POST、DELETE请求）</li>
<li>301(“Moved Permanently”)：永久性重定向</li>
<li>302(“Moved Temporarily”)：临时重定向</li>
<li>400(“Bad Request”)：请求报文语法有误，服务器无法识别</li>
<li>401(“Unauthorized”)：请求需要认证</li>
<li>403(“Forbidden”)：请求的对应资源禁止被访问</li>
<li>404(“Not Found”)：服务器无法找到对应资源</li>
<li>500(“Internal Server Error”)：服务器内部错误，执行请求处理代码遇到异常时发送此响应代码</li>
<li>503(“Service Unavailable”)：服务器正忙</li>
</ul>
<h3 id="Cookie和Session区别"><a href="#Cookie和Session区别" class="headerlink" title="Cookie和Session区别"></a>Cookie和Session区别</h3><ul>
<li><p>Cookie</p>
</li>
<li><ul>
<li><strong>Cookies分为会话**</strong>Cookie和持久**<strong>Cookie</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>会话Cookie：不设置Cookie过期时间，浏览器开启到关闭就是一次会话，关闭浏览器一次会话结束，会话Cookie随之销毁</li>
<li>持久Cookie：关闭浏览器不会销毁，过期时间到了才会销毁</li>
</ul>
</li>
</ul>
</li>
<li><p>Session原理：</p>
</li>
<li><ul>
<li><strong>Cookie是实现Session的一种方式</strong></li>
<li>Session机制采用的是一种在服务器端保持状态的解决方案，针对每一个用户的，变量的值保存在服务器上，用一个sessionID来区分是哪个用户session变量,这个值是通过用户的浏览器在访问的时候返回给服务器</li>
<li>浏览器第一次访问服务器时会创建一个session对象并返回一个JSESSIONID=ID的值，创建一个Cookie对象key为JSSIONID，value为ID的值，将这个Cookie写入浏览器</li>
<li>浏览器在第二次访问服务器的时候携带Cookie信息JSESSIONID=ID的值，如果该JSESSIONID的session已经销毁，那么会重新创建一个新的session再返回一个新的JSESSIONID通过Cookie返回到浏览器</li>
</ul>
</li>
<li><p>区别：</p>
</li>
<li><ul>
<li>Cookie和Session都是会话技术，Cookie是运行在客户端，Session是运行在服务器端</li>
<li>Cookie有大小限制4K以及浏览器在存cookie的个数也有限制，Session是没有大小限制</li>
<li>Cookie有安全隐患，通过拦截或本地文件找得到你的cookie后可以进行攻击</li>
<li>Session是保存在服务器端上会存在一段时间才会消失，如果session过多会增加服务器的压力</li>
</ul>
</li>
</ul>
<h3 id="HTTP与HTTPS的区别"><a href="#HTTP与HTTPS的区别" class="headerlink" title="HTTP与HTTPS的区别"></a>HTTP与HTTPS的区别</h3><ol>
<li>HTTP 的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头</li>
<li>HTTP 是不安全的，而 HTTPS 是安全的</li>
<li>HTTP 标准端口是80 ，而 HTTPS 的标准端口是443</li>
<li>在OSI 网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层</li>
<li>HTTP 无法加密，而HTTPS 对传输的数据进行加密</li>
<li>HTTP无需证书，而HTTPS 需要CA机构wosign的颁发的SSL证书</li>
</ol>
<p><a href="https://www.yuque.com/attachments/yuque/0/2020/pdf/1266758/1586526199564-25094c1e-ee63-4b18-a035-2964a6f3f06b.pdf?from=https://www.yuque.com/docs/share/9caaaa40-8890-41d7-a3c3-af074f1bb4c6?%23">计算机网络面试题总结.pdf</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发</title>
    <url>/2020/10/14/0000.Java%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h2 id="1-Synchronize关键字原理"><a href="#1-Synchronize关键字原理" class="headerlink" title="1. Synchronize关键字原理"></a>1. Synchronize关键字原理</h2><p>众所周知 <code>Synchronize</code> 关键字是解决并发问题常用解决方案，有以下三种使用方式:</p>
<ul>
<li>同步普通方法，锁的是当前对象。</li>
<li>同步静态方法，锁的是当前 <code>Class</code> 对象。</li>
<li>同步块，锁的是 <code>&#123;&#125;</code> 中的对象。</li>
</ul>
<p> <strong>实现原理：</strong><br><code>JVM</code> 是通过进入、退出对象监视器( <code>Monitor</code> )来实现对方法、同步块的同步的。</p>
<p>具体实现是在编译之后在同步方法调用前加入一个 <code>monitor.enter</code> 指令，在退出方法和异常处插入 <code>monitor.exit</code> 的指令。</p>
<p>其本质就是对一个对象监视器( <code>Monitor</code> )进行获取，而这个获取过程具有排他性从而达到了同一时刻只能一个线程访问的目的。</p>
<p>而对于没有获取到锁的线程将会阻塞到方法入口处，直到获取锁的线程 <code>monitor.exit</code> 之后才能尝试继续获取锁。</p>
<p>流程图如下:</p>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/094206_13b9dc67_1478371.jpeg"></p>
<p>通过一段代码来演示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Synchronize.class)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Synchronize&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>javap -c Synchronize</code> 可以查看编译之后的具体信息。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">public</span> <span class="string">class</span> <span class="string">com.crossoverjie.synchronize.Synchronize</span> &#123;</span><br><span class="line">  <span class="string">public</span> <span class="string">com.crossoverjie.synchronize.Synchronize();</span></span><br><span class="line">    <span class="attr">Code:</span></span><br><span class="line">       <span class="attr">0:</span> <span class="string">aload_0</span></span><br><span class="line">       <span class="attr">1:</span> <span class="string">invokespecial</span> <span class="comment">#1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="attr">4:</span> <span class="string">return</span></span><br><span class="line"></span><br><span class="line">  <span class="string">public</span> <span class="string">static</span> <span class="string">void</span> <span class="string">main(java.lang.String</span>[]<span class="string">);</span></span><br><span class="line">    <span class="attr">Code:</span></span><br><span class="line">       <span class="attr">0:</span> <span class="string">ldc</span>           <span class="comment">#2                  // class com/crossoverjie/synchronize/Synchronize</span></span><br><span class="line">       <span class="attr">2:</span> <span class="string">dup</span></span><br><span class="line">       <span class="attr">3:</span> <span class="string">astore_1</span></span><br><span class="line">       <span class="string">**4:</span> <span class="string">monitorenter**</span></span><br><span class="line">       <span class="attr">5:</span> <span class="string">getstatic</span>     <span class="comment">#3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       <span class="attr">8:</span> <span class="string">ldc</span>           <span class="comment">#4                  // String Synchronize</span></span><br><span class="line">      <span class="attr">10:</span> <span class="string">invokevirtual</span> <span class="comment">#5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="attr">13:</span> <span class="string">aload_1</span></span><br><span class="line">      <span class="string">**14:</span> <span class="string">monitorexit**</span></span><br><span class="line">      <span class="attr">15:</span> <span class="string">goto</span>          <span class="number">23</span></span><br><span class="line">      <span class="attr">18:</span> <span class="string">astore_2</span></span><br><span class="line">      <span class="attr">19:</span> <span class="string">aload_1</span></span><br><span class="line">      <span class="attr">20:</span> <span class="string">monitorexit</span></span><br><span class="line">      <span class="attr">21:</span> <span class="string">aload_2</span></span><br><span class="line">      <span class="attr">22:</span> <span class="string">athrow</span></span><br><span class="line">      <span class="attr">23:</span> <span class="string">return</span></span><br><span class="line">    <span class="attr">Exception table:</span></span><br><span class="line">       <span class="string">from</span>    <span class="string">to</span>  <span class="string">target</span> <span class="string">type</span></span><br><span class="line">           <span class="number">5</span>    <span class="number">15</span>    <span class="number">18</span>   <span class="string">any</span></span><br><span class="line">          <span class="number">18</span>    <span class="number">21</span>    <span class="number">18</span>   <span class="string">any</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在同步块的入口和出口分别有 <code>monitorenter,monitorexit</code><br>指令。</p>
<p> <strong>Java对象头和monitor是实现synchronized的基础</strong> </p>
<h3 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h3><ul>
<li>synchronized用的锁是存在Java对象头里的，那么什么是Java对象头呢？Hotspot虚拟机的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。其中Klass Point是是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，Mark Word用于存储对象自身的运行时数据，它是实现轻量级锁和偏向锁的关键</li>
</ul>
<h3 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h3><ul>
<li>Mark Word用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。Java对象头一般占有两个机器码,但是如果对象是数组类型，则需要三个机器码，因为JVM虚拟机可以通过Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据来确认数组的大小，所以用一块来记录数组长度。<br><img src="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/02/222222_2-1.jpg" alt="输入图片说明" title="在这里输入图片标题"></li>
<li>对象头信息是与对象自身定义的数据无关的额外存储成本，但是考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据，它会根据对象的状态复用自己的存储空间，也就是说，Mark Word会随着程序的运行发生变化，变化状态如下（32位虚拟机）：<br><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/094206_09228ac9_1478371.jpeg" alt="输入图片说明" title="在这里输入图片标题"></li>
</ul>
<h3 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h3><ul>
<li>什么是Monitor？我们可以把它理解为一个同步工具，也可以描述为一种同步机制，它通常被描述为一个对象。</li>
<li>与一切皆对象一样，所有的Java对象是天生的Monitor，每一个Java对象都有成为Monitor的潜质，因为在Java的设计中 ，每一个Java对象自打娘胎里出来就带了一把看不见的锁，它叫做内部锁或者Monitor锁。</li>
<li>Monitor 是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。</li>
<li>每一个被锁住的对象都会和一个monitor关联（对象头的MarkWord中的LockWord指向monitor的起始地址），同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/094206_14c72ca4_1478371.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<ol>
<li>Owner：初始时为NULL表示当前没有任何线程拥有该monitor record，当线程成功拥有该锁后保存线程唯一标识，当锁被释放时又设置为NULL；</li>
<li>EntryQ:关联一个系统互斥锁（semaphore），阻塞所有试图锁住monitor record失败的线程</li>
<li>RcThis:表示blocked或waiting在该monitor record上的所有线程的个数。</li>
<li>Nest:用来实现重入锁的计数。</li>
<li>HashCode:保存从对象头拷贝过来的HashCode值（可能还包含GC age）。</li>
<li>Candidate:用来避免不必要的阻塞或等待线程唤醒，因为每一次只有一个线程能够成功拥有锁，如果每次前一个释放锁的线程唤醒所有正在阻塞或等待的线程，会引起不必要的上下文切换（从阻塞到就绪然后因为竞争锁失败又被阻塞）从而导致性能严重下降。Candidate只有两种可能的值0表示没有需要唤醒的线程1表示要唤醒一个继任线程来竞争锁。</li>
</ol>
<h3 id="jdk1-6开始对锁锁优化"><a href="#jdk1-6开始对锁锁优化" class="headerlink" title="jdk1.6开始对锁锁优化"></a>jdk1.6开始对锁锁优化</h3><ul>
<li><code>synchronize</code>  很多都称之为重量锁，<code>JDK1.6</code> 中对 <code>synchronize</code> 进行了各种优化，为了能减少获取和释放锁带来的消耗引入了<code>偏向锁</code>和<code>轻量锁</code>。</li>
<li>锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</li>
</ul>
<h3 id="轻量锁"><a href="#轻量锁" class="headerlink" title="轻量锁"></a>轻量锁</h3><p>当代码进入同步块时，如果同步对象为无锁状态时，当前线程会在栈帧中创建一个锁记录(<code>Lock Record</code>)区域，同时将锁对象的对象头中 <code>Mark Word</code> 拷贝到锁记录中，再尝试使用 <code>CAS</code> 将 <code>Mark Word</code> 更新为指向锁记录的指针。</p>
<p>如果更新<strong>成功</strong>，当前线程就获得了锁。</p>
<p>如果更新<strong>失败</strong> <code>JVM</code> 会先检查锁对象的 <code>Mark Word</code> 是否指向当前线程的锁记录。</p>
<p>如果是则说明当前线程拥有锁对象的锁，可以直接进入同步块。</p>
<p>不是则说明有其他线程抢占了锁，如果存在多个线程同时竞争一把锁，<strong>轻量锁就会膨胀为重量锁</strong>。</p>
<h4 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h4><p>轻量锁的解锁过程也是利用 <code>CAS</code> 来实现的，会尝试锁记录替换回锁对象的 <code>Mark Word</code> 。如果替换成功则说明整个同步操作完成，失败则说明有其他线程尝试获取锁，这时就会唤醒被挂起的线程(此时已经膨胀为<code>重量锁</code>)</p>
<p>轻量锁能提升性能的原因是：</p>
<p>认为大多数锁在整个同步周期都不存在竞争，所以使用 <code>CAS</code> 比使用互斥开销更少。但如果锁竞争激烈，轻量锁就不但有互斥的开销，还有 <code>CAS</code> 的开销，甚至比重量锁更慢。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>为了进一步的降低获取锁的代价，<code>JDK1.6</code> 之后还引入了偏向锁。</p>
<p>偏向锁的特征是:锁不存在多线程竞争，并且应由一个线程多次获得锁。</p>
<p>当线程访问同步块时，会使用 <code>CAS</code> 将线程 ID 更新到锁对象的 <code>Mark Word</code> 中，如果更新成功则获得偏向锁，并且之后每次进入这个对象锁相关的同步块时都不需要再次获取锁了。</p>
<h4 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h4><p>当有另外一个线程获取这个锁时，持有偏向锁的线程就会释放锁，释放时会等待全局安全点(这一时刻没有字节码运行)，接着会暂停拥有偏向锁的线程，根据锁对象目前是否被锁来判定将对象头中的 <code>Mark Word</code> 设置为无锁或者是轻量锁状态。</p>
<p>偏向锁可以提高带有同步却没有竞争的程序性能，但如果程序中大多数锁都存在竞争时，那偏向锁就起不到太大作用。可以使用 <code>-XX:-userBiasedLocking=false</code> 来关闭偏向锁，并默认进入轻量锁。</p>
<h3 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h3><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><ul>
<li><p>线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。同时我们发现在许多应用上面，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的。所以引入自旋锁。</p>
<p><strong>何谓自旋锁？</strong> </p>
</li>
<li><p>所谓自旋锁，就是让该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。怎么等待呢？执行一段无意义的循环即可（自旋）。</p>
</li>
<li><p>自旋等待不能替代阻塞，先不说对处理器数量的要求,虽然它可以避免线程切换带来的开销，但是它占用了处理器的时间。如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好，反之，自旋的线程就会白白消耗掉处理的资源，它不会做任何有意义的工作，典型的占着茅坑不拉屎，这样反而会带来性能上的浪费。所以说，自旋等待的时间（自旋的次数）必须要有一个限度，如果自旋超过了定义的时间仍然没有获取到锁，则应该被挂起。</p>
</li>
<li><p>自旋锁在JDK 1.4.2中引入，默认关闭，但是可以使用-XX:+UseSpinning开开启，在JDK1.6中默认开启。同时自旋的默认次数为10次，可以通过参数-XX:PreBlockSpin来调整；</p>
</li>
<li><p>如果通过参数-XX:preBlockSpin来调整自旋锁的自旋次数，会带来诸多不便。假如我将参数调整为10，但是系统很多线程都是等你刚刚退出的时候就释放了锁（假如你多自旋一两次就可以获取锁），你是不是很尴尬。于是JDK1.6引入自适应的自旋锁，让虚拟机会变得越来越聪明。</p>
</li>
</ul>
<h3 id="适应性自旋（CAS）"><a href="#适应性自旋（CAS）" class="headerlink" title="适应性自旋（CAS）"></a>适应性自旋（CAS）</h3><ul>
<li>在使用 <code>CAS</code> 时，如果操作失败，<code>CAS</code> 会自旋再次尝试。由于自旋是需要消耗 <code>CPU</code> 资源的，所以如果长期自旋就白白浪费了 <code>CPU</code>。<code>JDK1.6</code>加入了适应性自旋:如果某个锁自旋很少成功获得，那么下一次就会减少自旋。</li>
<li>所谓自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定</li>
<li>线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。</li>
</ul>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><ul>
<li>我们知道在使用同步锁的时候，需要让同步块的作用范围尽可能小—仅在共享数据的实际作用域中才进行同步，这样做的目的是为了使需要同步的操作数量尽可能缩小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。</li>
<li>在大多数的情况下，上述观点是正确的，LZ也一直坚持着这个观点。但是如果一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，所以引入锁粗话的概念。</li>
<li>锁粗话概念比较好理解，就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。如：vector每次add的时候都需要加锁操作，JVM检测到对同一个对象（vector）连续加锁、解锁操作，会合并一个更大范围的加锁、解锁操作，即加锁解锁操作会移到for循环之外。</li>
</ul>
<h3 id="不同锁的比较"><a href="#不同锁的比较" class="headerlink" title="不同锁的比较"></a>不同锁的比较</h3><p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/094206_5f316f33_1478371.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<h2 id="2-volatile关键字的理解"><a href="#2-volatile关键字的理解" class="headerlink" title="2. volatile关键字的理解"></a>2. volatile关键字的理解</h2><p> <strong>具有了以下两点特性：</strong> </p>
<ul>
<li>1 . 保证了不同线程对该变量操作的内存可见性;</li>
<li>2 . 禁止指令重排序</li>
</ul>
<h3 id="内存可见性和是重排序"><a href="#内存可见性和是重排序" class="headerlink" title="内存可见性和是重排序"></a>内存可见性和是重排序</h3><p> <strong>java内存模型（JMM）</strong> </p>
<ul>
<li>Java虚拟机规范试图定义一种Java内存模型（JMM）,来屏蔽掉各种硬件和操作系统的内存访问差异，让Java程序在各种平台上都能达到一致的内存访问效果。</li>
<li>简单来说，由于CPU执行指令的速度是很快的，但是内存访问的速度就慢了很多，相差的不是一个数量级，所以搞处理器的那群大佬们又在CPU里加了好几层高速缓存。</li>
<li>在Java内存模型里，对上述的优化又进行了一波抽象。JMM规定所有变量都是存在主存中的，类似于上面提到的普通内存，每个线程又包含自己的工作内存，方便理解就可以看成CPU上的寄存器或者高速缓存。所以线程的操作都是以工作内存为主，它们只能访问自己的工作内存，且工作前后都要把值在同步回主内存。</li>
</ul>
<p>这么说得我自己都有些不清楚了，拿张纸画一下：<br><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/133856_52bf0ac2_1478371.png" alt="输入图片说明" title="clipboard.png"></p>
<p>在线程执行时，首先会从主存中read变量值，再load到工作内存中的副本中，然后再传给处理器执行，执行完毕后再给工作内存中的副本赋值，随后工作内存再把值传回给主存，主存中的值才更新。</p>
<p>使用工作内存和主存，虽然加快的速度，但是也带来了一些问题。比如看下面一个例子：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">i</span> = i + <span class="number">1</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>假设i初值为0，当只有一个线程执行它时，结果肯定得到1，当两个线程执行时，会得到结果2吗？这倒不一定了。可能存在这种情况：</p>
<p><img src="https://gitee.com/uploads/images/2018/0704/134053_43aae32f_1478371.png" alt="输入图片说明" title="clipboard.png"></p>
<ul>
<li>如果两个线程按照上面的执行流程，那么i最后的值居然是1了。如果最后的写回生效的慢，你再读取i的值，都可能是0，这就是缓存不一致问题。</li>
<li>下面就要提到你刚才问到的问题了，JMM主要就是围绕着如何在并发过程中如何处理原子性、可见性和有序性这3个特征来建立的，通过解决这三个问题，可以解除缓存不一致的问题。而volatile跟可见性和有序性都有关。</li>
</ul>
<h3 id="1-原子性-Atomicity-："><a href="#1-原子性-Atomicity-：" class="headerlink" title="1.原子性(Atomicity)："></a>1.原子性(Atomicity)：</h3><p>Java中，对基本数据类型的读取和赋值操作是原子性操作，所谓原子性操作就是指这些操作是不可中断的，要做一定做完，要么就没有执行。 比如：</p>
<p><img src="https://gitee.com/uploads/images/2018/0704/134216_1d4cdf07_1478371.png" alt="输入图片说明" title="clipboard.png"></p>
<ul>
<li>i=2是读取操作，必定是原子性操作，j=i你以为是原子性操作，其实吧，分为两步，一是读取i的值，然后再赋值给j,这就是2步操作了，称不上原子操作，i++和i = i + 1其实是等效的，读取i的值，加1，再写回主存，那就是3步操作了。所以上面的举例中，最后的值可能出现多种情况，就是因为满足不了原子性。只有简单的读取，赋值是原子操作，还只能是用数字赋值，用变量的话还多了一步读取变量值的操作。有个例外是虚拟机规范中允许对64位数据类型(long和double)，分为2次32为的操作来处理，但是最新JDK实现还是实现了原子操作的。</li>
<li>JMM只实现了基本的原子性，像上面i++那样的操作，必须借助于synchronized和Lock来保证整块代码的原子性了。线程在释放锁之前，必然会把i的值刷回到主存的。</li>
</ul>
<h3 id="2-可见性-Visibility-："><a href="#2-可见性-Visibility-：" class="headerlink" title="2.可见性(Visibility)："></a>2.可见性(Visibility)：</h3><ul>
<li>说到可见性，Java就是利用volatile来提供可见性的。 当一个变量被volatile修饰时，那么对它的修改会立刻刷新到主存，当其它线程需要读取该变量时，会去内存中读取新值。而普通变量则不能保证这一点。</li>
<li>其实通过synchronized和Lock也能够保证可见性，线程在释放锁之前，会把共享变量值都刷回主存，但是synchronized和Lock的开销都更大。</li>
</ul>
<h3 id="3-有序性（Ordering）"><a href="#3-有序性（Ordering）" class="headerlink" title="3.有序性（Ordering）"></a>3.有序性（Ordering）</h3><p>JMM是允许编译器和处理器对指令重排序的，但是规定了as-if-serial语义，即不管怎么重排序，程序的执行结果不能改变。比如下面的程序段：</p>
<p><img src="https://gitee.com/uploads/images/2018/0704/134324_6be6a576_1478371.png" alt="输入图片说明" title="clipboard.png"></p>
<ul>
<li>上面的语句，可以按照A-&gt;B-&gt;C执行，结果为3.14,但是也可以按照B-&gt;A-&gt;C的顺序执行，因为A、B是两句独立的语句，而C则依赖于A、B，所以A、B可以重排序，但是C却不能排到A、B的前面。JMM保证了重排序不会影响到单线程的执行，但是在多线程中却容易出问题。</li>
</ul>
<p> <strong>JMM具备一些先天的有序性,即不需要通过任何手段就可以保证的有序性，通常称为happens-before原则</strong> </p>
<ol>
<li>程序顺序规则： 一个线程中的每个操作，happens-before于该线程中的任意后续操作</li>
<li>监视器锁规则：对一个线程的解锁，happens-before于随后对这个线程的加锁</li>
<li>volatile变量规则： 对一个volatile域的写，happens-before于后续对这个volatile域的读</li>
<li>传递性：如果A happens-before B ,且 B happens-before C, 那么 A happens-before C</li>
<li>start()规则： 如果线程A执行操作ThreadB_start()(启动线程B) , 那么A线程的ThreadB_start()happens-before 于B中的任意操作</li>
<li>join()原则： 如果A执行ThreadB.join()并且成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</li>
<li>interrupt()原则： 对线程interrupt()方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测是否有中断发生</li>
<li>finalize()原则：一个对象的初始化完成先行发生于它的finalize()方法的开始</li>
</ol>
<ul>
<li><p>第1条规则程序顺序规则是说在一个线程里，所有的操作都是按顺序的，但是在JMM里其实只要执行结果一样，是允许重排序的，这边的happens-before强调的重点也是单线程执行结果的正确性，但是无法保证多线程也是如此。</p>
</li>
<li><p>第2条规则监视器规则其实也好理解，就是在加锁之前，确定这个锁之前已经被释放了，才能继续加锁。</p>
</li>
<li><p>第3条规则，就适用到所讨论的volatile，如果一个线程先去写一个变量，另外一个线程再去读，那么写入操作一定在读操作之前。</p>
</li>
<li></li>
<li><p>第4条规则，就是happens-before的传递性。</p>
</li>
</ul>
<h3 id="volatile如何满足并发的三大特性"><a href="#volatile如何满足并发的三大特性" class="headerlink" title="volatile如何满足并发的三大特性"></a>volatile如何满足并发的三大特性</h3><ul>
<li><p>如果一个变量声明成是volatile的，那么当我读变量时，总是能读到它的最新值，这里最新值是指不管其它哪个线程对该变量做了写操作，都会立刻被更新到主存里，我也能从主存里读到这个刚写入的值。也就是说volatile关键字可以保证可见性以及有序性。</p>
<p><strong>从内存语义上来看</strong> </p>
</li>
<li><p>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存</p>
</li>
<li><p>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量。</p>
<p><strong>volatile的两点内存语义能保证可见性和有序性，但是能保证原子性吗？</strong> </p>
</li>
</ul>
<p>首先我回答是不能保证原子性，要是说能保证，也只是对单个volatile变量的读/写具有原子性，但是对于类似volatile++这样的复合操作就无能为力了，比如下面的例子：</p>
<p><img src="https://gitee.com/uploads/images/2018/0704/134603_2e750e61_1478371.png" alt="输入图片说明" title="clipboard.png"></p>
<ul>
<li><p>按道理来说结果是10000，但是运行下很可能是个小于10000的值。有人可能会说volatile不是保证了可见性啊，一个线程对inc的修改，另外一个线程应该立刻看到啊！可是这里的操作inc++是个复合操作啊，包括读取inc的值，对其自增，然后再写回主存。</p>
</li>
<li><p>假设线程A，读取了inc的值为10，这时候被阻塞了，因为没有对变量进行修改，触发不了volatile规则。</p>
</li>
<li><p>线程B此时也读读inc的值，主存里inc的值依旧为10，做自增，然后立刻就被写回主存了，为11。</p>
</li>
<li><p>有人说，volatile不是会使缓存行无效的吗？但是这里线程A读取到线程B也进行操作之前，并没有修改inc值，所以线程B读取的时候，还是读的10。</p>
</li>
<li><p>又有人说，线程B将11写回主存，不会把线程A的缓存行设为无效吗？但是线程A的读取操作已经做过了啊，只有在做读取操作时，发现自己缓存行无效，才会去读主存的值，所以这里线程A只能继续做自增了。</p>
</li>
</ul>
<p>综上所述，在这种复合操作的情景下，原子性的功能是维持不了了。但是volatile在上面那种设置flag值的例子里，由于对flag的读/写操作都是单步的，所以还是能保证原子性的。</p>
<p>要想保证原子性，只能借助于synchronized,Lock以及并发包下的atomic的原子操作类了，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。</p>
<h3 id="volatile底层的实现机制"><a href="#volatile底层的实现机制" class="headerlink" title="volatile底层的实现机制"></a>volatile底层的实现机制</h3><ul>
<li><p>如果把加入volatile关键字的代码和未加入volatile关键字的代码都生成汇编代码，会发现加入volatile关键字的代码会多出一个lock前缀指令。</p>
<p><strong>lock前缀指令实际相当于一个内存屏障，内存屏障提供了以下功能：</strong> </p>
</li>
<li><p>1   重排序时不能把后面的指令重排序到内存屏障之前的位置</p>
</li>
<li><p>2 . 使得本CPU的Cache写入内存</p>
</li>
<li><p>3 . 写入动作也会引起别的CPU或者别的内核无效化其Cache，相当于让新写入的值对别的线程可见。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/134745_53217997_1478371.png" alt="输入图片说明" title="clipboard.png"></p>
<h2 id="3-ConcurrentHashMap-实现原理"><a href="#3-ConcurrentHashMap-实现原理" class="headerlink" title="3.  ConcurrentHashMap 实现原理"></a>3.  ConcurrentHashMap 实现原理</h2><p>由于 <code>HashMap</code> 是一个线程不安全的容器，主要体现在容量大于<code>总量*负载因子</code>发生扩容时会出现环形链表从而导致死循环。</p>
<p>因此需要支持线程安全的并发容器 <code>ConcurrentHashMap</code> 。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/20201015141802.jpeg"></p>
<p>如图所示，是由 <code>Segment</code> 数组、<code>HashEntry</code> 数组组成，和 <code>HashMap</code> 一样，仍然是数组加链表组成。</p>
<p><code>ConcurrentHashMap</code> 采用了分段锁技术，其中 <code>Segment</code> 继承于 <code>ReentrantLock</code>。不会像 <code>HashTable</code> 那样不管是 <code>put</code> 还是 <code>get</code> 操作都需要做同步处理，理论上 ConcurrentHashMap 支持 <code>CurrencyLevel</code> (Segment 数组数量)的线程并发。每当一个线程占用锁访问一个 <code>Segment</code> 时，不会影响到其他的 <code>Segment</code>。</p>
<h3 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h3><p><code>ConcurrentHashMap</code> 的 <code>get</code> 方法是非常高效的，因为整个过程都不需要加锁。</p>
<p>只需要将 <code>Key</code> 通过 <code>Hash</code> 之后定位到具体的 <code>Segment</code> ，再通过一次 <code>Hash</code> 定位到具体的元素上。由于 <code>HashEntry</code> 中的 <code>value</code> 属性是用 <code>volatile</code> 关键词修饰的，保证了内存可见性，所以每次获取时都是最新值(<a href="https://github.com/crossoverJie/Java-Interview/blob/master/MD/Threadcore.md#%E5%8F%AF%E8%A7%81%E6%80%A7">volatile 相关知识点</a>)。</p>
<h3 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h3><p>内部 <code>HashEntry</code> 类 ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V value;</span><br><span class="line">    <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    HashEntry(<span class="keyword">int</span> hash, K key, V value, HashEntry&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然 HashEntry 中的 value 是用 <code>volatile</code> 关键词修饰的，但是并不能保证并发的原子性，所以 put 操作时仍然需要加锁处理。</p>
<p>首先也是通过 Key 的 Hash 定位到具体的 Segment，在 put 之前会进行一次扩容校验。这里比 HashMap 要好的一点是：HashMap 是插入元素之后再看是否需要扩容，有可能扩容之后后续就没有插入就浪费了本次扩容(扩容非常消耗性能)。</p>
<p>而 ConcurrentHashMap 不一样，它是先将数据插入之后再检查是否需要扩容，之后再做插入。</p>
<h3 id="size-方法"><a href="#size-方法" class="headerlink" title="size 方法"></a>size 方法</h3><p>每个 <code>Segment</code> 都有一个 <code>volatile</code> 修饰的全局变量 <code>count</code> ,求整个 <code>ConcurrentHashMap</code> 的 <code>size</code> 时很明显就是将所有的 <code>count</code> 累加即可。但是 <code>volatile</code> 修饰的变量却不能保证多线程的原子性，所有直接累加很容易出现并发问题。</p>
<p>但如果每次调用 <code>size</code> 方法将其余的修改操作加锁效率也很低。所以做法是先尝试两次将 <code>count</code> 累加，如果容器的 <code>count</code> 发生了变化再加锁来统计 <code>size</code>。</p>
<p>至于 <code>ConcurrentHashMap</code> 是如何知道在统计时大小发生了变化呢，每个 <code>Segment</code> 都有一个 <code>modCount</code> 变量，每当进行一次 <code>put remove</code> 等操作，<code>modCount</code> 将会 +1。只要 <code>modCount</code> 发生了变化就认为容器的大小也在发生变化。</p>
<h2 id="4-什么是死锁"><a href="#4-什么是死锁" class="headerlink" title="4. 什么是死锁"></a>4. 什么是死锁</h2><p> <strong>死锁：是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。 由于资源占用是互斥的，当某个进程提出申请资源后，使得有关进程在无外力协助下，永远分配不到必需的资源而无法继续运行，这就产生了一种特殊现象：死锁。”</strong> </p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class MyTestSiSuo &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">Object</span> o1 = <span class="keyword">new</span> <span class="keyword">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">Object</span> o2 = <span class="keyword">new</span> <span class="keyword">Object</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        </span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> run()&#123;</span><br><span class="line">                <span class="comment">//抢占资源 o1</span></span><br><span class="line">                <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.<span class="built_in">println</span>(<span class="string">&quot;t1 ---Get o1&quot;</span>);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//需要资源o2 但是 t2 独占(未释放) --&gt;互相竞争资源--&gt;死锁</span></span><br><span class="line">                    <span class="keyword">synchronized</span>(o2)&#123;</span><br><span class="line">                        System.out.<span class="built_in">println</span>(<span class="string">&quot;t1 ---Get o2&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> run()&#123;</span><br><span class="line">                <span class="comment">//抢占资源o2</span></span><br><span class="line">                <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">                    System.out.<span class="built_in">println</span>(<span class="string">&quot;t2 ---Get o2&quot;</span>);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//需要资源 o1,但是 t1 独占(未释放) --&gt;互相竞争资源--&gt;死锁</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">                        System.out.<span class="built_in">println</span>(<span class="string">&quot;t2 ---Get o1&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">                </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> <strong>实现过程：</strong> </p>
<ul>
<li>有公共资源o1,o2;程序开始，线程t2抢占资源o2,在同步代码块中，o1也被抢占；线程t1睡眠等待1000ms；</li>
<li>t2在需要资源o1时，此时发现被t1独占，而t1此时睡眠醒来，需要资源o2，发现被t2独占；由此，产生 死锁；</li>
</ul>
<h2 id="5-什么是AQS"><a href="#5-什么是AQS" class="headerlink" title="5. 什么是AQS"></a>5. 什么是AQS</h2><p>Java并发包（JUC）中提供了很多并发工具，这其中，很多我们耳熟能详的并发工具，譬如ReentrangLock、Semaphore，它们的实现都用到了一个共同的基类–AbstractQueuedSynchronizer,简称AQS。AQS是一个用来构建锁和同步器的框架</p>
<h3 id="AQS的基本实现原理"><a href="#AQS的基本实现原理" class="headerlink" title="AQS的基本实现原理"></a>AQS的基本实现原理</h3><p>AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">private volatile int <span class="keyword">state</span>;//共享变量，使用volatile修饰保证线程可见性</span><br></pre></td></tr></table></figure>
<p>状态信息通过procted类型的getState，setState，compareAndSetState进行操作</p>
<h3 id="AQS支持两种同步方式"><a href="#AQS支持两种同步方式" class="headerlink" title="AQS支持两种同步方式"></a>AQS支持两种同步方式</h3><ol>
<li>独占式</li>
<li>共享式</li>
</ol>
<ul>
<li><p>独占式如ReentrantLock，共享式如Semaphore，CountDownLatch，组合式的如ReentrantReadWriteLock。总之，AQS为使用提供了底层支撑，如何组装实现，使用者可以自由发挥。</p>
<p><strong>同步器的设计是基于模板方法模式的，一般的使用方式是这样：</strong> </p>
</li>
</ul>
<ol>
<li><p>使用者继承AbstractQueuedSynchronizer并重写指定的方法。（这些重写方法很简单，无非是对于共享资源state的获取和释放）</p>
</li>
<li><p>将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</p>
<p><strong>AQS定义的这些可重写的方法：</strong> </p>
</li>
<li><p><code>protected boolean tryAcquire(int arg)</code> : 独占式获取同步状态，试着获取，成功返回true，反之为false</p>
</li>
<li><p><code> protected boolean tryRelease(int arg)</code> ：独占式释放同步状态，等待中的其他线程此时将有机会获取到同步状态；</p>
</li>
<li><p><code>protected int tryAcquireShared(int arg)</code> ：共享式获取同步状态，返回值大于等于0，代表获取成功；反之获取失败；</p>
</li>
<li><p><code>protected boolean tryReleaseShared(int arg)</code> ：共享式释放同步状态，成功为true，失败为false</p>
</li>
<li><p><code>protected boolean isHeldExclusively()</code> ： 是否在独占模式下被线程占用。</p>
</li>
</ol>
<h3 id="如何使用AQS"><a href="#如何使用AQS" class="headerlink" title="如何使用AQS"></a>如何使用AQS</h3><ul>
<li><p>首先，我们需要去继承AbstractQueuedSynchronizer这个类，然后我们根据我们的需求去重写相应的方法，比如要实现一个独占锁，那就去重写tryAcquire，tryRelease方法，要实现共享锁，就去重写tryAcquireShared，tryReleaseShared；最后，在我们的组件中调用AQS中的模板方法就可以了，而这些模板方法是会调用到我们之前重写的那些方法的。也就是说，我们只需要很小的工作量就可以实现自己的同步组件，重写的那些方法，仅仅是一些简单的对于共享资源state的获取和释放操作，至于像是获取资源失败，线程需要阻塞之类的操作，自然是AQS帮我们完成了。</p>
<p><strong>自定义同步器代码实现</strong> </p>
</li>
</ul>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.AQS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.AbstractQueuedSynchronizer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于AQS 实现自定义同步器&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> qinxuewu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 18/7/14下午1:23</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态内部类 继承AQS</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span>&#123;</span><br><span class="line">        <span class="comment">//是否处于占用状态</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState()==<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当状态为0的时候获取锁，CAS操作成功，则state状态为1，</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                 setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放锁，将同步状态置为0</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">if</span> (getState() == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">                  setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">                   setState(<span class="number">0</span>);</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同步对象完成一系列复杂的操作，我们仅需指向它即可</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line">    <span class="comment">//加锁操作，代理到acquire（模板方法）上就行，acquire会调用我们重写的tryAcquire方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> sync.<span class="title">tryAcquire</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放锁，代理到release（模板方法）上就行，release会调用我们重写的tryRelease方法。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> sync.<span class="title">isHeldExclusively</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.AQS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> qinxuewu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 18/7/14下午1:44</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMutex</span> </span>&#123;</span><br><span class="line">    <span class="comment">//CyclicBarrier是一个同步工具类，它允许一组线程互相等待，直到到达某个公共屏障点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">31</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  Mutex mutex = <span class="keyword">new</span> Mutex();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//说明:我们启用30个线程，每个线程对i自加10000次，同步正常的话，最终结果应为300000；</span></span><br><span class="line">        <span class="comment">//未加锁前</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">30</span>;i++)&#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">                        increment1();<span class="comment">//没有同步措施的a++；</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// barrier的await方法，在所有参与者都已经在此 barrier 上调用 await 方法之前，将一直等待。</span></span><br><span class="line">                        barrier.await();<span class="comment">//等30个线程累加完毕</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">        barrier.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;加锁前，a=&quot;</span>+a);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加锁后</span></span><br><span class="line">        barrier.reset();<span class="comment">//重置CyclicBarrier</span></span><br><span class="line">        a=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">30</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">                        increment2();<span class="comment">//a++采用Mutex进行同步处理</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        barrier.await();<span class="comment">//等30个线程累加完毕</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        barrier.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;加锁后，a=&quot;</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 没有同步措施的a++</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用自定义的Mutex进行同步处理的a++</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mutex.lock();</span><br><span class="line">        a++;</span><br><span class="line">        mutex.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="6-什么是CAS"><a href="#6-什么是CAS" class="headerlink" title="6. 什么是CAS"></a>6. 什么是CAS</h2><ul>
<li>CAS（Compare and Swap），即比较并替换，实现并发算法时常用到的一种技术，Doug lea大神在java同步器中大量使用了CAS技术，鬼斧神工的实现了多线程执行的安全性。</li>
<li>CAS的思想很简单：三个参数，一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。</li>
</ul>
<h3 id="一个n-的问题"><a href="#一个n-的问题" class="headerlink" title="一个n++的问题"></a>一个n++的问题</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Case</span> &#123;</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> n;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过javap -verbose Case看看add方法的字节码指令</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> add();</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0       </span><br><span class="line">         <span class="number">1</span>: dup           </span><br><span class="line">         <span class="number">2</span>: getfield      #<span class="number">2</span>                  <span class="comment">// Field n:I</span></span><br><span class="line">         <span class="number">5</span>: iconst_1      </span><br><span class="line">         <span class="number">6</span>: iadd          </span><br><span class="line">         <span class="number">7</span>: putfield      #<span class="number">2</span>                  <span class="comment">// Field n:I</span></span><br></pre></td></tr></table></figure>

<p>n++被拆分成了几个指令：</p>
<ul>
<li>执行getfield拿到原始n；</li>
<li>执行iadd进行加1操作；</li>
<li>执行putfield写把累加后的值写回n；</li>
</ul>
<p>通过volatile修饰的变量可以保证线程之间的可见性，但并不能保证这3个指令的原子执行，在多线程并发执行下，无法做到线程安全，得到正确的结果，那么应该如何解决呢？在add方法加上synchronized修饰解决，但是性能上差了点，除了低性能的加锁方案，我们还可以使用JDK自带的CAS方案，在CAS中，比较和替换是一组原子操作，不会被外部打断，且在性能上更占有优势。</p>
<p> <strong>在JDK 5之前Java语言是靠synchronized关键字保证同步的，这会导致有锁</strong><br>锁机制存在以下问题：</p>
<p>（1）在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。</p>
<p>（2）一个线程持有锁会导致其它所有需要此锁的线程挂起。</p>
<p>（3）如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。</p>
<p>volatile是不错的机制，但是volatile不能保证原子性。因此对于同步最终还是要回到锁机制上来。</p>
<p>独占锁是一种悲观锁，<code>synchronized</code>就是一种独占锁，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。而另一个更加有效的锁就是乐观锁。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁用到的机制就是CAS，Compare and Swap。</p>
<h3 id="并发之CAS操作"><a href="#并发之CAS操作" class="headerlink" title="并发之CAS操作"></a>并发之CAS操作</h3><ul>
<li>CAS即compare and set的缩写。常见于java.util.concurrent中，是构成concurrent包的基础。</li>
<li>CAS有三个操作数，内存值M，旧的预期(expect)值E和更新(update)值U。在CAS操作中，只有当M==E时，才会更新U。否则什么都不做。这些操作都是原子的。</li>
</ul>
<h3 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h3><ul>
<li>ABA问题。 CAS操作更新的基础是如果值没有变化则更新，若有变化则不更新。但如若有一值刚开始是A，然后变为B，最后又变为A。那么CAS检查时发现它没有变化就更新了，但实际上却是已经发生了变化。</li>
<li>CAS自旋。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。 </li>
<li>只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性。</li>
</ul>
<h3 id="1-偏向锁"><a href="#1-偏向锁" class="headerlink" title="1.偏向锁"></a>1.偏向锁</h3><ul>
<li>大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁</li>
<li>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁</li>
<li>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。</li>
<li>偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正<br>在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的MarkWord要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。</li>
<li>偏向锁在Java 6和Java7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用JVM参数来关闭延迟：-XX:BiasedLockingStartupDelay=0。如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，那么程序默认会进入轻量级锁状态</li>
</ul>
<h3 id="2-轻量级锁"><a href="#2-轻量级锁" class="headerlink" title="2.轻量级锁"></a>2.轻量级锁</h3><ul>
<li><p>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的MarkWord复制到锁记录中然后线程尝试使用CAS将对象头中的MarkWord替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁</p>
</li>
<li><p>轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。</p>
</li>
</ul>
<h3 id="3-锁的优缺点对比"><a href="#3-锁的优缺点对比" class="headerlink" title="3.锁的优缺点对比"></a>3.锁的优缺点对比</h3><table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁</td>
<td>加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距</td>
<td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td>
<td>适用于只有一个线程访问同步场景</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高了程序的响应速度</td>
<td>如果始终得不到锁竞争的线程，适用自旋消耗CPU</td>
<td>追求响应时间，同步块执行速度非常快</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争不使用自旋，不会消耗CPU</td>
<td>线程阻塞，响应时间缓慢</td>
<td>追求吞吐量 同步块执行速度较长</td>
</tr>
</tbody></table>
<h2 id="7-CountDownLatch"><a href="#7-CountDownLatch" class="headerlink" title="7. CountDownLatch"></a>7. CountDownLatch</h2><p>CountDownLatch 允许一个或多个线程等待其他线程完成操作。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>假如有这样一个需求，当我们需要解析一个Excel里多个sheet的数据时，可以考虑使用多线程，每个线程解析一个sheet里的数据，等到所有的sheet都解析完之后，程序需要提示解析完成。在这个需求中，要实现主线程等待所有线程完成sheet的解析操作，最简单的做法是使用join。代码如下：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="literal">void</span> main(<span class="built_in">String</span>[] args) throws InterruptedException &#123;</span><br><span class="line">    Thread t1=<span class="keyword">new</span></span><br><span class="line">            Thread<span class="function"><span class="params">(() -&gt; System.out.println(Thread.currentThread().getName()+<span class="string">&quot; finish&quot;</span>))</span>;</span></span><br><span class="line"><span class="function">    <span class="title">Thread</span> <span class="title">t2</span>=<span class="title">new</span> </span></span><br><span class="line"><span class="function">            <span class="title">Thread</span><span class="params">(() -&gt; System.out.println(Thread.currentThread().getName()+<span class="string">&quot; finish&quot;</span>))</span>;</span></span><br><span class="line"><span class="function">    <span class="title">t1</span>.<span class="title">start</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    <span class="title">t2</span>.<span class="title">start</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    <span class="title">t1</span>.<span class="title">join</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    <span class="title">t2</span>.<span class="title">join</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(<span class="string">&quot;所有线程执行完毕 主线程执行。。。。。。。。。。。。&quot;</span>)</span>;       </span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">输出：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Thread-0</span> <span class="title">finish</span></span></span><br><span class="line"><span class="function"><span class="title">Thread-1</span> <span class="title">finish</span></span></span><br><span class="line"><span class="function">所有线程执行完毕 主线程执行。。。。。。。。。。。。</span></span><br></pre></td></tr></table></figure>
<ul>
<li>join用于让当前执行线程等待join线程执行结束。其实现原理是不停检查join线程是否存活，如果join线程存活则让当前线程永远wait</li>
<li>直到join线程中止后，线程的this.notifyAll会被调用，调用notifyAll是在JVM里实现的，所以JDK里看不到，可以看看JVM源码。JDK不推荐在线程实例上使用wait，notify和notifyAll方法。</li>
</ul>
<p> <strong>JDK1.5之后的并发包中提供的CountDownLatch也可以实现join的这个功能，并且比join的功能更多</strong> </p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> CountDownLatch c=<span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">    public <span class="keyword">static</span> <span class="literal">void</span> main(<span class="built_in">String</span>[] args) throws InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread<span class="function"><span class="params">(() -&gt;&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">             System.out.println(<span class="number">1</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">             c.countDown();</span></span></span><br><span class="line"><span class="function"><span class="params">             System.out.println(<span class="number">2</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">             c.countDown();</span></span></span><br><span class="line"><span class="function"><span class="params">        &#125;)</span>.<span class="title">start</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">         <span class="title">c</span>.<span class="title">await</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">         <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(<span class="string">&quot;3&quot;</span>)</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>CountDownLatch的构造函数接收一个int类型的参数作为计数器，如果你想等待N个点完成，这里就传入N。</p>
<ul>
<li>当我们调用一次<code>CountDownLatch</code>的<code>countDown</code>方法时，<code>N</code>就会减1，CountDownLatch的await会阻塞当前线程，直到N变成零。由于countDown方法可以用在任何地方，所以这里说的N个点，可以是N个线程，也可以是1个线程里的N个执行步骤。用在多个线程时，你只需要把这个CountDownLatch的引用传递到线程里。</li>
</ul>
<h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><p>如果有某个解析sheet的线程处理的比较慢，我们不可能让主线程一直等待，所以我们可以使用另外一个带指定时间的await方法</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">这个方法等待特定时间后，就会不再阻塞当前线程。<span class="keyword">join</span>也有类似的方法。</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span>(<span class="keyword">long</span> time, TimeUnit unit): </span><br></pre></td></tr></table></figure>
<ul>
<li>注意：计数器必须大于等于0，只是等于0时候，计数器就是零，调用await方法时不会阻塞当前线程。CountDownLatch不可能重新初始化或者修改CountDownLatch对象的内部计数器的值。一个线程调用countDown方法 happen-before 另外一个线程调用await方法。</li>
</ul>
<h2 id="8-同步屏障CyclicBarrier"><a href="#8-同步屏障CyclicBarrier" class="headerlink" title="8.  同步屏障CyclicBarrier"></a>8.  同步屏障CyclicBarrier</h2><ul>
<li>CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> CyclicBarrier c=<span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>() &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                     c.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                 System.out.<span class="built_in">println</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             c.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">         System.out.<span class="built_in">println</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：<span class="number">2</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">如果把<span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>)修改成<span class="keyword">new</span> CyclicBarrier(<span class="number">3</span>)则主线程和子线程会永远等待，因为没有第三个线程执行await方法，即没有第三个线程到达屏障，所以之前到达屏障的两个线程都不会继续执行。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>CyclicBarrier的内部是使用重入锁ReentrantLock和Condition。它有两个构造函数：</p>
<ul>
<li>CyclicBarrier(int parties)：创建一个新的 CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，但它不会在启动 barrier 时执行预定义的操作。</li>
<li>CyclicBarrier还提供一个更高级的构造函数CyclicBarrier(int parties, Runnable barrierAction)，用于在线程到达屏障时，优先执行barrierAction，方便处理更复杂的业务场景</li>
</ul>
<p>代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CyclicBarrierTest2</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">A</span> <span class="title">implements</span> <span class="title">Runnable</span>&#123;</span><br><span class="line">        @Override</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">             System.<span class="keyword">out</span>.println(<span class="number">3</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> CyclicBarrier c=<span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>, <span class="keyword">new</span> A());</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    c.<span class="keyword">await</span>();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;                 </span><br><span class="line">                &#125;</span><br><span class="line">                 System.<span class="keyword">out</span>.println(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c.<span class="keyword">await</span>();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;     </span><br><span class="line">        &#125;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：<span class="number">3</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="CyclicBarrier的应用场景"><a href="#CyclicBarrier的应用场景" class="headerlink" title="CyclicBarrier的应用场景"></a>CyclicBarrier的应用场景</h3><ul>
<li>CyclicBarrier可以用于多线程计算数据，最后合并计算结果的应用场景。比如我们用一个Excel保存了用户所有银行流水，每个Sheet保存一个帐户近一年的每笔银行流水，现在需要统计用户的日均银行流水，先用多线程处理每个sheet里的银行流水，都执行完之后，得到每个sheet的日均银行流水，最后，再用barrierAction用这些线程的计算结果，计算出整个Excel的日均银行流水。</li>
</ul>
<p>应用示例 比如我们开会只有等所有的人到齐了才会开会，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  CyclicBarrier试用与多线程结果合并的操作，用于多线程计算数据，最后合并计算结果的应用场景</span></span><br><span class="line"><span class="comment"> *  比如我们需要统计多个Excel中的数据，然后等到一个总结果。我们可以通过多线程处理每一个Excel，执行完成后得到相应的结果，</span></span><br><span class="line"><span class="comment"> *  最后通过barrierAction来计算这些线程的计算结果，得到所有Excel的总和。 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> qxw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> 2018年7月26日下午3:00:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier cyclicBarrier;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;到了&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//应用示例 比如我们开会只有等所有的人到齐了才会开会，如下：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        cyclicBarrier=<span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>, <span class="keyword">new</span> Runnable() &#123;         </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;人到齐了 开会吧....&quot;</span>);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> CyclicBarrierThread().start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/151054_8c6b0b98_1478371.png" alt="输入图片说明" title="屏幕截图.png"></p>
<p>在CyclicBarrier中最重要的方法莫过于await()方法，在所有参与者都已经在此 barrier 上调用 await 方法之前，将一直等待。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/145223_d2deafdc_1478371.png" alt="输入图片说明" title="屏幕截图.png"></p>
<p>await()方法内部调用dowait(boolean timed, long nanos)方法：</p>
<p>其实await()的处理逻辑还是比较简单的：如果该线程不是到达的最后一个线程，则他会一直处于等待状态，除非发生以下情况：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/145317_2332e0eb_1478371.png" alt="输入图片说明" title="屏幕截图.png"></p>
<h3 id="CyclicBarrier和CountDownLatch的区别"><a href="#CyclicBarrier和CountDownLatch的区别" class="headerlink" title="CyclicBarrier和CountDownLatch的区别"></a>CyclicBarrier和CountDownLatch的区别</h3><ul>
<li>CountDownLatch的计数器只能使用一次。而CyclicBarrier的计数器可以使用reset() 方法重置。所以CyclicBarrier能处理更为复杂的业务场景，比如如果计算发生错误，可以重置计数器，并让线程们重新执行一次。</li>
<li>CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得CyclicBarrier阻塞的线程数量。isBroken方法用来知道阻塞的线程是否被中断。</li>
</ul>
<p>比如以下代码执行完之后会返回true。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest4</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> CyclicBarrier c = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>() &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    c.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.interrupt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">             System.out.<span class="built_in">println</span>(c.isBroken());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-并发工具类Exchanger"><a href="#9-并发工具类Exchanger" class="headerlink" title="9. 并发工具类Exchanger"></a>9. 并发工具类Exchanger</h2><p>Exchanger，它允许在并发任务之间交换数据。具体来说，Exchanger类允许在两个线程之间定义同步点。当两个线程都到达同步点时，他们交换数据结构，因此第一个线程的数据结构进入到第二个线程中，第二个线程的数据结构进入到第一个线程中。</p>
<h3 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">     <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="title">implements</span> <span class="title">Runnable</span>&#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//生产者、消费者交换的数据结构</span></span><br><span class="line">         <span class="keyword">private</span> List&lt;<span class="keyword">String</span>&gt; <span class="built_in">buffer</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生产者和消费者的交换对象</span></span><br><span class="line">         <span class="keyword">private</span> Exchanger&lt;List&lt;<span class="keyword">String</span>&gt;&gt; exchanger;</span><br><span class="line">         </span><br><span class="line">         Producer(List&lt;<span class="keyword">String</span>&gt; <span class="built_in">buffer</span>,Exchanger&lt;List&lt;<span class="keyword">String</span>&gt;&gt; exchanger)&#123;</span><br><span class="line">             <span class="keyword">this</span>.<span class="built_in">buffer</span>=<span class="built_in">buffer</span>;</span><br><span class="line">             <span class="keyword">this</span>.exchanger=exchanger;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">        @Override</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.<span class="built_in">println</span>(<span class="string">&quot;生产者第&quot;</span> +i +<span class="string">&quot;次提供&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;=<span class="number">3</span>; j++) &#123;</span><br><span class="line">                    System.out.<span class="built_in">println</span>(<span class="string">&quot;生产者装入&quot;</span>+ i  +  <span class="string">&quot;--&quot;</span> + j);</span><br><span class="line">                    <span class="built_in">buffer</span>.add(<span class="string">&quot;buffer :&quot;</span>+i +<span class="string">&quot;--&quot;</span>+j);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.<span class="built_in">println</span>(<span class="string">&quot;生产者装满,等待与消费者交换....&quot;</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    exchanger.exchange(<span class="built_in">buffer</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="title">implements</span> <span class="title">Runnable</span>&#123;</span></span><br><span class="line">         <span class="keyword">private</span> List&lt;<span class="keyword">String</span>&gt; <span class="built_in">buffer</span>;</span><br><span class="line">         <span class="keyword">private</span> Exchanger&lt;List&lt;<span class="keyword">String</span>&gt;&gt; exchanger;</span><br><span class="line">         </span><br><span class="line">         Consumer(List&lt;<span class="keyword">String</span>&gt; <span class="built_in">buffer</span>,Exchanger&lt;List&lt;<span class="keyword">String</span>&gt;&gt; exchanger)&#123;</span><br><span class="line">             <span class="keyword">this</span>.<span class="built_in">buffer</span>=<span class="built_in">buffer</span>;</span><br><span class="line">             <span class="keyword">this</span>.exchanger=exchanger;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">        @Override</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="comment">//调用exchange()与消费者进行数据交换</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="built_in">buffer</span>=exchanger.exchange(<span class="built_in">buffer</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.<span class="built_in">println</span>(<span class="string">&quot;消费者第&quot;</span> + i + <span class="string">&quot;次提取&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;=<span class="number">3</span>; j++) &#123;</span><br><span class="line">                    System.out.<span class="built_in">println</span>(<span class="string">&quot;消费者： &quot;</span>+<span class="built_in">buffer</span>.<span class="built_in">get</span>(<span class="number">0</span>));</span><br><span class="line">                    <span class="built_in">buffer</span>.<span class="built_in">remove</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;    </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;<span class="keyword">String</span>&gt; buffer1=<span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;();</span><br><span class="line">        List&lt;<span class="keyword">String</span>&gt; buffer2=<span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;();</span><br><span class="line">        Exchanger&lt;List&lt;<span class="keyword">String</span>&gt;&gt; exchanger=<span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span>  Producer(buffer1, exchanger));</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(<span class="keyword">new</span>  Consumer(buffer2, exchanger));</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>首先生产者Producer、消费者Consumer首先都创建一个缓冲列表，通过Exchanger来同步交换数据。消费中通过调用Exchanger与生产者进行同步来获取数据，而生产者则通过for循环向缓存队列存储数据并使用exchanger对象消费者同步。到消费者从exchanger哪里得到数据后，他的缓冲列表中有3个数据，而生产者得到的则是一个空的列表。上面的例子充分展示了消费者-生产者是如何利用Exchanger来完成数据交换的。</li>
</ul>
<p>在Exchanger中，如果一个线程已经到达了exchanger节点时，对于它的伙伴节点的情况有三种:</p>
<ol>
<li>如果它的伙伴节点在该线程到达之前已经调用了exchanger方法，则它会唤醒它的伙伴然后进行数据交换，得到各自数据返回。</li>
</ol>
<ol>
<li>如果它的伙伴节点还没有到达交换点，则该线程将会被挂起，等待它的伙伴节点到达被唤醒，完成数据交换。</li>
<li>如果当前线程被中断了则抛出异常，或者等待超时了，则抛出超时异常。</li>
</ol>
<h2 id="10-控制并发线程数Semaphore"><a href="#10-控制并发线程数Semaphore" class="headerlink" title="10.  控制并发线程数Semaphore"></a>10.  控制并发线程数Semaphore</h2><ul>
<li>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。很多年以来，我都觉得从字面上很难理解Semaphore所表达的含义，只能把它比作是控制流量的红绿灯，比如XX马路要限制流量，只允许同时有一百辆车在这条路上行使，其他的都必须在路口等待，所以前一百辆车会看到绿灯，可以开进这条马路，后面的车会看到红灯，不能驶入XX马路，但是如果前一百辆中有五辆车已经离开了XX马路，那么后面就允许有5辆车驶入马路，这个例子里说的车就是线程，驶入马路就表示线程在执行，离开马路就表示线程执行完成，看见红灯就表示线程被阻塞，不能执行。</li>
</ul>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul>
<li>Semaphore(int permits) ：创建具有给定的许可数和非公平的公平设置的 Semaphore。</li>
<li>Semaphore(int permits, boolean fair) ：创建具有给定的许可数和给定的公平设置的 Semaphore。</li>
</ul>
<p><img src="https://images.gitee.com/uploads/images/2018/0727/133123_0786a3a1_1478371.png" alt="输入图片说明" title="屏幕截图.png"></p>
<p> <strong>Semaphore默认选择非公平锁。</strong> </p>
<p>当信号量Semaphore = 1 时，它可以当作互斥锁使用。其中0、1就相当于它的状态，当=1时表示其他线程可以获取，当=0时，排他，即其他线程必须要等待。</p>
<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>Semaphore可以用于做流量控制，特别公用资源有限的应用场景。比如数据库连接。假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发的读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有十个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。</li>
</ul>
<p>这个时候，我们就可以使用Semaphore来做流控，代码如下：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> SemaphoreTest &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> static final <span class="built_in">int</span> SIZE=<span class="number">5</span>;</span><br><span class="line">    <span class="comment">//创建固定数量的线程池</span></span><br><span class="line">    <span class="keyword">private</span> static  ExecutorService threadPool=<span class="module-access"><span class="module"><span class="identifier">Executors</span>.</span></span><span class="keyword">new</span><span class="constructor">FixedThreadPool(SIZE)</span>;  </span><br><span class="line">    <span class="comment">//允许并发的线程数</span></span><br><span class="line">    <span class="keyword">private</span> static Semaphore s = <span class="keyword">new</span> <span class="constructor">Semaphore(3)</span>;</span><br><span class="line"></span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; SIZE; i++) &#123;</span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> <span class="constructor">Runnable()</span> &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run<span class="literal">()</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//获取取一个许可证</span></span><br><span class="line">                        s.acquire<span class="literal">()</span>;</span><br><span class="line">                        long time=(long)(<span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>random<span class="literal">()</span>*<span class="number">10</span>);</span><br><span class="line"><span class="comment">//                      System.out.println(&quot;此信号量中当前可用的许可证数:  &quot;+s.availablePermits());</span></span><br><span class="line"><span class="comment">//                      System.out.println(&quot;正在等待获取许可证的线程数:  &quot;+s.getQueueLength());</span></span><br><span class="line"><span class="comment">//                      System.out.println(&quot;是否有线程正在等待获取许可证:  &quot;+s.hasQueuedThreads());</span></span><br><span class="line">                        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span>+<span class="string">&quot;  从内存中读取存储到数据库耗时 ：&quot;</span>+time+<span class="string">&quot;秒。。。。&quot;</span>);</span><br><span class="line">                        <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>sleep(time);                     </span><br><span class="line">                        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span>+<span class="string">&quot; 释放数据库链接&quot;</span>);                        </span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">                    &#125;finally&#123;</span><br><span class="line">                        <span class="comment">//使用完之后调用release()归还许可证。还可以用tryAcquire()方法尝试获取许可证。</span></span><br><span class="line">                        s.release<span class="literal">()</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">         threadPool.shutdown<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在代码中，虽然有5个线程在执行，但是只允许3个并发的执行。Semaphore的构造方法Semaphore(int permits) 接受一个整型的数字，表示可用的许可证数量。Semaphore(3)表示允许3个线程获取许可证，也就是最大并发数是3。Semaphore的用法也很简单，首先线程使用Semaphore的acquire()获取一个许可证，使用完之后调用release()归还许可证。还可以用tryAcquire()方法尝试获取许可证。</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Semaphore还提供一些其他方法：</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> available<span class="constructor">Permits()</span> ：返回此信号量中当前可用的许可证数。</span><br><span class="line"><span class="built_in">int</span> get<span class="constructor">QueueLength()</span>：返回正在等待获取许可证的线程数。</span><br><span class="line">boolean has<span class="constructor">QueuedThreads()</span> ：是否有线程正在等待获取许可证。</span><br><span class="line">void reduce<span class="constructor">Permits(<span class="params">int</span> <span class="params">reduction</span>)</span> ：减少reduction个许可证。是个protected方法。</span><br><span class="line">Collection get<span class="constructor">QueuedThreads()</span> ：返回所有等待获取许可证的线程集合。是个protected方法。</span><br></pre></td></tr></table></figure>

<h2 id="11-乐观锁与悲观锁"><a href="#11-乐观锁与悲观锁" class="headerlink" title="11. 乐观锁与悲观锁"></a>11. 乐观锁与悲观锁</h2><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><ul>
<li><p>总是认为不会产生并发问题，每次去取数据的时候总认为不会有其他线程对数据进行修改，因此不会上锁，但是在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用版本号机制或CAS操作实现。</p>
</li>
<li><p>version方式：一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</p>
<p><strong>核心SQL代码：</strong> </p>
</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">update table <span class="builtin-name">set</span> <span class="attribute">x</span>=x+1, <span class="attribute">version</span>=version+1 where <span class="attribute">id</span>=#&#123;id&#125; <span class="keyword">and</span> <span class="attribute">version</span>=#&#123;version&#125;;  </span><br></pre></td></tr></table></figure>
<ul>
<li>CAS操作方式：即compare and swap(比较并交换) 或者 compare and set，涉及到三个操作数，数据所在的内存值，预期值，新值。当需要更新时，判断当前内存值与之前取到的值是否相等，若相等，则用新值更新，若失败则重试，一般情况下是一个自旋操作，即不断的重试。</li>
</ul>
<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><ul>
<li>总是假设最坏的情况，每次取数据时都认为其他线程会修改，所以都会加锁（读锁、写锁、行锁等），当其他线程想要访问数据时，都需要阻塞挂起。可以依靠数据库实现，如行锁、读锁和写锁等，都是在操作之前加锁，在Java中，synchronized的思想也是悲观锁。</li>
</ul>
<h3 id="程序中的乐观锁与悲观锁"><a href="#程序中的乐观锁与悲观锁" class="headerlink" title="程序中的乐观锁与悲观锁"></a>程序中的乐观锁与悲观锁</h3><p> <strong>概念:</strong> </p>
<ol>
<li>这里抛开数据库来谈乐观锁和悲观锁,扯上数据库总会觉得和Java离得很远.</li>
<li>悲观锁:一段执行逻辑加上悲观锁,不同线程同时执行时,只能有一个线程执行,其他的线程在入口处等待,直到锁被释放.</li>
<li>乐观锁:一段执行逻辑加上乐观锁,不同线程同时执行时,可以同时进入执行,在最后更新数据的时候要检查这些数据是否被其他线程修改了(版本和执行初是否相同),没有修改则进行更新,否则放弃本次操作.</li>
</ol>
<p>从解释上可以看出,悲观锁具有很强的独占性,也是最安全的.而乐观锁很开放,效率高,安全性比悲观锁低,因为在乐观锁检查数据版本一致性时也可能被其他线程修改数据.</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">package com.example.<span class="keyword">lock</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 乐观锁实现</span></span><br><span class="line"><span class="comment"> * @author qinxuewu</span></span><br><span class="line"><span class="comment"> * @version 1.00</span></span><br><span class="line"><span class="comment"> * @time 20/7/2018下午 12:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OptimisticLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="keyword">value</span> = <span class="number">0</span>; <span class="comment">// 多线程同时调用的操作对象</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A线程要执行的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invoke</span>(<span class="params"><span class="keyword">int</span> Avalue, String i</span>) throws InterruptedException</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);<span class="comment">//延长执行时间</span></span><br><span class="line">        <span class="keyword">if</span> (Avalue != <span class="keyword">value</span>) &#123;<span class="comment">//判断value版本</span></span><br><span class="line">            System.<span class="keyword">out</span>.println(Avalue + <span class="string">&quot;:&quot;</span> + <span class="keyword">value</span> + <span class="string">&quot;A版本不一致,不执行&quot;</span>);</span><br><span class="line">            <span class="keyword">value</span>--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Avalue++;<span class="comment">//对数据操作</span></span><br><span class="line">            <span class="keyword">value</span> = Avalue;;<span class="comment">//对数据操作</span></span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;invoke:   &quot;</span>+i + <span class="string">&quot;:&quot;</span> + <span class="keyword">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * B线程要执行的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invoke2</span>(<span class="params"><span class="keyword">int</span> Bvalue, String i</span>)</span></span><br><span class="line"><span class="function">            throws InterruptedException</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);<span class="comment">//延长执行时间</span></span><br><span class="line">        <span class="keyword">if</span> (Bvalue != <span class="keyword">value</span>) &#123;<span class="comment">//判断value版本</span></span><br><span class="line">            System.<span class="keyword">out</span>.println(Bvalue + <span class="string">&quot;:&quot;</span> + <span class="keyword">value</span> + <span class="string">&quot;B版本不一致,不执行&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;B:利用value运算,value=&quot;</span>+Bvalue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试,期待结果:B线程执行的时候value数据总是当前最新的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws InterruptedException</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;<span class="comment">//A线程</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                        <span class="keyword">int</span> Avalue = OptimisticLock.<span class="keyword">value</span>;<span class="comment">//A获取的value</span></span><br><span class="line">                        OptimisticLock.invoke(Avalue, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;<span class="comment">//B线程</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                        <span class="keyword">int</span> Bvalue = OptimisticLock.<span class="keyword">value</span>;<span class="comment">//B获取的value</span></span><br><span class="line">                        OptimisticLock.invoke2(Bvalue, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>测试结果:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">A:<span class="number">1</span></span><br><span class="line"><span class="number">0</span>:<span class="number">1</span>B版本不一致,不执行</span><br><span class="line">B:利用value运算,value=<span class="number">1</span></span><br><span class="line">A:<span class="number">2</span></span><br><span class="line">B:利用value运算,value=<span class="number">2</span></span><br><span class="line">A:<span class="number">3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">从结果中看出,B线程在执行的时候最后发现自己的value和执行前不一致,说明被A修改了,那么放弃了本次执行.</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">多运行几次发现了下面的结果:</span><br><span class="line"></span><br><span class="line">A:<span class="number">1</span></span><br><span class="line">B:利用value运算,value=<span class="number">0</span></span><br><span class="line">A:<span class="number">2</span></span><br><span class="line"><span class="number">1</span>:<span class="number">2</span>B版本不一致,不执行</span><br><span class="line">A:<span class="number">3</span></span><br><span class="line">B:利用value运算,value=<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>从结果看A修改了value值,B却没有检查出来,利用错误的value值进行了操作. 为什么会这样呢?</p>
<p>这里就回到前面说的乐观锁是有一定的不安全性的,B在检查版本的时候A还没有修改,在B检查完版本后更新数据前(例子中的输出语句),A更改了value值,这时B执行更新数据(例子中的输出语句)就发生了与现存value不一致的现象.</p>
<p>针对这个问题,我觉得乐观锁要解决这个问题还需要在检查版本与更新数据这个操作的时候能够使用悲观锁,比如加上synchronized,让它在最后一步保证数据的一致性.这样既保证多线程都能同时执行,牺牲最后一点的性能去保证数据的一致.</p>
<p> <strong>有两种方式来保证乐观锁最后同步数据保证它原子性的方法</strong> </p>
<ul>
<li><p>1,CAS方式:Java非公开API类Unsafe实现的CAS(比较-交换),由C++编写的调用硬件操作内存,保证这个操作的原子性,concurrent包下很多乐观锁实现使用到这个类,但这个类不作为公开API使用,随时可能会被更改.我在本地测试了一下,确实不能够直接调用,源码中Unsafe是私有构造函数,只能通过getUnsafe方法获取单例,首先去掉eclipse的检查(非API的调用限制)限制以后,执行发现报 java.lang.SecurityException异常,源码中getUnsafe方法中执行访问检查,看来java不允许应用程序获取Unsafe类. 值得一提的是反射是可以得到这个类对象的.</p>
</li>
<li></li>
<li><p>2,加锁方式:利用Java提供的现有API来实现最后数据同步的原子性(用悲观锁).看似乐观锁最后还是用了悲观锁来保证安全,效率没有提高.实际上针对于大多数只执行不同步数据的情况,效率比悲观加锁整个方法要高.特别注意:针对一个对象的数据同步,悲观锁对这个对象加锁和乐观锁效率差不多,如果是多个需要同步数据的对象,乐观锁就比较方便.</p>
</li>
</ul>
<h2 id="12-ReentrantLock实现原理"><a href="#12-ReentrantLock实现原理" class="headerlink" title="12. ReentrantLock实现原理"></a>12. ReentrantLock实现原理</h2><p><a href="https://blog.csdn.net/yanyan19880509/article/details/52345422/">原理解释</a></p>
<ul>
<li>ReentrantLock支持两种获取锁的方式，一种是公平模型，一种是非公平模型</li>
<li>使用 synchronize 来做同步处理时，锁的获取和释放都是隐式的，实现的原理是通过编译后加上不同的机器指令来实现。</li>
<li>而 ReentrantLock 就是一个普通的类，它是基于 AQS(AbstractQueuedSynchronizer)来实现的。是一个重入锁：一个线程获得了锁之后仍然可以反复的加锁，不会出现自己阻塞自己的情况。</li>
</ul>
<p>什么是AQS</p>
<ul>
<li>AQS即是AbstractQueuedSynchronizer，一个用来构建锁和同步工具的框架，包括常用的ReentrantLock、CountDownLatch、Semaphore等。</li>
<li>AQS没有锁之类的概念，它有个state变量，是个int类型，在不同场合有着不同含义。本文研究的是锁，为了好理解，姑且先把state当成锁。</li>
<li>AQS围绕state提供两种基本操作“获取”和“释放”，有条双向队列存放阻塞的等待线程，并提供一系列判断和处理方法，<br>简单说几点： state是独占的，还是共享的；</li>
</ul>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">state</span>被获取后，其他线程需要等待；</span><br><span class="line"><span class="keyword">state</span>被释放后，唤醒等待线程；</span><br><span class="line">线程等不及时，如何退出等待。</span><br></pre></td></tr></table></figure>


<h3 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认非公平锁</span></span><br><span class="line">  public <span class="constructor">ReentrantLock()</span> &#123;</span><br><span class="line">      sync = <span class="keyword">new</span> <span class="constructor">NonfairSync()</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//公平锁</span></span><br><span class="line">  public <span class="constructor">ReentrantLock(<span class="params">boolean</span> <span class="params">fair</span>)</span> &#123;</span><br><span class="line">      sync = fair ? <span class="keyword">new</span> <span class="constructor">FairSync()</span> : <span class="keyword">new</span> <span class="constructor">NonfairSync()</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>默认一般使用非公平锁，它的效率和吞吐量都比公平锁高的多</li>
<li>ReentrantLock的内部类Sync继承了AQS，分为公平锁FairSync和非公平锁NonfairSync。</li>
<li>公平锁：线程获取锁的顺序和调用lock的顺序一样，FIFO；</li>
<li>非公平锁：线程获取锁的顺序和调用lock的顺序无关，全凭运气。</li>
</ul>
<h3 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认非公平锁，</span></span><br><span class="line"> <span class="keyword">private</span> ReentrantLock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">// private ReentrantLock lock = new ReentrantLock(true); 公平锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//do bussiness</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">lock</span>.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h3 id="公平锁获取锁"><a href="#公平锁获取锁" class="headerlink" title="公平锁获取锁"></a>公平锁获取锁</h3><p>首先看下获取锁的过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到是使用 <code>sync</code>的方法，而这个方法是一个抽象方法，具体是由其子类(<code>FairSync</code>)来实现的，以下是公平锁的实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AbstractQueuedSynchronizer 中的 acquire()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">    acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">    selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一步是尝试获取锁(<code>tryAcquire(arg)</code>),这个也是由其子类实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先会判断 <code>AQS</code> 中的 <code>state</code> 是否等于 0，0 表示目前没有其他线程获得锁，当前线程就可以尝试获取锁。</p>
<p><strong>注意</strong>:尝试之前会利用 <code>hasQueuedPredecessors()</code> 方法来判断 AQS 的队列中中是否有其他线程，如果有则不会尝试获取锁(<strong>这是公平锁特有的情况</strong>)。</p>
<p>如果队列中没有线程就利用 CAS 来将 AQS 中的 state 修改为1，也就是获取锁，获取成功则将当前线程置为获得锁的独占线程(<code>setExclusiveOwnerThread(current)</code>)。</p>
<p>如果 <code>state</code> 大于 0 时，说明锁已经被获取了，则需要判断获取锁的线程是否为当前线程(<code>ReentrantLock</code> 支持重入)，是则需要将 <code>state + 1</code>，并将值更新。</p>
<h3 id="写入队列"><a href="#写入队列" class="headerlink" title="写入队列"></a>写入队列</h3><p>如果 <code>tryAcquire(arg)</code> 获取锁失败，则需要用 <code>addWaiter(Node.EXCLUSIVE)</code> 将当前线程写入队列中。</p>
<p>写入之前需要将当前线程包装为一个 <code>Node</code> 对象(<code>addWaiter(Node.EXCLUSIVE)</code>)。</p>
<blockquote>
<p>AQS 中的队列是由 Node 节点组成的双向链表实现的。</p>
</blockquote>
<p>包装代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先判断队列是否为空，不为空时则将封装好的 <code>Node</code> 利用 <code>CAS</code> 写入队尾，如果出现并发写入失败就需要调用 <code>enq(node);</code> 来写入了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个处理逻辑就相当于<code>自旋</code>加上 <code>CAS</code> 保证一定能写入队列。</p>
<h3 id="挂起等待线程"><a href="#挂起等待线程" class="headerlink" title="挂起等待线程"></a>挂起等待线程</h3><p>写入队列之后需要将当前线程挂起(利用<code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</code>)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先会根据 <code>node.predecessor()</code> 获取到上一个节点是否为头节点，如果是则尝试获取一次锁，获取成功就万事大吉了。</p>
<p>如果不是头节点，或者获取锁失败，则会根据上一个节点的 <code>waitStatus</code> 状态来处理(<code>shouldParkAfterFailedAcquire(p, node)</code>)。</p>
<p><code>waitStatus</code> 用于记录当前节点的状态，如节点取消、节点等待等。</p>
<p><code>shouldParkAfterFailedAcquire(p, node)</code> 返回当前线程是否需要挂起，如果需要则调用 <code>parkAndCheckInterrupt()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>他是利用 <code>LockSupport</code> 的 <code>part</code> 方法来挂起当前线程的，直到被唤醒。</p>
<h3 id="非公平锁获取锁"><a href="#非公平锁获取锁" class="headerlink" title="非公平锁获取锁"></a>非公平锁获取锁</h3><p>公平锁与非公平锁的差异主要在获取锁：</p>
<p>公平锁就相当于买票，后来的人需要排到队尾依次买票，<strong>不能插队</strong>。</p>
<p>而非公平锁则没有这些规则，是<strong>抢占模式</strong>，每来一个人不会去管队列如何，直接尝试获取锁。</p>
<p>非公平锁:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//直接尝试获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>公平锁:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还要一个重要的区别是在尝试获取锁时<code>tryAcquire(arg)</code>，非公平锁是不需要判断队列中是否还有其他线程，也是直接尝试获取锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//没有 !hasQueuedPredecessors() 判断</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="释放锁-1"><a href="#释放锁-1" class="headerlink" title="释放锁"></a>释放锁</h3><p>公平锁和非公平锁的释放流程都是一样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">               <span class="comment">//唤醒被挂起的线程</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试释放锁</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure>

<p>首先会判断当前线程是否为获得锁的线程，由于是重入锁所以需要将 <code>state</code> 减到 0 才认为完全释放锁。</p>
<p>释放之后需要调用 <code>unparkSuccessor(h)</code> 来唤醒被挂起的线程。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>由于公平锁需要关心队列的情况，得按照队列里的先后顺序来获取锁(会造成大量的线程上下文切换)，而非公平锁则没有这个限制。</p>
<p>所以也就能解释非公平锁的效率会被公平锁更高。</p>
<h3 id="羊群效应"><a href="#羊群效应" class="headerlink" title="羊群效应"></a>羊群效应</h3><ul>
<li>这里说一下羊群效应，当有多个线程去竞争同一个锁的时候，假设锁被某个线程占用，那么如果有成千上万个线程在等待锁，有一种做法是同时唤醒这成千上万个线程去去竞争锁，这个时候就发生了羊群效应，海量的竞争必然造成资源的剧增和浪费，因此终究只能有一个线程竞争成功，其他线程还是要老老实实的回去等待。AQS的FIFO的等待队列给解决在锁竞争方面的羊群效应问题提供了一个思路：保持一个FIFO队列，队列每个节点只关心其前一个节点的状态，线程唤醒也只唤醒队头等待线程。其实这个思路已经被应用到了分布式锁的实践中，见：Zookeeper分布式锁的改进实现方案。</li>
</ul>
<h2 id="13-阻塞队列ArrayBlockingQueu"><a href="#13-阻塞队列ArrayBlockingQueu" class="headerlink" title="13. 阻塞队列ArrayBlockingQueu"></a>13. 阻塞队列ArrayBlockingQueu</h2><ul>
<li>ArrayBlockingQueue，一个由数组实现的有界阻塞队列。该队列采用FIFO的原则对元素进行排序添加的。</li>
<li>ArrayBlockingQueue为有界且固定，其大小在构造时由构造函数来决定，确认之后就不能再改变了。</li>
<li>ArrayBlockingQueue支持对等待的生产者线程和使用者线程进行排序的可选公平策略，但是在默认情况下不保证线程公平的访问，在构造时可以选择公平策略（fair = true）。公平性通常会降低吞吐量，但是减少了可变性和避免了“不平衡性”。</li>
</ul>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">ArrayBlockingQueue</span>&lt;<span class="symbol">E</span>&gt; <span class="symbol">extends</span> <span class="symbol">AbstractQueue</span>&lt;<span class="symbol">E</span>&gt; <span class="symbol">implements</span> <span class="symbol">BlockingQueue</span>&lt;<span class="symbol">E</span>&gt;, <span class="symbol">Serializable</span> &#123;</span><br><span class="line">       <span class="keyword">private</span> static <span class="keyword">final</span> long serialVersionUID = <span class="number">-817911632652898426</span>L;</span><br><span class="line">       <span class="keyword">final</span> Object[] items;</span><br><span class="line">       <span class="built_in">int</span> takeIndex;</span><br><span class="line">       <span class="built_in">int</span> putIndex;</span><br><span class="line">       <span class="built_in">int</span> count;</span><br><span class="line">       <span class="comment">// 重入锁</span></span><br><span class="line">       <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line">       <span class="comment">// notEmpty condition</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line">       <span class="comment">// notFull condition</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line">       transient ArrayBlockingQueue.Itrs itrs;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>可以清楚地看到ArrayBlockingQueue继承AbstractQueue，实现BlockingQueue接口。看过java.util包源码的同学应该都认识AbstractQueue，改类在Queue接口中扮演着非常重要的作用，该类提供了对queue操作的骨干实现（具体内容移驾其源码）。BlockingQueue继承java.util.Queue为阻塞队列的核心接口，提供了在多线程环境下的出列、入列操作，作为使用者，则不需要关心队列在什么时候阻塞线程，什么时候唤醒线程，所有一切均由BlockingQueue来完成。</p>
<p><strong>ArrayBlockingQueue内部使用可重入锁ReentrantLock + Condition来完成多线程环境的并发操作。</strong> </p>
</li>
<li><p>items，一个定长数组，维护ArrayBlockingQueue的元素</p>
</li>
<li><p>takeIndex，int，为ArrayBlockingQueue对首位置</p>
</li>
<li><p>putIndex，int，ArrayBlockingQueue对尾位置</p>
</li>
<li><p>count，元素个数</p>
</li>
<li><p>lock，锁，ArrayBlockingQueue出列入列都必须获取该锁，两个步骤公用一个锁</p>
</li>
<li><p>notEmpty，出列条件</p>
</li>
<li><p>notFull，入列条件</p>
<p><strong>入队</strong> </p>
</li>
</ul>
<p>ArrayBlockingQueue提供了诸多方法，可以将元素加入队列尾部。</p>
<ul>
<li>add(E e) ：将指定的元素插入到此队列的尾部（如果立即可行且不会超过该队列的容量），在成功时返回 true，如果此队列已满，则抛出 IllegalStateException</li>
<li>offer(E e) :将指定的元素插入到此队列的尾部（如果立即可行且不会超过该队列的容量），在成功时返回 true，如果此队列已满，则返回 false</li>
<li>offer(E e, long timeout, TimeUnit unit) :将指定的元素插入此队列的尾部，如果该队列已满，则在到达指定的等待时间之前等待可用的空间</li>
<li>put(E e) :将指定的元素插入此队列的尾部，如果该队列已满，则等待可用的空间</li>
</ul>
<h3 id="add-E-e）"><a href="#add-E-e）" class="headerlink" title="add(E e）"></a>add(E e）</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">add</span><span class="params">(e)</span></span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (offer(e))</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Queue full&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>add方法调用offer(E e)，如果返回false，则直接抛出IllegalStateException异常。offer(E e)为ArrayBlockingQueue实现：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">offer</span>(<span class="params">E e</span>)</span> &#123;</span><br><span class="line">       checkNotNull(e);</span><br><span class="line">       final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;</span><br><span class="line">       <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (count == items.length)</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               enqueue(e);</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">lock</span>.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>方法首先检查是否为null，然后获取lock锁。获取锁成功后，如果队列已满则直接返回false，否则调用enqueue(E e)，enqueue(E e)为入列的核心方法，所有入列的方法最终都将调用该方法在队列尾部插入元素：</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> void enqueue(E x) &#123;</span><br><span class="line">       <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">       <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">       final Object[] <span class="built_in">items</span> = this.<span class="built_in">items</span>;</span><br><span class="line">       <span class="built_in">items</span>[putIndex] = x;</span><br><span class="line">       <span class="keyword">if</span> (++putIndex == <span class="built_in">items</span>.length)</span><br><span class="line">           putIndex = <span class="number">0</span>;</span><br><span class="line">       <span class="built_in">count</span>++;</span><br><span class="line">       notEmpty.signal();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>该方法就是在putIndex（对尾）为知处添加元素，最后使用notEmpty的signal()方法通知阻塞在出列的线程（如果队列为空，则进行出列操作是会阻塞）。</p>
<h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><ul>
<li><p>poll() :获取并移除此队列的头，如果此队列为空，则返回 null</p>
</li>
<li><p>poll(long timeout, TimeUnit unit) :获取并移除此队列的头部，在指定的等待时间前等待可用的元素（如果有必要）</p>
</li>
<li><p>remove(Object o) :从此队列中移除指定元素的单个实例（如果存在）</p>
</li>
<li><p>take() :获取并移除此队列的头部，在元素变得可用之前一直等待（如果有必要）</p>
<p><strong>poll()</strong> </p>
</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">       final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;</span><br><span class="line">       <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="literal">null</span> : dequeue();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">lock</span>.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>如果队列为空返回null，否则调用dequeue()获取列头元素：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> E dequeue() &#123;</span><br><span class="line">        <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">        E x = (E) items[takeIndex];</span><br><span class="line">        items[takeIndex] = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">            takeIndex = <span class="number">0</span>;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span> (itrs != <span class="literal">null</span>)</span><br><span class="line">            itrs.elementDequeued();</span><br><span class="line">        notFull.signal();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>该方法主要是从列头（takeIndex 位置）取出元素，同时如果迭代器itrs不为null，则需要维护下该迭代器。最后调用notFull.signal()唤醒入列线程。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span>(<span class="params"></span>) throws InterruptedException</span> &#123;</span><br><span class="line">       final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;</span><br><span class="line">       <span class="keyword">lock</span>.lockInterruptibly();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">               notEmpty.<span class="keyword">await</span>();</span><br><span class="line">           <span class="keyword">return</span> dequeue();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">lock</span>.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>take()与poll()存在一个区别就是count == 0 时的处理，poll()直接返回null，而take()则是在notEmpty上面等待直到被入列的线程唤醒。</p>
<h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueueTest</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//队列中存满20个元素 在添加新的元素 会一直阻塞</span></span><br><span class="line">        ArrayBlockingQueue&lt;<span class="keyword">String</span>&gt; <span class="built_in">queue</span>=<span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">21</span>; i++) &#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(i);</span><br><span class="line">            <span class="built_in">queue</span>.<span class="built_in">put</span>(<span class="string">&quot;put :&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;size:&quot;</span>+<span class="built_in">queue</span>.<span class="built_in">size</span>());</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-同步队列SynchronousQueue"><a href="#13-同步队列SynchronousQueue" class="headerlink" title="13. 同步队列SynchronousQueue"></a>13. 同步队列SynchronousQueue</h2><ul>
<li>SynchronousQueue 内部没有容量，但是由于一个插入操作总是对应一个移除操作，反过来同样需要满足那么一个元素就不会再SynchronousQueue 里面长时间停留，一旦有了插入线程和移除线程，元素很快就从插入线程移交给移除线程。也就是说这更像是一种信道（管道），资源从一个方向快速传递到另一方 向。显然这是一种快速传递元素的方式， 这种情况下元素总是以最快的方式从插入着（生产者）传递给移除着（消费者），这在多任务队列中是最快处理任务的方式</li>
<li>因为没有容量，所以对应 peek, contains, clear, isEmpty … 等方法其实是无效的。例如clear是不执行任何操作的，contains始终返回false,peek始终返回null。</li>
<li>SynchronousQueue分为公平和非公平，默认情况下采用非公平性访问策略，当然也可以通过构造函数来设置为公平性访问策略（为true即可）。</li>
<li>在线程池里的一个典型应用是Executors.newCachedThreadPool()就使用了SynchronousQueue， 这个线程池根据需要（新任务到来时）创建新的线程，如果有空闲线程则会重复使用，线程空闲了60秒后会被回收。</li>
</ul>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">iterator</span><span class="params">()</span></span> 永远返回空，因为里面没东西。 </span><br><span class="line"><span class="function"><span class="title">peek</span><span class="params">()</span></span> 永远返回null。 </span><br><span class="line"><span class="function"><span class="title">put</span><span class="params">()</span></span> 往queue放进去一个element以后就一直wait直到有其他thread进来把这个element取走。 </span><br><span class="line"><span class="function"><span class="title">offer</span><span class="params">()</span></span> 往queue里放一个element后立即返回，如果碰巧这个element被另一个thread取走了，offer方法返回true，认为offer成功；否则返回false。 </span><br><span class="line"><span class="function"><span class="title">offer</span><span class="params">(<span class="number">2000</span>, TimeUnit.SECONDS)</span></span> 往queue里放一个element但是等待指定的时间后才返回，返回的逻辑和offer()方法一样。 </span><br><span class="line"><span class="function"><span class="title">take</span><span class="params">()</span></span> 取出并且remove掉queue里的element（认为是在queue里的。。。），取不到东西他会一直等。 </span><br><span class="line"><span class="function"><span class="title">poll</span><span class="params">()</span></span> 取出并且remove掉queue里的element（认为是在queue里的。。。），只有到碰巧另外一个线程正在往queue里offer数据或者put数据的时候，该方法才会取到东西。否则立即返回null。 </span><br><span class="line"><span class="function"><span class="title">poll</span><span class="params">(<span class="number">2000</span>, TimeUnit.SECONDS)</span></span> 等待指定的时间然后取出并且remove掉queue里的element,其实就是再等其他的thread来往里塞。 </span><br><span class="line"><span class="function"><span class="title">isEmpty</span><span class="params">()</span></span>永远是true。 </span><br><span class="line"><span class="function"><span class="title">remainingCapacity</span><span class="params">()</span></span> 永远是<span class="number">0</span>。 </span><br><span class="line"><span class="function"><span class="title">remove</span><span class="params">()</span></span>和removeAll() 永远是false。 </span><br></pre></td></tr></table></figure>

<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> SynchronousQueueTest &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) throws InterruptedException &#123;</span><br><span class="line">         final SynchronousQueue&lt;String&gt; queue = <span class="keyword">new</span> SynchronousQueue&lt;String&gt;(<span class="literal">true</span>);</span><br><span class="line">         <span class="comment">//put线程</span></span><br><span class="line">          ExecutorService exec=<span class="module-access"><span class="module"><span class="identifier">Executors</span>.</span></span><span class="keyword">new</span><span class="constructor">CachedThreadPool()</span>;</span><br><span class="line">          exec.execute(<span class="keyword">new</span> <span class="constructor">Runnable()</span> &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run<span class="literal">()</span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                         <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span>+<span class="string">&quot;   put 开始&quot;</span>);</span><br><span class="line">                          queue.put(<span class="string">&quot;put:&quot;</span>+i);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">          exec.shutdown<span class="literal">()</span>;</span><br><span class="line">          <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>sleep(<span class="number">1000</span>);</span><br><span class="line">          <span class="comment">//消费线程</span></span><br><span class="line">          ExecutorService exec2=<span class="module-access"><span class="module"><span class="identifier">Executors</span>.</span></span><span class="keyword">new</span><span class="constructor">CachedThreadPool()</span>;</span><br><span class="line">          exec2.execute(<span class="keyword">new</span> <span class="constructor">Runnable()</span> &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run<span class="literal">()</span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;       </span><br><span class="line">                          <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span>+<span class="string">&quot;  take 消费开始&quot;</span>);</span><br><span class="line">                          <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span> +<span class="string">&quot;  take值： : &quot;</span> +queue.take<span class="literal">()</span>);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                     <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span>+<span class="string">&quot;  take 消费结束&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">          exec2.shutdown<span class="literal">()</span>;</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h3><p>与其他BlockingQueue一样，SynchronousQueue同样继承AbstractQueue和实现BlockingQueue接口：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SynchronousQueue&lt;E&gt;</span> <span class="keyword">extends</span> <span class="title">AbstractQueue&lt;E&gt;</span></span></span><br><span class="line"><span class="class">    <span class="title">implements</span> <span class="title">BlockingQueue&lt;E&gt;</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<p> <strong>SynchronousQueue提供了两个构造函数：</strong> </p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(<span class="literal">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 通过 fair 值来决定公平性和非公平性</span></span><br><span class="line">       <span class="comment">// 公平性使用TransferQueue，非公平性采用TransferStack</span></span><br><span class="line">       transferer = fair ? <span class="keyword">new</span> TransferQueue&lt;E&gt;() : <span class="keyword">new</span> TransferStack&lt;E&gt;();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p> <strong>TransferQueue、TransferStack继承Transferer，Transferer为SynchronousQueue的内部类，它提供了一个方法transfer()，该方法定义了转移数据的规范，如下：</strong> </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Transferer</span>&lt;<span class="title">E</span>&gt; &#123;</span><br><span class="line">       <span class="function"><span class="keyword">abstract</span> E <span class="title">transfer</span>(<span class="params">E e, boolean timed, <span class="keyword">long</span> nanos</span>)</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>transfer()方法主要用来完成转移数据的，如果e != null，相当于将一个数据交给消费者，如果e == null，则相当于从一个生产者接收一个消费者交出的数据。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库</title>
    <url>/2020/10/13/0000.%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p>（本笔记不能代替《高性能MySQL》，笔记中缺少了大量辅助理解的话和例子，缺少了很多信息量）</p>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/1590590509208-c55e311d-4d15-4bd8-8b43-5bec5a1c2193.png" alt="image"></p>
<h2 id="一、MySQL架构"><a href="#一、MySQL架构" class="headerlink" title="一、MySQL架构"></a>一、MySQL架构</h2><p>和其它数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎的架构上，<strong>插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离</strong>。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/1590590539775-66b802ba-2c1c-4c50-9cd0-a41eb54578e5.png" alt="image"></p>
<ul>
<li><strong>连接层</strong>：最上层是一些客户端和连接服务。<strong>主要完成一些类似于连接处理、授权认证、及相关的安全方案</strong>。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</li>
<li><strong>服务层</strong>：第二层服务层，主要完成大部分的核心服务功能， 包括<strong>查询解析、分析、优化、缓存**</strong>、以及所有的内置函数<strong>，所有跨存储引擎的功能也都在这一层实现，包括</strong>触发器、存储过程、视图**等</li>
<li><strong>引擎层</strong>：第三层存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取</li>
<li><strong>存储层</strong>：第四层为数据存储层，主要是将数据存储在运行于该设备的文件系统之上，并完成与存储引擎的交互</li>
</ul>
<p><strong>MySQL 的查询流程</strong></p>
<p>（所有SQL语句都可以称为查询，包括INSERT,DELETE,UPDATE）</p>
<p>—&gt; 客户端请求</p>
<p>—&gt; 连接器（验证用户身份，给予权限）  </p>
<p>—&gt; 查询缓存（存在缓存则直接返回，不存在则执行后续操作）</p>
<p>—&gt; 分析器（对SQL进行词法分析和语法分析操作）  </p>
<p>—&gt; 优化器（主要对执行的sql优化选择最优的执行方案方法）  </p>
<p>—&gt; 执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口）</p>
<p>—&gt; 去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）</p>
<h2 id="二、MySQL-事务"><a href="#二、MySQL-事务" class="headerlink" title="二、MySQL 事务"></a>二、MySQL 事务</h2><blockquote>
<p>❝</p>
<p>事务的隔离级别有哪些？MySQL的默认隔离级别是什么？</p>
<p>什么是幻读，脏读，不可重复读呢？</p>
<p>MySQL事务的四大特性以及实现原理</p>
<p>MVCC熟悉吗，它的底层原理？</p>
</blockquote>
<p>MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！</p>
<h3 id="ACID-—-事务基本要素"><a href="#ACID-—-事务基本要素" class="headerlink" title="ACID — 事务基本要素"></a>ACID — 事务基本要素</h3><p>事务是由一组SQL语句组成的逻辑处理单元，具有4个属性，通常简称为事务的ACID属性。</p>
<ul>
<li><strong>A (Atomicity) 原子性</strong>：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样</li>
<li><strong>C (Consistency) 一致性</strong>：在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。AID是手段，C是目的，即通过种种手段保证数据库在事务执行前后都处于正确的状态（即数据库列上没有限制数据的范围，但是转账业务中不可能出现账户余额为负的情况，所以要保证事务前后要保证数据库在业务上处于正确的状态）</li>
<li><strong>I (Isolation)隔离性</strong>：一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰</li>
<li><strong>D (Durability) 持久性</strong>：在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚</li>
</ul>
<p><strong>（隔离性不够时）**</strong>并发事务处理带来的问题**</p>
<ul>
<li>**更新丢失（Lost Update)**：事务A和事务B选择同一行，并基于最初选定的值更新该行时，由于两个事务都不知道彼此的存在，就会发生丢失更新问题</li>
<li>**脏读(Dirty Reads)**：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</li>
<li>**不可重复读（Non-Repeatable Reads)**：事务 A 多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。</li>
<li>**幻读（Phantom Reads)**：幻读与不可重复读类似。它发生在一个事务A读取了几行数据，接着另一个并发事务B插入了一些数据时。在随后的查询中，事务A就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>
</ul>
<p><strong>幻读和不可重复读的区别：</strong></p>
<ul>
<li><strong>不可重复读的重点是修改</strong>：在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样。（因为中间有其他事务提交了修改）</li>
<li><strong>幻读的重点在于新增或者删除</strong>：在同一事务中，同样的条件,第一次和第二次读出来的记录数不一样。（因为中间有其他事务提交了插入/删除）</li>
</ul>
<p><strong>并发事务处理带来的问题的解决办法：</strong></p>
<ul>
<li><p>“更新丢失”通常是应该完全避免的。但防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决，因此，防止更新丢失应该是应用的责任。</p>
</li>
<li><p><strong>“脏读” 、 “不可重复读”和“幻读” ，其实都是数据库读一致性问题</strong>，必须由数据库提供一定的事务隔离机制来解决：</p>
</li>
<li><ul>
<li>一种是加锁：在读取数据前，对其加锁，阻止其他事务对数据进行修改。</li>
<li>另一种是数据多版本并发控制（MultiVersion Concurrency Control，<strong>MVCC</strong> ）：可以认为是行级锁的变种， 通过一定机制生成一个数据请求时间点的一致性数据快照 （Snapshot)， 并用这个快照来提供一定级别 （语句级或事务级） 的一致性读取。下面会详细介绍MVCC。</li>
</ul>
</li>
</ul>
<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>数据库事务的隔离级别有4种，由低到高分别为</p>
<ul>
<li><strong>READ-UNCOMMITTED(读未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li>
<li><strong>READ-COMMITTED(读已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li>
<li><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li>
<li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li>
</ul>
<p>查看当前数据库的事务隔离级别：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">&#x27;tx_isolation&#x27;</span></span><br></pre></td></tr></table></figure>

<p>下面通过事例一一阐述在事务的并发操作中可能会出现脏读，不可重复读，幻读和事务隔离级别的联系。</p>
<p><strong>数据库的事务隔离越严格，并发副作用越小，但付出的代价就越大</strong>，因为事务隔离实质上就是使事务在一定程度上“串行化”进行，这显然与“并发”是矛盾的。同时，不同的应用对读一致性和事务隔离程度的要求也是不同的，比如许多应用对“不可重复读”和“幻读”并不敏感，可能更关心数据并发访问的能力。</p>
<ul>
<li><strong>Read uncommitted</strong></li>
</ul>
<p><strong>读未提交，就是一个事务可以读取另一个未提交事务的数据</strong>。</p>
<p>事例：老板要给程序员发工资，程序员的工资是3.6万/月。但是发工资时老板不小心按错了数字，按成3.9万/月，该钱已经打到程序员的户口，但是事务还没有提交，就在这时，程序员去查看自己这个月的工资，发现比往常多了3千元，以为涨工资了非常高兴。但是老板及时发现了不对，马上回滚差点就提交了的事务，将数字改成3.6万再提交。</p>
<p>分析：实际程序员这个月的工资还是3.6万，但是程序员看到的是3.9万。他看到的是老板还没提交事务时的数据。这就是脏读。</p>
<p>那怎么解决脏读呢？Read committed！读提交，能解决脏读问题。</p>
<ul>
<li><strong>Read committed</strong></li>
</ul>
<p><strong>读**</strong>提交，顾名思义，就是一个事务要等另一个事务提交后才能读取数据**。</p>
<p>事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（程序员事务开启），收费系统事先检测到他的卡里有3.6万，就在这个时候！！程序员的妻子要把钱全部转出充当家用，并提交。当收费系统准备扣款时，再检测卡里的金额，发现已经没钱了（第二次检测金额当然要等待妻子转出金额事务提交完）。程序员就会很郁闷，明明卡里是有钱的…</p>
<p>分析：这就是读提交，若有事务对数据进行更新（UPDATE）操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。但在这个事例中，<strong>出现了一个事务范围内两个相同的查询却返回了不同数据</strong>，这就是<strong>不可重复读</strong>。</p>
<p>那怎么解决可能的不可重复读问题？Repeatable read ！</p>
<ul>
<li><strong>Repeatable read</strong></li>
</ul>
<p>重复读，就是在开始读取数据（事务开启）时，不再允许修改操作。<strong>MySQL的默认事务隔离级别</strong></p>
<p>事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（事务开启，不允许其他事务的UPDATE修改操作），收费系统事先检测到他的卡里有3.6万。这个时候他的妻子不能转出金额了。接下来收费系统就可以扣款了。</p>
<p>分析：重复读可以解决不可重复读问题。写到这里，应该明白的一点就是，<strong>不可重复读对应的是修改，即UPDATE操作。但是可能还会有幻读问题。因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作</strong>。</p>
<p><strong>什么时候会出现幻读？</strong></p>
<p>事例：程序员某一天去消费，花了2千元，然后他的妻子去查看他今天的消费记录（全表扫描FTS，妻子事务开启），看到确实是花了2千元，就在这个时候，程序员花了1万买了一部电脑，即新增INSERT了一条消费记录，并提交。当妻子打印程序员的消费记录清单时（妻子事务提交），发现花了1.2万元，似乎出现了幻觉，这就是幻读。</p>
<p>那怎么解决幻读问题？Serializable！</p>
<ul>
<li><strong>Serializable</strong></li>
</ul>
<p>Serializable 是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。简单来说，Serializable会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用问题。这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。</p>
<h4 id="隔离级别比较"><a href="#隔离级别比较" class="headerlink" title="隔离级别比较"></a>隔离级别比较</h4><table>
<thead>
<tr>
<th>事务隔离级别</th>
<th>读数据一致性</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交（read-uncommitted）</td>
<td>最低级被，只能保证不读取物理上损坏的数据</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>读已提交（read-committed）</td>
<td>语句级</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>可重复读（repeatable-read）</td>
<td>事务级</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>串行化（serializable）</td>
<td>最高级别，事务级</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
<p>需要说明的是，<strong>事务隔离级别和数据访问的并发性是对立的</strong>，事务隔离级别越高并发性就越差。所以要根据具体的应用来确定合适的事务隔离级别，这个地方没有万能的原则。</p>
<p><strong>这里需要注意的是：</strong>与 SQL 标准不同的地方在于InnoDB 存储引擎在 <strong>REPEATABLE-READ</strong>（可重读）事务隔离级别下使用的是<strong>Next-Key Lock</strong> 算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 <strong>SERIALIZABLE</strong>(可串行化)隔离级别，而且保留了比较好的并发性能。</p>
<p>因为<strong>隔离级别越低，事务请求的锁越少</strong>，所以大部分数据库系统的隔离级别都是<strong>READ-COMMITTED</strong>(读已提交):，但是你要知道的是<strong>InnoDB 存储引擎默认使用 REPEATABLE-READ（可重读）并不会有任何性能损失</strong>。</p>
<h3 id="MVCC-多版本并发控制"><a href="#MVCC-多版本并发控制" class="headerlink" title="MVCC 多版本并发控制"></a>MVCC 多版本并发控制</h3><p>MySQL的大多数<strong>事务型存储引擎实现都不是简单的行级锁**</strong>。基于提升并发性考虑，一般都同时实现了多版本并发控制（MVCC）**，包括Oracle、PostgreSQL。只是实现机制各不相同</p>
<p><strong>可以认为 MVCC 是行级锁的一个变种，但它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只是锁定必要的行</strong></p>
<p>MVCC 的实现是通过保存数据在某个时间点的快照来实现的。也就是说不管事务需要执行多长时间，每个事物看到的数据都是一致的。根据事务开始时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的</p>
<p><strong>MVCC与幻读：</strong></p>
<ul>
<li><p>当前读：读取数据的最新版本，例如update/insert/dalete/select … for update/select … lock in share mode</p>
</li>
<li><ul>
<li>这种MVCC不能防止幻读</li>
</ul>
</li>
<li><p>快照读：读取事务快照，普通的select语句都是快照读</p>
</li>
<li><ul>
<li>这种方式因为读取的是快照（如果发生了insert也不会修改到快照），所以天然解决了幻读</li>
</ul>
</li>
</ul>
<p>典型的MVCC实现方式，分为<strong>乐观并发控制</strong>和<strong>悲观并发控制</strong>。下边通过 InnoDB的简化版行为来说明 MVCC 是如何工作的。</p>
<p><strong>InnoDB 的 MVCC，是通过在每行记录后面保存两个隐藏的列来实现</strong>。<strong>一个保存了行的创建时间，一个保存行的过期时间（删除时间）</strong>。当然存储的并不是真实的时间，而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</p>
<p><strong>REPEATABLE READ（可重读）隔离级别下MVCC如何工作：</strong></p>
<ul>
<li><p><strong>SELECT：</strong></p>
</li>
<li><ul>
<li>InnoDB会根据以下两个条件检查每行记录，只有符合上述两个条件的才会被查询出来</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>只查找版本早于当前事务版本的数据行，这样可以确保事务读取的行，要么是在开始事务之前已经存在要么是事务自身插入或者修改过的</li>
<li>行的删除版本号要么未定义，要么大于当前事务版本号，这样可以确保事务读取到的行在事务开始之前未被删除</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>INSERT：</strong>InnoDB为新插入的每一行保存当前系统版本号作为行版本号</p>
</li>
<li><p><strong>DELETE：</strong>InnoDB为删除的每一行保存当前系统版本号作为行删除标识</p>
</li>
<li><p><strong>UPDATE：**</strong>InnoDB为插入的一行新纪录保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识**</p>
</li>
</ul>
<p>保存这两个额外系统版本号，使大多数操作都不用加锁。使数据操作简单，性能很好，并且也能保证只会读取到符合要求的行。不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作和一些额外的维护工作。</p>
<p>MVCC 只在 COMMITTED READ（读提交）和REPEATABLE READ（可重复读）两种隔离级别下工作。</p>
<blockquote>
<p>❝你知道MySQL 有多少种日志吗？</p>
</blockquote>
<ul>
<li><strong>错误日志</strong>：记录出错信息，也记录一些警告信息或者正确的信息。</li>
<li><strong>查询日志</strong>：记录所有对数据库请求的信息，不论这些请求是否得到了正确的执行。</li>
<li><strong>慢查询日志</strong>：设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询的日志文件中。</li>
<li><strong>二进制日志</strong>：binlog 记录对数据库执行更改的所有操作。</li>
<li><strong>中继日志</strong>：中继日志也是二进制日志，用来给slave 库恢复</li>
<li><strong>事务日志</strong>：重做日志redo和回滚日志undo</li>
</ul>
<h3 id="InnoDB事务日志"><a href="#InnoDB事务日志" class="headerlink" title="InnoDB事务日志"></a>InnoDB事务日志</h3><p><strong>InnoDB 使用日志来减少提交事务时的开销：因为日志中已经记录了事务，就无须在每个事务提交时把缓冲池的脏块刷新(flush)到磁盘中</strong>。</p>
<p><strong>事务修改的数据和索引通常会映射到表空间的随机位置，所以刷新这些变更到磁盘需要很多随机 I/O</strong>。</p>
<p>随机I/O比顺序IO昂贵得多，因为一个I/O请求需要时间把磁头移到正确的位置，然后等待磁盘上读出需要的部分，再转到开始位置。</p>
<p><strong>InnoDB 用日志把随机IO变成顺序IO。一旦日志安全写到磁盘，事务就持久化了，即使断电了，InnoDB可以重放日志并且恢复已经提交的事务</strong>。</p>
<p>InnoDB 使用一个后台线程智能地刷新这些变更到数据文件。这个线程可以批量组合写入，使得数据写入更顺序，以提高效率。</p>
<p>事务日志可以帮助提高事务效率：</p>
<ul>
<li>使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。</li>
<li>事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，所以采用事务日志的方式相对来说要快得多。</li>
<li>事务日志持久以后，内存中被修改的数据在后台可以慢慢刷回到磁盘。</li>
<li>如果数据的修改已经记录到事务日志并持久化，但数据本身没有写回到磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这一部分修改的数据。</li>
</ul>
<p>目前来说，大多数存储引擎都是这样实现的，我们通常称之为<strong>预写式日志</strong>（Write-Ahead Logging），修改数据需要写两次磁盘。</p>
<h3 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h3><p>事务的实现是基于数据库的存储引擎。不同的存储引擎对事务的支持程度不一样。MySQL 中支持事务的存储引擎有 InnoDB 和 NDB。</p>
<p>事务的实现就是如何实现ACID特性。</p>
<p><strong>事务的隔离性是通过锁实现，而**</strong>事务的**<strong>一致性和持久性则是通过事务日志实现</strong> 。</p>
<blockquote>
<p>❝事务是如何通过日志来实现的，说得越深入越好。</p>
</blockquote>
<p>事务日志包括：<strong>重做日志redo</strong>和<strong>回滚日志undo</strong></p>
<ul>
<li><p><strong>redo log（重做日志</strong>）：实现持久化</p>
</li>
<li><ul>
<li>redo log 是<strong>事务中</strong>操作任何数据，都会将最新的数据备份到一个地方</li>
<li>在InnoDB的存储引擎中，事务日志通过重做(redo)日志和InnoDB存储引擎的日志缓冲(InnoDB Log Buffer)实现。事务开启时，<strong>事务中的操作，在**</strong>执行过程中都会先写入存储引擎的日志缓冲中，**<strong>在**</strong>事务提交之前**<strong>，这些缓冲的日志都需要提前刷新到磁盘上持久化</strong>，这就是DBA们口中常说的“日志先行”(Write-Ahead Logging)。</li>
<li>当事务提交之后，在Buffer Pool中映射的数据文件才会慢慢刷新到磁盘。此时如果数据库崩溃或者宕机，那么当系统重启进行恢复时，就可以根据redo log中记录的日志，把数据库恢复到崩溃前的一个状态。未完成的事务，可以继续提交，也可以选择回滚，这基于恢复的策略而定。</li>
<li><strong>在系统启动的时候，就已经为redo log分配了一块连续的存储空间，以顺序追加的方式记录redo log，通过顺序IO来改善性能</strong>。所有的事务共享redo log的存储空间，它们的redo log按语句的执行顺序，依次交替的记录在一起</li>
<li><strong>redo log和存储结构的关系：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>MySQL基本存储结构是页，所以会先将页加载到内存中，对内存中的页进行修改，然后再刷回磁盘（这个过程是随机IO）</li>
<li>但是一个页16KB，不值得每一次都刷入磁盘，所以会异步的刷到磁盘中</li>
<li>同时防止数据库宕机，而内存没有来得及刷入磁盘，引入了redo log（es也有类似的，translog）</li>
<li>redo log也有自己的内存buffer，先写buffer，然后由于redo log在磁盘中是顺序存储，所以可以很快的就写入磁盘</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1596528160059-8e4787a5-7932-43b1-9c53-c01696d8b624.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image.png"></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>undo log（回滚日志）：</strong>原子性</p>
</li>
<li><ul>
<li>undo log 是<strong>事务开始之前</strong>，操作任何数据之前，首先将需要操作的数据备份到一个地方</li>
<li>undo log 提供两个功能：回滚和MVCC（原子性需要要么成功要么回滚，所以undo log帮助实现原子性）</li>
<li><strong>undo log记录了数据在每个操作前的状态，如果事务执行过程中需要回滚，就可以根据undo log进行回滚操作</strong>。单个事务的回滚，只会回滚当前事务做的操作，并不会影响到其他的事务做的操作</li>
<li>undo log记录的是已部分完成并且写入硬盘的未完成的事务，默认情况下回滚日志是记录下表空间中的（共享表空间或者独享表空间）</li>
<li><strong>undo log和MVCC：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>undo log中的数据可以作为数据旧版本快照供其他并发事务进行快照读</li>
<li>当读取被其他事务锁定的行时，可以从undo log中分析出改行记录以前的数据是什么，从而提供该行版本信息，实现非锁定一致性读取</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1596527329634-8360cba5-8e2c-4d0f-8761-168fe59d4286.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>上面二种日志均可以视为一种恢复操作，redo_log是恢复提交事务修改的页操作，而undo_log是回滚行记录到特定版本。二者记录的内容也不同</p>
</li>
<li><p><strong>redo_log是物理日志，记录页的物理修改操作，而undo_log是逻辑日志，根据每行记录进行记录，binlog也是逻辑日志</strong></p>
</li>
<li><p><strong>binlog：实现复制功能</strong></p>
</li>
<li><ul>
<li><strong>因为MySQL可能使用不同的引擎，所以需要在server层记录执行操作的日志，这样可以实现MySQL的主从复制功能以及发送消息队列功能</strong></li>
<li>然而这种情况会导致redo log与binlog的一致性问题，MySQL通过内部XA两阶段提交机制解决这种一致性的问题</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>本来直接提交redo log啥事也没有，但是因为有binlog的存在，就要想办法保证redo log和binlog一致</li>
<li>步骤细节在下面一节</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>redo log 和 binlog都有共同的字段XID(事务ID)，崩溃时的恢复操作：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>恢复时，顺序扫描redo log</li>
<li>如果既prepare，又commit，则直接提交redo log，将redo log中的数据写入真正的页中</li>
<li>如果只有prepare，没有commit，则根据XID检查binlog，如果binlog中有XID，则也将redo log中的数据写入真的的页中</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>为什么这么做？</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>引入binlog保证数据库的主从一致性</li>
<li>防止出现主从不一致，使用了两阶段提交</li>
<li>崩溃恢复时如果binlog中包含了事务，则会提交，因为binlog会复制到其他数据库中，所以binlog中有的事务需要提交</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>只用binlog行不行？</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>binlog记录逻辑日志，没有数据页的更新细节，所以不能恢复</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>只用redo log行不行？</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>不可行，需要binlog屏蔽MySQL底层的引擎</li>
<li>同时，主从复制的时候传播的是逻辑操作，redo log这种物理操作不能应用在主从复制中</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="事务的写入过程"><a href="#事务的写入过程" class="headerlink" title="事务的写入过程"></a>事务的写入过程</h3><ul>
<li><p>一个事务的例子：</p>
</li>
<li><ul>
<li>步骤1:begin;</li>
<li>步骤2:insert into t1 …r</li>
<li>步骤3:insert into t2 …</li>
<li>步骤4:commit;</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/1590590539973-d4b0a609-44be-4018-b989-cc1e2967d8c9.png" alt="image.png"></p>
<ul>
<li><p>MySQL的事务使用两阶段提交(2PC)，事务提交前，将redo log的写入拆成了两个步骤，prepare和commit</p>
</li>
<li><ul>
<li>redo log 和binlog 有一个共同的数据字段，叫 XID,崩溃恢复的时候，会按顺序扫描 redo log</li>
<li>假设在写入binlog前系统崩溃，那么数据库恢复后顺序扫描 redo log，碰到只有 parepare、而没有 commit 的 redo log，就拿着 XID（事务ID） 去 binlog 找对应的事务，而且binlog也没写入，所以事务就直接回滚了</li>
<li>假设在写入binlog之后，事务提交前数据库崩溃，那么数据库恢复后顺序扫描 redo log，碰到既有 prepare、又有 commit 的 redo log，就直接提交，保证主从一致性</li>
</ul>
</li>
</ul>
<h3 id="MySQL对分布式事务的支持"><a href="#MySQL对分布式事务的支持" class="headerlink" title="MySQL对分布式事务的支持"></a>MySQL对分布式事务的支持</h3><p>分布式事务的实现方式有很多，既可以采用 InnoDB 提供的原生的事务支持，也可以采用消息队列来实现分布式事务的最终一致性。这里我们主要聊一下 InnoDB 对分布式事务的支持。</p>
<p>MySQL 从 5.0.3  InnoDB 存储引擎开始支持XA协议的分布式事务。一个分布式事务会涉及多个行动，这些行动本身是事务性的。所有行动都必须一起成功完成，或者一起被回滚。</p>
<p>在MySQL中，使用分布式事务涉及一个或多个资源管理器和一个事务管理器。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/1590590539973-d4b0a609-44be-4018-b989-cc1e2967d8c9.png" alt="image"></p>
<p>如图，MySQL 的分布式事务模型。模型中分三块：应用程序（AP）、资源管理器（RM）、事务管理器（TM）:</p>
<ul>
<li>应用程序：定义了事务的边界，指定需要做哪些事务；</li>
<li>资源管理器：提供了访问事务的方法，通常一个数据库就是一个资源管理器；</li>
<li>事务管理器：协调参与了全局事务中的各个事务。</li>
</ul>
<p>分布式事务采用两段式提交（two-phase commit）的方式：</p>
<ul>
<li>第一阶段所有的事务节点开始准备，告诉事务管理器ready。</li>
<li>第二阶段事务管理器告诉每个节点是commit还是rollback。如果有一个节点失败，就需要全局的节点全部rollback，以此保障事务的原子性。</li>
</ul>
<h2 id="三、MySQL锁机制"><a href="#三、MySQL锁机制" class="headerlink" title="三、MySQL锁机制"></a>三、MySQL锁机制</h2><blockquote>
<p>❝</p>
<p>数据库的乐观锁和悲观锁？</p>
<p>MySQL 中有哪几种锁，列举一下？</p>
<p>MySQL中InnoDB引擎的行锁是怎么实现的？</p>
<p>MySQL 间隙锁有没有了解，死锁有没有了解，写一段会造成死锁的 sql 语句，死锁发生了如何解决，MySQL 有没有提供什么机制去解决死锁</p>
</blockquote>
<h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><p><strong>从对数据操作的类型分类</strong>：</p>
<ul>
<li><strong>读锁</strong>（共享锁）：针对同一份数据，多个读操作可以同时进行，不会互相影响</li>
<li><strong>写锁</strong>（排他锁）：当前写操作没有完成前，它会阻断其他写锁和读锁</li>
</ul>
<p><strong>从对数据操作的粒度分类</strong>：</p>
<p>为了尽可能提高数据库的并发度，每次锁定的数据范围越小越好，理论上每次只锁定当前操作的数据的方案会得到最大的并发度，但是管理锁是很耗资源的事情（涉及获取，检查，释放锁等动作），因此数据库系统需要在高并发响应和系统性能两方面进行平衡，这样就产生了“锁粒度（Lock granularity）”的概念。</p>
<ul>
<li><strong>表级锁</strong>：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低（MyISAM 和 MEMORY 存储引擎采用的是表级锁）；</li>
<li><strong>行级锁</strong>：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高（InnoDB 存储引擎既支持行级锁也支持表级锁，但默认情况下是采用行级锁）；</li>
<li><strong>页面锁</strong>：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</li>
</ul>
<p>适用：从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。</p>
<table>
<thead>
<tr>
<th></th>
<th>行锁</th>
<th>表锁</th>
<th>页锁</th>
</tr>
</thead>
<tbody><tr>
<td>MyISAM</td>
<td></td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>BDB</td>
<td></td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>InnoDB</td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>Memory</td>
<td></td>
<td>√</td>
<td></td>
</tr>
</tbody></table>
<h3 id="MyISAM-表锁"><a href="#MyISAM-表锁" class="headerlink" title="MyISAM 表锁"></a>MyISAM 表锁</h3><p>MyISAM 的表锁有两种模式：</p>
<ul>
<li>表共享读锁 （Table Read Lock）：不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；</li>
<li>表独占写锁 （Table Write Lock）：会阻塞其他用户对同一表的读和写操作；</li>
</ul>
<p>MyISAM 表的读操作与写操作之间，以及写操作之间是串行的。当一个线程获得对一个表的写锁后， 只有持有锁的线程可以对表进行更新操作。其他线程的读、 写操作都会等待，直到锁被释放为止。</p>
<p>默认情况下，写锁比读锁具有更高的优先级：当一个锁释放时，这个锁会优先给写锁队列中等候的获取锁请求，然后再给读锁队列中等候的获取锁请求。</p>
<h3 id="InnoDB-行锁"><a href="#InnoDB-行锁" class="headerlink" title="InnoDB 行锁"></a>InnoDB 行锁</h3><ul>
<li><p>InnoDB 实现了以下两种类型的<strong>行锁</strong>：</p>
</li>
<li><ul>
<li>共享锁（shared lock S锁，又称读锁）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</li>
<li>排他锁（exclusive lock X锁，又称写锁）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。insert ，delete ， <strong>update在事务中都会自动默认加上排它锁</strong>。</li>
</ul>
</li>
<li><p>同时InnoDB还实现了<strong>多粒度锁</strong>：</p>
</li>
</ul>
<p><strong>为了允许行锁和表锁共存，实现多粒度锁机制——意向锁</strong>（Intention Locks）：未来的某个时刻，事务可能要加共享/排它锁了，先提前声明一个意向</p>
<ul>
<li><ul>
<li>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。</li>
<li>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。</li>
</ul>
</li>
<li><p>“冲突—兼容”规则：</p>
</li>
<li><ul>
<li><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/1590745463390-4377c2d2-8ea7-4d04-8a13-a78ec84125eb.png" alt="image"></li>
<li><strong>意向锁是怎么提高检测效率的？</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li><strong>在加表锁的时可立即检测到是否存在意向锁，若存在，则说明有行锁，因此无须遍历整个表即可知道发生冲突</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="加锁机制"><a href="#加锁机制" class="headerlink" title="加锁机制"></a>加锁机制</h4><ul>
<li><p><strong>乐观锁与悲观锁是两种并发控制的思想，可用于解决丢失更新问题</strong></p>
</li>
<li><ul>
<li>乐观锁会“乐观地”假定大概率不会发生并发更新冲突，访问、<strong>处理数据过程中不加锁**</strong>，**<strong>只在更新数据时再根据版本号或时间戳判断是否有冲突</strong>，有则处理，无则提交事务。用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式</li>
<li>悲观锁会“悲观地”假定大概率会发生并发更新冲突，访问、<strong>处理数据前就加排他锁</strong>，<strong>在整个数据处理过程中锁定数据，事务提交或回滚后才释放锁</strong>。另外与乐观锁相对应的，<strong>悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。</strong></li>
</ul>
</li>
<li><p><strong>悲观锁的例子：</strong></p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">//step1: 查出商品状态，使用悲观锁锁定需要修改的数据</span><br><span class="line"><span class="keyword">select</span> quantity <span class="keyword">from</span> items <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">100</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line">//step2: 根据商品信息生成订单</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> orders(<span class="keyword">id</span>,item_id) <span class="keyword">values</span>(<span class="literal">null</span>,<span class="number">100</span>);</span><br><span class="line">//step3: 修改商品的库存</span><br><span class="line"><span class="keyword">update</span> Items <span class="keyword">set</span> quantity=quantity<span class="number">-2</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>乐观锁的例子</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">//step1: 查询出商品信息，普通快照读</span><br><span class="line"><span class="keyword">select</span> (quantity,<span class="keyword">version</span>) <span class="keyword">from</span> items <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">100</span>;</span><br><span class="line">//step2: 根据商品信息生成订单</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> orders(<span class="keyword">id</span>,item_id) <span class="keyword">values</span>(<span class="literal">null</span>,<span class="number">100</span>);</span><br><span class="line">//step3: 修改商品的库存，使用版本号进行判断修改</span><br><span class="line"><span class="keyword">update</span> items <span class="keyword">set</span> quantity=quantity<span class="number">-1</span>,<span class="keyword">version</span>=<span class="keyword">version</span>+<span class="number">1</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">100</span> <span class="keyword">and</span> <span class="keyword">version</span>=<span class="comment">#&#123;version&#125;;</span></span><br></pre></td></tr></table></figure>

<p>**<br>**</p>
<h4 id="锁模式"><a href="#锁模式" class="headerlink" title="锁模式"></a>锁模式</h4><p><strong>上面是各种锁的思想，或者分类，下面是InnoDB实际使用的锁的模式</strong></p>
<ul>
<li><p>**记录锁(Record Locks，也被称为行锁)**：</p>
</li>
<li><ul>
<li>单个行记录上的锁。对索引项加锁，锁定符合条件的索引而不是真正的数据记录，如果表上没有索引，则会使用自动创建的隐藏主键索引</li>
<li>加上记录锁后，其他事务不能再获取排他锁，即不能修改和删除加锁项（但是可以快照读）；</li>
<li>记录锁分为共享锁和排他锁：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>使用共享锁：<code>SELECT ... </code>**<code>LOCK IN SHARE MODE</code>**<code>;</code></li>
<li>使用排他锁（悲观锁）：<code>SELECT ... </code>**<code>FOR UPDATE</code>**`;```</li>
<li>使用了排他锁，如果事务结束前，其他事务不能修改锁定的数据</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>使用记录锁的方法：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><strong>精准确定哪些行需要加锁时会使用记录锁</strong></li>
<li><code>SELECT * FROM table </code><strong><code>WHERE id = 1</code></strong><code> FOR UPDATE;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>它会在 id=1 的记录上加上记录锁，以阻止其他事务插入，更新，删除 id=1 这一行</p>
<p><strong>如果where中不是精准匹配，而是&gt;,&lt;,like等，那么就会转换成临建锁</strong></p>
<ul>
<li><ul>
<li><ul>
<li>在通过 主键索引 与 唯一索引 对数据行进行 UPDATE 操作时，也会对该行数据加记录锁：</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong><code>UPDATE</code></strong><code>SET age = 50</code><strong><code>WHERE id = 1</code></strong><code>;-- id 列为主键列或唯一索引列</code></p>
<ul>
<li><p><strong>间隙锁（Gap Locks）</strong>：</p>
</li>
<li><ul>
<li><strong>当检索数据是范围条件时，即不能精准确定哪些行数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁</strong>。</li>
<li>对索引项之间的“间隙”加锁，锁定记录的范围（对第一条记录前的间隙或最后一条将记录后的间隙加锁），不包含索引项本身。<strong>使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据</strong></li>
<li><strong>间隙锁基于非唯一索引，它锁定一段范围内的索引记录。间隙锁基于下面将会提到的**</strong><code>Next-Key Locking</code>** <strong>算法</strong></li>
<li>其他事务不能在锁范围内插入数据，这样就防止了别的事务新增幻影行（即，隔离级别为可重复读时解决部分幻读）。</li>
<li>如果将事务的隔离级别降级为读提交(Read Committed, RC)，间隙锁则会自动失效。</li>
<li>间隙锁是排他锁，只在UPDATE、DELETE以及特殊的SELECT语句中出现（INSERT语句采用了另外一种锁——插入意向间隙锁）</li>
<li>使用间隙锁：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><code>SELECT * FROM table</code><strong><code> WHERE id BETWEN 1 AND 10</code></strong><code> FOR UPDATE;</code></li>
<li>所有在**<code>（1，10）</code>**区间内的记录行都会被锁住，所有id 为 2-9 的数据行的插入会被阻塞，但是 1 和 10 两条记录行并不会被锁住。</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>间隙锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况</li>
</ul>
</li>
<li><p>**临键锁(Next-key Locks)**：</p>
</li>
<li><ul>
<li><strong>临键锁</strong>，是<strong>记录锁与间隙锁的组合</strong>，它的封锁范围，既包含索引记录，又包含索引区间。<br>Next-Key 可以理解为一种特殊的<strong>间隙锁</strong>，也可以理解为一种特殊的<strong>算法</strong>。</li>
<li><strong>临键锁的索引必须是非唯一索引，如果索引是唯一索引，则临键锁降级为行锁，仅锁住索引本身，而不会锁住范围</strong></li>
<li>通过临键锁可以解决幻读的问题。每个数据行上的非唯一索引列上都会存在一把临键锁，当某个事务持有该数据行的临键锁时，<strong>会锁住一段左开右闭区间的数据</strong>。</li>
<li>如果把事务的隔离级别降级为RC，临键锁则也会失效。</li>
<li>对于非唯一索引的行的查询，都是采用该方法，主要目的是解决幻读的问题。</li>
<li>例子：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>表table(id PK, age KEY, name)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1590748148197-bfa179a3-78e2-4f4f-b304-2f01083a34ca.png" alt="image.png"></p>
<ul>
<li><ul>
<li><ul>
<li>该表中 age 列潜在的临键锁有：-∞, 10], (10, 24], (24, 32], (32, 45], (45, +∞]</li>
<li>在<code>事务 A</code> 中执行如下命令：</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>– 根据非唯一索引列 UPDATE 某条记录</p>
<p>UPDATE table SET name = Vladimir WHERE age = 24;</p>
<p>– 或根据非唯一索引列 锁住某条记录</p>
<p>SELECT * FROM table WHERE age = 24 FOR UPDATE;</p>
<ul>
<li><ul>
<li><ul>
<li>不管执行了上述 SQL 中的哪一句，之后如果在<code>事务 B</code> 中执行以下命令，则该命令会被阻塞：</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>INSERT INTO table VALUES(100, 26, ‘Ezreal’);</p>
<ul>
<li><p><strong>插入意向间隙锁（Insert Intention Gap Lock）:</strong></p>
</li>
<li><ul>
<li>对于数据的修改和删除，必须使用强排他锁，而对于数据的插入不需要这么强的锁</li>
<li>如果多个事务希望对同一个索引间隙插入数据，只要插入的不是同一个位置，则可以直接执行，不用等待其他事务结束，即不会阻塞</li>
<li><strong>使用共享锁提高读读并发，使用插入意向间隙锁提高插入并发</strong></li>
<li>例子：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>表索引：t(id unique PK, name)，列name不是唯一索引</li>
<li>表中数据：</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>10, shenjian</li>
<li>20, zhangsan</li>
<li>30, lisi</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>事务A先执行，在10与20两条记录中插入了一行，还未提交：insert into t values(11, xxx);</li>
<li>事务B后执行，也在10与20两条记录中插入了一行：insert into t values(12, ooo);</li>
<li>这时使用插入意向间隙锁，事务B不会被阻塞</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li><strong>InnoDB</strong> 中的<code>行锁</code>的实现依赖于<code>索引</code>，一旦某个加锁操作没有使用到索引，那么该锁就会退化为<code>表锁</code>。</li>
<li><strong>记录锁</strong>存在于包括<code>主键索引</code>在内的<code>唯一索引</code>中，锁定单条索引记录。</li>
<li><strong>间隙锁</strong>存在于<code>非唯一索引</code>中，锁定<code>开区间</code>范围内的一段间隔，它是基于<strong>临键锁</strong>实现的。</li>
<li><strong>临键锁</strong>存在于<code>非唯一索引</code>中，该类型的每条记录的索引上都存在这种锁，它是一种特殊的<strong>间隙锁</strong>，锁定一段<code>左开右闭</code>的索引区间。</li>
</ol>
<blockquote>
<p>❝MySQL 遇到过死锁问题吗，你是如何解决的？</p>
</blockquote>
<h4 id="读取方式"><a href="#读取方式" class="headerlink" title="读取方式"></a>读取方式</h4><ul>
<li>快照读(Snapshot Read)：基于 MVCC 和 undo log 实现的，普通的select读，读数据记录的快照版本，不加锁</li>
</ul>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> xxx;</span><br></pre></td></tr></table></figure>

<ul>
<li>当前读(Current Read)：基于临键锁（记录锁 + 间隙锁）实现的，特殊的select读。读数据记录的最新版本，且在读取完成前需要保证数据不被其他事务修改，因此要加锁</li>
</ul>
<p>select * from t where xxx <strong>for update</strong>———排他锁</p>
<p>​    select * from t where xxx <strong>lock in share mode</strong>———共享锁</p>
<p>​    <strong>update / insert / delete</strong>———排他锁</p>
<h4 id="索引访问与加锁方式"><a href="#索引访问与加锁方式" class="headerlink" title="索引访问与加锁方式"></a>索引访问与加锁方式</h4><ul>
<li><p><strong>主键访问：</strong></p>
</li>
<li><ul>
<li>RC(Read Commit)模式： </li>
</ul>
</li>
</ul>
<p>只需要给主键上查询对应的记录加锁只需要给主键上查询对应的记录加锁，不存在间隙锁</p>
<ul>
<li><ul>
<li>RR(Repeatable Read)模式：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>等值查询：加Next-key LOCK，如果键值满足条件，Next-key LOCK退化为行锁，如果不满足条件，Next-key LOCK退化为GAP锁</li>
<li>范围查询：加Next-key LOCK，一直遍历到第一个不满足查询条件的键值为止，且锁不退化</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>唯一性二级索引访问：</strong></p>
<p>和主键访问的区别是一个是锁主键索引，一个是锁二级索引+对应的主键记录 </p>
</li>
<li><p><strong>非唯一性二级索引访问：</strong></p>
</li>
<li><ul>
<li>RC模式：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>只需要给二级索引上对应的记录和对应主键索引上的记录加锁只需要给主键上查询对应的记录加锁，不存在间隙锁</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>RR模式：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>等值查询：加Next-key LOCK，一直遍历到第一个不满足查询条件的键值为止，然后把这个Next-key LOCK退化为GAP锁</li>
<li>范围查询：加Next-key LOCK，一直遍历到第一个不满足查询条件的键值为止，且锁不退化</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>无索引访问</strong>(也可以叫做主键索引全扫描、全表扫描)：</p>
</li>
<li><ul>
<li>RC模式：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>主键上所有记录行加锁，返回给Server层，Server层进行过滤，对不满足条件的记录，调用unlock_row方法放锁</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>RR模式：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>主键上所有记录行和GAP加锁，返回给Server层，Server层进行过滤，且事务结束之前不会释放</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><strong>死锁产生</strong>：</p>
<ul>
<li>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环</li>
<li>当事务试图以不同的顺序锁定资源时，就可能产生死锁。多个事务同时锁定同一个资源时也可能会产生死锁</li>
<li>锁的行为和顺序和存储引擎相关。以同样的顺序执行语句，有些存储引擎会产生死锁有些不会——死锁有双重原因：真正的数据冲突；存储引擎的实现方式。</li>
</ul>
<p><strong>检测死锁</strong>：数据库系统实现了各种死锁检测和死锁超时的机制。InnoDB存储引擎能检测到死锁的循环依赖并立即返回一个错误。</p>
<p><strong>死锁恢复</strong>：死锁发生以后，只有部分或完全回滚其中一个事务，才能打破死锁，InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。所以事务型应用程序在设计时必须考虑如何处理死锁，多数情况下只需要重新执行因死锁回滚的事务即可。</p>
<p><strong>外部锁的死锁检测</strong>：发生死锁后，InnoDB 一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及表锁的情况下，InnoDB 并不能完全自动检测到死锁， 这需要通过设置锁等待超时参数 innodb_lock_wait_timeout 来解决</p>
<p><strong>死锁影响性能</strong>：死锁会影响性能而不是会产生严重错误，因为InnoDB会自动检测死锁状况并回滚其中一个受影响的事务。在高并发系统上，当许多线程等待同一个锁时，死锁检测可能导致速度变慢。有时当发生死锁时，禁用死锁检测（使用innodb_deadlock_detect配置选项）可能会更有效，这时可以依赖<code>innodb_lock_wait_timeout</code>设置进行事务回滚。</p>
<p><strong>MyISAM避免死锁</strong>：</p>
<ul>
<li><strong>在自动加锁的情况下，MyISAM 总是一次获得 SQL 语句所需要的全部锁，所以 MyISAM 表不会出现死锁。</strong></li>
</ul>
<p><strong>InnoDB避免死锁</strong>：</p>
<ul>
<li>为了在单个InnoDB表上执行多个并发写入操作时避免死锁，可以在事务开始时通过为预期要修改的每行使用<code>SELECT ... FOR UPDATE</code>语句来获取必要的锁，即使这些行的更改语句是在之后才执行的。</li>
<li>在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应先申请共享锁、更新时再申请排他锁，因为这时候当用户再申请排他锁时，其他事务可能又已经获得了相同记录的共享锁，从而造成锁冲突，甚至死锁</li>
<li>如果事务需要修改或锁定多个表，则应在每个事务中以相同的顺序使用加锁语句。在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会</li>
<li>通过<code>SELECT ... LOCK IN SHARE MODE</code>获取行的读锁后，如果当前事务再需要对该记录进行更新操作，则很有可能造成死锁。</li>
<li>改变事务隔离级别</li>
</ul>
<p>如果出现死锁，可以用 <code>show engine innodb status;</code>命令来确定最后一个死锁产生的原因。返回结果中包括死锁相关事务的详细信息，如引发死锁的 SQL 语句，事务已经获得的锁，正在等待什么锁，以及被回滚的事务等。据此可以分析死锁产生的原因和改进措施。</p>
<h3 id="with-nolock-（SQL-Server）"><a href="#with-nolock-（SQL-Server）" class="headerlink" title="with(nolock)（SQL Server）"></a>with(nolock)（SQL Server）</h3><ul>
<li><p>with(nolock)是表提示（table_hint）中的一种，等同于READUNCOMMITTED，提高并发查询性能的同时可能会导致脏读</p>
</li>
<li><p><strong>特点：</strong></p>
</li>
<li><ul>
<li>允许脏读：不发布共享锁来阻止其他事务修改当前事务读取的数据，其他事务设置的排他锁不会阻碍当前事务读取锁定数据。允许脏读可能产生较多的并发操作，但其代价是读取以后会被其他事务回滚的数据修改。这可能会使您的事务出错，向用户显示从未提交过的数据，或者导致用户两次看到记录（或根本看不到记录）</li>
<li>READUNCOMMITTED 和 NOLOCK 提示仅适用于数据锁。所有查询（包括那些带有 READUNCOMMITTED 和 NOLOCK 提示的查询）都会在编译和执行过程中获取 Sch-S（架构稳定性）锁。因此，当并发事务持有表的 Sch-M（架构修改）锁时，将阻塞查询。例如，数据定义语言 (DDL) 操作在修改表的架构信息之前获取 Sch-M 锁。所有并发查询（包括那些使用 READUNCOMMITTED 或 NOLOCK 提示运行的查询）都会在尝试获取 Sch-S 锁时被阻塞。相反，持有 Sch-S 锁的查询将阻塞尝试获取 Sch-M 锁的并发事务</li>
<li>不能为通过插入、更新或删除操作修改过的表指定 READUNCOMMITTED 和 NOLOCK。SQL Server 查询优化器忽略 FROM 子句中应用于 UPDATE 或 DELETE 语句的目标表的 READUNCOMMITTED 和 NOLOCK 提示</li>
</ul>
</li>
<li><p><strong>使用场景：</strong></p>
</li>
<li><ul>
<li>是否使用要综合考虑性能情况与业务要求来决定，大体来说一般有下面一些场景可以使用WITH(NOLOCK)</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>基础数据表，这些表的数据很少变更</li>
<li>历史数据表，这些表的数据很少变更</li>
<li>业务允许脏读情况出现涉及的表</li>
<li>数据量超大的表，出于性能考虑，而允许脏读</li>
</ul>
</li>
</ul>
</li>
<li><p>如何产生脏读</p>
</li>
<li><ul>
<li>不使用的正常情况</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>会话窗口1，开启事务修改数据但是不提交也不回滚</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li><code>BEGIN TRAN</code></li>
<li><code>UPDATE TEST SET NAME=&#39;Timmy&#39; WHERE OBJECT_ID =1;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>会话窗口2，查询数据，但是被阻塞了（会话2在等待获取共享锁）</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li><code>SELECT * FROM TEST;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>使用的情况</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>会话窗口3，可以查询结果</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li><code>SELECT * FROM TEST WITH(NOLOCK)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>会话窗口1，回滚，出现脏读</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="四、存储引擎"><a href="#四、存储引擎" class="headerlink" title="四、存储引擎"></a>四、存储引擎</h2><p>存储引擎是MySQL的组件，用于处理不同表类型的SQL操作。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以获得特定的功能。</p>
<p>使用哪一种引擎可以灵活选择，<strong>一个数据库中多个表可以使用不同引擎以满足各种性能和实际需求</strong>，使用合适的存储引擎，将会提高整个数据库的性能 。</p>
<p>MySQL服务器使用<strong>可插拔</strong>的存储引擎体系结构，可以从运行中的 MySQL 服务器加载或卸载存储引擎 。</p>
<h3 id="查看存储引擎"><a href="#查看存储引擎" class="headerlink" title="查看存储引擎"></a>查看存储引擎</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看支持的存储引擎</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">ENGINES</span></span><br><span class="line"><span class="comment">-- 查看默认存储引擎</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">&#x27;storage_engine&#x27;</span></span><br><span class="line"><span class="comment">--查看具体某一个表所使用的存储引擎，这个默认存储引擎被修改了！</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> tablename</span><br><span class="line"><span class="comment">--准确查看某个数据库中的某一表所使用的存储引擎</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">&#x27;tablename&#x27;</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> <span class="keyword">status</span> <span class="keyword">from</span> <span class="keyword">database</span> <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">&quot;tablename&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="设置存储引擎"><a href="#设置存储引擎" class="headerlink" title="设置存储引擎"></a>设置存储引擎</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 建表时指定存储引擎。默认的就是INNODB，不需要设置</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (i <span class="built_in">INT</span>) <span class="keyword">ENGINE</span> = <span class="keyword">INNODB</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t2 (i <span class="built_in">INT</span>) <span class="keyword">ENGINE</span> = CSV;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t3 (i <span class="built_in">INT</span>) <span class="keyword">ENGINE</span> = <span class="keyword">MEMORY</span>;</span><br><span class="line"><span class="comment">-- 修改存储引擎</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="comment">-- 修改默认存储引擎，也可以在配置文件my.cnf中修改默认引擎</span></span><br><span class="line"><span class="keyword">SET</span> default_storage_engine=NDBCLUSTER;</span><br></pre></td></tr></table></figure>

<p>默认情况下，每当 <code>CREATE TABLE</code> 或 <code>ALTER TABLE</code> 不能使用默认存储引擎时，都会生成一个警告。为了防止在所需的引擎不可用时出现令人困惑的意外行为，可以启用 <code>NO_ENGINE_SUBSTITUTION SQL</code> 模式。如果所需的引擎不可用，则此设置将产生错误而不是警告，并且不会创建或更改表</p>
<h3 id="存储引擎对比"><a href="#存储引擎对比" class="headerlink" title="存储引擎对比"></a>存储引擎对比</h3><p>常见的存储引擎就 InnoDB、MyISAM、Memory、NDB。</p>
<p>InnoDB 现在是 MySQL 默认的存储引擎，支持<strong>事务、行级锁定和外键</strong></p>
<h4 id="文件存储结构对比"><a href="#文件存储结构对比" class="headerlink" title="文件存储结构对比"></a>文件存储结构对比</h4><p>在 MySQL中建立任何一张数据表，在其数据目录对应的数据库目录下都有对应表的 <code>.frm</code> 文件，<code>.frm</code> 文件是用来保存每个数据表的元数据(meta)信息，包括表结构的定义等，与数据库存储引擎无关，也就是任何存储引擎的数据表都必须有<code>.frm</code>文件，命名方式为 数据表名.frm，如user.frm。</p>
<p>查看MySQL 数据保存在哪里：<code>show variables like &#39;data%&#39;</code></p>
<p><strong>MyISAM 物理文件结构为：</strong></p>
<ul>
<li><code>.frm</code>文件：与表相关的元数据信息都存放在frm文件，包括<strong>表结构的定义信息</strong>等</li>
<li><code>.MYD</code> (<code>MYData</code>) 文件：MyISAM 存储引擎专用，用于存储MyISAM <strong>表的数据</strong></li>
<li><code>.MYI</code> (<code>MYIndex</code>)文件：MyISAM 存储引擎专用，用于存储MyISAM <strong>表的索引相关信息</strong></li>
</ul>
<p><strong>InnoDB 物理文件结构为：</strong></p>
<ul>
<li><code>.frm</code> 文件：与表相关的元数据信息都存放在frm文件，包括<strong>表结构的定义信息</strong>等</li>
<li><code>.ibd</code> 文件或 <code>.ibdata</code> 文件：这两种文件都是存放 InnoDB 数据的文件，之所以有两种文件形式存放 InnoDB 的数据，是因为 InnoDB 的数据存储方式能够通过配置来决定是使用<strong>共享表空间</strong>存放存储数据，还是用<strong>独享表空间</strong>存放存储数据。<br>独享表空间存储方式使用<code>.ibd</code>文件，并且每个表一个<code>.ibd</code>文件 共享表空间存储方式使用<code>.ibdata</code>文件，所有表共同使用一个<code>.ibdata</code>文件（或多个，可自己配置）</li>
</ul>
<h4 id="MyISAM和InnoDB区别"><a href="#MyISAM和InnoDB区别" class="headerlink" title="MyISAM和InnoDB区别"></a>MyISAM和InnoDB区别</h4><ol>
<li>InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</li>
<li>InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；</li>
<li>InnoDB 是聚簇索引，MyISAM 是非聚簇索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是二级索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和二级索引是独立的。</li>
<li>InnoDB 不保存表的具体行数，执行<code>select count(*) from table</code> 时需要全表扫描。而 MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</li>
<li>InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。MyISAM一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</li>
</ol>
<table>
<thead>
<tr>
<th>对比项</th>
<th>MyISAM</th>
<th>InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td>主外键</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>事务</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>行表锁</td>
<td>表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</td>
<td>行锁,操作时只锁某一行，不对其它行有影响，适合高并发的操作</td>
</tr>
<tr>
<td>缓存</td>
<td>只缓存索引，不缓存真实数据</td>
<td>不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响</td>
</tr>
<tr>
<td>表空间</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>关注点</td>
<td>性能</td>
<td>事务</td>
</tr>
<tr>
<td>默认安装</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<blockquote>
<p>❝一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15 ？</p>
</blockquote>
<p>如果表的类型是MyISAM，那么是18。因为MyISAM表会把自增主键的最大ID 记录到数据文件中，重启MySQL自增主键的最大ID也不会丢失；</p>
<p>如果表的类型是InnoDB，那么是15。因为InnoDB 表只是把自增主键的最大ID记录到内存中，所以重启数据库或对表进行OPTION操作，都会导致最大ID丢失。</p>
<blockquote>
<p>❝哪个存储引擎执行 select count(*) 更快，为什么?</p>
</blockquote>
<p>MyISAM更快，因为MyISAM内部维护了一个计数器，可以直接调取。</p>
<ul>
<li>在 MyISAM 存储引擎中，把表的总行数存储在磁盘上，当执行 select count(*) from t 时，直接返回总数据。</li>
<li>在 InnoDB 存储引擎中，跟 MyISAM 不一样，没有将总行数存储在磁盘上，当执行 select count(*) from t 时，会先把数据读出来，一行一行的累加，最后返回总数量。</li>
</ul>
<p>InnoDB 中 count(*) 语句是在执行的时候，全表扫描统计总数量，所以当数据越来越大时，语句就越来越耗时了，为什么 InnoDB 引擎不像 MyISAM 引擎一样，将总行数存储到磁盘上？这跟 InnoDB 的事务特性有关，<strong>由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的</strong>。</p>
<p>❝为什么MyISAM读取速度更快？</p>
<ul>
<li>InnoDB 在做 SELECT 的时候，要维护的东西比 MYISAM 引擎多很多，比如检查和维护MVCC</li>
<li>innodb寻址要映射到块，再到行，MYISAM记录的直接是文件的OFFSET，定位比INNODB要快</li>
</ul>
<h2 id="五、数据类型"><a href="#五、数据类型" class="headerlink" title="五、数据类型"></a>五、数据类型</h2><h3 id="MySQL的数据类型"><a href="#MySQL的数据类型" class="headerlink" title="MySQL的数据类型"></a>MySQL的数据类型</h3><ul>
<li>整数类型：BIT、BOOL、TINY INT、SMALL INT、MEDIUM INT、 INT、 BIG INT</li>
<li>浮点数类型：FLOAT、DOUBLE、DECIMAL</li>
<li>字符串类型：CHAR、VARCHAR、TINY TEXT、TEXT、MEDIUM TEXT、LONG TEXT、TINY BLOB、BLOB、MEDIUM BLOB、LONG BLOB</li>
<li>日期类型：Date、DateTime、TimeStamp、Time、Year</li>
<li>其他数据类型：BINARY、VARBINARY、ENUM、SET、Geometry、Point、MultiPoint、LineString、MultiLineString、Polygon、GeometryCollection等</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xray1025/image01/1590590539852-f07a129b-1bfb-4487-af9a-df13273354c2.webp" alt="image"><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539869-222256f7-421d-4ca2-b17c-ab93c141d6aa.webp" alt="image"><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539903-c0a28251-0a32-486e-b3d6-4defbb7768ea.webp?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<blockquote>
<p>❝CHAR 和 VARCHAR 的区别？</p>
</blockquote>
<p>char是固定长度，varchar长度可变：</p>
<p>char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。</p>
<p>存储时，前者不管实际存储数据的长度，直接按 char 规定的长度分配存储空间；而后者会根据实际存储的数据分配最终的存储空间</p>
<p><strong>相同点：</strong></p>
<ol>
<li>char(n)，varchar(n)中的n都代表字符的个数</li>
<li>超过char，varchar最大长度n的限制后，字符串会被截断。</li>
</ol>
<p><strong>不同点：</strong></p>
<ol>
<li>char不论实际存储的字符数都会占用n个字符的空间，而varchar只会占用实际字符应该占用的字节空间加1（实际长度length，0&lt;=length&lt;255）或加2（length&gt;255）。因为varchar保存数据时除了要保存字符串之外还会加一个字节来记录长度（如果列声明长度大于255则使用两个字节来保存长度）。</li>
<li>能存储的最大空间限制不一样：char的存储上限为255字节。</li>
<li>char在存储时会截断尾部的空格，而varchar不会。</li>
</ol>
<p>char是适合存储很短的、一般固定长度的字符串。例如，char非常适合存储密码的MD5值，因为这是一个定长的值。对于非常短的列，char比varchar在存储空间上也更有效率。</p>
<blockquote>
<p>❝列的字符串类型可以是什么？</p>
</blockquote>
<p>字符串类型是：BIT、SET、BLOB、ENUM、CHAR、TEXT、VARCHAR</p>
<p>ENUM：使用枚举代替字符串类型，将不重复的字符串存储到预定义的集合中。列中存储的是整数，这样列表值会非常紧凑，压缩到1-2个字节中。定义好了ENUM的集合后，如果想向其中添加或删除字符串必须使用ALTER TABLE，除非是向集合列表末尾添加元素。</p>
<p>BIT：二进制的多个比特串，MySQL将其作为字符串类型处理</p>
<p>SET：多个BIT合并称的数据类型，有效利用存储空间。</p>
<p>上述三种都可以使用其他数据类型达到同样的功能，而且不容易犯错。</p>
<blockquote>
<p>❝BLOB和TEXT有什么区别？</p>
</blockquote>
<p>BLOB和TEXT都是为存储很大的数据而设计的字符串数据类型，且容纳可变数量的数据。</p>
<p>BLOB存储的是二进制数据，四种类型的BLOB：TINYBLOB、BLOB、MEDIUMBLO和 LONGBLOB</p>
<p>TEXT存储的是字符数据，四种TEXT类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。</p>
<p>数据类型相关还有很多细节，在《高性能MySQL》第四章。</p>
<h3 id="范式与反范式"><a href="#范式与反范式" class="headerlink" title="范式与反范式"></a>范式与反范式</h3><ul>
<li><p>范式化的数据库中，每个事实数据只会出现一次，而反范式化的数据库中，信息是冗余的，可能会存储在多个地方。</p>
</li>
<li><p>范式的优点：</p>
</li>
<li><ul>
<li>范式化修改的数据通常更少，更新操作通常比反范式化更快</li>
<li>范式化的表通常更小，可以更好的放在内存里</li>
<li>范式化很少有多余的数据意味着检索列表数据时可能不需要DISTINCT/GROUP BY语句</li>
</ul>
</li>
<li><p>范式的缺点：</p>
</li>
<li><ul>
<li>通常需要关联，不仅代价高而且可能使得一些索引无效。比如，将列存储在不用的表中，而这些列如果在一个表中则本可以属于同一个索引</li>
</ul>
</li>
<li><p>反范式的优点：</p>
</li>
<li><ul>
<li>避免了很多关联，在没有关联的情况下，反范式执行全表扫描是顺序I/O，可能比关联要快得多</li>
</ul>
</li>
<li><p>反范式优点的例子，查看所有付费用户中最近的10个消息：</p>
</li>
<li><ul>
<li>范式：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>范式需要使用message和user两个表，并关联，SQL语句：</li>
<li>SELECT message_text,user_name</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>FROM message </p>
<p>INNER JOIN user ON <strong>message.user_id=user.id</strong></p>
<p>WHERE <strong>user.account_type</strong>=’VIP’</p>
<p>ORDER BY <strong>message.published</strong> DESC LIMIT 10;</p>
<ul>
<li><ul>
<li><ul>
<li>范式化需要先对message表的published索引进行扫描，并且每一个消息都要去user表找到对应的用户并检查是否为付费用户，如果付费用户少则需要扫面很多数据。</li>
<li>因为关联的存在，使得在索引中查找另一个表并进行过滤，使得消耗了性能</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>反范式：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>将message和user表合并，并且增加索引（account_type,published），这样就不用使用关联，而且索引覆盖：</li>
<li>SELECT message_text,user_name</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>FROM user_message</p>
<p>WHERE account_type=’VIP’</p>
<p>ORDER BY published DESC LIMIT 10;</p>
<h4 id="混合范式化和反范式化"><a href="#混合范式化和反范式化" class="headerlink" title="混合范式化和反范式化"></a>混合范式化和反范式化</h4><ul>
<li><ul>
<li>实际并不会完全的范式化和反范式化，上面完全反范式化的例子user_message的表太大了，而且如果没有消息就会丢失用户信息。可以在user表和message表中都存储account_type字段，可以同时解决前面两个问题。但是新的问题是每次更新都要更新两张表，更新代价提高了。</li>
</ul>
</li>
</ul>
<h4 id="缓存表和汇总表"><a href="#缓存表和汇总表" class="headerlink" title="缓存表和汇总表"></a>缓存表和汇总表</h4><ul>
<li>上面的混合范式化是在同一张表中保存衍生的冗余数据，而有时也需要创建完全独立的缓存表和汇总表</li>
<li>缓存表：保存比较简单的从其他表获取且速度较慢的的数据</li>
<li>汇总表：保存使用GROUP BY语句聚合的数据</li>
</ul>
<h2 id="六、索引"><a href="#六、索引" class="headerlink" title="六、索引"></a>六、索引</h2><blockquote>
<p>❝</p>
<p>说说你对 MySQL 索引的理解？</p>
<p>数据库索引的原理，为什么要用 B+树，为什么不用二叉树？</p>
<p>聚集索引与非聚集索引的区别？</p>
<p>InnoDB引擎中的索引策略，了解过吗？</p>
<p>创建索引的方式有哪些？</p>
<p>聚簇索引/非聚簇索引，mysql索引底层实现，为什么不用B-tree，为什么不用hash，叶子结点存放的是数据还是指向数据的内存地址，使用索引需要注意的几个地方？</p>
</blockquote>
<ul>
<li>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构，所以说<strong>索引的本质是：数据结构</strong></li>
<li>索引的目的在于提高查询效率，可以类比字典、 火车站的车次表、图书的目录等 </li>
<li>可以简单的理解为“排好序的快速查找数据结构”，数据本身之外，<strong>数据库还维护着一个满足特定查找算法的数据结构</strong>，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。下图是一种可能的索引方式示例<img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539862-061bbf2b-9b17-4cb6-9ec2-3c2139bbfbc1.webp?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></li>
<li>左边的数据表，一共有两列七条记录，最左边的是数据记录的物理地址。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值，和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在一定的复杂度内获取到对应的数据，从而快速检索出符合条件的记录。</li>
<li>索引本身也很大，不可能全部存储在内存中，<strong>一般以索引文件的形式存储在磁盘上</strong></li>
<li>平常说的索引，没有特别指明的话，就是B+树（多路搜索树，不一定是二叉树）结构组织的索引。其中聚集索引，次要索引，覆盖索引，符合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。此外还有哈希索引等。</li>
</ul>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ul>
<li><p>创建：</p>
</li>
<li><ul>
<li>创建索引：<code>CREATE [UNIQUE] INDEX indexName ON mytable(username(length));</code><br>如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。</li>
<li>修改表结构(添加索引)：<code>ALTER table tableName ADD [UNIQUE] INDEX indexName(columnName)</code></li>
</ul>
</li>
<li><p>删除：<code>DROP INDEX [indexName] ON mytable;</code></p>
</li>
<li><p>查看：<code>SHOW INDEX FROM table_name\G</code>       –可以通过添加 \G 来格式化输出信息。</p>
</li>
<li><p>使用ALERT命令</p>
</li>
<li><ul>
<li><code>ALTER TABLE tbl_name ADD PRIMARY KEY (column_list):</code> 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。</li>
<li><code>ALTER TABLE tbl_name ADD UNIQUE index_name (column_list</code> 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。</li>
<li><code>ALTER TABLE tbl_name ADD INDEX index_name (column_list)</code> 添加普通索引，索引值可出现多次。</li>
<li><code>ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list)</code>该语句指定了索引为 FULLTEXT ，用于全文索引。</li>
</ul>
</li>
</ul>
<h3 id="索引的优势"><a href="#索引的优势" class="headerlink" title="索引的优势"></a>索引的优势</h3><ul>
<li><strong>大大减少服务器需要扫描的数据量</strong></li>
<li><strong>B+树种按照顺序存储数据，降低执行排序操作ORDER BY/GROUP BY的成本，避免生成临时表</strong></li>
<li><strong>B+树的特点+数据顺序存储，可以将随机I/O变为顺序I/O</strong></li>
</ul>
<h3 id="索引的劣势"><a href="#索引的劣势" class="headerlink" title="索引的劣势"></a>索引的劣势</h3><ul>
<li>索引也是一张表，保存了主键和索引字段，并指向实体表的记录，所以也需要占用内存</li>
<li><strong>虽然索引大大提高了查询速度，同时却会降低更新表的速度</strong>，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要更新索引文件中对应的索引列字段， 因为这三种操作会导致索引信息发生变化</li>
<li>对于非常小的表使用全表扫描更高效，中到大型表适合使用索引，特大型表建立和使用索引代价随之增加，可以使用分区技术</li>
</ul>
<h3 id="MySQL索引分类"><a href="#MySQL索引分类" class="headerlink" title="MySQL索引分类"></a>MySQL索引分类</h3><h4 id="数据结构角度"><a href="#数据结构角度" class="headerlink" title="数据结构角度"></a>数据结构角度</h4><ul>
<li>B+树索引</li>
<li>Hash索引</li>
<li>Full-Text全文索引</li>
<li>R-Tree索引</li>
</ul>
<h4 id="从物理存储角度"><a href="#从物理存储角度" class="headerlink" title="从物理存储角度"></a>从物理存储角度</h4><ul>
<li>聚集索引（clustered index）</li>
<li>非聚集索引（non-clustered index），也叫二级索引（secondary index）<br>聚集索引和非聚集索引都是B+树结构</li>
</ul>
<h4 id="从逻辑角度"><a href="#从逻辑角度" class="headerlink" title="从逻辑角度"></a>从逻辑角度</h4><ul>
<li>主键索引：主键索引是一种特殊的唯一索引，不允许有空值</li>
<li>普通索引或者单列索引：每个索引只包含单个列，一个表可以有多个单列索引</li>
<li>联合索引（复合索引、多列索引）：联合索引指多个字段上创建的索引，使用联合索引时遵循匹配最左前缀，即联合索引必须从左至右依次使用（只有在精准匹配第一列之后才可以使用后面的列，<strong>如果出现了between则不能再使用后面的索引</strong>）</li>
<li>唯一索引或者非唯一索引</li>
<li>空间索引：空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，<strong>空间索引只能在存储引擎为MYISAM的表中创建</strong></li>
</ul>
<blockquote>
<p>❝</p>
<p>为什么MySQL 索引中用B+tree，不用B-tree 或者其他树，为什么不用 Hash 索引</p>
<p>聚簇索引/非聚簇索引，MySQL 索引底层实现，叶子结点存放的是数据还是指向数据的内存地址，使用索引需要注意的几个地方？</p>
<p>使用索引查询一定能提高查询的性能吗？为什么?</p>
</blockquote>
<h3 id="MySQL索引结构"><a href="#MySQL索引结构" class="headerlink" title="MySQL索引结构"></a>MySQL索引结构</h3><p><strong>首先要明白索引（index）是在存储引擎（storage engine）层面实现的，而不是server层面</strong>。不是所有的存储引擎都支持所有的索引类型。即使多个存储引擎支持某一索引类型，它们的实现和行为也可能有所差别。</p>
<h4 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B+Tree索引"></a>B+Tree索引</h4><p>MyISAM 和 InnoDB 存储引擎，都使用 B+Tree的数据结构，它相对与 B-Tree结构，所有的数据都存放在叶子节点上，且把叶子节点通过指针连接到一起，形成了一条数据链表，以加快相邻数据的检索效率</p>
<p><strong>先了解下 B-Tree 和 B+Tree 的区别</strong></p>
<h5 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h5><ul>
<li>B-Tree是为磁盘等外存储设备设计的一种平衡多路查找树（查找路径不止两个）。</li>
<li>系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。</li>
<li>InnoDB 存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB 存储引擎中默认每个页的大小为16KB，可通过参数 <code>innodb_page_size</code> 将页的大小设置为 4K、8K、16K，在 MySQL 中可通过如下命令查看页的大小：<code>show variables like &#39;innodb_page_size&#39;;</code></li>
<li>而系统一个磁盘块的存储空间往往没有这么大，因此 InnoDB 每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小 16KB。InnoDB 在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。</li>
<li>B-Tree 结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述 B-Tree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值，对应表中的主键值，data 为一行记录中除主键外的数据。对于不同的记录，key值互不相同。</li>
<li><strong>m阶的B-Tree的特性：</strong></li>
</ul>
<ol>
<li>每个节点最多有m个子节点</li>
<li>除了根节点和叶子节点外，其它每个节点至少有ceil(m/2)个子节点（ceil()向上取整）。</li>
<li>若根节点不是叶子节点，则至少有2个子节点</li>
<li>所有叶子节点都在同一层，且不包含其它关键字信息</li>
<li>关键字的个数n满足：ceil(m/2)-1 &lt;= n &lt;= m-1</li>
<li>每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn）</li>
<li>ki(i=1,…n)为关键字，且关键字升序排序</li>
<li>Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)</li>
</ol>
<ul>
<li><p>B-Tree 中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个 3 阶的 B-Tree：</p>
</li>
<li><ul>
<li>每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。</li>
<li>模拟查找关键字29的过程：</li>
</ul>
</li>
</ul>
<ol>
<li><ol>
<li><ol>
<li>根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】</li>
<li>比较关键字29在区间（17,35），找到磁盘块1的指针P2。</li>
<li>根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】</li>
<li>比较关键字29在区间（26,30），找到磁盘块3的指针P2。</li>
<li>根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】</li>
<li>在磁盘块8中的关键字列表中找到关键字29。</li>
</ol>
</li>
</ol>
</li>
</ol>
<ul>
<li><ul>
<li>分析上面过程，发现需要3次磁盘I/O操作，和3次内存查找操作。而3次磁盘I/O操作是影响整个B-Tree查找效率的决定因素，所以<strong>B-Tree相对于AVLTree缩减了节点个数</strong>，从而提高了查询效率。</li>
</ul>
</li>
</ul>
<h5 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h5><ul>
<li>B+Tree 是在 B-Tree 基础上的一种优化，使其更适合实现外存储索引结构，InnoDB 存储引擎就是用 B+Tree 实现其索引结构。</li>
<li>B-Tree结构图中每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。在B+Tree中，<strong>所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上**</strong>，而非叶子节点上只存储key值信息**<strong>，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度</strong>。</li>
<li>B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对B+Tree进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。</li>
<li><strong>B+Tree相对于B-Tree有几点不同：</strong></li>
</ul>
<ol>
<li>非叶子节点只存储键值信息；</li>
<li>所有叶子节点之间都有一个链指针；</li>
<li>数据记录都存放在叶子节点中</li>
</ol>
<ul>
<li>假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示：</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539886-ed20e377-d331-41d0-a2f8-1f7273b9442d.webp?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<ul>
<li><p>可能上面例子中只有22条数据记录，看不出B+Tree的优点，下面做一个推算：</p>
</li>
<li><ul>
<li>InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为10^3）。也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录。</li>
</ul>
</li>
<li><p>实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2-4层。MySQL的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。</p>
</li>
<li><p>B+Tree性质</p>
</li>
</ul>
<ol>
<li>通过上面的分析，我们知道IO次数取决于B+树的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有<img src="https://cdn.nlark.com/yuque/__latex/419c87720465f7f5a8523f3cc041af27.svg" alt="img">，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。</li>
<li>当B+树的数据项是复合的数据结构，比如(name,age,sex)的时候，B+树是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，B+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即<strong>索引的最左匹配特性</strong>。</li>
</ol>
<blockquote>
<p>❝B+树是怎么保证平衡的？</p>
</blockquote>
<p><a href="https://www.cnblogs.com/nullzx/p/8729425.html">B树、B+树插入删除过程</a></p>
<h5 id="MyISAM主键索引与二级索引的结构"><a href="#MyISAM主键索引与二级索引的结构" class="headerlink" title="MyISAM主键索引与二级索引的结构"></a>MyISAM主键索引与二级索引的结构</h5><ul>
<li><p>MyISAM引擎的索引文件和数据文件是分离的。<strong>MyISAM引擎索引结构的叶子节点的数据域，存放的并不是实际的数据记录，而是数据记录的地址</strong>。索引文件与数据文件分离，这样的索引称为”非聚簇索引”。MyISAM的主索引与二级索引区别并不大，只是主索引不能有重复的关键字</p>
</li>
<li><p>MyISAM索引</p>
</li>
<li><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590541902-8b1f0c77-6a43-4901-beab-7f3a2f3b0ff5.webp?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></li>
</ul>
</li>
<li><p>在MyISAM中，索引（含叶子节点）存放在单独的.myi文件中，叶子节点存放的是数据的物理地址偏移量</p>
</li>
<li><p>主索引是指主键索引，键值不可能重复；二级索引则是普通索引，键值可能重复。</p>
</li>
<li><p>通过索引查找数据的流程：先从索引文件中查找到索引节点，从中拿到数据的文件指针，再到数据文件中通过文件指针定位了具体的数据。二级索引类似。</p>
</li>
</ul>
<h5 id="InnoDB主键索引与二级索引的结构"><a href="#InnoDB主键索引与二级索引的结构" class="headerlink" title="InnoDB主键索引与二级索引的结构"></a>InnoDB主键索引与二级索引的结构</h5><ul>
<li><strong>InnoDB引擎索引结构的叶子节点的数据域，存放的就是实际的数据记录</strong>（对于主索引，此处会存放表中所有的数据记录；对于二级索引叶子节点存储的是主键，检索的时候通过叶子节点的主键到主键索引中找到对应数据行，即二级索引需要访问两次索引）</li>
<li>或者说，<strong>InnoDB的数据文件本身就是主键索引文件</strong>，这样的索引被称为“聚簇索引”，一个表只能有一个聚簇索引。</li>
<li><strong>向聚簇索引中的页插入新行，如果超出了存储容量则需要执行“页分裂”**</strong>，会导致页与页之间不连续**（分裂的页就不是聚簇的概念，会通过优化表的操作重新完成聚簇）</li>
</ul>
<h6 id="主键索引："><a href="#主键索引：" class="headerlink" title="主键索引："></a>主键索引：</h6><ul>
<li>InnoDB索引是聚集索引，它的索引和数据是存入同一个.idb文件中的，因此它的索引结构是在同一个树节点中同时存放索引和数据，如下图中最底层的叶子节点有三行数据，对应于数据表中的id、stu_id、name数据项。</li>
<li>在Innodb中，索引分叶子节点和非叶子节点，非叶子节点就像新华字典的目录，单独存放在索引段中，叶子节点则是顺序排列的，在数据段中。Innodb的数据文件可以按照表来切分（只需要开启<code>innodb_file_per_table)</code>，切分后存放在<code>xxx.ibd</code>中，默认不切分，存放在<code>xxx.ibdata</code>中。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539905-19dcb659-d0cf-440b-995d-2a62040981f3.webp?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<h6 id="二级（非主键）索引："><a href="#二级（非主键）索引：" class="headerlink" title="二级（非主键）索引："></a>二级（非主键）索引：</h6><ul>
<li>以示例中学生表中的name列建立二级索引，它的索引结构跟主键索引的结构有很大差别，在最底层的叶子结点有两行数据，第一行的字符串是二级索引，按照ASCII码进行排序，第二行的整数是主键的值。</li>
<li>这就意味着，对name列进行条件搜索，需要两个步骤：</li>
</ul>
<ol>
<li>在二级索引上检索name，到达其叶子节点获取对应的主键；</li>
<li>使用主键在主索引上再进行对应的检索操作</li>
</ol>
<p>这也就是所谓的“<strong>回表查询</strong>”</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539900-bb4d422c-e6a4-4b89-a3f0-44deb87c26cf.webp?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<h5 id="InnoDB-索引结构需要注意的点"><a href="#InnoDB-索引结构需要注意的点" class="headerlink" title="InnoDB 索引结构需要注意的点"></a>InnoDB 索引结构需要注意的点</h5><ol>
<li>数据文件本身就是索引文件</li>
<li>聚集索引中叶节点包含了完整的数据记录</li>
<li>InnoDB 表必须要有主键，并且推荐使用整型自增主键</li>
</ol>
<ul>
<li>不管是主键索引还是二级索引，所有的查询都是通过先查找到索引节点才能拿到相对应的数据，所以如果在设计表结构时没有显式指定索引列的话，MySQL 会从表中选择数据不重复的列建立索引，如果没有符合的列，则 MySQL 自动为 InnoDB 表生成一个隐含字段作为主键，并且这个字段长度为6个字节，类型为整型。</li>
</ul>
<blockquote>
<p>❝那为什么推荐使用整型自增主键而不是选择UUID？</p>
</blockquote>
<ul>
<li>UUID是字符串，比整型消耗更多的存储空间；</li>
<li>在B+树中进行查找时需要跟经过的节点值比较大小，整型数据的比较运算比字符串更快速；</li>
<li>自增的整型索引在磁盘中会连续存储，在读取一页数据时也是连续；UUID是随机产生的，读取的上下两行数据存储是分散的，不适合执行where id &gt; 5 &amp;&amp; id &lt; 20的条件查询语句。</li>
<li>在插入或删除数据时，整型自增主键会在叶子结点的末尾建立新的叶子节点，不会破坏左侧子树的结构；UUID主键很容易就破坏了原有树结构，B+树为了维持自身的特性，有可能会进行结构的重构，消耗更多的时间。</li>
</ul>
<blockquote>
<p>❝为什么非主键索引结构叶子节点存储的是主键值？</p>
</blockquote>
<p>保证数据一致性（更新数据的时候只更新主键索引中的数据即可）和节省存储空间，</p>
<h4 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h4><ul>
<li><p>主要就是通过Hash算法，将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。<br>检索算法：在检索查询时，就再次对待查关键字再次执行相同的Hash算法，得到Hash值，到对应Hash表对应位置取出数据即可，如果发生Hash碰撞，则需要在取值时进行筛选。</p>
</li>
<li><p><strong>Hash索引的限制：</strong></p>
</li>
<li><ul>
<li>value存储的是行指针，不能实现覆盖索引</li>
<li>哈希索引不是按照索引值顺序存储的，所以不能用于排序，也就不支持范围查找</li>
<li>联合索引时不支持使用部分索引进行查找，因为hash值是由全部索引列计算得到的</li>
<li>哈希冲突严重的时候相当于遍历链表，反而比不上二叉树</li>
</ul>
</li>
<li><p>MySQL目前有Memory引擎和NDB引擎支持Hash索引。</p>
</li>
<li><p>InnoDB可以创建自定义哈希索引：</p>
</li>
<li><ul>
<li>当需要根据URL进行索引时，可以将URL的hash值作为索引的列，这样可以降低索引值长度，并且是整数比较速度快</li>
<li>即使有大量的哈希冲突，但是索引仍然可以过滤很多数据，而且速度比直接使用URL快</li>
</ul>
</li>
</ul>
<h4 id="full-text全文索引"><a href="#full-text全文索引" class="headerlink" title="full-text全文索引"></a>full-text全文索引</h4><ul>
<li>全文索引也是MyISAM的一种特殊索引类型，主要用于全文索引，InnoDB从MYSQL5.6版本提供对全文索引的支持。</li>
<li>它用于替代效率较低的LIKE模糊匹配操作，而且可以通过多字段组合的全文索引一次性全模糊匹配多个字段。</li>
<li>同样使用B-Tree存放索引数据，但使用的是特定的算法，将字段数据分割后再进行索引（一般每4个字节一次分割），索引文件存储的是分割前的索引字符串集合，与分割后的索引信息，对应B-tree结构的节点存储的是分割后的词信息以及它在分割前的索引字符串集合中的位置。</li>
</ul>
<h4 id="R-Tree空间索引"><a href="#R-Tree空间索引" class="headerlink" title="R-Tree空间索引"></a>R-Tree空间索引</h4><p>空间索引是MyISAM的一种特殊索引类型，主要用于地理空间数据类型</p>
<blockquote>
<p>❝为什么Mysql索引要用B+树不是B树？</p>
</blockquote>
<p>用B+树不用B树考虑的是IO对性能的影响，B树的每个节点都存储数据，而B+树只有叶子节点才存储数据，所以查找相同数据量的情况下，B树的高度更高，IO更频繁。数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。其中在MySQL底层对B+树进行进一步优化：在叶子节点中是双向链表，且在链表的头结点和尾节点也是循环指向的。</p>
<blockquote>
<p>❝面试官：为何不采用Hash方式？</p>
</blockquote>
<p>因为Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。所以，哈希索引只适用于等值查询的场景。而B+Tree是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描。</p>
<p>哈希索引不支持多列联合索引的最左匹配规则，如果有大量重复键值的情况下，哈希索引的效率会很低，因为存在哈希碰撞问题。</p>
<h3 id="哪些情况需要创建索引"><a href="#哪些情况需要创建索引" class="headerlink" title="哪些情况需要创建索引"></a>哪些情况需要创建索引</h3><ol>
<li>主键自动建立唯一索引</li>
<li>频繁作为查询条件的字段</li>
<li>查询中与其他表关联的字段，外键关系建立索引</li>
<li>单键/组合索引的选择问题，高并发下倾向创建组合索引</li>
<li>查询中排序的字段，排序字段通过索引访问大幅提高排序速度</li>
<li>查询中统计或分组字段</li>
</ol>
<h3 id="哪些情况不要创建索引"><a href="#哪些情况不要创建索引" class="headerlink" title="哪些情况不要创建索引"></a>哪些情况不要创建索引</h3><ol>
<li>表记录太少</li>
<li>经常增删改的表</li>
<li>数据重复且分布均匀的表字段，只应该为最经常查询和最经常排序的数据列建立索引（如果某个数据类包含太多的重复数据，建立索引没有太大意义）</li>
<li>频繁更新的字段不适合创建索引（会加重I/O负担）</li>
<li>where条件里用不到的字段不创建索引</li>
</ol>
<h3 id="高性能创建索引"><a href="#高性能创建索引" class="headerlink" title="高性能创建索引"></a>高性能创建索引</h3><p>创建索引的时候有各种细节可以使得索引的使用效率进一步提高**<br>**</p>
<h4 id="列前缀索引"><a href="#列前缀索引" class="headerlink" title="列前缀索引"></a>列前缀索引</h4><ul>
<li><p>有时需要索引很长的字符列，会让索引变得大且慢。一个策略是使用哈希索引，另一种方式是使用列前缀索引，即使用该列前一部分字符建立索引，并查询时也只使用该列的前一部分字符。注意：列前缀索引和匹配最前缀索引不是一回事，前者是一个列，后者是多个列</p>
</li>
<li><ul>
<li>例如</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>建立city列字符串的前3个字符的索引：</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>ALTER TABLE sakila.city_demo ADD KEY (city(7));</p>
<ul>
<li><ul>
<li><ul>
<li>查询city列字符串的前3个字符：</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>SELECT COUNT(*) AS cnt, LEFT(city,3) AS pref</p>
<p>FROM sakila.city_demo GROUP BY pref ORDER BY cnt DESC LIMIT 10;</p>
<ul>
<li><p>查询时究竟选择几个字符需要根据实际列判断索引选择性：</p>
</li>
<li><ul>
<li><ul>
<li>索引选择性：不重复的索引项/数据表的记录总数（即，分支越多索引选择性越大）</li>
<li>选择全部的字符串时索引选择性大</li>
<li>当选择前n个字符的索引选择性接近全字符串的索引选择性时是最佳的列前缀索引</li>
</ul>
</li>
</ul>
</li>
<li><p>使用列前缀索引则不能在该列上使用ORDER BY/GROUP BY，也不能作为覆盖索引</p>
</li>
</ul>
<h4 id="联合索引中索引顺序"><a href="#联合索引中索引顺序" class="headerlink" title="联合索引中索引顺序"></a>联合索引中索引顺序</h4><ul>
<li><p>“三星”索引概念：</p>
</li>
<li><ul>
<li>与查询相关的索引行是相邻的，也就是where后面的等值谓词，可以匹配索引列顺序——where和索引匹配越多，扫描的数据行越少</li>
<li>索引行的顺序与查询语句需求一致，也就是order by 中的排序和索引顺序是否一致——避免排序</li>
<li>索引行包含查询语句中所有的列——避免扫描数据行</li>
</ul>
</li>
<li><p>一个联合索引中的索引列顺序可以影响到一个索引是否是“三星”索引</p>
</li>
<li><p>通用经验是将选择性高的列放在索引最前列，这样仅仅在where进行查找时效果较好，仅仅是一个经验，排序和分组时这样并不一定适合，实践中并不一定这么做</p>
</li>
<li><p>《高性能MySQL》P183 5.4 索引学习中有很好的设计索引的例子，例子中的选择</p>
</li>
<li><ul>
<li>例子：根据用户信息表的多个列筛选出指定的特征的一批用户</li>
<li>country,sex这种列虽然选择性不强但使用这个列进行查询的情况比较多，所以作为联合索引的头两列(sex,country)</li>
<li>如果查新时没有限定性别，则可以在WHERE中新增AND SEX IN(‘m’,’f’)，保证满足匹配最左索引，使得该索引发挥作用</li>
<li>对于age这种一般都设定为范围的列，建立索引时要放在联合索引的最右边(sex,country,…,age)</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>因为基于索引查询需要满足匹配最左前缀，直到遇到第一个范围条件列。即，如果age在第一列，那么使用WHERE AGE BETWEEN 18 AND 24，那么后面的sex,country列就不能作为索引列了，联合索引仅仅只使用了第一列age</li>
<li>当然可以转化为AND AGE IN (18,19,20,21,22,23,24)，但是不是所有的范围查询都可以转换的</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>IN(…)这种技巧不要过于依赖，由于多列IN组合的数量是乘法，所以组合数会快速增加，当组合数达到上千个时就需要小心了</li>
</ul>
</li>
</ul>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p><strong>覆盖索引</strong>（Covering Index）,或者叫索引覆盖， 可以不需要回表操作</p>
<ul>
<li>就是select查询数据列在索引中就已经完全包含，不必读取数据行，利用索引返回select列表中的字段，而不必根据索引再次读取数据文件，换句话说<strong>查询列要被所建的索引覆盖</strong>。</li>
<li>索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据，当能通过读取索引就可以得到想要的数据，那就不需要读取行了。一个索引包含（覆盖）满足查询结果的数据就叫做覆盖索引。</li>
<li><strong>判断标准</strong><br>使用explain，可以通过输出的extra列来判断，对于一个索引覆盖查询，显示为<strong>using index</strong>，MySQL查询优化器在执行查询前会决定是否有索引覆盖查询</li>
</ul>
<h2 id="七、MySQL查询"><a href="#七、MySQL查询" class="headerlink" title="七、MySQL查询"></a>七、MySQL查询</h2><ul>
<li>查询优化、索引优化、库表结构优化需要齐头并进</li>
</ul>
<h3 id="优化慢查询"><a href="#优化慢查询" class="headerlink" title="优化慢查询"></a>优化慢查询</h3><ul>
<li>是否查询了大量的结果，但是仅使用前10条——使用LIMIT</li>
<li>多表关联的时候返回了全部的列（SELECT * FROM actor INNER JOIN film_actor USING(actor_id) WHERE …）——仅返回需要的列</li>
<li>取出不需要的列（SELECT * FROM xxx）</li>
</ul>
<p>取出不需要的列会导致优化器无法使用索引覆盖进行优化，同时还会带来额外的I/O、内存和CPU消耗</p>
<h3 id="索引效果与优化"><a href="#索引效果与优化" class="headerlink" title="索引效果与优化"></a>索引效果与优化</h3><p>使用WHERE条件的三种方式，从好到坏：</p>
<ul>
<li>索引中使用WHERE条件过滤不匹配的记录。在存储引擎层完成</li>
<li>使用索引覆盖扫描返回记录（Explain中Extra列为Using index）。在MySQL服务器层完成，不需要回表查询</li>
<li>从数据表中返回记录，然后根据WHERE过滤不满足条件的记录（Explain中Extra列为Using Where）。在MySQL服务器层完成，需要先从数据表读出记录再过滤</li>
</ul>
<p>发现扫描大量数据，但只返回需要的少量数据，优化方式：</p>
<ul>
<li>从索引角度入手，使用索引覆盖扫描</li>
<li>从库表结构入手，例如使用单独的汇总表（优化count()语句）</li>
<li>从查询语句入手，重写查询语句，下面会介绍</li>
</ul>
<h3 id="重构查询的方式"><a href="#重构查询的方式" class="headerlink" title="重构查询的方式"></a>重构查询的方式</h3><h4 id="切分查询"><a href="#切分查询" class="headerlink" title="切分查询"></a>切分查询</h4><ul>
<li><p>有时候可以将一个大查询切分成小查询</p>
</li>
<li><p>例如，删除旧数据</p>
</li>
<li><ul>
<li>一次删除大量数据可能锁住很多数据，占满整个事务日志、耗尽资源、阻塞很多重要查询</li>
<li>将要删除的数据分为多次小删除对服务器影响较小</li>
<li>原SQL语句一次删除大量数据：DELETE FROM messages WHERE created &lt; DATE_SUB(NOW(),INTERVAL 3 MONTH);</li>
<li>一次只删除10000行数据：rows_affected = 0</li>
</ul>
</li>
</ul>
<p>do {</p>
<p> rows_affected = do_query{</p>
<p>“DELETE FROM messages WHERE created &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH)</p>
<p>LIMIT 10000”)</p>
<p>} while rows_affected &gt; 0</p>
<h4 id="分解关联查询"><a href="#分解关联查询" class="headerlink" title="分解关联查询"></a>分解关联查询</h4><ul>
<li><p><strong>将一条关联查询分解成多个独立的单表查询，可以具有如下优势：</strong></p>
</li>
<li><ul>
<li>缓存的效率更高。缓存单表查询的话重复查询的频率会更高</li>
<li>执行单个查询可以减少锁竞争</li>
<li>持久层分解，应用层关联，可以更容易拆分数据库，提高可伸缩性</li>
</ul>
</li>
</ul>
<h3 id="查询执行的基础"><a href="#查询执行的基础" class="headerlink" title="查询执行的基础"></a>查询执行的基础</h3><ul>
<li><p>客户端向服务器发送请求时的步骤：</p>
</li>
<li><ul>
<li>客户端发送一条查询给服务器</li>
<li>服务器先检查<strong>查询缓存</strong>，如果命中缓存则立即返回缓存中的结果，否则进入下一阶段</li>
<li>服务器端进行SQL<strong>解析、预处理</strong>，再由<strong>优化器</strong>生成对应的<strong>执行计划</strong></li>
<li>根据执行计划调用存储引擎的API来执行查询</li>
<li>将结果返回给客户端</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1590917863447-22c656bd-a4c5-4b08-8c99-7b39215b5f4f.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image.png"></li>
</ul>
</li>
</ul>
<h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><ul>
<li>解析查询语句前MySQL会解析查询是否命中缓存中的数据。检查是通过大小写敏感的哈希查找，即使查询语句有一个字节不同也不会匹配</li>
<li>如果匹配了则检查权限，并直接返回缓存中的结果</li>
<li>如果没有匹配则执行下面的步骤</li>
</ul>
<h4 id="查询优化处理"><a href="#查询优化处理" class="headerlink" title="查询优化处理"></a>查询优化处理</h4><ul>
<li>查询在查询缓存后的下一个生命周期是将SQL转换成一个执行计划，具体步骤包括：<strong>解析SQL、预处理、优化SQL执行计划</strong></li>
</ul>
<h5 id="语法解析器和预处理"><a href="#语法解析器和预处理" class="headerlink" title="语法解析器和预处理"></a>语法解析器和预处理</h5><ul>
<li>解析器根据SQL关键字解析，并生成“解析树”。这个步骤会进行验证和解析查询，例如，验证是否错误的关键字，关键字顺序是否正确</li>
<li>预处理器进一步检查解析树是否合法，例如，查询数据表和数据列是否存在。同时会验证权限。</li>
</ul>
<h5 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h5><ul>
<li><p>优化器将这个合法的语法树转化成执行计划</p>
</li>
<li><p>一条查询语句可以有多种执行方式，返回相同的结果，优化器的作用就是找到其中最好的执行计划</p>
</li>
<li><p>MySQL使用基于成本的优化器，主要是完成查询需要读取数据页的数量。受限于统计信息不准确（MVCC架构），没有考虑并发情况等，最终的执行计划并不一定是最优的</p>
</li>
<li><p>优化策略可以分为两种：</p>
</li>
<li><ul>
<li>静态优化：直接对解析树进行优化，例如通过简单的代数变换将where条件转换成另一种等价形式（下面有例子）</li>
<li>动态优化：与查询的上下文有关，也可能和很多其他因素有关，例如where条件中的取值、索引中条目对应的数据行数。因为不是固定的优化策略，所以每次查询都要重新评估。</li>
</ul>
</li>
<li><p>MySQL能够处理的优化类型：</p>
</li>
<li><ul>
<li><strong>重新定义关联表的顺序：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>下面会说</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>将外连接转化成内连接：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>有些外连接LEFT OUTER JOIN 可以转换成内连接INNER JOIN，这样就可以调整管关联顺序了</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>优化COUNT()、MIN()、MAX()：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>例如最小值可以直接查询B-Tree最左端记录</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>预估并转换为常数表达式：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>检测到表达式可以转化成常数时会将其当作常数进行优化处理</li>
<li>此外，有时候一个查询也可以转化为一个常数，例子：</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>EXPLAIN SELECT film.film_id, film_actor.actor_id</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>FROM sakila.film</p>
<p>INNER JOIN sakila.film_actor USING(film_id)</p>
<p>WHERE film.film_id=1;</p>
<ul>
<li><ul>
<li><ul>
<li><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1590914393242-1ebaea4c-d929-4b6a-820e-b21c8c6de7a9.png" alt="image.png"></li>
<li>上面查询分为两步：</li>
<li>①：先从film表找到需要的行，因为film_id字段上有主键索引，所以MySQL知道只会返回一行数据，所以表的访问类型是const</li>
<li>②：因为第一步返回的film_id列当作已知取值的列，那么对表film_actor的访问类型也是const</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>覆盖索引扫描：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>索引中的列包含所有查询中需要的列时就可以使用索引返回需要的数据，无须查询对应的数据行</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>子查询优化：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>某些情况下会将子查询转换一种形式，从而减少多个查询多次对数据进行访问的次数</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>提前终止查询：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>发现已经满足查询需求时候会立刻终止查询，比如使用LIMIT的时候，或者发现一个不成立的条件时（SELECT  film.film_id FROM sakila.film WHERE film_id = -1）</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>等值传播：</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>如果两个列通过等式关联，那么MySQL能够把其中一个列的WHERE条件传递到另一个列上，例如：</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>SELECT film.film_id</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>FROM sakila.film</p>
<p>INNER JOIN sakila.film_actor USING(film_id)</p>
<p>WHERE film.film_id&gt;500;</p>
<ul>
<li><ul>
<li><ul>
<li><ul>
<li>由于WHERE 子句中的film_id字段同样适用于film_actor表，那么MySQL会优化成下面的形式：</li>
<li>… WHERE film.film_id &gt; 500 AND film_actor.film_id &gt; 500</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>列表IN()</strong></li>
</ul>
</li>
<li><ul>
<li><ul>
<li>很多数据库系统中，IN()完全等同于多个OR条件的子句，复杂度O(n)。但是MySQL会将IN()中的数据先排序，然后通过二分查找确定IN()中的值是否满足条件，复杂度O(logn)。IN()中有大量取值时，MySQL处理速度会快一定</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="数据和索引的统计信息"><a href="#数据和索引的统计信息" class="headerlink" title="数据和索引的统计信息"></a>数据和索引的统计信息</h5><ul>
<li><p>统计信息由存储引擎实现</p>
</li>
<li><p>查询优化器在生成查询计划时，需要向存储引擎获取相应的统计信息，包括</p>
</li>
<li><ul>
<li>每个表或索引有多少页</li>
<li>每个表的每个索引的基数是多少（索引选择性）</li>
<li>数据行和索引长度、索引的分布信息等</li>
</ul>
</li>
</ul>
<h5 id="如何执行关联查询"><a href="#如何执行关联查询" class="headerlink" title="如何执行关联查询"></a>如何执行关联查询</h5><ul>
<li><p>MySQL概念中不仅仅是查询需要到两个表才叫关联，，每个查询都是一次关联。</p>
</li>
<li><p>MySQL关联执行的策略：</p>
</li>
<li><ul>
<li>嵌套循环关联：先在一个表中循环取出单条数据，然后再执行嵌套循环到下一个表中匹配的行，依次下去，直到找到所有表中匹配的行。然后根据各表匹配的行，返回查询中需要的各个列。先在最后一个关联表尝试找到所有匹配的行，然后再回溯到上一个表。</li>
<li>即，循环+嵌套获取所有匹配的行，然后回溯返回数据</li>
</ul>
</li>
<li><p>MySQL多表关联示意图：</p>
</li>
<li><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1590918172760-399cd7a4-0411-4da4-8812-47e69bb74014.png" alt="image.png"></li>
</ul>
</li>
<li><p>MySQL关联查询示例图</p>
</li>
<li><ul>
<li>SQL语句：SELECT tbl1.col1, tbl2.col2 FROM tbl1 INNER JOIN tbl2 USING(col3) WHERE tbl1.col1 IN(5,6);</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1590917828821-0399668d-00d1-4c66-8d35-70e18754ede5.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image.png"></li>
</ul>
</li>
</ul>
<h5 id="关联查询优化器"><a href="#关联查询优化器" class="headerlink" title="关联查询优化器"></a>关联查询优化器</h5><ul>
<li><p>MySQL优化器最重要的部分就是关联查询优化，多表关联时可以有多种不同的关联顺序来获取相同的结果，关联查询优化器就是通过评估不同顺序时的成本来选择代价最小的关联顺序</p>
</li>
<li><p>例子：</p>
</li>
<li><ul>
<li>SQL语句：SELECT film_id, film.title, film.release_year, actor.actor_id, actor.first_name, actor.last_name</li>
</ul>
</li>
</ul>
<p>FROM sakila.<strong>film</strong></p>
<p>INNER JOIN sakila.<strong>film_actor</strong> USING(film_id)</p>
<p>INNER JOIN sakila.<strong>actor</strong> USING(actor_id);</p>
<ul>
<li><ul>
<li>MySQL没有按照SQL关联的顺序，而是优化了关联顺序，EXPLAIN结果如下：</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1590918875519-95211bf1-b239-4546-924d-652fd842d47d.png" alt="image.png"></li>
<li>如果让MySQL强行按照SQL顺序执行，在SELECT后加STRAIGHT_JOIN，EXPLAIN结果如下：</li>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1266758/1590919015592-d17f26a1-03b9-416c-966d-b313c527d900.png" alt="image.png"></li>
<li>可以发现修改关联顺序可以减少扫描的行数，让查询进行更少的嵌套循环和回溯操作</li>
<li>如果可以的话，优化器会遍历每一个表然后逐个做嵌套循环计算成本，然后返回最优的执行计划</li>
<li>但是n个表的关联种数是阶乘，所以会使用“启发式”优化策略，并不会遍历计算所有可能的执行计划</li>
<li>（注意：各个查询的顺序不能随意安排，因为后面的表的查询需要依赖于前面表的查询结果。比如左外连接、相关子查询）</li>
</ul>
</li>
</ul>
<h5 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h5><ul>
<li><p>MySQL排序规则：</p>
</li>
<li><ul>
<li>当不能使用索引生成排序结果时，MySQL会使用filesort进行排序</li>
<li><strong>如果数据量小于“排序缓冲区”会在内存中使用快排进行排序。如果数据量大于则会在磁盘中进行排序，先将数据分块，对每个独立的块使用快排，然后将各个块的排序结果存放在磁盘上，然后将各个排好序的块进行合并，最后返回结果</strong></li>
</ul>
</li>
<li><p>MySQL排序算法：</p>
</li>
<li><ul>
<li>两次传输排序：① 读取行指针和需要排序的字段，并对其排序。② 然后根据排序结果读取所需要的数据行</li>
<li>单次传输排序：① 读取查询需要的所有列，然后根据给定列进行排序，最后直接返回排序结果</li>
<li>两种算法各有优劣</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>两次传输排序：因为排序后再读取数据行，会产生大量的随机I/O</li>
<li>顺序读取数据行，不会随机I/O，缺点是如果需要返回的列非常多，会额外占用大量的空间，而这些列对排序本身没有帮助</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="查询执行计划"><a href="#查询执行计划" class="headerlink" title="查询执行计划"></a>查询执行计划</h4><ul>
<li>查询执行引擎根据执行计划调用API完成查询</li>
</ul>
<h4 id="返回结果给客户端"><a href="#返回结果给客户端" class="headerlink" title="返回结果给客户端"></a>返回结果给客户端</h4><ul>
<li>将查询结果返回给客户端，如果缓存开启，则将结果存放到查询缓存中</li>
<li>并不是查询彻底完成后才开始返回的，一旦服务器处理完最后一个关联表，开始生成第一条结果时，就开始向客户端逐步返回结果集</li>
<li>好处：服务器端不用存储太多了结果，客户端可以第一时间获得返回的结果</li>
</ul>
<h3 id="几个查询语句的区别"><a href="#几个查询语句的区别" class="headerlink" title="几个查询语句的区别"></a>几个查询语句的区别</h3><h5 id="count-和count-列名-查询"><a href="#count-和count-列名-查询" class="headerlink" title="count(*)和count(列名)查询"></a>count(*)和count(列名)查询</h5><ul>
<li>count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL</li>
<li>count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数，即某个字段值为NULL时，不统计。</li>
</ul>
<h5 id="in和-exists-的区别？"><a href="#in和-exists-的区别？" class="headerlink" title="in和 exists 的区别？"></a>in和 exists 的区别？</h5><ul>
<li>exists：exists对外表用loop逐条查询，每次查询都会查看exists的条件语句，当exists里的条件语句能够返回记录行时（无论记录行是的多少，只要能返回），条件就为真，返回当前loop到的这条记录；反之，如果exists里的条件语句不能返回记录行，则当前loop到的这条记录被丢弃，exists的条件就像一个bool条件，当能返回结果集则为true，不能返回结果集则为false</li>
<li>in：in查询相当于多个or条件的叠加</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> A.id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> B);</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> * <span class="keyword">from</span> B <span class="keyword">WHERE</span> B.id = A.id);</span><br></pre></td></tr></table></figure>

<ul>
<li>如果查询的两个表大小相当，那么用in和exists差别不大</li>
<li>如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in</li>
</ul>
<h5 id="UNION和UNION-ALL的区别"><a href="#UNION和UNION-ALL的区别" class="headerlink" title="UNION和UNION ALL的区别?"></a>UNION和UNION ALL的区别?</h5><p>UNION和UNION ALL都是将两个结果集合并为一个，<strong>两个要联合的SQL语句 字段个数必须一样，而且字段类型要“相容”（一致）；</strong></p>
<ul>
<li>UNION在进行表连接后会筛选掉重复的数据记录（效率较低），而UNION ALL则不会去掉重复的数据记录；</li>
<li>UNION会按照字段的顺序进行排序，而UNION ALL只是简单的将两个结果合并就返回；</li>
</ul>
<h3 id="SQL执行顺序"><a href="#SQL执行顺序" class="headerlink" title="SQL执行顺序"></a>SQL执行顺序</h3><ul>
<li>手写</li>
</ul>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> &lt;select_list&gt;</span><br><span class="line"><span class="keyword">FROM</span>  &lt;left_table&gt; &lt;join_type&gt;</span><br><span class="line"><span class="keyword">JOIN</span>  &lt;right_table&gt; <span class="keyword">ON</span> &lt;join_condition&gt;</span><br><span class="line"><span class="keyword">WHERE</span>  &lt;where_condition&gt;</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span>  &lt;group_by_list&gt;</span><br><span class="line"><span class="keyword">HAVING</span> &lt;having_condition&gt;</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;order_by_condition&gt;</span><br><span class="line"><span class="keyword">LIMIT</span> &lt;limit_number&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>机读</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span>  &lt;left_table&gt;</span><br><span class="line"><span class="keyword">ON</span> &lt;join_condition&gt;</span><br><span class="line">&lt;join_type&gt; <span class="keyword">JOIN</span>  &lt;right_table&gt;</span><br><span class="line"><span class="keyword">WHERE</span>  &lt;where_condition&gt;</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span>  &lt;group_by_list&gt;</span><br><span class="line"><span class="keyword">HAVING</span> &lt;having_condition&gt;</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">DISTINCT</span> &lt;select_list&gt;</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;order_by_condition&gt;</span><br><span class="line"><span class="keyword">LIMIT</span> &lt;limit_number&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>总结</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539949-2595b2b5-7eac-4a9f-a6ca-016a37625d12.webp" alt="image"></p>
<blockquote>
<p>❝</p>
<p>mysql 的内连接、左连接、右连接有什么区别？</p>
<p>什么是内连接、外连接、交叉连接、笛卡尔积呢？</p>
</blockquote>
<h3 id="Join图"><a href="#Join图" class="headerlink" title="Join图"></a>Join图</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539969-2ac4a686-05ba-4792-baa4-251a6c5bd854.webp?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<h2 id="八、MySQL调优"><a href="#八、MySQL调优" class="headerlink" title="八、MySQL调优"></a>八、MySQL调优</h2><blockquote>
<p>❝</p>
<p>日常工作中你是怎么优化SQL的？</p>
<p>SQL优化的一般步骤是什么，怎么看执行计划（explain），如何理解其中各个字段的含义？</p>
<p>如何写sql能够有效的使用到复合索引？</p>
<p>一条sql执行过长的时间，你如何优化，从哪些方面入手？</p>
<p>什么是最左前缀原则？什么是最左匹配原则？</p>
</blockquote>
<h3 id="影响mysql的性能因素"><a href="#影响mysql的性能因素" class="headerlink" title="影响mysql的性能因素"></a>影响mysql的性能因素</h3><ul>
<li><p>业务需求对MySQL的影响(合适合度)</p>
</li>
<li><p>存储定位对MySQL的影响</p>
</li>
<li><ul>
<li>系统各种配置及规则数据</li>
<li>活跃用户的基本信息数据</li>
<li>活跃用户的个性化定制信息数据</li>
<li>准实时的统计信息数据</li>
<li>其他一些访问频繁但变更较少的数据</li>
<li>二进制多媒体数据</li>
<li>流水队列数据</li>
<li>超大文本数据</li>
<li>不适合放进MySQL的数据</li>
<li>需要放进缓存的数据</li>
</ul>
</li>
<li><p>Schema设计对系统的性能影响</p>
</li>
<li><ul>
<li>尽量减少对数据库访问的请求</li>
<li>尽量减少无用数据的查询请求</li>
</ul>
</li>
<li><p>硬件环境对系统性能的影响</p>
</li>
</ul>
<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><h4 id="MySQL-Query-Optimizer"><a href="#MySQL-Query-Optimizer" class="headerlink" title="MySQL Query Optimizer"></a>MySQL Query Optimizer</h4><ol>
<li>MySQL 中有专门负责优化 SELECT 语句的优化器模块，主要功能：通过计算分析系统中收集到的统计信息，为客户端请求的 Query 提供他认为最优的执行计划（他认为最优的数据检索方式，但不见得是 DBA 认为是最优的，这部分最耗费时间）</li>
<li>当客户端向 MySQL 请求一条 Query，命令解析器模块完成请求分类，区别出是 SELECT 并转发给 MySQL Query Optimize r时，MySQL Query Optimizer 首先会对整条 Query 进行优化，处理掉一些常量表达式的预算，直接换算成常量值。并对 Query 中的查询条件进行简化和转换，如去掉一些无用或显而易见的条件、结构调整等。然后分析 Query 中的 Hint 信息（如果有），看显示 Hint 信息是否可以完全确定该 Query 的执行计划。如果没有 Hint 或 Hint 信息还不足以完全确定执行计划，则会读取所涉及对象的统计信息，根据 Query 进行写相应的计算分析，然后再得出最后的执行计划。</li>
</ol>
<h4 id="MySQL常见瓶颈"><a href="#MySQL常见瓶颈" class="headerlink" title="MySQL常见瓶颈"></a>MySQL常见瓶颈</h4><ul>
<li>CPU：CPU在饱和的时候一般发生在数据装入内存或从磁盘上读取数据时候</li>
<li>IO：磁盘I/O瓶颈发生在装入数据远大于内存容量的时候</li>
<li>服务器硬件的性能瓶颈：top，free，iostat 和 vmstat来查看系统的性能状态</li>
</ul>
<h4 id="性能下降SQL慢-执行时间长-等待时间长-原因分析"><a href="#性能下降SQL慢-执行时间长-等待时间长-原因分析" class="headerlink" title="性能下降SQL慢 执行时间长 等待时间长 原因分析"></a>性能下降SQL慢 执行时间长 等待时间长 原因分析</h4><ul>
<li>查询语句写的烂</li>
<li>索引失效（单值、复合）</li>
<li>关联查询太多join（设计缺陷或不得已的需求）</li>
<li>服务器调优及各个参数设置（缓冲、线程数等）</li>
</ul>
<h4 id="MySQL常见性能分析手段"><a href="#MySQL常见性能分析手段" class="headerlink" title="MySQL常见性能分析手段"></a>MySQL常见性能分析手段</h4><p>在优化MySQL时，通常需要对数据库进行分析，常见的分析手段有<strong>慢查询日志</strong>，<strong>EXPLAIN 分析查询</strong>，<strong>profiling分析</strong>以及<strong>show命令查询系统状态及系统变量</strong>，通过定位分析性能的瓶颈，才能更好的优化数据库系统的性能。</p>
<h5 id="性能瓶颈定位"><a href="#性能瓶颈定位" class="headerlink" title="性能瓶颈定位"></a>性能瓶颈定位</h5><p>我们可以通过 show 命令查看 MySQL 状态及变量，找到系统的瓶颈：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">Mysql&gt; <span class="keyword">show</span> status ——显示状态信息（扩展<span class="keyword">show</span> status <span class="keyword">like</span> ‘XXX’）</span><br><span class="line">Mysql&gt; <span class="keyword">show</span> variables ——显示系统变量（扩展<span class="keyword">show</span> variables <span class="keyword">like</span> ‘XXX’）</span><br><span class="line">Mysql&gt; <span class="keyword">show</span> innodb status ——显示InnoDB存储引擎的状态</span><br><span class="line">Mysql&gt; <span class="keyword">show</span> processlist ——查看当前<span class="keyword">SQL</span>执行，包括执行状态、是否锁表等</span><br><span class="line">Shell&gt; mysqladmin variables -u username -p <span class="keyword">password</span>——显示系统变量</span><br><span class="line">Shell&gt; mysqladmin extended-status -u username -p <span class="keyword">password</span>——显示状态信息</span><br></pre></td></tr></table></figure>

<h5 id="Explain-执行计划"><a href="#Explain-执行计划" class="headerlink" title="Explain(执行计划)"></a>Explain(执行计划)</h5><p>是什么：使用 <strong>Explain</strong> 关键字可以模拟优化器执行SQL查询语句，从而知道 MySQL 是如何处理你的 SQL 语句的。分析你的查询语句或是表结构的性能瓶颈</p>
<p>能干吗：</p>
<ul>
<li>表的读取顺序</li>
<li>数据读取操作的操作类型</li>
<li>哪些索引可以使用</li>
<li>哪些索引被实际使用</li>
<li>表之间的引用</li>
<li>每张表有多少行被优化器查询</li>
</ul>
<p>怎么玩：</p>
<ul>
<li>Explain + SQL语句</li>
<li>执行计划包含的信息（如果有分区表的话还会有<strong>partitions</strong>）</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539945-f25d6d79-1cb8-42b6-a6fa-b57a1ba9b5c9.webp" alt="image">expalin</p>
<p>各字段解释</p>
<ul>
<li><p><strong>id</strong>（select 查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序）</p>
</li>
<li><ul>
<li>id相同，执行顺序从上往下</li>
<li>id全不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</li>
<li>id部分相同，执行顺序是先按照数字大的先执行，然后数字相同的按照从上往下的顺序执行</li>
</ul>
</li>
<li><p><strong>select_type</strong>（查询类型，用于区别普通查询、联合查询、子查询等复杂查询）</p>
</li>
<li><ul>
<li><strong>SIMPLE</strong> ：简单的select查询，查询中不包含子查询或UNION</li>
<li><strong>PRIMARY</strong>：查询中若包含任何复杂的子部分，最外层查询被标记为PRIMARY</li>
<li><strong>SUBQUERY</strong>：在select或where列表中包含了子查询</li>
<li><strong>DERIVED</strong>：在from列表中包含的子查询被标记为DERIVED，MySQL会递归执行这些子查询，把结果放在临时表里</li>
<li><strong>UNION</strong>：若第二个select出现在UNION之后，则被标记为UNION，若UNION包含在from子句的子查询中，外层select将被标记为DERIVED</li>
<li><strong>UNION RESULT</strong>：从UNION表获取结果的select</li>
</ul>
</li>
<li><p><strong>table</strong>（显示这一行的数据是关于哪张表的）</p>
</li>
<li><p><strong>type</strong>（显示查询使用了那种类型，从最好到最差依次排列 <strong>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</strong> ）<br>tip: 一般来说，得保证查询至少达到range级别，最好到达ref</p>
</li>
<li><ul>
<li>system：表只有一行记录（等于系统表），是 const 类型的特例，平时不会出现</li>
<li>const：表示通过索引一次就找到了，const 用于比较 primary key 或 unique 索引，因为只要匹配一行数据，所以很快，如将主键置于 where 列表中，mysql 就能将该查询转换为一个常量</li>
<li>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常见于主键或唯一索引扫描</li>
<li>ref：非唯一性索引扫描，范围匹配某个单独值得所有行。本质上也是一种索引访问，他返回所有匹配某个单独值的行，然而，它可能也会找到多个符合条件的行，多以他应该属于查找和扫描的混合体</li>
<li>range：只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引，一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询，这种范围扫描索引比全表扫描要好，因为它只需开始于索引的某一点，而结束于另一点，不用扫描全部索引</li>
<li>index：Full Index Scan，index于ALL区别为index类型只遍历索引树。通常比ALL快，因为索引文件通常比数据文件小。（<strong>也就是说虽然all和index都是读全表，但index是从索引中读取的，而all是从硬盘中读的</strong>）</li>
<li>ALL：Full Table Scan，将遍历全表找到匹配的行</li>
</ul>
</li>
<li><p><strong>possible_keys</strong>（显示可能应用在这张表中的索引，一个或多个，查询涉及到的字段若存在索引，则该索引将被列出，但不一定被查询实际使用）</p>
</li>
<li><p><strong>key</strong></p>
</li>
<li><ul>
<li>实际使用的索引，如果为NULL，则没有使用索引</li>
<li><strong>查询中若使用了覆盖索引，则该索引和查询的 select 字段重叠，仅出现在key列表中</strong></li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539958-bcf79915-a194-4c29-9bb0-f8a828626624.webp" alt="image">explain-key</p>
<ul>
<li><p><strong>key_len</strong></p>
</li>
<li><ul>
<li>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好</li>
<li>key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的</li>
</ul>
</li>
<li><p><strong>ref</strong>（显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值）</p>
</li>
<li><p><strong>rows</strong>（根据表统计信息及索引选用情况，大致估算找到所需的记录所需要读取的行数）</p>
</li>
<li><p><strong>Extra</strong>（包含不适合在其他列中显示但十分重要的额外信息）</p>
</li>
</ul>
<ol>
<li><ol>
<li>using filesort: 说明mysql会对数据使用一个外部的索引排序，不是按照表内的索引顺序进行读取。mysql中无法利用索引完成的排序操作称为“文件排序”。常见于order by和group by语句中</li>
<li>Using temporary：使用了临时表保存中间结果，mysql在对查询结果排序时使用临时表。常见于排序order by和分组查询group by。</li>
<li>using index：表示相应的select操作中使用了覆盖索引，避免访问了表的数据行，效率不错，如果同时出现using where，表明索引被用来执行索引键值的查找；否则索引被用来读取数据而非执行查找操作</li>
<li>using where：使用了where过滤</li>
<li>using join buffer：使用了连接缓存</li>
<li>impossible where：where子句的值总是false，不能用来获取任何元祖</li>
<li>select tables optimized away：在没有group by子句的情况下，基于索引优化操作或对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化</li>
<li>distinct：优化distinct操作，在找到第一匹配的元祖后即停止找同样值的动作</li>
</ol>
</li>
</ol>
<p><strong>case</strong>:</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539975-a8ae7858-047b-4816-a2d7-c5b3cab09fab.webp" alt="image">explain-demo</p>
<ol>
<li>第一行（执行顺序4）：id列为1，表示是union里的第一个select，select_type列的primary表示该查询为外层查询，table列被标记为，表示查询结果来自一个衍生表，其中derived3中3代表该查询衍生自第三个select查询，即id为3的select。【select d1.name……】</li>
<li>第二行（执行顺序2）：id为3，是整个查询中第三个select的一部分。因查询包含在from中，所以为derived。【select id,name from t1 where other_column=’’】</li>
<li>第三行（执行顺序3）：select列表中的子查询select_type为subquery，为整个查询中的第二个select。【select id from t3】</li>
<li>第四行（执行顺序1）：select_type为union，说明第四个select是union里的第二个select，最先执行【select name,id from t2】</li>
<li>第五行（执行顺序5）：代表从union的临时表中读取行的阶段，table列的&lt;union1,4&gt;表示用第一个和第四个select的结果进行union操作。【两个结果union操作】</li>
</ol>
<h5 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h5><p>MySQL 的慢查询日志是 MySQL 提供的一种日志记录，它用来记录在 MySQL 中响应时间超过阈值的语句，具体指运行时间超过 <code>long_query_time</code> 值的 SQL，则会被记录到慢查询日志中。</p>
<ul>
<li><code>long_query_time</code> 的默认值为10，意思是运行10秒以上的语句</li>
<li>默认情况下，MySQL数据库没有开启慢查询日志，需要手动设置参数开启</li>
</ul>
<p><strong>查看开启状态</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">&#x27;%slow_query_log%&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>开启慢查询日志</strong></p>
<ul>
<li>临时配置：</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">mysql&gt; <span class="builtin-name">set</span> global <span class="attribute">slow_query_log</span>=<span class="string">&#x27;ON&#x27;</span>;</span><br><span class="line">mysql&gt; <span class="builtin-name">set</span> global <span class="attribute">slow_query_log_file</span>=<span class="string">&#x27;/var/lib/mysql/hostname-slow.log&#x27;</span>;</span><br><span class="line">mysql&gt; <span class="builtin-name">set</span> global <span class="attribute">long_query_time</span>=2;</span><br></pre></td></tr></table></figure>

<p>也可set文件位置，系统会默认给一个缺省文件host_name-slow.log</p>
<p>使用set操作开启慢查询日志只对当前数据库生效，如果MySQL重启则会失效。</p>
<ul>
<li>永久配置<br>修改配置文件my.cnf或my.ini，在[mysqld]一行下面加入两个配置参数</li>
</ul>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">slow_query_log</span> = <span class="literal">ON</span></span><br><span class="line"><span class="attr">slow_query_log_file</span> = /var/lib/mysql/hostname-slow.log</span><br><span class="line"><span class="attr">long_query_time</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>注：log-slow-queries 参数为慢查询日志存放的位置，一般这个目录要有 MySQL 的运行帐号的可写权限，一般都将这个目录设置为 MySQL 的数据存放目录；long_query_time=2 中的 2 表示查询超过两秒才记录；在my.cnf或者 my.ini 中添加 log-queries-not-using-indexes 参数，表示记录下没有使用索引的查询。</p>
<p>可以用 <code>select sleep(4)</code> 验证是否成功开启。</p>
<p>在生产环境中，如果手工分析日志，查找、分析SQL，还是比较费劲的，所以MySQL提供了日志分析工具<strong>mysqldumpslow</strong>。</p>
<p>通过 mysqldumpslow –help 查看操作帮助信息</p>
<ul>
<li>得到返回记录集最多的10个SQL<br><code>mysqldumpslow -s r -t 10 /var/lib/mysql/hostname-slow.log</code></li>
<li>得到访问次数最多的10个SQL<br><code>mysqldumpslow -s c -t 10 /var/lib/mysql/hostname-slow.log</code></li>
<li>得到按照时间排序的前10条里面含有左连接的查询语句<br><code>mysqldumpslow -s t -t 10 -g &quot;left join&quot; /var/lib/mysql/hostname-slow.log</code></li>
<li>也可以和管道配合使用<br><code>mysqldumpslow -s r -t 10 /var/lib/mysql/hostname-slow.log | more</code></li>
</ul>
<p><strong>也可使用 pt-query-digest 分析 RDS MySQL 慢查询日志</strong></p>
<h5 id="Show-Profile-分析查询"><a href="#Show-Profile-分析查询" class="headerlink" title="Show Profile 分析查询"></a>Show Profile 分析查询</h5><p>通过慢日志查询可以知道哪些 SQL 语句执行效率低下，通过 explain 我们可以得知 SQL 语句的具体执行情况，索引使用等，还可以结合<code>Show Profile</code>命令查看执行状态。</p>
<ul>
<li><p>Show Profile 是 MySQL 提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于SQL的调优的测量</p>
</li>
<li><p>默认情况下，参数处于关闭状态，并保存最近15次的运行结果</p>
</li>
<li><p>分析步骤<br>mysql&gt; show profiles; +———-+————+———————————+ | Query_ID | Duration  | Query              | +———-+————+———————————+ |     1 | 0.00385450 | show variables like “profiling” | |     2 | 0.00170050 | show variables like “profiling” | |     3 | 0.00038025 | select * from t_base_user    | +———-+————+———————————+</p>
</li>
<li><ul>
<li>converting HEAP to MyISAM 查询结果太大，内存都不够用了往磁盘上搬了。</li>
<li>create tmp table 创建临时表，这个要注意</li>
<li>Copying to tmp table on disk  把内存临时表复制到磁盘</li>
<li>locked</li>
</ul>
</li>
</ul>
<ol>
<li><ol>
<li>诊断SQL，show profile cpu,block io for query  id(上一步前面的问题SQL数字号码)</li>
<li>日常开发需要注意的结论</li>
<li>是否支持，看看当前的mysql版本是否支持</li>
</ol>
</li>
</ol>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">mysql&gt;Show  <span class="keyword">variables</span> like <span class="comment">&#x27;profiling&#x27;</span>;  --默认是关闭，使用前需要开启</span><br></pre></td></tr></table></figure>

<ol>
<li><ol>
<li>开启功能，默认是关闭，使用前需要开启</li>
</ol>
</li>
</ol>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">mysql&gt;<span class="builtin-name">set</span> <span class="attribute">profiling</span>=1;</span><br></pre></td></tr></table></figure>

<ol>
<li><ol>
<li>运行SQL</li>
<li>查看结果</li>
</ol>
</li>
</ol>
<blockquote>
<p>❝查询中哪些情况不会使用索引？</p>
</blockquote>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><h4 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h4><ol>
<li>全值匹配我最爱</li>
<li>最佳左前缀法则，比如建立了一个联合索引(a,b,c)，那么其实我们可利用的索引就有(a), (a,b), (a,b,c)</li>
<li>不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描</li>
<li>存储引擎不能使用索引中范围条件右边的列</li>
<li>尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致))，减少select</li>
<li>is null ,is not null 也无法使用索引</li>
<li>like “xxxx%” 是可以用到索引的，like “%xxxx” 则不行(like “%xxx%” 同理)。like以通配符开头(‘%abc…’)索引失效会变成全表扫描的操作，</li>
<li>字符串不加单引号索引失效</li>
<li>少用or，用它来连接时会索引失效</li>
<li>&lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN 可用到索引，&lt;&gt;，not in ，!= 则不行，会导致全表扫描</li>
</ol>
<p><strong>一般性建议</strong></p>
<ul>
<li>对于单键索引，尽量选择针对当前query过滤性更好的索引</li>
<li>在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。</li>
<li>在选择组合索引的时候，尽量选择可以能够包含当前query中的where字句中更多字段的索引</li>
<li>尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的</li>
<li>少用Hint强制索引</li>
</ul>
<h4 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h4><p><strong>永远小表驱动大表（小的数据集驱动大的数据集）</strong></p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">slect * <span class="keyword">from</span> A <span class="keyword">where</span> <span class="built_in">id</span> <span class="keyword">in</span> (select <span class="built_in">id</span> <span class="keyword">from</span> B)`等价于</span><br><span class="line"><span class="comment">#等价于</span></span><br><span class="line">select <span class="built_in">id</span> <span class="keyword">from</span> B</span><br><span class="line">select * <span class="keyword">from</span> A <span class="keyword">where</span> A.<span class="built_in">id</span>=B.<span class="built_in">id</span></span><br></pre></td></tr></table></figure>

<p>当 B 表的数据集必须小于 A 表的数据集时，用 in 优于 exists</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> B <span class="keyword">where</span> B.id=A.id)</span><br><span class="line"><span class="comment">#等价于</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> B <span class="keyword">where</span> B.id = A.id<span class="string">`</span></span><br></pre></td></tr></table></figure>

<p>当 A 表的数据集小于B表的数据集时，用 exists优于用 in</p>
<p>注意：A表与B表的ID字段应建立索引。</p>
<p><strong>order by关键字优化</strong></p>
<ul>
<li><p>order by子句，尽量使用 Index 方式排序，避免使用 FileSort 方式排序</p>
</li>
<li><p>MySQL 支持两种方式的排序，FileSort 和 Index，Index效率高，它指 MySQL 扫描索引本身完成排序，FileSort 效率较低；</p>
</li>
<li><p>ORDER BY 满足两种情况，会使用Index方式排序；①ORDER BY语句使用索引最左前列 ②使用where子句与ORDER BY子句条件列组合满足索引最左前列</p>
</li>
<li><p>尽可能在索引列上完成排序操作，遵照索引建的最佳最前缀</p>
</li>
<li><p>如果不在索引列上，filesort 有两种算法，mysql就要启动双路排序和单路排序</p>
</li>
<li><ul>
<li>双路排序：MySQL 4.1之前是使用双路排序,字面意思就是两次扫描磁盘，最终得到数据</li>
<li>单路排序：从磁盘读取查询需要的所有列，按照order by 列在 buffer对它们进行排序，然后扫描排序后的列表进行输出，效率高于双路排序</li>
</ul>
</li>
<li><p>优化策略</p>
</li>
<li><ul>
<li>增大sort_buffer_size参数的设置</li>
<li>增大max_lencth_for_sort_data参数的设置</li>
</ul>
</li>
</ul>
<p><strong>GROUP BY关键字优化</strong></p>
<ul>
<li>group by实质是先排序后进行分组，遵照索引建的最佳左前缀</li>
<li>当无法使用索引列，增大 <code>max_length_for_sort_data</code> 参数的设置，增大<code>sort_buffer_size</code>参数的设置</li>
<li>where高于having，能写在where限定的条件就不要去having限定了</li>
</ul>
<h4 id="数据类型优化"><a href="#数据类型优化" class="headerlink" title="数据类型优化"></a>数据类型优化</h4><p>MySQL 支持的数据类型非常多，选择正确的数据类型对于获取高性能至关重要。不管存储哪种类型的数据，下面几个简单的原则都有助于做出更好的选择。</p>
<ul>
<li>更小的通常更好：一般情况下，应该尽量使用可以正确存储数据的最小数据类型。<br>简单就好：简单的数据类型通常需要更少的CPU周期。例如，整数比字符操作代价更低，因为字符集和校对规则（排序规则）使字符比较比整型比较复杂。</li>
<li>尽量避免NULL：通常情况下最好指定列为NOT NULL</li>
</ul>
<h2 id="九、分区、分表、分库"><a href="#九、分区、分表、分库" class="headerlink" title="九、分区、分表、分库"></a>九、分区、分表、分库</h2><h3 id="MySQL分区"><a href="#MySQL分区" class="headerlink" title="MySQL分区"></a>MySQL分区</h3><p>一般情况下我们创建的表对应一组存储文件，使用<code>MyISAM</code>存储引擎时是一个<code>.MYI</code>和<code>.MYD</code>文件，使用<code>Innodb</code>存储引擎时是一个<code>.ibd</code>和<code>.frm</code>（表结构）文件。</p>
<p>当数据量较大时（一般千万条记录级别以上），MySQL的性能就会开始下降，这时我们就需要将数据分散到多组存储文件，保证其单个文件的执行效率</p>
<p><strong>能干嘛</strong></p>
<ul>
<li>逻辑数据分割</li>
<li>提高单一的写和读应用速度</li>
<li>提高分区范围读查询的速度</li>
<li>分割数据能够有多个不同的物理文件路径</li>
<li>高效的保存历史数据</li>
</ul>
<p><strong>怎么玩</strong></p>
<p>首先查看当前数据库是否支持分区</p>
<ul>
<li>MySQL5.6以及之前版本：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">&#x27;%partition%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>MySQL5.6：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> plugins;</span><br></pre></td></tr></table></figure>

<p><strong>分区类型及操作</strong></p>
<ul>
<li><strong>RANGE分区</strong>：基于属于一个给定连续区间的列值，把多行分配给分区。mysql将会根据指定的拆分策略，,把数据放在不同的表文件上。相当于在文件上,被拆成了小块.但是,对外给客户的感觉还是一张表，透明的。<br>按照 range 来分，就是每个库一段连续的数据，这个一般是按比如<strong>时间范围</strong>来的，比如交易表啊，销售表啊等，可以根据年月来存放数据。可能会产生热点问题，大量的流量都打在最新的数据上了。<br>range 来分，好处在于说，扩容的时候很简单。</li>
<li><strong>LIST分区</strong>：类似于按RANGE分区，每个分区必须明确定义。它们的主要区别在于，LIST分区中每个分区的定义和选择是基于某列的值从属于一个值列表集中的一个值，而RANGE分区是从属于一个连续区间值的集合。</li>
<li><strong>HASH分区</strong>：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL 中有效的、产生非负整数值的任何表达式。<br>hash 分发，好处在于说，可以平均分配每个库的数据量和请求压力；坏处在于说扩容起来比较麻烦，会有一个数据迁移的过程，之前的数据需要重新计算 hash 值重新分配到不同的库或表</li>
<li><strong>KEY分区</strong>：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL服务器提供其自身的哈希函数。必须有一列或多列包含整数值。</li>
</ul>
<p><strong>看上去分区表很帅气，为什么大部分互联网还是更多的选择自己分库分表来水平扩展咧？</strong></p>
<ul>
<li>分区表，分区键设计不太灵活，如果不走分区键，很容易出现全表锁</li>
<li>一旦数据并发量上来，如果在分区表实施关联，就是一个灾难</li>
<li>自己分库分表，自己掌控业务场景与访问模式，可控。分区表，研发写了一个sql，都不确定mysql是怎么玩的，不太可控</li>
</ul>
<blockquote>
<p>❝</p>
<p>随着业务的发展，业务越来越复杂，应用的模块越来越多，总的数据量很大，高并发读写操作均超过单个数据库服务器的处理能力怎么办？</p>
</blockquote>
<p>这个时候就出现了<strong>数据分片</strong>，数据分片指按照某个维度将存放在单一数据库中的数据分散地存放至多个数据库或表中。数据分片的有效手段就是对关系型数据库进行分库和分表。</p>
<p>区别于分区的是，分区一般都是放在单机里的，用的比较多的是时间范围分区，方便归档。只不过分库分表需要代码实现，分区则是mysql内部实现。分库分表和分区并不冲突，可以结合使用。</p>
<blockquote>
<p>❝</p>
<p>说说分库与分表的设计</p>
</blockquote>
<h3 id="MySQL分表"><a href="#MySQL分表" class="headerlink" title="MySQL分表"></a>MySQL分表</h3><p>分表有两种分割方式，一种垂直拆分，另一种水平拆分。</p>
<ul>
<li><p><strong>垂直拆分</strong><br>垂直分表，通常是按照业务功能的使用频次，把主要的、热门的字段放在一起做为主要表。然后把不常用的，按照各自的业务属性进行聚集，拆分到不同的次要表中；主要表和次要表的关系一般都是一对一的。</p>
</li>
<li><p><strong>水平拆分(数据分片)</strong><br>单表的容量不超过500W，否则建议水平拆分。是把一个表复制成同样表结构的不同表，然后把数据按照一定的规则划分，分别存储到这些表中，从而保证单表的容量不会太大，提升性能；当然这些结构一样的表，可以放在一个或多个数据库中。<br>水平分割的几种方法：</p>
</li>
<li><ul>
<li>使用MD5哈希，做法是对UID进行md5加密，然后取前几位（我们这里取前两位），然后就可以将不同的UID哈希到不同的用户表（user_xx）中了。</li>
<li>还可根据时间放入不同的表，比如：article_201601，article_201602。</li>
<li>按热度拆分，高点击率的词条生成各自的一张表，低热度的词条都放在一张大表里，待低热度的词条达到一定的贴数后，再把低热度的表单独拆分成一张表。</li>
<li>根据ID的值放入对应的表，第一个表user_0000，第二个100万的用户数据放在第二 个表user_0001中，随用户增加，直接添加用户表就行了。</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590539957-9e85fd78-eebe-4644-a408-80ff3dfc87cd.webp?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image"></p>
<h3 id="MySQL分库"><a href="#MySQL分库" class="headerlink" title="MySQL分库"></a>MySQL分库</h3><blockquote>
<p>❝为什么要分库?</p>
</blockquote>
<p>数据库集群环境后都是多台 slave，基本满足了读取操作;  但是写入或者说大数据、频繁的写入操作对master性能影响就比较大，这个时候，单库并不能解决大规模并发写入的问题，所以就会考虑分库。</p>
<blockquote>
<p>❝分库是什么？</p>
</blockquote>
<p>一个库里表太多了，导致了海量数据，系统性能下降，把原本存储于一个库的表拆分存储到多个库上， 通常是将表按照功能模块、关系密切程度划分出来，部署到不同库上。</p>
<p>优点：</p>
<ul>
<li>减少增量数据写入时的锁对查询的影响</li>
<li>由于单表数量下降，常见的查询操作由于减少了需要扫描的记录，使得单表单次查询所需的检索行数变少，减少了磁盘IO，时延变短</li>
</ul>
<p>但是它无法解决单表数据量太大的问题</p>
<p><strong>分库分表后的难题</strong></p>
<p>分布式事务的问题，数据的完整性和一致性问题。</p>
<p>数据操作维度问题：用户、交易、订单各个不同的维度，用户查询维度、产品数据分析维度的不同对比分析角度。跨库联合查询的问题，可能需要两次查询 跨节点的count、order by、group by以及聚合函数问题，可能需要分别在各个节点上得到结果后在应用程序端进行合并 额外的数据管理负担，如：访问数据表的导航定位 额外的数据运算压力，如：需要在多个节点执行，然后再合并计算程序编码开发难度提升，没有太好的框架解决，更多依赖业务看如何分，如何合，是个难题。</p>
<blockquote>
<p>❝配主从，正经公司的话，也不会让 Javaer 去搞的，但还是要知道</p>
</blockquote>
<h2 id="十、主从复制"><a href="#十、主从复制" class="headerlink" title="十、主从复制"></a>十、主从复制</h2><h3 id="复制的基本原理"><a href="#复制的基本原理" class="headerlink" title="复制的基本原理"></a>复制的基本原理</h3><ul>
<li>slave 会从 master 读取 binlog 来进行数据同步</li>
<li>三个步骤<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/1266758/1590590540019-3b79bd00-05a5-47a9-a4bb-c594e451c33c.webp?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_THVrYQ==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image">img</li>
</ul>
<ol>
<li><ol>
<li>master将改变记录到二进制日志（binary log）。这些记录过程叫做二进制日志事件，binary log events；</li>
<li>salve 将 master 的 binary log events 拷贝到它的中继日志（relay log）;</li>
<li>slave 重做中继日志中的事件，将改变应用到自己的数据库中。MySQL 复制是异步且是串行化的。</li>
</ol>
</li>
</ol>
<h3 id="复制的基本原则"><a href="#复制的基本原则" class="headerlink" title="复制的基本原则"></a>复制的基本原则</h3><ul>
<li>每个 slave只有一个 master</li>
<li>每个 salve只能有一个唯一的服务器 ID</li>
<li>每个master可以有多个salve</li>
</ul>
<h3 id="复制的最大问题"><a href="#复制的最大问题" class="headerlink" title="复制的最大问题"></a>复制的最大问题</h3><ul>
<li>延时</li>
</ul>
<h2 id="十一、其他问题"><a href="#十一、其他问题" class="headerlink" title="十一、其他问题"></a>十一、其他问题</h2><h3 id="说一说三个范式"><a href="#说一说三个范式" class="headerlink" title="说一说三个范式"></a>说一说三个范式</h3><ul>
<li>第一范式（1NF）：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。</li>
<li>第二范式（2NF）：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。</li>
<li>第三范式（3NF）：在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。所谓传递函数依赖，指的是如 果存在”A → B → C”的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系：关键字段 → 非关键字段 x → 非关键字段y</li>
</ul>
<h3 id="百万级别或以上的数据如何删除"><a href="#百万级别或以上的数据如何删除" class="headerlink" title="百万级别或以上的数据如何删除"></a>百万级别或以上的数据如何删除</h3><p>关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。</p>
<ol>
<li>所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）</li>
<li>然后删除其中无用数据（此过程需要不到两分钟）</li>
<li>删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。</li>
<li>与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
</search>
